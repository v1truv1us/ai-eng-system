// src/context/progressive.ts
import { existsSync } from "node:fs";
import { readFile, readdir } from "node:fs/promises";
import { join } from "node:path";

class ProgressiveSkillLoader {
  skillsDir;
  loadedCache = new Map;
  constructor(skillsDir = "./skills") {
    this.skillsDir = skillsDir;
  }
  parseFrontmatter(content) {
    const match = content.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/);
    if (!match) {
      return { meta: {}, body: content };
    }
    const [, frontmatter, body] = match;
    const meta = {};
    for (const line of frontmatter.split(`
`)) {
      const colonIndex = line.indexOf(":");
      if (colonIndex > 0) {
        const key = line.slice(0, colonIndex).trim();
        let value = line.slice(colonIndex + 1).trim();
        if (value === "true")
          value = true;
        else if (value === "false")
          value = false;
        else if (!Number.isNaN(Number(value)))
          value = Number(value);
        meta[key] = value;
      }
    }
    return { meta, body: body.trim() };
  }
  extractTierContent(body) {
    const tier2Match = body.match(/<!--\s*tier:2\s*-->([\s\S]*?)(?=<!--\s*tier:3\s*-->|$)/);
    const tier3Match = body.match(/<!--\s*tier:3\s*-->([\s\S]*)$/);
    const overviewEnd = body.indexOf("<!-- tier:2 -->");
    const overview = overviewEnd > -1 ? body.substring(0, overviewEnd).trim() : body.trim();
    return {
      overview,
      instructions: tier2Match ? tier2Match[1].trim() : undefined,
      resources: tier3Match ? tier3Match[1].trim() : undefined
    };
  }
  estimateTokens(content) {
    return Math.ceil(content.length / 4);
  }
  async loadSkillMetadata(skillPath) {
    if (!existsSync(skillPath)) {
      return null;
    }
    try {
      const content = await readFile(skillPath, "utf-8");
      const { meta } = this.parseFrontmatter(content);
      return {
        name: meta.name || "unknown",
        description: meta.description || "",
        tier: meta.tier || 1,
        capabilities: meta.capabilities || [],
        path: skillPath
      };
    } catch (error) {
      console.error(`Failed to load skill metadata from ${skillPath}:`, error);
      return null;
    }
  }
  async loadSkill(skillPath, tiers = [1]) {
    const cacheKey = `${skillPath}:${tiers.join(",")}`;
    if (this.loadedCache.has(cacheKey)) {
      return this.loadedCache.get(cacheKey);
    }
    if (!existsSync(skillPath)) {
      return null;
    }
    try {
      const content = await readFile(skillPath, "utf-8");
      const { meta, body } = this.parseFrontmatter(content);
      const tierContent = this.extractTierContent(body);
      const metadata = {
        name: meta.name || "unknown",
        description: meta.description || "",
        tier: meta.tier || 1,
        capabilities: meta.capabilities || [],
        path: skillPath
      };
      const contentParts = [];
      let tokenEstimate = 0;
      if (tiers.includes(1)) {
        contentParts.push(tierContent.overview);
        tokenEstimate += this.estimateTokens(tierContent.overview);
      }
      if (tiers.includes(2) && tierContent.instructions) {
        contentParts.push(tierContent.instructions);
        tokenEstimate += this.estimateTokens(tierContent.instructions);
      }
      if (tiers.includes(3) && tierContent.resources) {
        contentParts.push(tierContent.resources);
        tokenEstimate += this.estimateTokens(tierContent.resources);
      }
      const loaded = {
        metadata,
        loadedTiers: tiers,
        content: contentParts.join(`

`),
        tokenEstimate
      };
      this.loadedCache.set(cacheKey, loaded);
      return loaded;
    } catch (error) {
      console.error(`Failed to load skill from ${skillPath}:`, error);
      return null;
    }
  }
  async loadSkillsInDirectory(dir, tiers = [1]) {
    if (!existsSync(dir)) {
      return [];
    }
    const skills = [];
    try {
      const entries = await readdir(dir, { withFileTypes: true });
      for (const entry of entries) {
        const fullPath = join(dir, entry.name);
        if (entry.isDirectory()) {
          const skillPath = join(fullPath, "SKILL.md");
          if (existsSync(skillPath)) {
            const skill = await this.loadSkill(skillPath, tiers);
            if (skill)
              skills.push(skill);
          }
        } else if (entry.name.endsWith(".md")) {
          const skill = await this.loadSkill(fullPath, tiers);
          if (skill)
            skills.push(skill);
        }
      }
    } catch (error) {
      console.error(`Failed to load skills from ${dir}:`, error);
    }
    return skills;
  }
  async loadSkillsByCapability(dir, capability, tiers = [1]) {
    const allSkills = await this.loadSkillsInDirectory(dir, [1]);
    const matching = [];
    for (const skill of allSkills) {
      if (skill.metadata.capabilities.includes(capability)) {
        const fullSkill = await this.loadSkill(skill.metadata.path, tiers);
        if (fullSkill)
          matching.push(fullSkill);
      }
    }
    return matching;
  }
  estimateTokenSavings(skills) {
    const tier1Only = skills.reduce((sum, s) => {
      const t1Skill = { ...s, loadedTiers: [1] };
      return sum + this.estimateTokens(s.metadata.description);
    }, 0);
    const allTiers = skills.reduce((sum, s) => sum + s.tokenEstimate, 0);
    const savings = allTiers - tier1Only;
    const savingsPercent = Math.round(savings / allTiers * 100);
    return {
      tier1Only,
      allTiers,
      savings,
      savingsPercent
    };
  }
  clearCache() {
    this.loadedCache.clear();
  }
  getCacheStats() {
    return {
      size: this.loadedCache.size,
      entries: Array.from(this.loadedCache.keys())
    };
  }
}
function createSkillLoader(skillsDir) {
  return new ProgressiveSkillLoader(skillsDir || "./skills");
}
var TIER_STRATEGIES = {
  minimal: [1],
  standard: [1, 2],
  full: [1, 2, 3],
  onDemand: [1, 2]
};
export {
  createSkillLoader,
  TIER_STRATEGIES,
  ProgressiveSkillLoader
};

//# debugId=F5EA47B3B76DCCBD64756E2164756E21
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vc3JjL2NvbnRleHQvcHJvZ3Jlc3NpdmUudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbCiAgICAiLyoqXG4gKiBQcm9ncmVzc2l2ZSBEaXNjbG9zdXJlIEFyY2hpdGVjdHVyZSAoUERBKVxuICpcbiAqIEltcGxlbWVudHMgMy10aWVyIHNraWxsIGxvYWRpbmcgdG8gcmVkdWNlIHRva2VuIHVzYWdlIGJ5IH45MCUuXG4gKiBCYXNlZCBvbiBDbGF1ZGUgU2tpbGxzIHJlc2VhcmNoIGJ5IFJpY2sgSGlnaHRvd2VyLlxuICpcbiAqIFRpZXIgMTogTWV0YWRhdGEgKGFsd2F5cyBsb2FkZWQpIC0gfjUwIHRva2Vuc1xuICogVGllciAyOiBJbnN0cnVjdGlvbnMgKGxvYWRlZCBvbiBkZW1hbmQpIC0gfjUwMCB0b2tlbnNcbiAqIFRpZXIgMzogUmVzb3VyY2VzIChsb2FkZWQgd2hlbiBuZWVkZWQpIC0gfjIwMDArIHRva2Vuc1xuICovXG5cbmltcG9ydCB7IGV4aXN0c1N5bmMgfSBmcm9tIFwibm9kZTpmc1wiO1xuaW1wb3J0IHsgcmVhZEZpbGUsIHJlYWRkaXIgfSBmcm9tIFwibm9kZTpmcy9wcm9taXNlc1wiO1xuaW1wb3J0IHsgam9pbiB9IGZyb20gXCJub2RlOnBhdGhcIjtcbmltcG9ydCB0eXBlIHtcbiAgICBMb2FkZWRTa2lsbCxcbiAgICBTa2lsbENvbnRlbnQsXG4gICAgU2tpbGxNZXRhZGF0YSxcbiAgICBTa2lsbFRpZXIsXG59IGZyb20gXCIuL3R5cGVzXCI7XG5cbmV4cG9ydCBjbGFzcyBQcm9ncmVzc2l2ZVNraWxsTG9hZGVyIHtcbiAgICBwcml2YXRlIHNraWxsc0Rpcjogc3RyaW5nO1xuICAgIHByaXZhdGUgbG9hZGVkQ2FjaGU6IE1hcDxzdHJpbmcsIExvYWRlZFNraWxsPiA9IG5ldyBNYXAoKTtcblxuICAgIGNvbnN0cnVjdG9yKHNraWxsc0RpciA9IFwiLi9za2lsbHNcIikge1xuICAgICAgICB0aGlzLnNraWxsc0RpciA9IHNraWxsc0RpcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBZQU1MIGZyb250bWF0dGVyIGZyb20gc2tpbGwgbWFya2Rvd25cbiAgICAgKi9cbiAgICBwcml2YXRlIHBhcnNlRnJvbnRtYXR0ZXIoY29udGVudDogc3RyaW5nKToge1xuICAgICAgICBtZXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICAgICAgICBib2R5OiBzdHJpbmc7XG4gICAgfSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gY29udGVudC5tYXRjaCgvXi0tLVxcbihbXFxzXFxTXSo/KVxcbi0tLVxcbihbXFxzXFxTXSopJC8pO1xuICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtZXRhOiB7fSwgYm9keTogY29udGVudCB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgWywgZnJvbnRtYXR0ZXIsIGJvZHldID0gbWF0Y2g7XG4gICAgICAgIGNvbnN0IG1ldGE6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fTtcblxuICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgZnJvbnRtYXR0ZXIuc3BsaXQoXCJcXG5cIikpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9uSW5kZXggPSBsaW5lLmluZGV4T2YoXCI6XCIpO1xuICAgICAgICAgICAgaWYgKGNvbG9uSW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gbGluZS5zbGljZSgwLCBjb2xvbkluZGV4KS50cmltKCk7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlOiBhbnkgPSBsaW5lLnNsaWNlKGNvbG9uSW5kZXggKyAxKS50cmltKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBib29sZWFucyBhbmQgbnVtYmVyc1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCJ0cnVlXCIpIHZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gXCJmYWxzZVwiKSB2YWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFOdW1iZXIuaXNOYU4oTnVtYmVyKHZhbHVlKSkpIHZhbHVlID0gTnVtYmVyKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIG1ldGFba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHsgbWV0YSwgYm9keTogYm9keS50cmltKCkgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0IHRpZXIgY29udGVudCBmcm9tIG1hcmtkb3duXG4gICAgICogVGllciBtYXJrZXJzOiA8IS0tIHRpZXI6MiAtLT4gYW5kIDwhLS0gdGllcjozIC0tPlxuICAgICAqL1xuICAgIHByaXZhdGUgZXh0cmFjdFRpZXJDb250ZW50KGJvZHk6IHN0cmluZyk6IHtcbiAgICAgICAgb3ZlcnZpZXc6IHN0cmluZztcbiAgICAgICAgaW5zdHJ1Y3Rpb25zPzogc3RyaW5nO1xuICAgICAgICByZXNvdXJjZXM/OiBzdHJpbmc7XG4gICAgfSB7XG4gICAgICAgIGNvbnN0IHRpZXIyTWF0Y2ggPSBib2R5Lm1hdGNoKFxuICAgICAgICAgICAgLzwhLS1cXHMqdGllcjoyXFxzKi0tPihbXFxzXFxTXSo/KSg/PTwhLS1cXHMqdGllcjozXFxzKi0tPnwkKS8sXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHRpZXIzTWF0Y2ggPSBib2R5Lm1hdGNoKC88IS0tXFxzKnRpZXI6M1xccyotLT4oW1xcc1xcU10qKSQvKTtcblxuICAgICAgICAvLyBFdmVyeXRoaW5nIGJlZm9yZSB0aWVyOjIgbWFya2VyIGlzIG92ZXJ2aWV3XG4gICAgICAgIGNvbnN0IG92ZXJ2aWV3RW5kID0gYm9keS5pbmRleE9mKFwiPCEtLSB0aWVyOjIgLS0+XCIpO1xuICAgICAgICBjb25zdCBvdmVydmlldyA9XG4gICAgICAgICAgICBvdmVydmlld0VuZCA+IC0xXG4gICAgICAgICAgICAgICAgPyBib2R5LnN1YnN0cmluZygwLCBvdmVydmlld0VuZCkudHJpbSgpXG4gICAgICAgICAgICAgICAgOiBib2R5LnRyaW0oKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3ZlcnZpZXcsXG4gICAgICAgICAgICBpbnN0cnVjdGlvbnM6IHRpZXIyTWF0Y2ggPyB0aWVyMk1hdGNoWzFdLnRyaW0oKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHJlc291cmNlczogdGllcjNNYXRjaCA/IHRpZXIzTWF0Y2hbMV0udHJpbSgpIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVzdGltYXRlIHRva2VucyBmb3IgY29udGVudCAocm91Z2ggYXBwcm94aW1hdGlvbilcbiAgICAgKiB+MSB0b2tlbiBwZXIgNCBjaGFyYWN0ZXJzXG4gICAgICovXG4gICAgcHJpdmF0ZSBlc3RpbWF0ZVRva2Vucyhjb250ZW50OiBzdHJpbmcpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKGNvbnRlbnQubGVuZ3RoIC8gNCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZCBza2lsbCBtZXRhZGF0YSBvbmx5IChUaWVyIDEpXG4gICAgICovXG4gICAgYXN5bmMgbG9hZFNraWxsTWV0YWRhdGEoc2tpbGxQYXRoOiBzdHJpbmcpOiBQcm9taXNlPFNraWxsTWV0YWRhdGEgfCBudWxsPiB7XG4gICAgICAgIGlmICghZXhpc3RzU3luYyhza2lsbFBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgcmVhZEZpbGUoc2tpbGxQYXRoLCBcInV0Zi04XCIpO1xuICAgICAgICAgICAgY29uc3QgeyBtZXRhIH0gPSB0aGlzLnBhcnNlRnJvbnRtYXR0ZXIoY29udGVudCk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogbWV0YS5uYW1lIHx8IFwidW5rbm93blwiLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBtZXRhLmRlc2NyaXB0aW9uIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgdGllcjogbWV0YS50aWVyIHx8IDEsXG4gICAgICAgICAgICAgICAgY2FwYWJpbGl0aWVzOiBtZXRhLmNhcGFiaWxpdGllcyB8fCBbXSxcbiAgICAgICAgICAgICAgICBwYXRoOiBza2lsbFBhdGgsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBgRmFpbGVkIHRvIGxvYWQgc2tpbGwgbWV0YWRhdGEgZnJvbSAke3NraWxsUGF0aH06YCxcbiAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWQgc2tpbGwgd2l0aCBzcGVjaWZpZWQgdGllcnNcbiAgICAgKi9cbiAgICBhc3luYyBsb2FkU2tpbGwoXG4gICAgICAgIHNraWxsUGF0aDogc3RyaW5nLFxuICAgICAgICB0aWVyczogU2tpbGxUaWVyW10gPSBbMV0sXG4gICAgKTogUHJvbWlzZTxMb2FkZWRTa2lsbCB8IG51bGw+IHtcbiAgICAgICAgLy8gQ2hlY2sgY2FjaGVcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBgJHtza2lsbFBhdGh9OiR7dGllcnMuam9pbihcIixcIil9YDtcbiAgICAgICAgaWYgKHRoaXMubG9hZGVkQ2FjaGUuaGFzKGNhY2hlS2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9hZGVkQ2FjaGUuZ2V0KGNhY2hlS2V5KSE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWV4aXN0c1N5bmMoc2tpbGxQYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IHJlYWRGaWxlKHNraWxsUGF0aCwgXCJ1dGYtOFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHsgbWV0YSwgYm9keSB9ID0gdGhpcy5wYXJzZUZyb250bWF0dGVyKGNvbnRlbnQpO1xuICAgICAgICAgICAgY29uc3QgdGllckNvbnRlbnQgPSB0aGlzLmV4dHJhY3RUaWVyQ29udGVudChib2R5KTtcblxuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGE6IFNraWxsTWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogbWV0YS5uYW1lIHx8IFwidW5rbm93blwiLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBtZXRhLmRlc2NyaXB0aW9uIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgdGllcjogbWV0YS50aWVyIHx8IDEsXG4gICAgICAgICAgICAgICAgY2FwYWJpbGl0aWVzOiBtZXRhLmNhcGFiaWxpdGllcyB8fCBbXSxcbiAgICAgICAgICAgICAgICBwYXRoOiBza2lsbFBhdGgsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBCdWlsZCBjb250ZW50IGJhc2VkIG9uIHJlcXVlc3RlZCB0aWVyc1xuICAgICAgICAgICAgY29uc3QgY29udGVudFBhcnRzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICAgICAgbGV0IHRva2VuRXN0aW1hdGUgPSAwO1xuXG4gICAgICAgICAgICBpZiAodGllcnMuaW5jbHVkZXMoMSkpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50UGFydHMucHVzaCh0aWVyQ29udGVudC5vdmVydmlldyk7XG4gICAgICAgICAgICAgICAgdG9rZW5Fc3RpbWF0ZSArPSB0aGlzLmVzdGltYXRlVG9rZW5zKHRpZXJDb250ZW50Lm92ZXJ2aWV3KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRpZXJzLmluY2x1ZGVzKDIpICYmIHRpZXJDb250ZW50Lmluc3RydWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRQYXJ0cy5wdXNoKHRpZXJDb250ZW50Lmluc3RydWN0aW9ucyk7XG4gICAgICAgICAgICAgICAgdG9rZW5Fc3RpbWF0ZSArPSB0aGlzLmVzdGltYXRlVG9rZW5zKHRpZXJDb250ZW50Lmluc3RydWN0aW9ucyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aWVycy5pbmNsdWRlcygzKSAmJiB0aWVyQ29udGVudC5yZXNvdXJjZXMpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50UGFydHMucHVzaCh0aWVyQ29udGVudC5yZXNvdXJjZXMpO1xuICAgICAgICAgICAgICAgIHRva2VuRXN0aW1hdGUgKz0gdGhpcy5lc3RpbWF0ZVRva2Vucyh0aWVyQ29udGVudC5yZXNvdXJjZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBsb2FkZWQ6IExvYWRlZFNraWxsID0ge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIGxvYWRlZFRpZXJzOiB0aWVycyxcbiAgICAgICAgICAgICAgICBjb250ZW50OiBjb250ZW50UGFydHMuam9pbihcIlxcblxcblwiKSxcbiAgICAgICAgICAgICAgICB0b2tlbkVzdGltYXRlLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIHJlc3VsdFxuICAgICAgICAgICAgdGhpcy5sb2FkZWRDYWNoZS5zZXQoY2FjaGVLZXksIGxvYWRlZCk7XG5cbiAgICAgICAgICAgIHJldHVybiBsb2FkZWQ7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gbG9hZCBza2lsbCBmcm9tICR7c2tpbGxQYXRofTpgLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWQgYWxsIHNraWxscyBpbiBhIGRpcmVjdG9yeSB3aXRoIHNwZWNpZmllZCB0aWVyc1xuICAgICAqL1xuICAgIGFzeW5jIGxvYWRTa2lsbHNJbkRpcmVjdG9yeShcbiAgICAgICAgZGlyOiBzdHJpbmcsXG4gICAgICAgIHRpZXJzOiBTa2lsbFRpZXJbXSA9IFsxXSxcbiAgICApOiBQcm9taXNlPExvYWRlZFNraWxsW10+IHtcbiAgICAgICAgaWYgKCFleGlzdHNTeW5jKGRpcikpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNraWxsczogTG9hZGVkU2tpbGxbXSA9IFtdO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBlbnRyaWVzID0gYXdhaXQgcmVhZGRpcihkaXIsIHsgd2l0aEZpbGVUeXBlczogdHJ1ZSB9KTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnVsbFBhdGggPSBqb2luKGRpciwgZW50cnkubmFtZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZW50cnkuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBMb29rIGZvciBTS0lMTC5tZCBpbiBzdWJkaXJlY3Rvcmllc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBza2lsbFBhdGggPSBqb2luKGZ1bGxQYXRoLCBcIlNLSUxMLm1kXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RzU3luYyhza2lsbFBhdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBza2lsbCA9IGF3YWl0IHRoaXMubG9hZFNraWxsKHNraWxsUGF0aCwgdGllcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNraWxsKSBza2lsbHMucHVzaChza2lsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVudHJ5Lm5hbWUuZW5kc1dpdGgoXCIubWRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTG9hZCBtYXJrZG93biBmaWxlcyBkaXJlY3RseVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBza2lsbCA9IGF3YWl0IHRoaXMubG9hZFNraWxsKGZ1bGxQYXRoLCB0aWVycyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChza2lsbCkgc2tpbGxzLnB1c2goc2tpbGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBsb2FkIHNraWxscyBmcm9tICR7ZGlyfTpgLCBlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2tpbGxzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWQgc2tpbGxzIGJ5IGNhcGFiaWxpdHlcbiAgICAgKi9cbiAgICBhc3luYyBsb2FkU2tpbGxzQnlDYXBhYmlsaXR5KFxuICAgICAgICBkaXI6IHN0cmluZyxcbiAgICAgICAgY2FwYWJpbGl0eTogc3RyaW5nLFxuICAgICAgICB0aWVyczogU2tpbGxUaWVyW10gPSBbMV0sXG4gICAgKTogUHJvbWlzZTxMb2FkZWRTa2lsbFtdPiB7XG4gICAgICAgIGNvbnN0IGFsbFNraWxscyA9IGF3YWl0IHRoaXMubG9hZFNraWxsc0luRGlyZWN0b3J5KGRpciwgWzFdKTsgLy8gTG9hZCBtZXRhZGF0YSBmaXJzdFxuXG4gICAgICAgIGNvbnN0IG1hdGNoaW5nOiBMb2FkZWRTa2lsbFtdID0gW107XG5cbiAgICAgICAgZm9yIChjb25zdCBza2lsbCBvZiBhbGxTa2lsbHMpIHtcbiAgICAgICAgICAgIGlmIChza2lsbC5tZXRhZGF0YS5jYXBhYmlsaXRpZXMuaW5jbHVkZXMoY2FwYWJpbGl0eSkpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3cgbG9hZCBmdWxsIHRpZXJzIGZvciBtYXRjaGluZyBza2lsbHNcbiAgICAgICAgICAgICAgICBjb25zdCBmdWxsU2tpbGwgPSBhd2FpdCB0aGlzLmxvYWRTa2lsbChcbiAgICAgICAgICAgICAgICAgICAgc2tpbGwubWV0YWRhdGEucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgdGllcnMsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoZnVsbFNraWxsKSBtYXRjaGluZy5wdXNoKGZ1bGxTa2lsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWF0Y2hpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXN0aW1hdGUgdG9rZW4gc2F2aW5ncyBmcm9tIHByb2dyZXNzaXZlIGRpc2Nsb3N1cmVcbiAgICAgKi9cbiAgICBlc3RpbWF0ZVRva2VuU2F2aW5ncyhza2lsbHM6IExvYWRlZFNraWxsW10pOiB7XG4gICAgICAgIHRpZXIxT25seTogbnVtYmVyO1xuICAgICAgICBhbGxUaWVyczogbnVtYmVyO1xuICAgICAgICBzYXZpbmdzOiBudW1iZXI7XG4gICAgICAgIHNhdmluZ3NQZXJjZW50OiBudW1iZXI7XG4gICAgfSB7XG4gICAgICAgIGNvbnN0IHRpZXIxT25seSA9IHNraWxscy5yZWR1Y2UoKHN1bSwgcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgdDFTa2lsbCA9IHsgLi4ucywgbG9hZGVkVGllcnM6IFsxXSBhcyBTa2lsbFRpZXJbXSB9O1xuICAgICAgICAgICAgcmV0dXJuIHN1bSArIHRoaXMuZXN0aW1hdGVUb2tlbnMocy5tZXRhZGF0YS5kZXNjcmlwdGlvbik7XG4gICAgICAgIH0sIDApO1xuXG4gICAgICAgIGNvbnN0IGFsbFRpZXJzID0gc2tpbGxzLnJlZHVjZSgoc3VtLCBzKSA9PiBzdW0gKyBzLnRva2VuRXN0aW1hdGUsIDApO1xuICAgICAgICBjb25zdCBzYXZpbmdzID0gYWxsVGllcnMgLSB0aWVyMU9ubHk7XG4gICAgICAgIGNvbnN0IHNhdmluZ3NQZXJjZW50ID0gTWF0aC5yb3VuZCgoc2F2aW5ncyAvIGFsbFRpZXJzKSAqIDEwMCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRpZXIxT25seSxcbiAgICAgICAgICAgIGFsbFRpZXJzLFxuICAgICAgICAgICAgc2F2aW5ncyxcbiAgICAgICAgICAgIHNhdmluZ3NQZXJjZW50LFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSBjYWNoZVxuICAgICAqL1xuICAgIGNsZWFyQ2FjaGUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMubG9hZGVkQ2FjaGUuY2xlYXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2FjaGUgc3RhdGlzdGljc1xuICAgICAqL1xuICAgIGdldENhY2hlU3RhdHMoKToge1xuICAgICAgICBzaXplOiBudW1iZXI7XG4gICAgICAgIGVudHJpZXM6IHN0cmluZ1tdO1xuICAgIH0ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2l6ZTogdGhpcy5sb2FkZWRDYWNoZS5zaXplLFxuICAgICAgICAgICAgZW50cmllczogQXJyYXkuZnJvbSh0aGlzLmxvYWRlZENhY2hlLmtleXMoKSksXG4gICAgICAgIH07XG4gICAgfVxufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYSBza2lsbCBsb2FkZXIgZm9yIHRoZSBkZWZhdWx0IHNraWxscyBkaXJlY3RvcnlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNraWxsTG9hZGVyKHNraWxsc0Rpcj86IHN0cmluZyk6IFByb2dyZXNzaXZlU2tpbGxMb2FkZXIge1xuICAgIHJldHVybiBuZXcgUHJvZ3Jlc3NpdmVTa2lsbExvYWRlcihza2lsbHNEaXIgfHwgXCIuL3NraWxsc1wiKTtcbn1cblxuLyoqXG4gKiBSZWNvbW1lbmRlZCB0aWVyIGxvYWRpbmcgc3RyYXRlZ2llc1xuICovXG5leHBvcnQgY29uc3QgVElFUl9TVFJBVEVHSUVTID0ge1xuICAgIC8qKiBNaW5pbWFsIGNvbnRleHQgLSBqdXN0IHNraWxsIG5hbWVzIGFuZCBkZXNjcmlwdGlvbnMgKi9cbiAgICBtaW5pbWFsOiBbMV0gYXMgU2tpbGxUaWVyW10sXG5cbiAgICAvKiogU3RhbmRhcmQgY29udGV4dCAtIG1ldGFkYXRhICsgaW5zdHJ1Y3Rpb25zICovXG4gICAgc3RhbmRhcmQ6IFsxLCAyXSBhcyBTa2lsbFRpZXJbXSxcblxuICAgIC8qKiBGdWxsIGNvbnRleHQgLSBldmVyeXRoaW5nICovXG4gICAgZnVsbDogWzEsIDIsIDNdIGFzIFNraWxsVGllcltdLFxuXG4gICAgLyoqIE9uLWRlbWFuZCAtIGxvYWQgdGllciAzIG9ubHkgd2hlbiBzcGVjaWZpY2FsbHkgcmVxdWVzdGVkICovXG4gICAgb25EZW1hbmQ6IFsxLCAyXSBhcyBTa2lsbFRpZXJbXSxcbn07XG4iCiAgXSwKICAibWFwcGluZ3MiOiAiO0FBV0E7QUFDQTtBQUNBO0FBQUE7QUFRTyxNQUFNLHVCQUF1QjtBQUFBLEVBQ3hCO0FBQUEsRUFDQSxjQUF3QyxJQUFJO0FBQUEsRUFFcEQsV0FBVyxDQUFDLFlBQVksWUFBWTtBQUFBLElBQ2hDLEtBQUssWUFBWTtBQUFBO0FBQUEsRUFNYixnQkFBZ0IsQ0FBQyxTQUd2QjtBQUFBLElBQ0UsTUFBTSxRQUFRLFFBQVEsTUFBTSxtQ0FBbUM7QUFBQSxJQUMvRCxJQUFJLENBQUMsT0FBTztBQUFBLE1BQ1IsT0FBTyxFQUFFLE1BQU0sQ0FBQyxHQUFHLE1BQU0sUUFBUTtBQUFBLElBQ3JDO0FBQUEsSUFFQSxTQUFTLGFBQWEsUUFBUTtBQUFBLElBQzlCLE1BQU0sT0FBNEIsQ0FBQztBQUFBLElBRW5DLFdBQVcsUUFBUSxZQUFZLE1BQU07QUFBQSxDQUFJLEdBQUc7QUFBQSxNQUN4QyxNQUFNLGFBQWEsS0FBSyxRQUFRLEdBQUc7QUFBQSxNQUNuQyxJQUFJLGFBQWEsR0FBRztBQUFBLFFBQ2hCLE1BQU0sTUFBTSxLQUFLLE1BQU0sR0FBRyxVQUFVLEVBQUUsS0FBSztBQUFBLFFBQzNDLElBQUksUUFBYSxLQUFLLE1BQU0sYUFBYSxD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QU0sVUFBVSxXQUFXO0FBQUEsSUFDM0IsTUFBTSxpQkFBaUIsS0FBSyxNQUFPLFVBQVUsV0FBWSxHQUFHO0FBQUEsSUFFNUQsT0FBTztBQUFBLE1BQ0g7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxJQUNKO0FBQUE7QUFBQSxFQU1KLFVBQVUsR0FBUztBQUFBLElBQ2YsS0FBSyxZQUFZLE1BQU07QUFBQTtBQUFBLEVBTTNCLGFBQWEsR0FHWDtBQUFBLElBQ0UsT0FBTztBQUFBLE1BQ0gsTUFBTSxLQUFLLFlBQVk7QUFBQSxNQUN2QixTQUFTLE1BQU0sS0FBSyxLQUFLLFlBQVksS0FBSyxDQUFDO0FBQUEsSUFDL0M7QUFBQTtBQUVSO0FBS08sU0FBUyxpQkFBaUIsQ0FBQyxXQUE0QztBQUFBLEVBQzFFLE9BQU8sSUFBSSx1QkFBdUIsYUFBYSxVQUFVO0FBQUE7QUFNdEQsSUFBTSxrQkFBa0I7QUFBQSxFQUUzQixTQUFTLENBQUMsQ0FBQztBQUFBLEVBR1gsVUFBVSxDQUFDLEdBQUcsQ0FBQztBQUFBLEVBR2YsTUFBTSxDQUFDLEdBQUcsR0FBRyxDQUFDO0FBQUEsRUFHZCxVQUFVLENBQUMsR0FBRyxDQUFDO0FBQ25COyIsCiAgImRlYnVnSWQiOiAiRjVFQTQ3QjNCNzZEQ0NCRDY0NzU2RTIxNjQ3NTZFMjEiLAogICJuYW1lcyI6IFtdCn0=

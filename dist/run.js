#!/usr/bin/env node
import { createRequire } from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// node_modules/yaml/dist/nodes/identity.js
var require_identity = __commonJS((exports) => {
  var ALIAS = Symbol.for("yaml.alias");
  var DOC = Symbol.for("yaml.document");
  var MAP = Symbol.for("yaml.map");
  var PAIR = Symbol.for("yaml.pair");
  var SCALAR = Symbol.for("yaml.scalar");
  var SEQ = Symbol.for("yaml.seq");
  var NODE_TYPE = Symbol.for("yaml.node.type");
  var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
  var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
  var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
  var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
  var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
  var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
  function isCollection(node) {
    if (node && typeof node === "object")
      switch (node[NODE_TYPE]) {
        case MAP:
        case SEQ:
          return true;
      }
    return false;
  }
  function isNode(node) {
    if (node && typeof node === "object")
      switch (node[NODE_TYPE]) {
        case ALIAS:
        case MAP:
        case SCALAR:
        case SEQ:
          return true;
      }
    return false;
  }
  var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
  exports.ALIAS = ALIAS;
  exports.DOC = DOC;
  exports.MAP = MAP;
  exports.NODE_TYPE = NODE_TYPE;
  exports.PAIR = PAIR;
  exports.SCALAR = SCALAR;
  exports.SEQ = SEQ;
  exports.hasAnchor = hasAnchor;
  exports.isAlias = isAlias;
  exports.isCollection = isCollection;
  exports.isDocument = isDocument;
  exports.isMap = isMap;
  exports.isNode = isNode;
  exports.isPair = isPair;
  exports.isScalar = isScalar;
  exports.isSeq = isSeq;
});

// node_modules/yaml/dist/visit.js
var require_visit = __commonJS((exports) => {
  var identity = require_identity();
  var BREAK = Symbol("break visit");
  var SKIP = Symbol("skip children");
  var REMOVE = Symbol("remove node");
  function visit(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (identity.isDocument(node)) {
      const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
      if (cd === REMOVE)
        node.contents = null;
    } else
      visit_(null, node, visitor_, Object.freeze([]));
  }
  visit.BREAK = BREAK;
  visit.SKIP = SKIP;
  visit.REMOVE = REMOVE;
  function visit_(key, node, visitor, path) {
    const ctrl = callVisitor(key, node, visitor, path);
    if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
      replaceNode(key, path, ctrl);
      return visit_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== "symbol") {
      if (identity.isCollection(node)) {
        path = Object.freeze(path.concat(node));
        for (let i = 0;i < node.items.length; ++i) {
          const ci = visit_(i, node.items[i], visitor, path);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            node.items.splice(i, 1);
            i -= 1;
          }
        }
      } else if (identity.isPair(node)) {
        path = Object.freeze(path.concat(node));
        const ck = visit_("key", node.key, visitor, path);
        if (ck === BREAK)
          return BREAK;
        else if (ck === REMOVE)
          node.key = null;
        const cv = visit_("value", node.value, visitor, path);
        if (cv === BREAK)
          return BREAK;
        else if (cv === REMOVE)
          node.value = null;
      }
    }
    return ctrl;
  }
  async function visitAsync(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (identity.isDocument(node)) {
      const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
      if (cd === REMOVE)
        node.contents = null;
    } else
      await visitAsync_(null, node, visitor_, Object.freeze([]));
  }
  visitAsync.BREAK = BREAK;
  visitAsync.SKIP = SKIP;
  visitAsync.REMOVE = REMOVE;
  async function visitAsync_(key, node, visitor, path) {
    const ctrl = await callVisitor(key, node, visitor, path);
    if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
      replaceNode(key, path, ctrl);
      return visitAsync_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== "symbol") {
      if (identity.isCollection(node)) {
        path = Object.freeze(path.concat(node));
        for (let i = 0;i < node.items.length; ++i) {
          const ci = await visitAsync_(i, node.items[i], visitor, path);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            node.items.splice(i, 1);
            i -= 1;
          }
        }
      } else if (identity.isPair(node)) {
        path = Object.freeze(path.concat(node));
        const ck = await visitAsync_("key", node.key, visitor, path);
        if (ck === BREAK)
          return BREAK;
        else if (ck === REMOVE)
          node.key = null;
        const cv = await visitAsync_("value", node.value, visitor, path);
        if (cv === BREAK)
          return BREAK;
        else if (cv === REMOVE)
          node.value = null;
      }
    }
    return ctrl;
  }
  function initVisitor(visitor) {
    if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
      return Object.assign({
        Alias: visitor.Node,
        Map: visitor.Node,
        Scalar: visitor.Node,
        Seq: visitor.Node
      }, visitor.Value && {
        Map: visitor.Value,
        Scalar: visitor.Value,
        Seq: visitor.Value
      }, visitor.Collection && {
        Map: visitor.Collection,
        Seq: visitor.Collection
      }, visitor);
    }
    return visitor;
  }
  function callVisitor(key, node, visitor, path) {
    if (typeof visitor === "function")
      return visitor(key, node, path);
    if (identity.isMap(node))
      return visitor.Map?.(key, node, path);
    if (identity.isSeq(node))
      return visitor.Seq?.(key, node, path);
    if (identity.isPair(node))
      return visitor.Pair?.(key, node, path);
    if (identity.isScalar(node))
      return visitor.Scalar?.(key, node, path);
    if (identity.isAlias(node))
      return visitor.Alias?.(key, node, path);
    return;
  }
  function replaceNode(key, path, node) {
    const parent = path[path.length - 1];
    if (identity.isCollection(parent)) {
      parent.items[key] = node;
    } else if (identity.isPair(parent)) {
      if (key === "key")
        parent.key = node;
      else
        parent.value = node;
    } else if (identity.isDocument(parent)) {
      parent.contents = node;
    } else {
      const pt = identity.isAlias(parent) ? "alias" : "scalar";
      throw new Error(`Cannot replace node with ${pt} parent`);
    }
  }
  exports.visit = visit;
  exports.visitAsync = visitAsync;
});

// node_modules/yaml/dist/doc/directives.js
var require_directives = __commonJS((exports) => {
  var identity = require_identity();
  var visit = require_visit();
  var escapeChars = {
    "!": "%21",
    ",": "%2C",
    "[": "%5B",
    "]": "%5D",
    "{": "%7B",
    "}": "%7D"
  };
  var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);

  class Directives {
    constructor(yaml, tags) {
      this.docStart = null;
      this.docEnd = false;
      this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
      this.tags = Object.assign({}, Directives.defaultTags, tags);
    }
    clone() {
      const copy = new Directives(this.yaml, this.tags);
      copy.docStart = this.docStart;
      return copy;
    }
    atDocument() {
      const res = new Directives(this.yaml, this.tags);
      switch (this.yaml.version) {
        case "1.1":
          this.atNextDocument = true;
          break;
        case "1.2":
          this.atNextDocument = false;
          this.yaml = {
            explicit: Directives.defaultYaml.explicit,
            version: "1.2"
          };
          this.tags = Object.assign({}, Directives.defaultTags);
          break;
      }
      return res;
    }
    add(line, onError) {
      if (this.atNextDocument) {
        this.yaml = { explicit: Directives.defaultYaml.explicit, version: "1.1" };
        this.tags = Object.assign({}, Directives.defaultTags);
        this.atNextDocument = false;
      }
      const parts = line.trim().split(/[ \t]+/);
      const name = parts.shift();
      switch (name) {
        case "%TAG": {
          if (parts.length !== 2) {
            onError(0, "%TAG directive should contain exactly two parts");
            if (parts.length < 2)
              return false;
          }
          const [handle, prefix] = parts;
          this.tags[handle] = prefix;
          return true;
        }
        case "%YAML": {
          this.yaml.explicit = true;
          if (parts.length !== 1) {
            onError(0, "%YAML directive should contain exactly one part");
            return false;
          }
          const [version] = parts;
          if (version === "1.1" || version === "1.2") {
            this.yaml.version = version;
            return true;
          } else {
            const isValid = /^\d+\.\d+$/.test(version);
            onError(6, `Unsupported YAML version ${version}`, isValid);
            return false;
          }
        }
        default:
          onError(0, `Unknown directive ${name}`, true);
          return false;
      }
    }
    tagName(source, onError) {
      if (source === "!")
        return "!";
      if (source[0] !== "!") {
        onError(`Not a valid tag: ${source}`);
        return null;
      }
      if (source[1] === "<") {
        const verbatim = source.slice(2, -1);
        if (verbatim === "!" || verbatim === "!!") {
          onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
          return null;
        }
        if (source[source.length - 1] !== ">")
          onError("Verbatim tags must end with a >");
        return verbatim;
      }
      const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
      if (!suffix)
        onError(`The ${source} tag has no suffix`);
      const prefix = this.tags[handle];
      if (prefix) {
        try {
          return prefix + decodeURIComponent(suffix);
        } catch (error) {
          onError(String(error));
          return null;
        }
      }
      if (handle === "!")
        return source;
      onError(`Could not resolve tag: ${source}`);
      return null;
    }
    tagString(tag) {
      for (const [handle, prefix] of Object.entries(this.tags)) {
        if (tag.startsWith(prefix))
          return handle + escapeTagName(tag.substring(prefix.length));
      }
      return tag[0] === "!" ? tag : `!<${tag}>`;
    }
    toString(doc) {
      const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
      const tagEntries = Object.entries(this.tags);
      let tagNames;
      if (doc && tagEntries.length > 0 && identity.isNode(doc.contents)) {
        const tags = {};
        visit.visit(doc.contents, (_key, node) => {
          if (identity.isNode(node) && node.tag)
            tags[node.tag] = true;
        });
        tagNames = Object.keys(tags);
      } else
        tagNames = [];
      for (const [handle, prefix] of tagEntries) {
        if (handle === "!!" && prefix === "tag:yaml.org,2002:")
          continue;
        if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
          lines.push(`%TAG ${handle} ${prefix}`);
      }
      return lines.join(`
`);
    }
  }
  Directives.defaultYaml = { explicit: false, version: "1.2" };
  Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
  exports.Directives = Directives;
});

// node_modules/yaml/dist/doc/anchors.js
var require_anchors = __commonJS((exports) => {
  var identity = require_identity();
  var visit = require_visit();
  function anchorIsValid(anchor) {
    if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
      const sa = JSON.stringify(anchor);
      const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
      throw new Error(msg);
    }
    return true;
  }
  function anchorNames(root) {
    const anchors = new Set;
    visit.visit(root, {
      Value(_key, node) {
        if (node.anchor)
          anchors.add(node.anchor);
      }
    });
    return anchors;
  }
  function findNewAnchor(prefix, exclude) {
    for (let i = 1;; ++i) {
      const name = `${prefix}${i}`;
      if (!exclude.has(name))
        return name;
    }
  }
  function createNodeAnchors(doc, prefix) {
    const aliasObjects = [];
    const sourceObjects = new Map;
    let prevAnchors = null;
    return {
      onAnchor: (source) => {
        aliasObjects.push(source);
        prevAnchors ?? (prevAnchors = anchorNames(doc));
        const anchor = findNewAnchor(prefix, prevAnchors);
        prevAnchors.add(anchor);
        return anchor;
      },
      setAnchors: () => {
        for (const source of aliasObjects) {
          const ref = sourceObjects.get(source);
          if (typeof ref === "object" && ref.anchor && (identity.isScalar(ref.node) || identity.isCollection(ref.node))) {
            ref.node.anchor = ref.anchor;
          } else {
            const error = new Error("Failed to resolve repeated object (this should not happen)");
            error.source = source;
            throw error;
          }
        }
      },
      sourceObjects
    };
  }
  exports.anchorIsValid = anchorIsValid;
  exports.anchorNames = anchorNames;
  exports.createNodeAnchors = createNodeAnchors;
  exports.findNewAnchor = findNewAnchor;
});

// node_modules/yaml/dist/doc/applyReviver.js
var require_applyReviver = __commonJS((exports) => {
  function applyReviver(reviver, obj, key, val) {
    if (val && typeof val === "object") {
      if (Array.isArray(val)) {
        for (let i = 0, len = val.length;i < len; ++i) {
          const v0 = val[i];
          const v1 = applyReviver(reviver, val, String(i), v0);
          if (v1 === undefined)
            delete val[i];
          else if (v1 !== v0)
            val[i] = v1;
        }
      } else if (val instanceof Map) {
        for (const k of Array.from(val.keys())) {
          const v0 = val.get(k);
          const v1 = applyReviver(reviver, val, k, v0);
          if (v1 === undefined)
            val.delete(k);
          else if (v1 !== v0)
            val.set(k, v1);
        }
      } else if (val instanceof Set) {
        for (const v0 of Array.from(val)) {
          const v1 = applyReviver(reviver, val, v0, v0);
          if (v1 === undefined)
            val.delete(v0);
          else if (v1 !== v0) {
            val.delete(v0);
            val.add(v1);
          }
        }
      } else {
        for (const [k, v0] of Object.entries(val)) {
          const v1 = applyReviver(reviver, val, k, v0);
          if (v1 === undefined)
            delete val[k];
          else if (v1 !== v0)
            val[k] = v1;
        }
      }
    }
    return reviver.call(obj, key, val);
  }
  exports.applyReviver = applyReviver;
});

// node_modules/yaml/dist/nodes/toJS.js
var require_toJS = __commonJS((exports) => {
  var identity = require_identity();
  function toJS(value, arg, ctx) {
    if (Array.isArray(value))
      return value.map((v, i) => toJS(v, String(i), ctx));
    if (value && typeof value.toJSON === "function") {
      if (!ctx || !identity.hasAnchor(value))
        return value.toJSON(arg, ctx);
      const data = { aliasCount: 0, count: 1, res: undefined };
      ctx.anchors.set(value, data);
      ctx.onCreate = (res2) => {
        data.res = res2;
        delete ctx.onCreate;
      };
      const res = value.toJSON(arg, ctx);
      if (ctx.onCreate)
        ctx.onCreate(res);
      return res;
    }
    if (typeof value === "bigint" && !ctx?.keep)
      return Number(value);
    return value;
  }
  exports.toJS = toJS;
});

// node_modules/yaml/dist/nodes/Node.js
var require_Node = __commonJS((exports) => {
  var applyReviver = require_applyReviver();
  var identity = require_identity();
  var toJS = require_toJS();

  class NodeBase {
    constructor(type) {
      Object.defineProperty(this, identity.NODE_TYPE, { value: type });
    }
    clone() {
      const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
      if (this.range)
        copy.range = this.range.slice();
      return copy;
    }
    toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
      if (!identity.isDocument(doc))
        throw new TypeError("A document argument is required");
      const ctx = {
        anchors: new Map,
        doc,
        keep: true,
        mapAsMap: mapAsMap === true,
        mapKeyWarned: false,
        maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
      };
      const res = toJS.toJS(this, "", ctx);
      if (typeof onAnchor === "function")
        for (const { count, res: res2 } of ctx.anchors.values())
          onAnchor(res2, count);
      return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
    }
  }
  exports.NodeBase = NodeBase;
});

// node_modules/yaml/dist/nodes/Alias.js
var require_Alias = __commonJS((exports) => {
  var anchors = require_anchors();
  var visit = require_visit();
  var identity = require_identity();
  var Node = require_Node();
  var toJS = require_toJS();

  class Alias extends Node.NodeBase {
    constructor(source) {
      super(identity.ALIAS);
      this.source = source;
      Object.defineProperty(this, "tag", {
        set() {
          throw new Error("Alias nodes cannot have tags");
        }
      });
    }
    resolve(doc, ctx) {
      let nodes;
      if (ctx?.aliasResolveCache) {
        nodes = ctx.aliasResolveCache;
      } else {
        nodes = [];
        visit.visit(doc, {
          Node: (_key, node) => {
            if (identity.isAlias(node) || identity.hasAnchor(node))
              nodes.push(node);
          }
        });
        if (ctx)
          ctx.aliasResolveCache = nodes;
      }
      let found = undefined;
      for (const node of nodes) {
        if (node === this)
          break;
        if (node.anchor === this.source)
          found = node;
      }
      return found;
    }
    toJSON(_arg, ctx) {
      if (!ctx)
        return { source: this.source };
      const { anchors: anchors2, doc, maxAliasCount } = ctx;
      const source = this.resolve(doc, ctx);
      if (!source) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new ReferenceError(msg);
      }
      let data = anchors2.get(source);
      if (!data) {
        toJS.toJS(source, null, ctx);
        data = anchors2.get(source);
      }
      if (data?.res === undefined) {
        const msg = "This should not happen: Alias anchor was not resolved?";
        throw new ReferenceError(msg);
      }
      if (maxAliasCount >= 0) {
        data.count += 1;
        if (data.aliasCount === 0)
          data.aliasCount = getAliasCount(doc, source, anchors2);
        if (data.count * data.aliasCount > maxAliasCount) {
          const msg = "Excessive alias count indicates a resource exhaustion attack";
          throw new ReferenceError(msg);
        }
      }
      return data.res;
    }
    toString(ctx, _onComment, _onChompKeep) {
      const src = `*${this.source}`;
      if (ctx) {
        anchors.anchorIsValid(this.source);
        if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new Error(msg);
        }
        if (ctx.implicitKey)
          return `${src} `;
      }
      return src;
    }
  }
  function getAliasCount(doc, node, anchors2) {
    if (identity.isAlias(node)) {
      const source = node.resolve(doc);
      const anchor = anchors2 && source && anchors2.get(source);
      return anchor ? anchor.count * anchor.aliasCount : 0;
    } else if (identity.isCollection(node)) {
      let count = 0;
      for (const item of node.items) {
        const c = getAliasCount(doc, item, anchors2);
        if (c > count)
          count = c;
      }
      return count;
    } else if (identity.isPair(node)) {
      const kc = getAliasCount(doc, node.key, anchors2);
      const vc = getAliasCount(doc, node.value, anchors2);
      return Math.max(kc, vc);
    }
    return 1;
  }
  exports.Alias = Alias;
});

// node_modules/yaml/dist/nodes/Scalar.js
var require_Scalar = __commonJS((exports) => {
  var identity = require_identity();
  var Node = require_Node();
  var toJS = require_toJS();
  var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";

  class Scalar extends Node.NodeBase {
    constructor(value) {
      super(identity.SCALAR);
      this.value = value;
    }
    toJSON(arg, ctx) {
      return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
    }
    toString() {
      return String(this.value);
    }
  }
  Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
  Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
  Scalar.PLAIN = "PLAIN";
  Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
  Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
  exports.Scalar = Scalar;
  exports.isScalarValue = isScalarValue;
});

// node_modules/yaml/dist/doc/createNode.js
var require_createNode = __commonJS((exports) => {
  var Alias = require_Alias();
  var identity = require_identity();
  var Scalar = require_Scalar();
  var defaultTagPrefix = "tag:yaml.org,2002:";
  function findTagObject(value, tagName, tags) {
    if (tagName) {
      const match = tags.filter((t) => t.tag === tagName);
      const tagObj = match.find((t) => !t.format) ?? match[0];
      if (!tagObj)
        throw new Error(`Tag ${tagName} not found`);
      return tagObj;
    }
    return tags.find((t) => t.identify?.(value) && !t.format);
  }
  function createNode(value, tagName, ctx) {
    if (identity.isDocument(value))
      value = value.contents;
    if (identity.isNode(value))
      return value;
    if (identity.isPair(value)) {
      const map = ctx.schema[identity.MAP].createNode?.(ctx.schema, null, ctx);
      map.items.push(value);
      return map;
    }
    if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
      value = value.valueOf();
    }
    const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
    let ref = undefined;
    if (aliasDuplicateObjects && value && typeof value === "object") {
      ref = sourceObjects.get(value);
      if (ref) {
        ref.anchor ?? (ref.anchor = onAnchor(value));
        return new Alias.Alias(ref.anchor);
      } else {
        ref = { anchor: null, node: null };
        sourceObjects.set(value, ref);
      }
    }
    if (tagName?.startsWith("!!"))
      tagName = defaultTagPrefix + tagName.slice(2);
    let tagObj = findTagObject(value, tagName, schema.tags);
    if (!tagObj) {
      if (value && typeof value.toJSON === "function") {
        value = value.toJSON();
      }
      if (!value || typeof value !== "object") {
        const node2 = new Scalar.Scalar(value);
        if (ref)
          ref.node = node2;
        return node2;
      }
      tagObj = value instanceof Map ? schema[identity.MAP] : (Symbol.iterator in Object(value)) ? schema[identity.SEQ] : schema[identity.MAP];
    }
    if (onTagObj) {
      onTagObj(tagObj);
      delete ctx.onTagObj;
    }
    const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar.Scalar(value);
    if (tagName)
      node.tag = tagName;
    else if (!tagObj.default)
      node.tag = tagObj.tag;
    if (ref)
      ref.node = node;
    return node;
  }
  exports.createNode = createNode;
});

// node_modules/yaml/dist/nodes/Collection.js
var require_Collection = __commonJS((exports) => {
  var createNode = require_createNode();
  var identity = require_identity();
  var Node = require_Node();
  function collectionFromPath(schema, path, value) {
    let v = value;
    for (let i = path.length - 1;i >= 0; --i) {
      const k = path[i];
      if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
        const a = [];
        a[k] = v;
        v = a;
      } else {
        v = new Map([[k, v]]);
      }
    }
    return createNode.createNode(v, undefined, {
      aliasDuplicateObjects: false,
      keepUndefined: false,
      onAnchor: () => {
        throw new Error("This should not happen, please report a bug.");
      },
      schema,
      sourceObjects: new Map
    });
  }
  var isEmptyPath = (path) => path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;

  class Collection extends Node.NodeBase {
    constructor(type, schema) {
      super(type);
      Object.defineProperty(this, "schema", {
        value: schema,
        configurable: true,
        enumerable: false,
        writable: true
      });
    }
    clone(schema) {
      const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
      if (schema)
        copy.schema = schema;
      copy.items = copy.items.map((it) => identity.isNode(it) || identity.isPair(it) ? it.clone(schema) : it);
      if (this.range)
        copy.range = this.range.slice();
      return copy;
    }
    addIn(path, value) {
      if (isEmptyPath(path))
        this.add(value);
      else {
        const [key, ...rest] = path;
        const node = this.get(key, true);
        if (identity.isCollection(node))
          node.addIn(rest, value);
        else if (node === undefined && this.schema)
          this.set(key, collectionFromPath(this.schema, rest, value));
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
    }
    deleteIn(path) {
      const [key, ...rest] = path;
      if (rest.length === 0)
        return this.delete(key);
      const node = this.get(key, true);
      if (identity.isCollection(node))
        return node.deleteIn(rest);
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
    getIn(path, keepScalar) {
      const [key, ...rest] = path;
      const node = this.get(key, true);
      if (rest.length === 0)
        return !keepScalar && identity.isScalar(node) ? node.value : node;
      else
        return identity.isCollection(node) ? node.getIn(rest, keepScalar) : undefined;
    }
    hasAllNullValues(allowScalar) {
      return this.items.every((node) => {
        if (!identity.isPair(node))
          return false;
        const n = node.value;
        return n == null || allowScalar && identity.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
      });
    }
    hasIn(path) {
      const [key, ...rest] = path;
      if (rest.length === 0)
        return this.has(key);
      const node = this.get(key, true);
      return identity.isCollection(node) ? node.hasIn(rest) : false;
    }
    setIn(path, value) {
      const [key, ...rest] = path;
      if (rest.length === 0) {
        this.set(key, value);
      } else {
        const node = this.get(key, true);
        if (identity.isCollection(node))
          node.setIn(rest, value);
        else if (node === undefined && this.schema)
          this.set(key, collectionFromPath(this.schema, rest, value));
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
    }
  }
  exports.Collection = Collection;
  exports.collectionFromPath = collectionFromPath;
  exports.isEmptyPath = isEmptyPath;
});

// node_modules/yaml/dist/stringify/stringifyComment.js
var require_stringifyComment = __commonJS((exports) => {
  var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
  function indentComment(comment, indent) {
    if (/^\n+$/.test(comment))
      return comment.substring(1);
    return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
  }
  var lineComment = (str, indent, comment) => str.endsWith(`
`) ? indentComment(comment, indent) : comment.includes(`
`) ? `
` + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;
  exports.indentComment = indentComment;
  exports.lineComment = lineComment;
  exports.stringifyComment = stringifyComment;
});

// node_modules/yaml/dist/stringify/foldFlowLines.js
var require_foldFlowLines = __commonJS((exports) => {
  var FOLD_FLOW = "flow";
  var FOLD_BLOCK = "block";
  var FOLD_QUOTED = "quoted";
  function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
    if (!lineWidth || lineWidth < 0)
      return text;
    if (lineWidth < minContentWidth)
      minContentWidth = 0;
    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
    if (text.length <= endStep)
      return text;
    const folds = [];
    const escapedFolds = {};
    let end = lineWidth - indent.length;
    if (typeof indentAtStart === "number") {
      if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
        folds.push(0);
      else
        end = lineWidth - indentAtStart;
    }
    let split = undefined;
    let prev = undefined;
    let overflow = false;
    let i = -1;
    let escStart = -1;
    let escEnd = -1;
    if (mode === FOLD_BLOCK) {
      i = consumeMoreIndentedLines(text, i, indent.length);
      if (i !== -1)
        end = i + endStep;
    }
    for (let ch;ch = text[i += 1]; ) {
      if (mode === FOLD_QUOTED && ch === "\\") {
        escStart = i;
        switch (text[i + 1]) {
          case "x":
            i += 3;
            break;
          case "u":
            i += 5;
            break;
          case "U":
            i += 9;
            break;
          default:
            i += 1;
        }
        escEnd = i;
      }
      if (ch === `
`) {
        if (mode === FOLD_BLOCK)
          i = consumeMoreIndentedLines(text, i, indent.length);
        end = i + indent.length + endStep;
        split = undefined;
      } else {
        if (ch === " " && prev && prev !== " " && prev !== `
` && prev !== "\t") {
          const next = text[i + 1];
          if (next && next !== " " && next !== `
` && next !== "\t")
            split = i;
        }
        if (i >= end) {
          if (split) {
            folds.push(split);
            end = split + endStep;
            split = undefined;
          } else if (mode === FOLD_QUOTED) {
            while (prev === " " || prev === "\t") {
              prev = ch;
              ch = text[i += 1];
              overflow = true;
            }
            const j = i > escEnd + 1 ? i - 2 : escStart - 1;
            if (escapedFolds[j])
              return text;
            folds.push(j);
            escapedFolds[j] = true;
            end = j + endStep;
            split = undefined;
          } else {
            overflow = true;
          }
        }
      }
      prev = ch;
    }
    if (overflow && onOverflow)
      onOverflow();
    if (folds.length === 0)
      return text;
    if (onFold)
      onFold();
    let res = text.slice(0, folds[0]);
    for (let i2 = 0;i2 < folds.length; ++i2) {
      const fold = folds[i2];
      const end2 = folds[i2 + 1] || text.length;
      if (fold === 0)
        res = `
${indent}${text.slice(0, end2)}`;
      else {
        if (mode === FOLD_QUOTED && escapedFolds[fold])
          res += `${text[fold]}\\`;
        res += `
${indent}${text.slice(fold + 1, end2)}`;
      }
    }
    return res;
  }
  function consumeMoreIndentedLines(text, i, indent) {
    let end = i;
    let start = i + 1;
    let ch = text[start];
    while (ch === " " || ch === "\t") {
      if (i < start + indent) {
        ch = text[++i];
      } else {
        do {
          ch = text[++i];
        } while (ch && ch !== `
`);
        end = i;
        start = i + 1;
        ch = text[start];
      }
    }
    return end;
  }
  exports.FOLD_BLOCK = FOLD_BLOCK;
  exports.FOLD_FLOW = FOLD_FLOW;
  exports.FOLD_QUOTED = FOLD_QUOTED;
  exports.foldFlowLines = foldFlowLines;
});

// node_modules/yaml/dist/stringify/stringifyString.js
var require_stringifyString = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var foldFlowLines = require_foldFlowLines();
  var getFoldOptions = (ctx, isBlock) => ({
    indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
    lineWidth: ctx.options.lineWidth,
    minContentWidth: ctx.options.minContentWidth
  });
  var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
  function lineLengthOverLimit(str, lineWidth, indentLength) {
    if (!lineWidth || lineWidth < 0)
      return false;
    const limit = lineWidth - indentLength;
    const strLen = str.length;
    if (strLen <= limit)
      return false;
    for (let i = 0, start = 0;i < strLen; ++i) {
      if (str[i] === `
`) {
        if (i - start > limit)
          return true;
        start = i + 1;
        if (strLen - start <= limit)
          return false;
      }
    }
    return true;
  }
  function doubleQuotedString(value, ctx) {
    const json = JSON.stringify(value);
    if (ctx.options.doubleQuotedAsJSON)
      return json;
    const { implicitKey } = ctx;
    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
    const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
    let str = "";
    let start = 0;
    for (let i = 0, ch = json[i];ch; ch = json[++i]) {
      if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
        str += json.slice(start, i) + "\\ ";
        i += 1;
        start = i;
        ch = "\\";
      }
      if (ch === "\\")
        switch (json[i + 1]) {
          case "u":
            {
              str += json.slice(start, i);
              const code = json.substr(i + 2, 4);
              switch (code) {
                case "0000":
                  str += "\\0";
                  break;
                case "0007":
                  str += "\\a";
                  break;
                case "000b":
                  str += "\\v";
                  break;
                case "001b":
                  str += "\\e";
                  break;
                case "0085":
                  str += "\\N";
                  break;
                case "00a0":
                  str += "\\_";
                  break;
                case "2028":
                  str += "\\L";
                  break;
                case "2029":
                  str += "\\P";
                  break;
                default:
                  if (code.substr(0, 2) === "00")
                    str += "\\x" + code.substr(2);
                  else
                    str += json.substr(i, 6);
              }
              i += 5;
              start = i + 1;
            }
            break;
          case "n":
            if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
              i += 1;
            } else {
              str += json.slice(start, i) + `

`;
              while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
                str += `
`;
                i += 2;
              }
              str += indent;
              if (json[i + 2] === " ")
                str += "\\";
              i += 1;
              start = i + 1;
            }
            break;
          default:
            i += 1;
        }
    }
    str = start ? str + json.slice(start) : json;
    return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));
  }
  function singleQuotedString(value, ctx) {
    if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes(`
`) || /[ \t]\n|\n[ \t]/.test(value))
      return doubleQuotedString(value, ctx);
    const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
    const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
    return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
  }
  function quotedString(value, ctx) {
    const { singleQuote } = ctx.options;
    let qs;
    if (singleQuote === false)
      qs = doubleQuotedString;
    else {
      const hasDouble = value.includes('"');
      const hasSingle = value.includes("'");
      if (hasDouble && !hasSingle)
        qs = singleQuotedString;
      else if (hasSingle && !hasDouble)
        qs = doubleQuotedString;
      else
        qs = singleQuote ? singleQuotedString : doubleQuotedString;
    }
    return qs(value, ctx);
  }
  var blockEndNewlines;
  try {
    blockEndNewlines = new RegExp(`(^|(?<!
))
+(?!
|$)`, "g");
  } catch {
    blockEndNewlines = /\n+(?!\n|$)/g;
  }
  function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
    const { blockQuote, commentString, lineWidth } = ctx.options;
    if (!blockQuote || /\n[\t ]+$/.test(value)) {
      return quotedString(value, ctx);
    }
    const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
    const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.Scalar.BLOCK_FOLDED ? false : type === Scalar.Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
    if (!value)
      return literal ? `|
` : `>
`;
    let chomp;
    let endStart;
    for (endStart = value.length;endStart > 0; --endStart) {
      const ch = value[endStart - 1];
      if (ch !== `
` && ch !== "\t" && ch !== " ")
        break;
    }
    let end = value.substring(endStart);
    const endNlPos = end.indexOf(`
`);
    if (endNlPos === -1) {
      chomp = "-";
    } else if (value === end || endNlPos !== end.length - 1) {
      chomp = "+";
      if (onChompKeep)
        onChompKeep();
    } else {
      chomp = "";
    }
    if (end) {
      value = value.slice(0, -end.length);
      if (end[end.length - 1] === `
`)
        end = end.slice(0, -1);
      end = end.replace(blockEndNewlines, `$&${indent}`);
    }
    let startWithSpace = false;
    let startEnd;
    let startNlPos = -1;
    for (startEnd = 0;startEnd < value.length; ++startEnd) {
      const ch = value[startEnd];
      if (ch === " ")
        startWithSpace = true;
      else if (ch === `
`)
        startNlPos = startEnd;
      else
        break;
    }
    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
    if (start) {
      value = value.substring(start.length);
      start = start.replace(/\n+/g, `$&${indent}`);
    }
    const indentSize = indent ? "2" : "1";
    let header = (startWithSpace ? indentSize : "") + chomp;
    if (comment) {
      header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
      if (onComment)
        onComment();
    }
    if (!literal) {
      const foldedValue = value.replace(/\n+/g, `
$&`).replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
      let literalFallback = false;
      const foldOptions = getFoldOptions(ctx, true);
      if (blockQuote !== "folded" && type !== Scalar.Scalar.BLOCK_FOLDED) {
        foldOptions.onOverflow = () => {
          literalFallback = true;
        };
      }
      const body = foldFlowLines.foldFlowLines(`${start}${foldedValue}${end}`, indent, foldFlowLines.FOLD_BLOCK, foldOptions);
      if (!literalFallback)
        return `>${header}
${indent}${body}`;
    }
    value = value.replace(/\n+/g, `$&${indent}`);
    return `|${header}
${indent}${start}${value}${end}`;
  }
  function plainString(item, ctx, onComment, onChompKeep) {
    const { type, value } = item;
    const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
    if (implicitKey && value.includes(`
`) || inFlow && /[[\]{},]/.test(value)) {
      return quotedString(value, ctx);
    }
    if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
      return implicitKey || inFlow || !value.includes(`
`) ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
    }
    if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value.includes(`
`)) {
      return blockString(item, ctx, onComment, onChompKeep);
    }
    if (containsDocumentMarker(value)) {
      if (indent === "") {
        ctx.forceBlockIndent = true;
        return blockString(item, ctx, onComment, onChompKeep);
      } else if (implicitKey && indent === indentStep) {
        return quotedString(value, ctx);
      }
    }
    const str = value.replace(/\n+/g, `$&
${indent}`);
    if (actualString) {
      const test = (tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str);
      const { compat, tags } = ctx.doc.schema;
      if (tags.some(test) || compat?.some(test))
        return quotedString(value, ctx);
    }
    return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
  }
  function stringifyString(item, ctx, onComment, onChompKeep) {
    const { implicitKey, inFlow } = ctx;
    const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
    let { type } = item;
    if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
      if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
        type = Scalar.Scalar.QUOTE_DOUBLE;
    }
    const _stringify = (_type) => {
      switch (_type) {
        case Scalar.Scalar.BLOCK_FOLDED:
        case Scalar.Scalar.BLOCK_LITERAL:
          return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
        case Scalar.Scalar.QUOTE_DOUBLE:
          return doubleQuotedString(ss.value, ctx);
        case Scalar.Scalar.QUOTE_SINGLE:
          return singleQuotedString(ss.value, ctx);
        case Scalar.Scalar.PLAIN:
          return plainString(ss, ctx, onComment, onChompKeep);
        default:
          return null;
      }
    };
    let res = _stringify(type);
    if (res === null) {
      const { defaultKeyType, defaultStringType } = ctx.options;
      const t = implicitKey && defaultKeyType || defaultStringType;
      res = _stringify(t);
      if (res === null)
        throw new Error(`Unsupported default string type ${t}`);
    }
    return res;
  }
  exports.stringifyString = stringifyString;
});

// node_modules/yaml/dist/stringify/stringify.js
var require_stringify = __commonJS((exports) => {
  var anchors = require_anchors();
  var identity = require_identity();
  var stringifyComment = require_stringifyComment();
  var stringifyString = require_stringifyString();
  function createStringifyContext(doc, options) {
    const opt = Object.assign({
      blockQuote: true,
      commentString: stringifyComment.stringifyComment,
      defaultKeyType: null,
      defaultStringType: "PLAIN",
      directives: null,
      doubleQuotedAsJSON: false,
      doubleQuotedMinMultiLineLength: 40,
      falseStr: "false",
      flowCollectionPadding: true,
      indentSeq: true,
      lineWidth: 80,
      minContentWidth: 20,
      nullStr: "null",
      simpleKeys: false,
      singleQuote: null,
      trueStr: "true",
      verifyAliasOrder: true
    }, doc.schema.toStringOptions, options);
    let inFlow;
    switch (opt.collectionStyle) {
      case "block":
        inFlow = false;
        break;
      case "flow":
        inFlow = true;
        break;
      default:
        inFlow = null;
    }
    return {
      anchors: new Set,
      doc,
      flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
      indent: "",
      indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
      inFlow,
      options: opt
    };
  }
  function getTagObject(tags, item) {
    if (item.tag) {
      const match = tags.filter((t) => t.tag === item.tag);
      if (match.length > 0)
        return match.find((t) => t.format === item.format) ?? match[0];
    }
    let tagObj = undefined;
    let obj;
    if (identity.isScalar(item)) {
      obj = item.value;
      let match = tags.filter((t) => t.identify?.(obj));
      if (match.length > 1) {
        const testMatch = match.filter((t) => t.test);
        if (testMatch.length > 0)
          match = testMatch;
      }
      tagObj = match.find((t) => t.format === item.format) ?? match.find((t) => !t.format);
    } else {
      obj = item;
      tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
    }
    if (!tagObj) {
      const name = obj?.constructor?.name ?? (obj === null ? "null" : typeof obj);
      throw new Error(`Tag not resolved for ${name} value`);
    }
    return tagObj;
  }
  function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
    if (!doc.directives)
      return "";
    const props = [];
    const anchor = (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;
    if (anchor && anchors.anchorIsValid(anchor)) {
      anchors$1.add(anchor);
      props.push(`&${anchor}`);
    }
    const tag = node.tag ?? (tagObj.default ? null : tagObj.tag);
    if (tag)
      props.push(doc.directives.tagString(tag));
    return props.join(" ");
  }
  function stringify(item, ctx, onComment, onChompKeep) {
    if (identity.isPair(item))
      return item.toString(ctx, onComment, onChompKeep);
    if (identity.isAlias(item)) {
      if (ctx.doc.directives)
        return item.toString(ctx);
      if (ctx.resolvedAliases?.has(item)) {
        throw new TypeError(`Cannot stringify circular structure without alias nodes`);
      } else {
        if (ctx.resolvedAliases)
          ctx.resolvedAliases.add(item);
        else
          ctx.resolvedAliases = new Set([item]);
        item = item.resolve(ctx.doc);
      }
    }
    let tagObj = undefined;
    const node = identity.isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
    tagObj ?? (tagObj = getTagObject(ctx.doc.schema.tags, node));
    const props = stringifyProps(node, tagObj, ctx);
    if (props.length > 0)
      ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
    const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : identity.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
    if (!props)
      return str;
    return identity.isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
  }
  exports.createStringifyContext = createStringifyContext;
  exports.stringify = stringify;
});

// node_modules/yaml/dist/stringify/stringifyPair.js
var require_stringifyPair = __commonJS((exports) => {
  var identity = require_identity();
  var Scalar = require_Scalar();
  var stringify = require_stringify();
  var stringifyComment = require_stringifyComment();
  function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
    const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
    let keyComment = identity.isNode(key) && key.comment || null;
    if (simpleKeys) {
      if (keyComment) {
        throw new Error("With simple keys, key nodes cannot have comments");
      }
      if (identity.isCollection(key) || !identity.isNode(key) && typeof key === "object") {
        const msg = "With simple keys, collection cannot be used as a key value";
        throw new Error(msg);
      }
    }
    let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || identity.isCollection(key) || (identity.isScalar(key) ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL : typeof key === "object"));
    ctx = Object.assign({}, ctx, {
      allNullValues: false,
      implicitKey: !explicitKey && (simpleKeys || !allNullValues),
      indent: indent + indentStep
    });
    let keyCommentDone = false;
    let chompKeep = false;
    let str = stringify.stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
    if (!explicitKey && !ctx.inFlow && str.length > 1024) {
      if (simpleKeys)
        throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
      explicitKey = true;
    }
    if (ctx.inFlow) {
      if (allNullValues || value == null) {
        if (keyCommentDone && onComment)
          onComment();
        return str === "" ? "?" : explicitKey ? `? ${str}` : str;
      }
    } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
      str = `? ${str}`;
      if (keyComment && !keyCommentDone) {
        str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
      } else if (chompKeep && onChompKeep)
        onChompKeep();
      return str;
    }
    if (keyCommentDone)
      keyComment = null;
    if (explicitKey) {
      if (keyComment)
        str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
      str = `? ${str}
${indent}:`;
    } else {
      str = `${str}:`;
      if (keyComment)
        str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
    }
    let vsb, vcb, valueComment;
    if (identity.isNode(value)) {
      vsb = !!value.spaceBefore;
      vcb = value.commentBefore;
      valueComment = value.comment;
    } else {
      vsb = false;
      vcb = null;
      valueComment = null;
      if (value && typeof value === "object")
        value = doc.createNode(value);
    }
    ctx.implicitKey = false;
    if (!explicitKey && !keyComment && identity.isScalar(value))
      ctx.indentAtStart = str.length + 1;
    chompKeep = false;
    if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && identity.isSeq(value) && !value.flow && !value.tag && !value.anchor) {
      ctx.indent = ctx.indent.substring(2);
    }
    let valueCommentDone = false;
    const valueStr = stringify.stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
    let ws = " ";
    if (keyComment || vsb || vcb) {
      ws = vsb ? `
` : "";
      if (vcb) {
        const cs = commentString(vcb);
        ws += `
${stringifyComment.indentComment(cs, ctx.indent)}`;
      }
      if (valueStr === "" && !ctx.inFlow) {
        if (ws === `
` && valueComment)
          ws = `

`;
      } else {
        ws += `
${ctx.indent}`;
      }
    } else if (!explicitKey && identity.isCollection(value)) {
      const vs0 = valueStr[0];
      const nl0 = valueStr.indexOf(`
`);
      const hasNewline = nl0 !== -1;
      const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
      if (hasNewline || !flow) {
        let hasPropsLine = false;
        if (hasNewline && (vs0 === "&" || vs0 === "!")) {
          let sp0 = valueStr.indexOf(" ");
          if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
            sp0 = valueStr.indexOf(" ", sp0 + 1);
          }
          if (sp0 === -1 || nl0 < sp0)
            hasPropsLine = true;
        }
        if (!hasPropsLine)
          ws = `
${ctx.indent}`;
      }
    } else if (valueStr === "" || valueStr[0] === `
`) {
      ws = "";
    }
    str += ws + valueStr;
    if (ctx.inFlow) {
      if (valueCommentDone && onComment)
        onComment();
    } else if (valueComment && !valueCommentDone) {
      str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));
    } else if (chompKeep && onChompKeep) {
      onChompKeep();
    }
    return str;
  }
  exports.stringifyPair = stringifyPair;
});

// node_modules/yaml/dist/log.js
var require_log = __commonJS((exports) => {
  var node_process = __require("process");
  function debug(logLevel, ...messages) {
    if (logLevel === "debug")
      console.log(...messages);
  }
  function warn(logLevel, warning) {
    if (logLevel === "debug" || logLevel === "warn") {
      if (typeof node_process.emitWarning === "function")
        node_process.emitWarning(warning);
      else
        console.warn(warning);
    }
  }
  exports.debug = debug;
  exports.warn = warn;
});

// node_modules/yaml/dist/schema/yaml-1.1/merge.js
var require_merge = __commonJS((exports) => {
  var identity = require_identity();
  var Scalar = require_Scalar();
  var MERGE_KEY = "<<";
  var merge = {
    identify: (value) => value === MERGE_KEY || typeof value === "symbol" && value.description === MERGE_KEY,
    default: "key",
    tag: "tag:yaml.org,2002:merge",
    test: /^<<$/,
    resolve: () => Object.assign(new Scalar.Scalar(Symbol(MERGE_KEY)), {
      addToJSMap: addMergeToJSMap
    }),
    stringify: () => MERGE_KEY
  };
  var isMergeKey = (ctx, key) => (merge.identify(key) || identity.isScalar(key) && (!key.type || key.type === Scalar.Scalar.PLAIN) && merge.identify(key.value)) && ctx?.doc.schema.tags.some((tag) => tag.tag === merge.tag && tag.default);
  function addMergeToJSMap(ctx, map, value) {
    value = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
    if (identity.isSeq(value))
      for (const it of value.items)
        mergeValue(ctx, map, it);
    else if (Array.isArray(value))
      for (const it of value)
        mergeValue(ctx, map, it);
    else
      mergeValue(ctx, map, value);
  }
  function mergeValue(ctx, map, value) {
    const source = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
    if (!identity.isMap(source))
      throw new Error("Merge sources must be maps or map aliases");
    const srcMap = source.toJSON(null, ctx, Map);
    for (const [key, value2] of srcMap) {
      if (map instanceof Map) {
        if (!map.has(key))
          map.set(key, value2);
      } else if (map instanceof Set) {
        map.add(key);
      } else if (!Object.prototype.hasOwnProperty.call(map, key)) {
        Object.defineProperty(map, key, {
          value: value2,
          writable: true,
          enumerable: true,
          configurable: true
        });
      }
    }
    return map;
  }
  exports.addMergeToJSMap = addMergeToJSMap;
  exports.isMergeKey = isMergeKey;
  exports.merge = merge;
});

// node_modules/yaml/dist/nodes/addPairToJSMap.js
var require_addPairToJSMap = __commonJS((exports) => {
  var log = require_log();
  var merge = require_merge();
  var stringify = require_stringify();
  var identity = require_identity();
  var toJS = require_toJS();
  function addPairToJSMap(ctx, map, { key, value }) {
    if (identity.isNode(key) && key.addToJSMap)
      key.addToJSMap(ctx, map, value);
    else if (merge.isMergeKey(ctx, key))
      merge.addMergeToJSMap(ctx, map, value);
    else {
      const jsKey = toJS.toJS(key, "", ctx);
      if (map instanceof Map) {
        map.set(jsKey, toJS.toJS(value, jsKey, ctx));
      } else if (map instanceof Set) {
        map.add(jsKey);
      } else {
        const stringKey = stringifyKey(key, jsKey, ctx);
        const jsValue = toJS.toJS(value, stringKey, ctx);
        if (stringKey in map)
          Object.defineProperty(map, stringKey, {
            value: jsValue,
            writable: true,
            enumerable: true,
            configurable: true
          });
        else
          map[stringKey] = jsValue;
      }
    }
    return map;
  }
  function stringifyKey(key, jsKey, ctx) {
    if (jsKey === null)
      return "";
    if (typeof jsKey !== "object")
      return String(jsKey);
    if (identity.isNode(key) && ctx?.doc) {
      const strCtx = stringify.createStringifyContext(ctx.doc, {});
      strCtx.anchors = new Set;
      for (const node of ctx.anchors.keys())
        strCtx.anchors.add(node.anchor);
      strCtx.inFlow = true;
      strCtx.inStringifyKey = true;
      const strKey = key.toString(strCtx);
      if (!ctx.mapKeyWarned) {
        let jsonStr = JSON.stringify(strKey);
        if (jsonStr.length > 40)
          jsonStr = jsonStr.substring(0, 36) + '..."';
        log.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
        ctx.mapKeyWarned = true;
      }
      return strKey;
    }
    return JSON.stringify(jsKey);
  }
  exports.addPairToJSMap = addPairToJSMap;
});

// node_modules/yaml/dist/nodes/Pair.js
var require_Pair = __commonJS((exports) => {
  var createNode = require_createNode();
  var stringifyPair = require_stringifyPair();
  var addPairToJSMap = require_addPairToJSMap();
  var identity = require_identity();
  function createPair(key, value, ctx) {
    const k = createNode.createNode(key, undefined, ctx);
    const v = createNode.createNode(value, undefined, ctx);
    return new Pair(k, v);
  }

  class Pair {
    constructor(key, value = null) {
      Object.defineProperty(this, identity.NODE_TYPE, { value: identity.PAIR });
      this.key = key;
      this.value = value;
    }
    clone(schema) {
      let { key, value } = this;
      if (identity.isNode(key))
        key = key.clone(schema);
      if (identity.isNode(value))
        value = value.clone(schema);
      return new Pair(key, value);
    }
    toJSON(_, ctx) {
      const pair = ctx?.mapAsMap ? new Map : {};
      return addPairToJSMap.addPairToJSMap(ctx, pair, this);
    }
    toString(ctx, onComment, onChompKeep) {
      return ctx?.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
    }
  }
  exports.Pair = Pair;
  exports.createPair = createPair;
});

// node_modules/yaml/dist/stringify/stringifyCollection.js
var require_stringifyCollection = __commonJS((exports) => {
  var identity = require_identity();
  var stringify = require_stringify();
  var stringifyComment = require_stringifyComment();
  function stringifyCollection(collection, ctx, options) {
    const flow = ctx.inFlow ?? collection.flow;
    const stringify2 = flow ? stringifyFlowCollection : stringifyBlockCollection;
    return stringify2(collection, ctx, options);
  }
  function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
    const { indent, options: { commentString } } = ctx;
    const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
    let chompKeep = false;
    const lines = [];
    for (let i = 0;i < items.length; ++i) {
      const item = items[i];
      let comment2 = null;
      if (identity.isNode(item)) {
        if (!chompKeep && item.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
        if (item.comment)
          comment2 = item.comment;
      } else if (identity.isPair(item)) {
        const ik = identity.isNode(item.key) ? item.key : null;
        if (ik) {
          if (!chompKeep && ik.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
        }
      }
      chompKeep = false;
      let str2 = stringify.stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
      if (comment2)
        str2 += stringifyComment.lineComment(str2, itemIndent, commentString(comment2));
      if (chompKeep && comment2)
        chompKeep = false;
      lines.push(blockItemPrefix + str2);
    }
    let str;
    if (lines.length === 0) {
      str = flowChars.start + flowChars.end;
    } else {
      str = lines[0];
      for (let i = 1;i < lines.length; ++i) {
        const line = lines[i];
        str += line ? `
${indent}${line}` : `
`;
      }
    }
    if (comment) {
      str += `
` + stringifyComment.indentComment(commentString(comment), indent);
      if (onComment)
        onComment();
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
    const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
    itemIndent += indentStep;
    const itemCtx = Object.assign({}, ctx, {
      indent: itemIndent,
      inFlow: true,
      type: null
    });
    let reqNewline = false;
    let linesAtValue = 0;
    const lines = [];
    for (let i = 0;i < items.length; ++i) {
      const item = items[i];
      let comment = null;
      if (identity.isNode(item)) {
        if (item.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, item.commentBefore, false);
        if (item.comment)
          comment = item.comment;
      } else if (identity.isPair(item)) {
        const ik = identity.isNode(item.key) ? item.key : null;
        if (ik) {
          if (ik.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, ik.commentBefore, false);
          if (ik.comment)
            reqNewline = true;
        }
        const iv = identity.isNode(item.value) ? item.value : null;
        if (iv) {
          if (iv.comment)
            comment = iv.comment;
          if (iv.commentBefore)
            reqNewline = true;
        } else if (item.value == null && ik?.comment) {
          comment = ik.comment;
        }
      }
      if (comment)
        reqNewline = true;
      let str = stringify.stringify(item, itemCtx, () => comment = null);
      if (i < items.length - 1)
        str += ",";
      if (comment)
        str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
      if (!reqNewline && (lines.length > linesAtValue || str.includes(`
`)))
        reqNewline = true;
      lines.push(str);
      linesAtValue = lines.length;
    }
    const { start, end } = flowChars;
    if (lines.length === 0) {
      return start + end;
    } else {
      if (!reqNewline) {
        const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
        reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
      }
      if (reqNewline) {
        let str = start;
        for (const line of lines)
          str += line ? `
${indentStep}${indent}${line}` : `
`;
        return `${str}
${indent}${end}`;
      } else {
        return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
      }
    }
  }
  function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
    if (comment && chompKeep)
      comment = comment.replace(/^\n+/, "");
    if (comment) {
      const ic = stringifyComment.indentComment(commentString(comment), indent);
      lines.push(ic.trimStart());
    }
  }
  exports.stringifyCollection = stringifyCollection;
});

// node_modules/yaml/dist/nodes/YAMLMap.js
var require_YAMLMap = __commonJS((exports) => {
  var stringifyCollection = require_stringifyCollection();
  var addPairToJSMap = require_addPairToJSMap();
  var Collection = require_Collection();
  var identity = require_identity();
  var Pair = require_Pair();
  var Scalar = require_Scalar();
  function findPair(items, key) {
    const k = identity.isScalar(key) ? key.value : key;
    for (const it of items) {
      if (identity.isPair(it)) {
        if (it.key === key || it.key === k)
          return it;
        if (identity.isScalar(it.key) && it.key.value === k)
          return it;
      }
    }
    return;
  }

  class YAMLMap extends Collection.Collection {
    static get tagName() {
      return "tag:yaml.org,2002:map";
    }
    constructor(schema) {
      super(identity.MAP, schema);
      this.items = [];
    }
    static from(schema, obj, ctx) {
      const { keepUndefined, replacer } = ctx;
      const map = new this(schema);
      const add = (key, value) => {
        if (typeof replacer === "function")
          value = replacer.call(obj, key, value);
        else if (Array.isArray(replacer) && !replacer.includes(key))
          return;
        if (value !== undefined || keepUndefined)
          map.items.push(Pair.createPair(key, value, ctx));
      };
      if (obj instanceof Map) {
        for (const [key, value] of obj)
          add(key, value);
      } else if (obj && typeof obj === "object") {
        for (const key of Object.keys(obj))
          add(key, obj[key]);
      }
      if (typeof schema.sortMapEntries === "function") {
        map.items.sort(schema.sortMapEntries);
      }
      return map;
    }
    add(pair, overwrite) {
      let _pair;
      if (identity.isPair(pair))
        _pair = pair;
      else if (!pair || typeof pair !== "object" || !("key" in pair)) {
        _pair = new Pair.Pair(pair, pair?.value);
      } else
        _pair = new Pair.Pair(pair.key, pair.value);
      const prev = findPair(this.items, _pair.key);
      const sortEntries = this.schema?.sortMapEntries;
      if (prev) {
        if (!overwrite)
          throw new Error(`Key ${_pair.key} already set`);
        if (identity.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))
          prev.value.value = _pair.value;
        else
          prev.value = _pair.value;
      } else if (sortEntries) {
        const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
        if (i === -1)
          this.items.push(_pair);
        else
          this.items.splice(i, 0, _pair);
      } else {
        this.items.push(_pair);
      }
    }
    delete(key) {
      const it = findPair(this.items, key);
      if (!it)
        return false;
      const del = this.items.splice(this.items.indexOf(it), 1);
      return del.length > 0;
    }
    get(key, keepScalar) {
      const it = findPair(this.items, key);
      const node = it?.value;
      return (!keepScalar && identity.isScalar(node) ? node.value : node) ?? undefined;
    }
    has(key) {
      return !!findPair(this.items, key);
    }
    set(key, value) {
      this.add(new Pair.Pair(key, value), true);
    }
    toJSON(_, ctx, Type) {
      const map = Type ? new Type : ctx?.mapAsMap ? new Map : {};
      if (ctx?.onCreate)
        ctx.onCreate(map);
      for (const item of this.items)
        addPairToJSMap.addPairToJSMap(ctx, map, item);
      return map;
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      for (const item of this.items) {
        if (!identity.isPair(item))
          throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
      }
      if (!ctx.allNullValues && this.hasAllNullValues(false))
        ctx = Object.assign({}, ctx, { allNullValues: true });
      return stringifyCollection.stringifyCollection(this, ctx, {
        blockItemPrefix: "",
        flowChars: { start: "{", end: "}" },
        itemIndent: ctx.indent || "",
        onChompKeep,
        onComment
      });
    }
  }
  exports.YAMLMap = YAMLMap;
  exports.findPair = findPair;
});

// node_modules/yaml/dist/schema/common/map.js
var require_map = __commonJS((exports) => {
  var identity = require_identity();
  var YAMLMap = require_YAMLMap();
  var map = {
    collection: "map",
    default: true,
    nodeClass: YAMLMap.YAMLMap,
    tag: "tag:yaml.org,2002:map",
    resolve(map2, onError) {
      if (!identity.isMap(map2))
        onError("Expected a mapping for this tag");
      return map2;
    },
    createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx)
  };
  exports.map = map;
});

// node_modules/yaml/dist/nodes/YAMLSeq.js
var require_YAMLSeq = __commonJS((exports) => {
  var createNode = require_createNode();
  var stringifyCollection = require_stringifyCollection();
  var Collection = require_Collection();
  var identity = require_identity();
  var Scalar = require_Scalar();
  var toJS = require_toJS();

  class YAMLSeq extends Collection.Collection {
    static get tagName() {
      return "tag:yaml.org,2002:seq";
    }
    constructor(schema) {
      super(identity.SEQ, schema);
      this.items = [];
    }
    add(value) {
      this.items.push(value);
    }
    delete(key) {
      const idx = asItemIndex(key);
      if (typeof idx !== "number")
        return false;
      const del = this.items.splice(idx, 1);
      return del.length > 0;
    }
    get(key, keepScalar) {
      const idx = asItemIndex(key);
      if (typeof idx !== "number")
        return;
      const it = this.items[idx];
      return !keepScalar && identity.isScalar(it) ? it.value : it;
    }
    has(key) {
      const idx = asItemIndex(key);
      return typeof idx === "number" && idx < this.items.length;
    }
    set(key, value) {
      const idx = asItemIndex(key);
      if (typeof idx !== "number")
        throw new Error(`Expected a valid index, not ${key}.`);
      const prev = this.items[idx];
      if (identity.isScalar(prev) && Scalar.isScalarValue(value))
        prev.value = value;
      else
        this.items[idx] = value;
    }
    toJSON(_, ctx) {
      const seq = [];
      if (ctx?.onCreate)
        ctx.onCreate(seq);
      let i = 0;
      for (const item of this.items)
        seq.push(toJS.toJS(item, String(i++), ctx));
      return seq;
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      return stringifyCollection.stringifyCollection(this, ctx, {
        blockItemPrefix: "- ",
        flowChars: { start: "[", end: "]" },
        itemIndent: (ctx.indent || "") + "  ",
        onChompKeep,
        onComment
      });
    }
    static from(schema, obj, ctx) {
      const { replacer } = ctx;
      const seq = new this(schema);
      if (obj && Symbol.iterator in Object(obj)) {
        let i = 0;
        for (let it of obj) {
          if (typeof replacer === "function") {
            const key = obj instanceof Set ? it : String(i++);
            it = replacer.call(obj, key, it);
          }
          seq.items.push(createNode.createNode(it, undefined, ctx));
        }
      }
      return seq;
    }
  }
  function asItemIndex(key) {
    let idx = identity.isScalar(key) ? key.value : key;
    if (idx && typeof idx === "string")
      idx = Number(idx);
    return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
  }
  exports.YAMLSeq = YAMLSeq;
});

// node_modules/yaml/dist/schema/common/seq.js
var require_seq = __commonJS((exports) => {
  var identity = require_identity();
  var YAMLSeq = require_YAMLSeq();
  var seq = {
    collection: "seq",
    default: true,
    nodeClass: YAMLSeq.YAMLSeq,
    tag: "tag:yaml.org,2002:seq",
    resolve(seq2, onError) {
      if (!identity.isSeq(seq2))
        onError("Expected a sequence for this tag");
      return seq2;
    },
    createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx)
  };
  exports.seq = seq;
});

// node_modules/yaml/dist/schema/common/string.js
var require_string = __commonJS((exports) => {
  var stringifyString = require_stringifyString();
  var string = {
    identify: (value) => typeof value === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str) => str,
    stringify(item, ctx, onComment, onChompKeep) {
      ctx = Object.assign({ actualString: true }, ctx);
      return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
    }
  };
  exports.string = string;
});

// node_modules/yaml/dist/schema/common/null.js
var require_null = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var nullTag = {
    identify: (value) => value == null,
    createNode: () => new Scalar.Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^(?:~|[Nn]ull|NULL)?$/,
    resolve: () => new Scalar.Scalar(null),
    stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
  };
  exports.nullTag = nullTag;
});

// node_modules/yaml/dist/schema/core/bool.js
var require_bool = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var boolTag = {
    identify: (value) => typeof value === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
    resolve: (str) => new Scalar.Scalar(str[0] === "t" || str[0] === "T"),
    stringify({ source, value }, ctx) {
      if (source && boolTag.test.test(source)) {
        const sv = source[0] === "t" || source[0] === "T";
        if (value === sv)
          return source;
      }
      return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
  };
  exports.boolTag = boolTag;
});

// node_modules/yaml/dist/stringify/stringifyNumber.js
var require_stringifyNumber = __commonJS((exports) => {
  function stringifyNumber({ format, minFractionDigits, tag, value }) {
    if (typeof value === "bigint")
      return String(value);
    const num = typeof value === "number" ? value : Number(value);
    if (!isFinite(num))
      return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
    let n = Object.is(value, -0) ? "-0" : JSON.stringify(value);
    if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
      let i = n.indexOf(".");
      if (i < 0) {
        i = n.length;
        n += ".";
      }
      let d = minFractionDigits - (n.length - i - 1);
      while (d-- > 0)
        n += "0";
    }
    return n;
  }
  exports.stringifyNumber = stringifyNumber;
});

// node_modules/yaml/dist/schema/core/float.js
var require_float = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var stringifyNumber = require_stringifyNumber();
  var floatNaN = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
    resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
  };
  var floatExp = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str),
    stringify(node) {
      const num = Number(node.value);
      return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
    }
  };
  var float = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
    resolve(str) {
      const node = new Scalar.Scalar(parseFloat(str));
      const dot = str.indexOf(".");
      if (dot !== -1 && str[str.length - 1] === "0")
        node.minFractionDigits = str.length - dot - 1;
      return node;
    },
    stringify: stringifyNumber.stringifyNumber
  };
  exports.float = float;
  exports.floatExp = floatExp;
  exports.floatNaN = floatNaN;
});

// node_modules/yaml/dist/schema/core/int.js
var require_int = __commonJS((exports) => {
  var stringifyNumber = require_stringifyNumber();
  var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
  var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
  function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value) && value >= 0)
      return prefix + value.toString(radix);
    return stringifyNumber.stringifyNumber(node);
  }
  var intOct = {
    identify: (value) => intIdentify(value) && value >= 0,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^0o[0-7]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
    stringify: (node) => intStringify(node, 8, "0o")
  };
  var int = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^[-+]?[0-9]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
  };
  var intHex = {
    identify: (value) => intIdentify(value) && value >= 0,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^0x[0-9a-fA-F]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: (node) => intStringify(node, 16, "0x")
  };
  exports.int = int;
  exports.intHex = intHex;
  exports.intOct = intOct;
});

// node_modules/yaml/dist/schema/core/schema.js
var require_schema = __commonJS((exports) => {
  var map = require_map();
  var _null = require_null();
  var seq = require_seq();
  var string = require_string();
  var bool = require_bool();
  var float = require_float();
  var int = require_int();
  var schema = [
    map.map,
    seq.seq,
    string.string,
    _null.nullTag,
    bool.boolTag,
    int.intOct,
    int.int,
    int.intHex,
    float.floatNaN,
    float.floatExp,
    float.float
  ];
  exports.schema = schema;
});

// node_modules/yaml/dist/schema/json/schema.js
var require_schema2 = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var map = require_map();
  var seq = require_seq();
  function intIdentify(value) {
    return typeof value === "bigint" || Number.isInteger(value);
  }
  var stringifyJSON = ({ value }) => JSON.stringify(value);
  var jsonScalars = [
    {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str) => str,
      stringify: stringifyJSON
    },
    {
      identify: (value) => value == null,
      createNode: () => new Scalar.Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^null$/,
      resolve: () => null,
      stringify: stringifyJSON
    },
    {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^true$|^false$/,
      resolve: (str) => str === "true",
      stringify: stringifyJSON
    },
    {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^-?(?:0|[1-9][0-9]*)$/,
      resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
      stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)
    },
    {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
      resolve: (str) => parseFloat(str),
      stringify: stringifyJSON
    }
  ];
  var jsonError = {
    default: true,
    tag: "",
    test: /^/,
    resolve(str, onError) {
      onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
      return str;
    }
  };
  var schema = [map.map, seq.seq].concat(jsonScalars, jsonError);
  exports.schema = schema;
});

// node_modules/yaml/dist/schema/yaml-1.1/binary.js
var require_binary = __commonJS((exports) => {
  var node_buffer = __require("buffer");
  var Scalar = require_Scalar();
  var stringifyString = require_stringifyString();
  var binary = {
    identify: (value) => value instanceof Uint8Array,
    default: false,
    tag: "tag:yaml.org,2002:binary",
    resolve(src, onError) {
      if (typeof node_buffer.Buffer === "function") {
        return node_buffer.Buffer.from(src, "base64");
      } else if (typeof atob === "function") {
        const str = atob(src.replace(/[\n\r]/g, ""));
        const buffer = new Uint8Array(str.length);
        for (let i = 0;i < str.length; ++i)
          buffer[i] = str.charCodeAt(i);
        return buffer;
      } else {
        onError("This environment does not support reading binary tags; either Buffer or atob is required");
        return src;
      }
    },
    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
      if (!value)
        return "";
      const buf = value;
      let str;
      if (typeof node_buffer.Buffer === "function") {
        str = buf instanceof node_buffer.Buffer ? buf.toString("base64") : node_buffer.Buffer.from(buf.buffer).toString("base64");
      } else if (typeof btoa === "function") {
        let s = "";
        for (let i = 0;i < buf.length; ++i)
          s += String.fromCharCode(buf[i]);
        str = btoa(s);
      } else {
        throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
      }
      type ?? (type = Scalar.Scalar.BLOCK_LITERAL);
      if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
        const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
        const n = Math.ceil(str.length / lineWidth);
        const lines = new Array(n);
        for (let i = 0, o = 0;i < n; ++i, o += lineWidth) {
          lines[i] = str.substr(o, lineWidth);
        }
        str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? `
` : " ");
      }
      return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
    }
  };
  exports.binary = binary;
});

// node_modules/yaml/dist/schema/yaml-1.1/pairs.js
var require_pairs = __commonJS((exports) => {
  var identity = require_identity();
  var Pair = require_Pair();
  var Scalar = require_Scalar();
  var YAMLSeq = require_YAMLSeq();
  function resolvePairs(seq, onError) {
    if (identity.isSeq(seq)) {
      for (let i = 0;i < seq.items.length; ++i) {
        let item = seq.items[i];
        if (identity.isPair(item))
          continue;
        else if (identity.isMap(item)) {
          if (item.items.length > 1)
            onError("Each pair must have its own sequence indicator");
          const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
          if (item.commentBefore)
            pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
          if (item.comment) {
            const cn = pair.value ?? pair.key;
            cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
          }
          item = pair;
        }
        seq.items[i] = identity.isPair(item) ? item : new Pair.Pair(item);
      }
    } else
      onError("Expected a sequence for this tag");
    return seq;
  }
  function createPairs(schema, iterable, ctx) {
    const { replacer } = ctx;
    const pairs2 = new YAMLSeq.YAMLSeq(schema);
    pairs2.tag = "tag:yaml.org,2002:pairs";
    let i = 0;
    if (iterable && Symbol.iterator in Object(iterable))
      for (let it of iterable) {
        if (typeof replacer === "function")
          it = replacer.call(iterable, String(i++), it);
        let key, value;
        if (Array.isArray(it)) {
          if (it.length === 2) {
            key = it[0];
            value = it[1];
          } else
            throw new TypeError(`Expected [key, value] tuple: ${it}`);
        } else if (it && it instanceof Object) {
          const keys = Object.keys(it);
          if (keys.length === 1) {
            key = keys[0];
            value = it[key];
          } else {
            throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
          }
        } else {
          key = it;
        }
        pairs2.items.push(Pair.createPair(key, value, ctx));
      }
    return pairs2;
  }
  var pairs = {
    collection: "seq",
    default: false,
    tag: "tag:yaml.org,2002:pairs",
    resolve: resolvePairs,
    createNode: createPairs
  };
  exports.createPairs = createPairs;
  exports.pairs = pairs;
  exports.resolvePairs = resolvePairs;
});

// node_modules/yaml/dist/schema/yaml-1.1/omap.js
var require_omap = __commonJS((exports) => {
  var identity = require_identity();
  var toJS = require_toJS();
  var YAMLMap = require_YAMLMap();
  var YAMLSeq = require_YAMLSeq();
  var pairs = require_pairs();

  class YAMLOMap extends YAMLSeq.YAMLSeq {
    constructor() {
      super();
      this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
      this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
      this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
      this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
      this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
      this.tag = YAMLOMap.tag;
    }
    toJSON(_, ctx) {
      if (!ctx)
        return super.toJSON(_);
      const map = new Map;
      if (ctx?.onCreate)
        ctx.onCreate(map);
      for (const pair of this.items) {
        let key, value;
        if (identity.isPair(pair)) {
          key = toJS.toJS(pair.key, "", ctx);
          value = toJS.toJS(pair.value, key, ctx);
        } else {
          key = toJS.toJS(pair, "", ctx);
        }
        if (map.has(key))
          throw new Error("Ordered maps must not include duplicate keys");
        map.set(key, value);
      }
      return map;
    }
    static from(schema, iterable, ctx) {
      const pairs$1 = pairs.createPairs(schema, iterable, ctx);
      const omap2 = new this;
      omap2.items = pairs$1.items;
      return omap2;
    }
  }
  YAMLOMap.tag = "tag:yaml.org,2002:omap";
  var omap = {
    collection: "seq",
    identify: (value) => value instanceof Map,
    nodeClass: YAMLOMap,
    default: false,
    tag: "tag:yaml.org,2002:omap",
    resolve(seq, onError) {
      const pairs$1 = pairs.resolvePairs(seq, onError);
      const seenKeys = [];
      for (const { key } of pairs$1.items) {
        if (identity.isScalar(key)) {
          if (seenKeys.includes(key.value)) {
            onError(`Ordered maps must not include duplicate keys: ${key.value}`);
          } else {
            seenKeys.push(key.value);
          }
        }
      }
      return Object.assign(new YAMLOMap, pairs$1);
    },
    createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
  };
  exports.YAMLOMap = YAMLOMap;
  exports.omap = omap;
});

// node_modules/yaml/dist/schema/yaml-1.1/bool.js
var require_bool2 = __commonJS((exports) => {
  var Scalar = require_Scalar();
  function boolStringify({ value, source }, ctx) {
    const boolObj = value ? trueTag : falseTag;
    if (source && boolObj.test.test(source))
      return source;
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
  var trueTag = {
    identify: (value) => value === true,
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
    resolve: () => new Scalar.Scalar(true),
    stringify: boolStringify
  };
  var falseTag = {
    identify: (value) => value === false,
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
    resolve: () => new Scalar.Scalar(false),
    stringify: boolStringify
  };
  exports.falseTag = falseTag;
  exports.trueTag = trueTag;
});

// node_modules/yaml/dist/schema/yaml-1.1/float.js
var require_float2 = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var stringifyNumber = require_stringifyNumber();
  var floatNaN = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
    resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
  };
  var floatExp = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str.replace(/_/g, "")),
    stringify(node) {
      const num = Number(node.value);
      return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
    }
  };
  var float = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
    resolve(str) {
      const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, "")));
      const dot = str.indexOf(".");
      if (dot !== -1) {
        const f = str.substring(dot + 1).replace(/_/g, "");
        if (f[f.length - 1] === "0")
          node.minFractionDigits = f.length;
      }
      return node;
    },
    stringify: stringifyNumber.stringifyNumber
  };
  exports.float = float;
  exports.floatExp = floatExp;
  exports.floatNaN = floatNaN;
});

// node_modules/yaml/dist/schema/yaml-1.1/int.js
var require_int2 = __commonJS((exports) => {
  var stringifyNumber = require_stringifyNumber();
  var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
  function intResolve(str, offset, radix, { intAsBigInt }) {
    const sign = str[0];
    if (sign === "-" || sign === "+")
      offset += 1;
    str = str.substring(offset).replace(/_/g, "");
    if (intAsBigInt) {
      switch (radix) {
        case 2:
          str = `0b${str}`;
          break;
        case 8:
          str = `0o${str}`;
          break;
        case 16:
          str = `0x${str}`;
          break;
      }
      const n2 = BigInt(str);
      return sign === "-" ? BigInt(-1) * n2 : n2;
    }
    const n = parseInt(str, radix);
    return sign === "-" ? -1 * n : n;
  }
  function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value)) {
      const str = value.toString(radix);
      return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
    }
    return stringifyNumber.stringifyNumber(node);
  }
  var intBin = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "BIN",
    test: /^[-+]?0b[0-1_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
    stringify: (node) => intStringify(node, 2, "0b")
  };
  var intOct = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^[-+]?0[0-7_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
    stringify: (node) => intStringify(node, 8, "0")
  };
  var int = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^[-+]?[0-9][0-9_]*$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
  };
  var intHex = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^[-+]?0x[0-9a-fA-F_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: (node) => intStringify(node, 16, "0x")
  };
  exports.int = int;
  exports.intBin = intBin;
  exports.intHex = intHex;
  exports.intOct = intOct;
});

// node_modules/yaml/dist/schema/yaml-1.1/set.js
var require_set = __commonJS((exports) => {
  var identity = require_identity();
  var Pair = require_Pair();
  var YAMLMap = require_YAMLMap();

  class YAMLSet extends YAMLMap.YAMLMap {
    constructor(schema) {
      super(schema);
      this.tag = YAMLSet.tag;
    }
    add(key) {
      let pair;
      if (identity.isPair(key))
        pair = key;
      else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
        pair = new Pair.Pair(key.key, null);
      else
        pair = new Pair.Pair(key, null);
      const prev = YAMLMap.findPair(this.items, pair.key);
      if (!prev)
        this.items.push(pair);
    }
    get(key, keepPair) {
      const pair = YAMLMap.findPair(this.items, key);
      return !keepPair && identity.isPair(pair) ? identity.isScalar(pair.key) ? pair.key.value : pair.key : pair;
    }
    set(key, value) {
      if (typeof value !== "boolean")
        throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
      const prev = YAMLMap.findPair(this.items, key);
      if (prev && !value) {
        this.items.splice(this.items.indexOf(prev), 1);
      } else if (!prev && value) {
        this.items.push(new Pair.Pair(key));
      }
    }
    toJSON(_, ctx) {
      return super.toJSON(_, ctx, Set);
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      if (this.hasAllNullValues(true))
        return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
      else
        throw new Error("Set items must all have null values");
    }
    static from(schema, iterable, ctx) {
      const { replacer } = ctx;
      const set2 = new this(schema);
      if (iterable && Symbol.iterator in Object(iterable))
        for (let value of iterable) {
          if (typeof replacer === "function")
            value = replacer.call(iterable, value, value);
          set2.items.push(Pair.createPair(value, null, ctx));
        }
      return set2;
    }
  }
  YAMLSet.tag = "tag:yaml.org,2002:set";
  var set = {
    collection: "map",
    identify: (value) => value instanceof Set,
    nodeClass: YAMLSet,
    default: false,
    tag: "tag:yaml.org,2002:set",
    createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
    resolve(map, onError) {
      if (identity.isMap(map)) {
        if (map.hasAllNullValues(true))
          return Object.assign(new YAMLSet, map);
        else
          onError("Set items must all have null values");
      } else
        onError("Expected a mapping for this tag");
      return map;
    }
  };
  exports.YAMLSet = YAMLSet;
  exports.set = set;
});

// node_modules/yaml/dist/schema/yaml-1.1/timestamp.js
var require_timestamp = __commonJS((exports) => {
  var stringifyNumber = require_stringifyNumber();
  function parseSexagesimal(str, asBigInt) {
    const sign = str[0];
    const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
    const num = (n) => asBigInt ? BigInt(n) : Number(n);
    const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
    return sign === "-" ? num(-1) * res : res;
  }
  function stringifySexagesimal(node) {
    let { value } = node;
    let num = (n) => n;
    if (typeof value === "bigint")
      num = (n) => BigInt(n);
    else if (isNaN(value) || !isFinite(value))
      return stringifyNumber.stringifyNumber(node);
    let sign = "";
    if (value < 0) {
      sign = "-";
      value *= num(-1);
    }
    const _60 = num(60);
    const parts = [value % _60];
    if (value < 60) {
      parts.unshift(0);
    } else {
      value = (value - parts[0]) / _60;
      parts.unshift(value % _60);
      if (value >= 60) {
        value = (value - parts[0]) / _60;
        parts.unshift(value);
      }
    }
    return sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
  }
  var intTime = {
    identify: (value) => typeof value === "bigint" || Number.isInteger(value),
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "TIME",
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
    resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
    stringify: stringifySexagesimal
  };
  var floatTime = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "TIME",
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
    resolve: (str) => parseSexagesimal(str, false),
    stringify: stringifySexagesimal
  };
  var timestamp = {
    identify: (value) => value instanceof Date,
    default: true,
    tag: "tag:yaml.org,2002:timestamp",
    test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})" + "(?:" + "(?:t|T|[ \\t]+)" + "([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)" + "(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?" + ")?$"),
    resolve(str) {
      const match = str.match(timestamp.test);
      if (!match)
        throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
      const [, year, month, day, hour, minute, second] = match.map(Number);
      const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
      let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
      const tz = match[8];
      if (tz && tz !== "Z") {
        let d = parseSexagesimal(tz, false);
        if (Math.abs(d) < 30)
          d *= 60;
        date -= 60000 * d;
      }
      return new Date(date);
    },
    stringify: ({ value }) => value?.toISOString().replace(/(T00:00:00)?\.000Z$/, "") ?? ""
  };
  exports.floatTime = floatTime;
  exports.intTime = intTime;
  exports.timestamp = timestamp;
});

// node_modules/yaml/dist/schema/yaml-1.1/schema.js
var require_schema3 = __commonJS((exports) => {
  var map = require_map();
  var _null = require_null();
  var seq = require_seq();
  var string = require_string();
  var binary = require_binary();
  var bool = require_bool2();
  var float = require_float2();
  var int = require_int2();
  var merge = require_merge();
  var omap = require_omap();
  var pairs = require_pairs();
  var set = require_set();
  var timestamp = require_timestamp();
  var schema = [
    map.map,
    seq.seq,
    string.string,
    _null.nullTag,
    bool.trueTag,
    bool.falseTag,
    int.intBin,
    int.intOct,
    int.int,
    int.intHex,
    float.floatNaN,
    float.floatExp,
    float.float,
    binary.binary,
    merge.merge,
    omap.omap,
    pairs.pairs,
    set.set,
    timestamp.intTime,
    timestamp.floatTime,
    timestamp.timestamp
  ];
  exports.schema = schema;
});

// node_modules/yaml/dist/schema/tags.js
var require_tags = __commonJS((exports) => {
  var map = require_map();
  var _null = require_null();
  var seq = require_seq();
  var string = require_string();
  var bool = require_bool();
  var float = require_float();
  var int = require_int();
  var schema = require_schema();
  var schema$1 = require_schema2();
  var binary = require_binary();
  var merge = require_merge();
  var omap = require_omap();
  var pairs = require_pairs();
  var schema$2 = require_schema3();
  var set = require_set();
  var timestamp = require_timestamp();
  var schemas = new Map([
    ["core", schema.schema],
    ["failsafe", [map.map, seq.seq, string.string]],
    ["json", schema$1.schema],
    ["yaml11", schema$2.schema],
    ["yaml-1.1", schema$2.schema]
  ]);
  var tagsByName = {
    binary: binary.binary,
    bool: bool.boolTag,
    float: float.float,
    floatExp: float.floatExp,
    floatNaN: float.floatNaN,
    floatTime: timestamp.floatTime,
    int: int.int,
    intHex: int.intHex,
    intOct: int.intOct,
    intTime: timestamp.intTime,
    map: map.map,
    merge: merge.merge,
    null: _null.nullTag,
    omap: omap.omap,
    pairs: pairs.pairs,
    seq: seq.seq,
    set: set.set,
    timestamp: timestamp.timestamp
  };
  var coreKnownTags = {
    "tag:yaml.org,2002:binary": binary.binary,
    "tag:yaml.org,2002:merge": merge.merge,
    "tag:yaml.org,2002:omap": omap.omap,
    "tag:yaml.org,2002:pairs": pairs.pairs,
    "tag:yaml.org,2002:set": set.set,
    "tag:yaml.org,2002:timestamp": timestamp.timestamp
  };
  function getTags(customTags, schemaName, addMergeTag) {
    const schemaTags = schemas.get(schemaName);
    if (schemaTags && !customTags) {
      return addMergeTag && !schemaTags.includes(merge.merge) ? schemaTags.concat(merge.merge) : schemaTags.slice();
    }
    let tags = schemaTags;
    if (!tags) {
      if (Array.isArray(customTags))
        tags = [];
      else {
        const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
      }
    }
    if (Array.isArray(customTags)) {
      for (const tag of customTags)
        tags = tags.concat(tag);
    } else if (typeof customTags === "function") {
      tags = customTags(tags.slice());
    }
    if (addMergeTag)
      tags = tags.concat(merge.merge);
    return tags.reduce((tags2, tag) => {
      const tagObj = typeof tag === "string" ? tagsByName[tag] : tag;
      if (!tagObj) {
        const tagName = JSON.stringify(tag);
        const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
      }
      if (!tags2.includes(tagObj))
        tags2.push(tagObj);
      return tags2;
    }, []);
  }
  exports.coreKnownTags = coreKnownTags;
  exports.getTags = getTags;
});

// node_modules/yaml/dist/schema/Schema.js
var require_Schema = __commonJS((exports) => {
  var identity = require_identity();
  var map = require_map();
  var seq = require_seq();
  var string = require_string();
  var tags = require_tags();
  var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;

  class Schema {
    constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
      this.compat = Array.isArray(compat) ? tags.getTags(compat, "compat") : compat ? tags.getTags(null, compat) : null;
      this.name = typeof schema === "string" && schema || "core";
      this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
      this.tags = tags.getTags(customTags, this.name, merge);
      this.toStringOptions = toStringDefaults ?? null;
      Object.defineProperty(this, identity.MAP, { value: map.map });
      Object.defineProperty(this, identity.SCALAR, { value: string.string });
      Object.defineProperty(this, identity.SEQ, { value: seq.seq });
      this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
    }
    clone() {
      const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
      copy.tags = this.tags.slice();
      return copy;
    }
  }
  exports.Schema = Schema;
});

// node_modules/yaml/dist/stringify/stringifyDocument.js
var require_stringifyDocument = __commonJS((exports) => {
  var identity = require_identity();
  var stringify = require_stringify();
  var stringifyComment = require_stringifyComment();
  function stringifyDocument(doc, options) {
    const lines = [];
    let hasDirectives = options.directives === true;
    if (options.directives !== false && doc.directives) {
      const dir = doc.directives.toString(doc);
      if (dir) {
        lines.push(dir);
        hasDirectives = true;
      } else if (doc.directives.docStart)
        hasDirectives = true;
    }
    if (hasDirectives)
      lines.push("---");
    const ctx = stringify.createStringifyContext(doc, options);
    const { commentString } = ctx.options;
    if (doc.commentBefore) {
      if (lines.length !== 1)
        lines.unshift("");
      const cs = commentString(doc.commentBefore);
      lines.unshift(stringifyComment.indentComment(cs, ""));
    }
    let chompKeep = false;
    let contentComment = null;
    if (doc.contents) {
      if (identity.isNode(doc.contents)) {
        if (doc.contents.spaceBefore && hasDirectives)
          lines.push("");
        if (doc.contents.commentBefore) {
          const cs = commentString(doc.contents.commentBefore);
          lines.push(stringifyComment.indentComment(cs, ""));
        }
        ctx.forceBlockIndent = !!doc.comment;
        contentComment = doc.contents.comment;
      }
      const onChompKeep = contentComment ? undefined : () => chompKeep = true;
      let body = stringify.stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
      if (contentComment)
        body += stringifyComment.lineComment(body, "", commentString(contentComment));
      if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
        lines[lines.length - 1] = `--- ${body}`;
      } else
        lines.push(body);
    } else {
      lines.push(stringify.stringify(doc.contents, ctx));
    }
    if (doc.directives?.docEnd) {
      if (doc.comment) {
        const cs = commentString(doc.comment);
        if (cs.includes(`
`)) {
          lines.push("...");
          lines.push(stringifyComment.indentComment(cs, ""));
        } else {
          lines.push(`... ${cs}`);
        }
      } else {
        lines.push("...");
      }
    } else {
      let dc = doc.comment;
      if (dc && chompKeep)
        dc = dc.replace(/^\n+/, "");
      if (dc) {
        if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
          lines.push("");
        lines.push(stringifyComment.indentComment(commentString(dc), ""));
      }
    }
    return lines.join(`
`) + `
`;
  }
  exports.stringifyDocument = stringifyDocument;
});

// node_modules/yaml/dist/doc/Document.js
var require_Document = __commonJS((exports) => {
  var Alias = require_Alias();
  var Collection = require_Collection();
  var identity = require_identity();
  var Pair = require_Pair();
  var toJS = require_toJS();
  var Schema = require_Schema();
  var stringifyDocument = require_stringifyDocument();
  var anchors = require_anchors();
  var applyReviver = require_applyReviver();
  var createNode = require_createNode();
  var directives = require_directives();

  class Document {
    constructor(value, replacer, options) {
      this.commentBefore = null;
      this.comment = null;
      this.errors = [];
      this.warnings = [];
      Object.defineProperty(this, identity.NODE_TYPE, { value: identity.DOC });
      let _replacer = null;
      if (typeof replacer === "function" || Array.isArray(replacer)) {
        _replacer = replacer;
      } else if (options === undefined && replacer) {
        options = replacer;
        replacer = undefined;
      }
      const opt = Object.assign({
        intAsBigInt: false,
        keepSourceTokens: false,
        logLevel: "warn",
        prettyErrors: true,
        strict: true,
        stringKeys: false,
        uniqueKeys: true,
        version: "1.2"
      }, options);
      this.options = opt;
      let { version } = opt;
      if (options?._directives) {
        this.directives = options._directives.atDocument();
        if (this.directives.yaml.explicit)
          version = this.directives.yaml.version;
      } else
        this.directives = new directives.Directives({ version });
      this.setSchema(version, options);
      this.contents = value === undefined ? null : this.createNode(value, _replacer, options);
    }
    clone() {
      const copy = Object.create(Document.prototype, {
        [identity.NODE_TYPE]: { value: identity.DOC }
      });
      copy.commentBefore = this.commentBefore;
      copy.comment = this.comment;
      copy.errors = this.errors.slice();
      copy.warnings = this.warnings.slice();
      copy.options = Object.assign({}, this.options);
      if (this.directives)
        copy.directives = this.directives.clone();
      copy.schema = this.schema.clone();
      copy.contents = identity.isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
      if (this.range)
        copy.range = this.range.slice();
      return copy;
    }
    add(value) {
      if (assertCollection(this.contents))
        this.contents.add(value);
    }
    addIn(path, value) {
      if (assertCollection(this.contents))
        this.contents.addIn(path, value);
    }
    createAlias(node, name) {
      if (!node.anchor) {
        const prev = anchors.anchorNames(this);
        node.anchor = !name || prev.has(name) ? anchors.findNewAnchor(name || "a", prev) : name;
      }
      return new Alias.Alias(node.anchor);
    }
    createNode(value, replacer, options) {
      let _replacer = undefined;
      if (typeof replacer === "function") {
        value = replacer.call({ "": value }, "", value);
        _replacer = replacer;
      } else if (Array.isArray(replacer)) {
        const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
        const asStr = replacer.filter(keyToStr).map(String);
        if (asStr.length > 0)
          replacer = replacer.concat(asStr);
        _replacer = replacer;
      } else if (options === undefined && replacer) {
        options = replacer;
        replacer = undefined;
      }
      const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
      const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(this, anchorPrefix || "a");
      const ctx = {
        aliasDuplicateObjects: aliasDuplicateObjects ?? true,
        keepUndefined: keepUndefined ?? false,
        onAnchor,
        onTagObj,
        replacer: _replacer,
        schema: this.schema,
        sourceObjects
      };
      const node = createNode.createNode(value, tag, ctx);
      if (flow && identity.isCollection(node))
        node.flow = true;
      setAnchors();
      return node;
    }
    createPair(key, value, options = {}) {
      const k = this.createNode(key, null, options);
      const v = this.createNode(value, null, options);
      return new Pair.Pair(k, v);
    }
    delete(key) {
      return assertCollection(this.contents) ? this.contents.delete(key) : false;
    }
    deleteIn(path) {
      if (Collection.isEmptyPath(path)) {
        if (this.contents == null)
          return false;
        this.contents = null;
        return true;
      }
      return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
    }
    get(key, keepScalar) {
      return identity.isCollection(this.contents) ? this.contents.get(key, keepScalar) : undefined;
    }
    getIn(path, keepScalar) {
      if (Collection.isEmptyPath(path))
        return !keepScalar && identity.isScalar(this.contents) ? this.contents.value : this.contents;
      return identity.isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : undefined;
    }
    has(key) {
      return identity.isCollection(this.contents) ? this.contents.has(key) : false;
    }
    hasIn(path) {
      if (Collection.isEmptyPath(path))
        return this.contents !== undefined;
      return identity.isCollection(this.contents) ? this.contents.hasIn(path) : false;
    }
    set(key, value) {
      if (this.contents == null) {
        this.contents = Collection.collectionFromPath(this.schema, [key], value);
      } else if (assertCollection(this.contents)) {
        this.contents.set(key, value);
      }
    }
    setIn(path, value) {
      if (Collection.isEmptyPath(path)) {
        this.contents = value;
      } else if (this.contents == null) {
        this.contents = Collection.collectionFromPath(this.schema, Array.from(path), value);
      } else if (assertCollection(this.contents)) {
        this.contents.setIn(path, value);
      }
    }
    setSchema(version, options = {}) {
      if (typeof version === "number")
        version = String(version);
      let opt;
      switch (version) {
        case "1.1":
          if (this.directives)
            this.directives.yaml.version = "1.1";
          else
            this.directives = new directives.Directives({ version: "1.1" });
          opt = { resolveKnownTags: false, schema: "yaml-1.1" };
          break;
        case "1.2":
        case "next":
          if (this.directives)
            this.directives.yaml.version = version;
          else
            this.directives = new directives.Directives({ version });
          opt = { resolveKnownTags: true, schema: "core" };
          break;
        case null:
          if (this.directives)
            delete this.directives;
          opt = null;
          break;
        default: {
          const sv = JSON.stringify(version);
          throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
        }
      }
      if (options.schema instanceof Object)
        this.schema = options.schema;
      else if (opt)
        this.schema = new Schema.Schema(Object.assign(opt, options));
      else
        throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
    }
    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
      const ctx = {
        anchors: new Map,
        doc: this,
        keep: !json,
        mapAsMap: mapAsMap === true,
        mapKeyWarned: false,
        maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
      };
      const res = toJS.toJS(this.contents, jsonArg ?? "", ctx);
      if (typeof onAnchor === "function")
        for (const { count, res: res2 } of ctx.anchors.values())
          onAnchor(res2, count);
      return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
    }
    toJSON(jsonArg, onAnchor) {
      return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
    }
    toString(options = {}) {
      if (this.errors.length > 0)
        throw new Error("Document with errors cannot be stringified");
      if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
        const s = JSON.stringify(options.indent);
        throw new Error(`"indent" option must be a positive integer, not ${s}`);
      }
      return stringifyDocument.stringifyDocument(this, options);
    }
  }
  function assertCollection(contents) {
    if (identity.isCollection(contents))
      return true;
    throw new Error("Expected a YAML collection as document contents");
  }
  exports.Document = Document;
});

// node_modules/yaml/dist/errors.js
var require_errors = __commonJS((exports) => {
  class YAMLError extends Error {
    constructor(name, pos, code, message) {
      super();
      this.name = name;
      this.code = code;
      this.message = message;
      this.pos = pos;
    }
  }

  class YAMLParseError extends YAMLError {
    constructor(pos, code, message) {
      super("YAMLParseError", pos, code, message);
    }
  }

  class YAMLWarning extends YAMLError {
    constructor(pos, code, message) {
      super("YAMLWarning", pos, code, message);
    }
  }
  var prettifyError = (src, lc) => (error) => {
    if (error.pos[0] === -1)
      return;
    error.linePos = error.pos.map((pos) => lc.linePos(pos));
    const { line, col } = error.linePos[0];
    error.message += ` at line ${line}, column ${col}`;
    let ci = col - 1;
    let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
    if (ci >= 60 && lineStr.length > 80) {
      const trimStart = Math.min(ci - 39, lineStr.length - 79);
      lineStr = "" + lineStr.substring(trimStart);
      ci -= trimStart - 1;
    }
    if (lineStr.length > 80)
      lineStr = lineStr.substring(0, 79) + "";
    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
      let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
      if (prev.length > 80)
        prev = prev.substring(0, 79) + `
`;
      lineStr = prev + lineStr;
    }
    if (/[^ ]/.test(lineStr)) {
      let count = 1;
      const end = error.linePos[1];
      if (end?.line === line && end.col > col) {
        count = Math.max(1, Math.min(end.col - col, 80 - ci));
      }
      const pointer = " ".repeat(ci) + "^".repeat(count);
      error.message += `:

${lineStr}
${pointer}
`;
    }
  };
  exports.YAMLError = YAMLError;
  exports.YAMLParseError = YAMLParseError;
  exports.YAMLWarning = YAMLWarning;
  exports.prettifyError = prettifyError;
});

// node_modules/yaml/dist/compose/resolve-props.js
var require_resolve_props = __commonJS((exports) => {
  function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {
    let spaceBefore = false;
    let atNewline = startOnNewline;
    let hasSpace = startOnNewline;
    let comment = "";
    let commentSep = "";
    let hasNewline = false;
    let reqSpace = false;
    let tab = null;
    let anchor = null;
    let tag = null;
    let newlineAfterProp = null;
    let comma = null;
    let found = null;
    let start = null;
    for (const token of tokens) {
      if (reqSpace) {
        if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
          onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
        reqSpace = false;
      }
      if (tab) {
        if (atNewline && token.type !== "comment" && token.type !== "newline") {
          onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
        }
        tab = null;
      }
      switch (token.type) {
        case "space":
          if (!flow && (indicator !== "doc-start" || next?.type !== "flow-collection") && token.source.includes("\t")) {
            tab = token;
          }
          hasSpace = true;
          break;
        case "comment": {
          if (!hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = token.source.substring(1) || " ";
          if (!comment)
            comment = cb;
          else
            comment += commentSep + cb;
          commentSep = "";
          atNewline = false;
          break;
        }
        case "newline":
          if (atNewline) {
            if (comment)
              comment += token.source;
            else if (!found || indicator !== "seq-item-ind")
              spaceBefore = true;
          } else
            commentSep += token.source;
          atNewline = true;
          hasNewline = true;
          if (anchor || tag)
            newlineAfterProp = token;
          hasSpace = true;
          break;
        case "anchor":
          if (anchor)
            onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
          if (token.source.endsWith(":"))
            onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
          anchor = token;
          start ?? (start = token.offset);
          atNewline = false;
          hasSpace = false;
          reqSpace = true;
          break;
        case "tag": {
          if (tag)
            onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
          tag = token;
          start ?? (start = token.offset);
          atNewline = false;
          hasSpace = false;
          reqSpace = true;
          break;
        }
        case indicator:
          if (anchor || tag)
            onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
          if (found)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
          found = token;
          atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
          hasSpace = false;
          break;
        case "comma":
          if (flow) {
            if (comma)
              onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
            comma = token;
            atNewline = false;
            hasSpace = false;
            break;
          }
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
          atNewline = false;
          hasSpace = false;
      }
    }
    const last = tokens[tokens.length - 1];
    const end = last ? last.offset + last.source.length : offset;
    if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) {
      onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
    }
    if (tab && (atNewline && tab.indent <= parentIndent || next?.type === "block-map" || next?.type === "block-seq"))
      onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
    return {
      comma,
      found,
      spaceBefore,
      comment,
      hasNewline,
      anchor,
      tag,
      newlineAfterProp,
      end,
      start: start ?? end
    };
  }
  exports.resolveProps = resolveProps;
});

// node_modules/yaml/dist/compose/util-contains-newline.js
var require_util_contains_newline = __commonJS((exports) => {
  function containsNewline(key) {
    if (!key)
      return null;
    switch (key.type) {
      case "alias":
      case "scalar":
      case "double-quoted-scalar":
      case "single-quoted-scalar":
        if (key.source.includes(`
`))
          return true;
        if (key.end) {
          for (const st of key.end)
            if (st.type === "newline")
              return true;
        }
        return false;
      case "flow-collection":
        for (const it of key.items) {
          for (const st of it.start)
            if (st.type === "newline")
              return true;
          if (it.sep) {
            for (const st of it.sep)
              if (st.type === "newline")
                return true;
          }
          if (containsNewline(it.key) || containsNewline(it.value))
            return true;
        }
        return false;
      default:
        return true;
    }
  }
  exports.containsNewline = containsNewline;
});

// node_modules/yaml/dist/compose/util-flow-indent-check.js
var require_util_flow_indent_check = __commonJS((exports) => {
  var utilContainsNewline = require_util_contains_newline();
  function flowIndentCheck(indent, fc, onError) {
    if (fc?.type === "flow-collection") {
      const end = fc.end[0];
      if (end.indent === indent && (end.source === "]" || end.source === "}") && utilContainsNewline.containsNewline(fc)) {
        const msg = "Flow end indicator should be more indented than parent";
        onError(end, "BAD_INDENT", msg, true);
      }
    }
  }
  exports.flowIndentCheck = flowIndentCheck;
});

// node_modules/yaml/dist/compose/util-map-includes.js
var require_util_map_includes = __commonJS((exports) => {
  var identity = require_identity();
  function mapIncludes(ctx, items, search) {
    const { uniqueKeys } = ctx.options;
    if (uniqueKeys === false)
      return false;
    const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || identity.isScalar(a) && identity.isScalar(b) && a.value === b.value;
    return items.some((pair) => isEqual(pair.key, search));
  }
  exports.mapIncludes = mapIncludes;
});

// node_modules/yaml/dist/compose/resolve-block-map.js
var require_resolve_block_map = __commonJS((exports) => {
  var Pair = require_Pair();
  var YAMLMap = require_YAMLMap();
  var resolveProps = require_resolve_props();
  var utilContainsNewline = require_util_contains_newline();
  var utilFlowIndentCheck = require_util_flow_indent_check();
  var utilMapIncludes = require_util_map_includes();
  var startColMsg = "All mapping items must start at the same column";
  function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLMap.YAMLMap;
    const map = new NodeClass(ctx.schema);
    if (ctx.atRoot)
      ctx.atRoot = false;
    let offset = bm.offset;
    let commentEnd = null;
    for (const collItem of bm.items) {
      const { start, key, sep, value } = collItem;
      const keyProps = resolveProps.resolveProps(start, {
        indicator: "explicit-key-ind",
        next: key ?? sep?.[0],
        offset,
        onError,
        parentIndent: bm.indent,
        startOnNewline: true
      });
      const implicitKey = !keyProps.found;
      if (implicitKey) {
        if (key) {
          if (key.type === "block-seq")
            onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
          else if ("indent" in key && key.indent !== bm.indent)
            onError(offset, "BAD_INDENT", startColMsg);
        }
        if (!keyProps.anchor && !keyProps.tag && !sep) {
          commentEnd = keyProps.end;
          if (keyProps.comment) {
            if (map.comment)
              map.comment += `
` + keyProps.comment;
            else
              map.comment = keyProps.comment;
          }
          continue;
        }
        if (keyProps.newlineAfterProp || utilContainsNewline.containsNewline(key)) {
          onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
        }
      } else if (keyProps.found?.indent !== bm.indent) {
        onError(offset, "BAD_INDENT", startColMsg);
      }
      ctx.atKey = true;
      const keyStart = keyProps.end;
      const keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
      if (ctx.schema.compat)
        utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);
      ctx.atKey = false;
      if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
        onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
      const valueProps = resolveProps.resolveProps(sep ?? [], {
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        parentIndent: bm.indent,
        startOnNewline: !key || key.type === "block-scalar"
      });
      offset = valueProps.end;
      if (valueProps.found) {
        if (implicitKey) {
          if (value?.type === "block-map" && !valueProps.hasNewline)
            onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
          if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
            onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
        }
        const valueNode = value ? composeNode(ctx, value, valueProps, onError) : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError);
        offset = valueNode.range[2];
        const pair = new Pair.Pair(keyNode, valueNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        map.items.push(pair);
      } else {
        if (implicitKey)
          onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
        if (valueProps.comment) {
          if (keyNode.comment)
            keyNode.comment += `
` + valueProps.comment;
          else
            keyNode.comment = valueProps.comment;
        }
        const pair = new Pair.Pair(keyNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        map.items.push(pair);
      }
    }
    if (commentEnd && commentEnd < offset)
      onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
    map.range = [bm.offset, offset, commentEnd ?? offset];
    return map;
  }
  exports.resolveBlockMap = resolveBlockMap;
});

// node_modules/yaml/dist/compose/resolve-block-seq.js
var require_resolve_block_seq = __commonJS((exports) => {
  var YAMLSeq = require_YAMLSeq();
  var resolveProps = require_resolve_props();
  var utilFlowIndentCheck = require_util_flow_indent_check();
  function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLSeq.YAMLSeq;
    const seq = new NodeClass(ctx.schema);
    if (ctx.atRoot)
      ctx.atRoot = false;
    if (ctx.atKey)
      ctx.atKey = false;
    let offset = bs.offset;
    let commentEnd = null;
    for (const { start, value } of bs.items) {
      const props = resolveProps.resolveProps(start, {
        indicator: "seq-item-ind",
        next: value,
        offset,
        onError,
        parentIndent: bs.indent,
        startOnNewline: true
      });
      if (!props.found) {
        if (props.anchor || props.tag || value) {
          if (value?.type === "block-seq")
            onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
          else
            onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
        } else {
          commentEnd = props.end;
          if (props.comment)
            seq.comment = props.comment;
          continue;
        }
      }
      const node = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
      if (ctx.schema.compat)
        utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError);
      offset = node.range[2];
      seq.items.push(node);
    }
    seq.range = [bs.offset, offset, commentEnd ?? offset];
    return seq;
  }
  exports.resolveBlockSeq = resolveBlockSeq;
});

// node_modules/yaml/dist/compose/resolve-end.js
var require_resolve_end = __commonJS((exports) => {
  function resolveEnd(end, offset, reqSpace, onError) {
    let comment = "";
    if (end) {
      let hasSpace = false;
      let sep = "";
      for (const token of end) {
        const { source, type } = token;
        switch (type) {
          case "space":
            hasSpace = true;
            break;
          case "comment": {
            if (reqSpace && !hasSpace)
              onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
            const cb = source.substring(1) || " ";
            if (!comment)
              comment = cb;
            else
              comment += sep + cb;
            sep = "";
            break;
          }
          case "newline":
            if (comment)
              sep += source;
            hasSpace = true;
            break;
          default:
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
        }
        offset += source.length;
      }
    }
    return { comment, offset };
  }
  exports.resolveEnd = resolveEnd;
});

// node_modules/yaml/dist/compose/resolve-flow-collection.js
var require_resolve_flow_collection = __commonJS((exports) => {
  var identity = require_identity();
  var Pair = require_Pair();
  var YAMLMap = require_YAMLMap();
  var YAMLSeq = require_YAMLSeq();
  var resolveEnd = require_resolve_end();
  var resolveProps = require_resolve_props();
  var utilContainsNewline = require_util_contains_newline();
  var utilMapIncludes = require_util_map_includes();
  var blockMsg = "Block collections are not allowed within flow collections";
  var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
  function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {
    const isMap = fc.start.source === "{";
    const fcName = isMap ? "flow map" : "flow sequence";
    const NodeClass = tag?.nodeClass ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq);
    const coll = new NodeClass(ctx.schema);
    coll.flow = true;
    const atRoot = ctx.atRoot;
    if (atRoot)
      ctx.atRoot = false;
    if (ctx.atKey)
      ctx.atKey = false;
    let offset = fc.offset + fc.start.source.length;
    for (let i = 0;i < fc.items.length; ++i) {
      const collItem = fc.items[i];
      const { start, key, sep, value } = collItem;
      const props = resolveProps.resolveProps(start, {
        flow: fcName,
        indicator: "explicit-key-ind",
        next: key ?? sep?.[0],
        offset,
        onError,
        parentIndent: fc.indent,
        startOnNewline: false
      });
      if (!props.found) {
        if (!props.anchor && !props.tag && !sep && !value) {
          if (i === 0 && props.comma)
            onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
          else if (i < fc.items.length - 1)
            onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
          if (props.comment) {
            if (coll.comment)
              coll.comment += `
` + props.comment;
            else
              coll.comment = props.comment;
          }
          offset = props.end;
          continue;
        }
        if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))
          onError(key, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
      }
      if (i === 0) {
        if (props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
      } else {
        if (!props.comma)
          onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
        if (props.comment) {
          let prevItemComment = "";
          loop:
            for (const st of start) {
              switch (st.type) {
                case "comma":
                case "space":
                  break;
                case "comment":
                  prevItemComment = st.source.substring(1);
                  break loop;
                default:
                  break loop;
              }
            }
          if (prevItemComment) {
            let prev = coll.items[coll.items.length - 1];
            if (identity.isPair(prev))
              prev = prev.value ?? prev.key;
            if (prev.comment)
              prev.comment += `
` + prevItemComment;
            else
              prev.comment = prevItemComment;
            props.comment = props.comment.substring(prevItemComment.length + 1);
          }
        }
      }
      if (!isMap && !sep && !props.found) {
        const valueNode = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, sep, null, props, onError);
        coll.items.push(valueNode);
        offset = valueNode.range[2];
        if (isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else {
        ctx.atKey = true;
        const keyStart = props.end;
        const keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);
        if (isBlock(key))
          onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
        ctx.atKey = false;
        const valueProps = resolveProps.resolveProps(sep ?? [], {
          flow: fcName,
          indicator: "map-value-ind",
          next: value,
          offset: keyNode.range[2],
          onError,
          parentIndent: fc.indent,
          startOnNewline: false
        });
        if (valueProps.found) {
          if (!isMap && !props.found && ctx.options.strict) {
            if (sep)
              for (const st of sep) {
                if (st === valueProps.found)
                  break;
                if (st.type === "newline") {
                  onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                  break;
                }
              }
            if (props.start < valueProps.found.offset - 1024)
              onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
          }
        } else if (value) {
          if ("source" in value && value.source?.[0] === ":")
            onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
          else
            onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
        }
        const valueNode = value ? composeNode(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError) : null;
        if (valueNode) {
          if (isBlock(value))
            onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
        } else if (valueProps.comment) {
          if (keyNode.comment)
            keyNode.comment += `
` + valueProps.comment;
          else
            keyNode.comment = valueProps.comment;
        }
        const pair = new Pair.Pair(keyNode, valueNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        if (isMap) {
          const map = coll;
          if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
            onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
          map.items.push(pair);
        } else {
          const map = new YAMLMap.YAMLMap(ctx.schema);
          map.flow = true;
          map.items.push(pair);
          const endRange = (valueNode ?? keyNode).range;
          map.range = [keyNode.range[0], endRange[1], endRange[2]];
          coll.items.push(map);
        }
        offset = valueNode ? valueNode.range[2] : valueProps.end;
      }
    }
    const expectedEnd = isMap ? "}" : "]";
    const [ce, ...ee] = fc.end;
    let cePos = offset;
    if (ce?.source === expectedEnd)
      cePos = ce.offset + ce.source.length;
    else {
      const name = fcName[0].toUpperCase() + fcName.substring(1);
      const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
      onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
      if (ce && ce.source.length !== 1)
        ee.unshift(ce);
    }
    if (ee.length > 0) {
      const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
      if (end.comment) {
        if (coll.comment)
          coll.comment += `
` + end.comment;
        else
          coll.comment = end.comment;
      }
      coll.range = [fc.offset, cePos, end.offset];
    } else {
      coll.range = [fc.offset, cePos, cePos];
    }
    return coll;
  }
  exports.resolveFlowCollection = resolveFlowCollection;
});

// node_modules/yaml/dist/compose/compose-collection.js
var require_compose_collection = __commonJS((exports) => {
  var identity = require_identity();
  var Scalar = require_Scalar();
  var YAMLMap = require_YAMLMap();
  var YAMLSeq = require_YAMLSeq();
  var resolveBlockMap = require_resolve_block_map();
  var resolveBlockSeq = require_resolve_block_seq();
  var resolveFlowCollection = require_resolve_flow_collection();
  function resolveCollection(CN, ctx, token, onError, tagName, tag) {
    const coll = token.type === "block-map" ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError, tag) : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError, tag);
    const Coll = coll.constructor;
    if (tagName === "!" || tagName === Coll.tagName) {
      coll.tag = Coll.tagName;
      return coll;
    }
    if (tagName)
      coll.tag = tagName;
    return coll;
  }
  function composeCollection(CN, ctx, token, props, onError) {
    const tagToken = props.tag;
    const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
    if (token.type === "block-seq") {
      const { anchor, newlineAfterProp: nl } = props;
      const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
      if (lastProp && (!nl || nl.offset < lastProp.offset)) {
        const message = "Missing newline after block sequence props";
        onError(lastProp, "MISSING_CHAR", message);
      }
    }
    const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
    if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.YAMLSeq.tagName && expType === "seq") {
      return resolveCollection(CN, ctx, token, onError, tagName);
    }
    let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
    if (!tag) {
      const kt = ctx.schema.knownTags[tagName];
      if (kt?.collection === expType) {
        ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
        tag = kt;
      } else {
        if (kt) {
          onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? "scalar"}`, true);
        } else {
          onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
        }
        return resolveCollection(CN, ctx, token, onError, tagName);
      }
    }
    const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);
    const res = tag.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
    const node = identity.isNode(res) ? res : new Scalar.Scalar(res);
    node.range = coll.range;
    node.tag = tagName;
    if (tag?.format)
      node.format = tag.format;
    return node;
  }
  exports.composeCollection = composeCollection;
});

// node_modules/yaml/dist/compose/resolve-block-scalar.js
var require_resolve_block_scalar = __commonJS((exports) => {
  var Scalar = require_Scalar();
  function resolveBlockScalar(ctx, scalar, onError) {
    const start = scalar.offset;
    const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
    if (!header)
      return { value: "", type: null, comment: "", range: [start, start, start] };
    const type = header.mode === ">" ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
    const lines = scalar.source ? splitLines(scalar.source) : [];
    let chompStart = lines.length;
    for (let i = lines.length - 1;i >= 0; --i) {
      const content = lines[i][1];
      if (content === "" || content === "\r")
        chompStart = i;
      else
        break;
    }
    if (chompStart === 0) {
      const value2 = header.chomp === "+" && lines.length > 0 ? `
`.repeat(Math.max(1, lines.length - 1)) : "";
      let end2 = start + header.length;
      if (scalar.source)
        end2 += scalar.source.length;
      return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
    }
    let trimIndent = scalar.indent + header.indent;
    let offset = scalar.offset + header.length;
    let contentStart = 0;
    for (let i = 0;i < chompStart; ++i) {
      const [indent, content] = lines[i];
      if (content === "" || content === "\r") {
        if (header.indent === 0 && indent.length > trimIndent)
          trimIndent = indent.length;
      } else {
        if (indent.length < trimIndent) {
          const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
          onError(offset + indent.length, "MISSING_CHAR", message);
        }
        if (header.indent === 0)
          trimIndent = indent.length;
        contentStart = i;
        if (trimIndent === 0 && !ctx.atRoot) {
          const message = "Block scalar values in collections must be indented";
          onError(offset, "BAD_INDENT", message);
        }
        break;
      }
      offset += indent.length + content.length + 1;
    }
    for (let i = lines.length - 1;i >= chompStart; --i) {
      if (lines[i][0].length > trimIndent)
        chompStart = i + 1;
    }
    let value = "";
    let sep = "";
    let prevMoreIndented = false;
    for (let i = 0;i < contentStart; ++i)
      value += lines[i][0].slice(trimIndent) + `
`;
    for (let i = contentStart;i < chompStart; ++i) {
      let [indent, content] = lines[i];
      offset += indent.length + content.length + 1;
      const crlf = content[content.length - 1] === "\r";
      if (crlf)
        content = content.slice(0, -1);
      if (content && indent.length < trimIndent) {
        const src = header.indent ? "explicit indentation indicator" : "first line";
        const message = `Block scalar lines must not be less indented than their ${src}`;
        onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
        indent = "";
      }
      if (type === Scalar.Scalar.BLOCK_LITERAL) {
        value += sep + indent.slice(trimIndent) + content;
        sep = `
`;
      } else if (indent.length > trimIndent || content[0] === "\t") {
        if (sep === " ")
          sep = `
`;
        else if (!prevMoreIndented && sep === `
`)
          sep = `

`;
        value += sep + indent.slice(trimIndent) + content;
        sep = `
`;
        prevMoreIndented = true;
      } else if (content === "") {
        if (sep === `
`)
          value += `
`;
        else
          sep = `
`;
      } else {
        value += sep + content;
        sep = " ";
        prevMoreIndented = false;
      }
    }
    switch (header.chomp) {
      case "-":
        break;
      case "+":
        for (let i = chompStart;i < lines.length; ++i)
          value += `
` + lines[i][0].slice(trimIndent);
        if (value[value.length - 1] !== `
`)
          value += `
`;
        break;
      default:
        value += `
`;
    }
    const end = start + header.length + scalar.source.length;
    return { value, type, comment: header.comment, range: [start, end, end] };
  }
  function parseBlockScalarHeader({ offset, props }, strict, onError) {
    if (props[0].type !== "block-scalar-header") {
      onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
      return null;
    }
    const { source } = props[0];
    const mode = source[0];
    let indent = 0;
    let chomp = "";
    let error = -1;
    for (let i = 1;i < source.length; ++i) {
      const ch = source[i];
      if (!chomp && (ch === "-" || ch === "+"))
        chomp = ch;
      else {
        const n = Number(ch);
        if (!indent && n)
          indent = n;
        else if (error === -1)
          error = offset + i;
      }
    }
    if (error !== -1)
      onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
    let hasSpace = false;
    let comment = "";
    let length = source.length;
    for (let i = 1;i < props.length; ++i) {
      const token = props[i];
      switch (token.type) {
        case "space":
          hasSpace = true;
        case "newline":
          length += token.source.length;
          break;
        case "comment":
          if (strict && !hasSpace) {
            const message = "Comments must be separated from other tokens by white space characters";
            onError(token, "MISSING_CHAR", message);
          }
          length += token.source.length;
          comment = token.source.substring(1);
          break;
        case "error":
          onError(token, "UNEXPECTED_TOKEN", token.message);
          length += token.source.length;
          break;
        default: {
          const message = `Unexpected token in block scalar header: ${token.type}`;
          onError(token, "UNEXPECTED_TOKEN", message);
          const ts = token.source;
          if (ts && typeof ts === "string")
            length += ts.length;
        }
      }
    }
    return { mode, indent, chomp, comment, length };
  }
  function splitLines(source) {
    const split = source.split(/\n( *)/);
    const first = split[0];
    const m = first.match(/^( *)/);
    const line0 = m?.[1] ? [m[1], first.slice(m[1].length)] : ["", first];
    const lines = [line0];
    for (let i = 1;i < split.length; i += 2)
      lines.push([split[i], split[i + 1]]);
    return lines;
  }
  exports.resolveBlockScalar = resolveBlockScalar;
});

// node_modules/yaml/dist/compose/resolve-flow-scalar.js
var require_resolve_flow_scalar = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var resolveEnd = require_resolve_end();
  function resolveFlowScalar(scalar, strict, onError) {
    const { offset, type, source, end } = scalar;
    let _type;
    let value;
    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
    switch (type) {
      case "scalar":
        _type = Scalar.Scalar.PLAIN;
        value = plainValue(source, _onError);
        break;
      case "single-quoted-scalar":
        _type = Scalar.Scalar.QUOTE_SINGLE;
        value = singleQuotedValue(source, _onError);
        break;
      case "double-quoted-scalar":
        _type = Scalar.Scalar.QUOTE_DOUBLE;
        value = doubleQuotedValue(source, _onError);
        break;
      default:
        onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
        return {
          value: "",
          type: null,
          comment: "",
          range: [offset, offset + source.length, offset + source.length]
        };
    }
    const valueEnd = offset + source.length;
    const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
    return {
      value,
      type: _type,
      comment: re.comment,
      range: [offset, valueEnd, re.offset]
    };
  }
  function plainValue(source, onError) {
    let badChar = "";
    switch (source[0]) {
      case "\t":
        badChar = "a tab character";
        break;
      case ",":
        badChar = "flow indicator character ,";
        break;
      case "%":
        badChar = "directive indicator character %";
        break;
      case "|":
      case ">": {
        badChar = `block scalar indicator ${source[0]}`;
        break;
      }
      case "@":
      case "`": {
        badChar = `reserved character ${source[0]}`;
        break;
      }
    }
    if (badChar)
      onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
    return foldLines(source);
  }
  function singleQuotedValue(source, onError) {
    if (source[source.length - 1] !== "'" || source.length === 1)
      onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
    return foldLines(source.slice(1, -1)).replace(/''/g, "'");
  }
  function foldLines(source) {
    let first, line;
    try {
      first = new RegExp(`(.*?)(?<![ 	])[ 	]*\r?
`, "sy");
      line = new RegExp(`[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?
`, "sy");
    } catch {
      first = /(.*?)[ \t]*\r?\n/sy;
      line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
    }
    let match = first.exec(source);
    if (!match)
      return source;
    let res = match[1];
    let sep = " ";
    let pos = first.lastIndex;
    line.lastIndex = pos;
    while (match = line.exec(source)) {
      if (match[1] === "") {
        if (sep === `
`)
          res += sep;
        else
          sep = `
`;
      } else {
        res += sep + match[1];
        sep = " ";
      }
      pos = line.lastIndex;
    }
    const last = /[ \t]*(.*)/sy;
    last.lastIndex = pos;
    match = last.exec(source);
    return res + sep + (match?.[1] ?? "");
  }
  function doubleQuotedValue(source, onError) {
    let res = "";
    for (let i = 1;i < source.length - 1; ++i) {
      const ch = source[i];
      if (ch === "\r" && source[i + 1] === `
`)
        continue;
      if (ch === `
`) {
        const { fold, offset } = foldNewline(source, i);
        res += fold;
        i = offset;
      } else if (ch === "\\") {
        let next = source[++i];
        const cc = escapeCodes[next];
        if (cc)
          res += cc;
        else if (next === `
`) {
          next = source[i + 1];
          while (next === " " || next === "\t")
            next = source[++i + 1];
        } else if (next === "\r" && source[i + 1] === `
`) {
          next = source[++i + 1];
          while (next === " " || next === "\t")
            next = source[++i + 1];
        } else if (next === "x" || next === "u" || next === "U") {
          const length = { x: 2, u: 4, U: 8 }[next];
          res += parseCharCode(source, i + 1, length, onError);
          i += length;
        } else {
          const raw = source.substr(i - 1, 2);
          onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
          res += raw;
        }
      } else if (ch === " " || ch === "\t") {
        const wsStart = i;
        let next = source[i + 1];
        while (next === " " || next === "\t")
          next = source[++i + 1];
        if (next !== `
` && !(next === "\r" && source[i + 2] === `
`))
          res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
      } else {
        res += ch;
      }
    }
    if (source[source.length - 1] !== '"' || source.length === 1)
      onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
    return res;
  }
  function foldNewline(source, offset) {
    let fold = "";
    let ch = source[offset + 1];
    while (ch === " " || ch === "\t" || ch === `
` || ch === "\r") {
      if (ch === "\r" && source[offset + 2] !== `
`)
        break;
      if (ch === `
`)
        fold += `
`;
      offset += 1;
      ch = source[offset + 1];
    }
    if (!fold)
      fold = " ";
    return { fold, offset };
  }
  var escapeCodes = {
    "0": "\x00",
    a: "\x07",
    b: "\b",
    e: "\x1B",
    f: "\f",
    n: `
`,
    r: "\r",
    t: "\t",
    v: "\v",
    N: "",
    _: "",
    L: "\u2028",
    P: "\u2029",
    " ": " ",
    '"': '"',
    "/": "/",
    "\\": "\\",
    "\t": "\t"
  };
  function parseCharCode(source, offset, length, onError) {
    const cc = source.substr(offset, length);
    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
    const code = ok ? parseInt(cc, 16) : NaN;
    if (isNaN(code)) {
      const raw = source.substr(offset - 2, length + 2);
      onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
      return raw;
    }
    return String.fromCodePoint(code);
  }
  exports.resolveFlowScalar = resolveFlowScalar;
});

// node_modules/yaml/dist/compose/compose-scalar.js
var require_compose_scalar = __commonJS((exports) => {
  var identity = require_identity();
  var Scalar = require_Scalar();
  var resolveBlockScalar = require_resolve_block_scalar();
  var resolveFlowScalar = require_resolve_flow_scalar();
  function composeScalar(ctx, token, tagToken, onError) {
    const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar.resolveBlockScalar(ctx, token, onError) : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);
    const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
    let tag;
    if (ctx.options.stringKeys && ctx.atKey) {
      tag = ctx.schema[identity.SCALAR];
    } else if (tagName)
      tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
    else if (token.type === "scalar")
      tag = findScalarTagByTest(ctx, value, token, onError);
    else
      tag = ctx.schema[identity.SCALAR];
    let scalar;
    try {
      const res = tag.resolve(value, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
      scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);
    } catch (error) {
      const msg = error instanceof Error ? error.message : String(error);
      onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
      scalar = new Scalar.Scalar(value);
    }
    scalar.range = range;
    scalar.source = value;
    if (type)
      scalar.type = type;
    if (tagName)
      scalar.tag = tagName;
    if (tag.format)
      scalar.format = tag.format;
    if (comment)
      scalar.comment = comment;
    return scalar;
  }
  function findScalarTagByName(schema, value, tagName, tagToken, onError) {
    if (tagName === "!")
      return schema[identity.SCALAR];
    const matchWithTest = [];
    for (const tag of schema.tags) {
      if (!tag.collection && tag.tag === tagName) {
        if (tag.default && tag.test)
          matchWithTest.push(tag);
        else
          return tag;
      }
    }
    for (const tag of matchWithTest)
      if (tag.test?.test(value))
        return tag;
    const kt = schema.knownTags[tagName];
    if (kt && !kt.collection) {
      schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));
      return kt;
    }
    onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
    return schema[identity.SCALAR];
  }
  function findScalarTagByTest({ atKey, directives, schema }, value, token, onError) {
    const tag = schema.tags.find((tag2) => (tag2.default === true || atKey && tag2.default === "key") && tag2.test?.test(value)) || schema[identity.SCALAR];
    if (schema.compat) {
      const compat = schema.compat.find((tag2) => tag2.default && tag2.test?.test(value)) ?? schema[identity.SCALAR];
      if (tag.tag !== compat.tag) {
        const ts = directives.tagString(tag.tag);
        const cs = directives.tagString(compat.tag);
        const msg = `Value may be parsed as either ${ts} or ${cs}`;
        onError(token, "TAG_RESOLVE_FAILED", msg, true);
      }
    }
    return tag;
  }
  exports.composeScalar = composeScalar;
});

// node_modules/yaml/dist/compose/util-empty-scalar-position.js
var require_util_empty_scalar_position = __commonJS((exports) => {
  function emptyScalarPosition(offset, before, pos) {
    if (before) {
      pos ?? (pos = before.length);
      for (let i = pos - 1;i >= 0; --i) {
        let st = before[i];
        switch (st.type) {
          case "space":
          case "comment":
          case "newline":
            offset -= st.source.length;
            continue;
        }
        st = before[++i];
        while (st?.type === "space") {
          offset += st.source.length;
          st = before[++i];
        }
        break;
      }
    }
    return offset;
  }
  exports.emptyScalarPosition = emptyScalarPosition;
});

// node_modules/yaml/dist/compose/compose-node.js
var require_compose_node = __commonJS((exports) => {
  var Alias = require_Alias();
  var identity = require_identity();
  var composeCollection = require_compose_collection();
  var composeScalar = require_compose_scalar();
  var resolveEnd = require_resolve_end();
  var utilEmptyScalarPosition = require_util_empty_scalar_position();
  var CN = { composeNode, composeEmptyNode };
  function composeNode(ctx, token, props, onError) {
    const atKey = ctx.atKey;
    const { spaceBefore, comment, anchor, tag } = props;
    let node;
    let isSrcToken = true;
    switch (token.type) {
      case "alias":
        node = composeAlias(ctx, token, onError);
        if (anchor || tag)
          onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
        break;
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
      case "block-scalar":
        node = composeScalar.composeScalar(ctx, token, tag, onError);
        if (anchor)
          node.anchor = anchor.source.substring(1);
        break;
      case "block-map":
      case "block-seq":
      case "flow-collection":
        node = composeCollection.composeCollection(CN, ctx, token, props, onError);
        if (anchor)
          node.anchor = anchor.source.substring(1);
        break;
      default: {
        const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
        onError(token, "UNEXPECTED_TOKEN", message);
        node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);
        isSrcToken = false;
      }
    }
    if (anchor && node.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
    if (atKey && ctx.options.stringKeys && (!identity.isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) {
      const msg = "With stringKeys, all keys must be strings";
      onError(tag ?? token, "NON_STRING_KEY", msg);
    }
    if (spaceBefore)
      node.spaceBefore = true;
    if (comment) {
      if (token.type === "scalar" && token.source === "")
        node.comment = comment;
      else
        node.commentBefore = comment;
    }
    if (ctx.options.keepSourceTokens && isSrcToken)
      node.srcToken = token;
    return node;
  }
  function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
    const token = {
      type: "scalar",
      offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
      indent: -1,
      source: ""
    };
    const node = composeScalar.composeScalar(ctx, token, tag, onError);
    if (anchor) {
      node.anchor = anchor.source.substring(1);
      if (node.anchor === "")
        onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
    }
    if (spaceBefore)
      node.spaceBefore = true;
    if (comment) {
      node.comment = comment;
      node.range[2] = end;
    }
    return node;
  }
  function composeAlias({ options }, { offset, source, end }, onError) {
    const alias = new Alias.Alias(source.substring(1));
    if (alias.source === "")
      onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
    if (alias.source.endsWith(":"))
      onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
    const valueEnd = offset + source.length;
    const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
    alias.range = [offset, valueEnd, re.offset];
    if (re.comment)
      alias.comment = re.comment;
    return alias;
  }
  exports.composeEmptyNode = composeEmptyNode;
  exports.composeNode = composeNode;
});

// node_modules/yaml/dist/compose/compose-doc.js
var require_compose_doc = __commonJS((exports) => {
  var Document = require_Document();
  var composeNode = require_compose_node();
  var resolveEnd = require_resolve_end();
  var resolveProps = require_resolve_props();
  function composeDoc(options, directives, { offset, start, value, end }, onError) {
    const opts = Object.assign({ _directives: directives }, options);
    const doc = new Document.Document(undefined, opts);
    const ctx = {
      atKey: false,
      atRoot: true,
      directives: doc.directives,
      options: doc.options,
      schema: doc.schema
    };
    const props = resolveProps.resolveProps(start, {
      indicator: "doc-start",
      next: value ?? end?.[0],
      offset,
      onError,
      parentIndent: 0,
      startOnNewline: true
    });
    if (props.found) {
      doc.directives.docStart = true;
      if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
        onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
    }
    doc.contents = value ? composeNode.composeNode(ctx, value, props, onError) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
    const contentEnd = doc.contents.range[2];
    const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);
    if (re.comment)
      doc.comment = re.comment;
    doc.range = [offset, contentEnd, re.offset];
    return doc;
  }
  exports.composeDoc = composeDoc;
});

// node_modules/yaml/dist/compose/composer.js
var require_composer = __commonJS((exports) => {
  var node_process = __require("process");
  var directives = require_directives();
  var Document = require_Document();
  var errors = require_errors();
  var identity = require_identity();
  var composeDoc = require_compose_doc();
  var resolveEnd = require_resolve_end();
  function getErrorPos(src) {
    if (typeof src === "number")
      return [src, src + 1];
    if (Array.isArray(src))
      return src.length === 2 ? src : [src[0], src[1]];
    const { offset, source } = src;
    return [offset, offset + (typeof source === "string" ? source.length : 1)];
  }
  function parsePrelude(prelude) {
    let comment = "";
    let atComment = false;
    let afterEmptyLine = false;
    for (let i = 0;i < prelude.length; ++i) {
      const source = prelude[i];
      switch (source[0]) {
        case "#":
          comment += (comment === "" ? "" : afterEmptyLine ? `

` : `
`) + (source.substring(1) || " ");
          atComment = true;
          afterEmptyLine = false;
          break;
        case "%":
          if (prelude[i + 1]?.[0] !== "#")
            i += 1;
          atComment = false;
          break;
        default:
          if (!atComment)
            afterEmptyLine = true;
          atComment = false;
      }
    }
    return { comment, afterEmptyLine };
  }

  class Composer {
    constructor(options = {}) {
      this.doc = null;
      this.atDirectives = false;
      this.prelude = [];
      this.errors = [];
      this.warnings = [];
      this.onError = (source, code, message, warning) => {
        const pos = getErrorPos(source);
        if (warning)
          this.warnings.push(new errors.YAMLWarning(pos, code, message));
        else
          this.errors.push(new errors.YAMLParseError(pos, code, message));
      };
      this.directives = new directives.Directives({ version: options.version || "1.2" });
      this.options = options;
    }
    decorate(doc, afterDoc) {
      const { comment, afterEmptyLine } = parsePrelude(this.prelude);
      if (comment) {
        const dc = doc.contents;
        if (afterDoc) {
          doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
        } else if (afterEmptyLine || doc.directives.docStart || !dc) {
          doc.commentBefore = comment;
        } else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {
          let it = dc.items[0];
          if (identity.isPair(it))
            it = it.key;
          const cb = it.commentBefore;
          it.commentBefore = cb ? `${comment}
${cb}` : comment;
        } else {
          const cb = dc.commentBefore;
          dc.commentBefore = cb ? `${comment}
${cb}` : comment;
        }
      }
      if (afterDoc) {
        Array.prototype.push.apply(doc.errors, this.errors);
        Array.prototype.push.apply(doc.warnings, this.warnings);
      } else {
        doc.errors = this.errors;
        doc.warnings = this.warnings;
      }
      this.prelude = [];
      this.errors = [];
      this.warnings = [];
    }
    streamInfo() {
      return {
        comment: parsePrelude(this.prelude).comment,
        directives: this.directives,
        errors: this.errors,
        warnings: this.warnings
      };
    }
    *compose(tokens, forceDoc = false, endOffset = -1) {
      for (const token of tokens)
        yield* this.next(token);
      yield* this.end(forceDoc, endOffset);
    }
    *next(token) {
      if (node_process.env.LOG_STREAM)
        console.dir(token, { depth: null });
      switch (token.type) {
        case "directive":
          this.directives.add(token.source, (offset, message, warning) => {
            const pos = getErrorPos(token);
            pos[0] += offset;
            this.onError(pos, "BAD_DIRECTIVE", message, warning);
          });
          this.prelude.push(token.source);
          this.atDirectives = true;
          break;
        case "document": {
          const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
          if (this.atDirectives && !doc.directives.docStart)
            this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
          this.decorate(doc, false);
          if (this.doc)
            yield this.doc;
          this.doc = doc;
          this.atDirectives = false;
          break;
        }
        case "byte-order-mark":
        case "space":
          break;
        case "comment":
        case "newline":
          this.prelude.push(token.source);
          break;
        case "error": {
          const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
          const error = new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
          if (this.atDirectives || !this.doc)
            this.errors.push(error);
          else
            this.doc.errors.push(error);
          break;
        }
        case "doc-end": {
          if (!this.doc) {
            const msg = "Unexpected doc-end without preceding document";
            this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
            break;
          }
          this.doc.directives.docEnd = true;
          const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
          this.decorate(this.doc, true);
          if (end.comment) {
            const dc = this.doc.comment;
            this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
          }
          this.doc.range[2] = end.offset;
          break;
        }
        default:
          this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
      }
    }
    *end(forceDoc = false, endOffset = -1) {
      if (this.doc) {
        this.decorate(this.doc, true);
        yield this.doc;
        this.doc = null;
      } else if (forceDoc) {
        const opts = Object.assign({ _directives: this.directives }, this.options);
        const doc = new Document.Document(undefined, opts);
        if (this.atDirectives)
          this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
        doc.range = [0, endOffset, endOffset];
        this.decorate(doc, false);
        yield doc;
      }
    }
  }
  exports.Composer = Composer;
});

// node_modules/yaml/dist/parse/cst-scalar.js
var require_cst_scalar = __commonJS((exports) => {
  var resolveBlockScalar = require_resolve_block_scalar();
  var resolveFlowScalar = require_resolve_flow_scalar();
  var errors = require_errors();
  var stringifyString = require_stringifyString();
  function resolveAsScalar(token, strict = true, onError) {
    if (token) {
      const _onError = (pos, code, message) => {
        const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
        if (onError)
          onError(offset, code, message);
        else
          throw new errors.YAMLParseError([offset, offset + 1], code, message);
      };
      switch (token.type) {
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
        case "block-scalar":
          return resolveBlockScalar.resolveBlockScalar({ options: { strict } }, token, _onError);
      }
    }
    return null;
  }
  function createScalarToken(value, context) {
    const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context;
    const source = stringifyString.stringifyString({ type, value }, {
      implicitKey,
      indent: indent > 0 ? " ".repeat(indent) : "",
      inFlow,
      options: { blockQuote: true, lineWidth: -1 }
    });
    const end = context.end ?? [
      { type: "newline", offset: -1, indent, source: `
` }
    ];
    switch (source[0]) {
      case "|":
      case ">": {
        const he = source.indexOf(`
`);
        const head = source.substring(0, he);
        const body = source.substring(he + 1) + `
`;
        const props = [
          { type: "block-scalar-header", offset, indent, source: head }
        ];
        if (!addEndtoBlockProps(props, end))
          props.push({ type: "newline", offset: -1, indent, source: `
` });
        return { type: "block-scalar", offset, indent, props, source: body };
      }
      case '"':
        return { type: "double-quoted-scalar", offset, indent, source, end };
      case "'":
        return { type: "single-quoted-scalar", offset, indent, source, end };
      default:
        return { type: "scalar", offset, indent, source, end };
    }
  }
  function setScalarValue(token, value, context = {}) {
    let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
    let indent = "indent" in token ? token.indent : null;
    if (afterKey && typeof indent === "number")
      indent += 2;
    if (!type)
      switch (token.type) {
        case "single-quoted-scalar":
          type = "QUOTE_SINGLE";
          break;
        case "double-quoted-scalar":
          type = "QUOTE_DOUBLE";
          break;
        case "block-scalar": {
          const header = token.props[0];
          if (header.type !== "block-scalar-header")
            throw new Error("Invalid block scalar header");
          type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
          break;
        }
        default:
          type = "PLAIN";
      }
    const source = stringifyString.stringifyString({ type, value }, {
      implicitKey: implicitKey || indent === null,
      indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
      inFlow,
      options: { blockQuote: true, lineWidth: -1 }
    });
    switch (source[0]) {
      case "|":
      case ">":
        setBlockScalarValue(token, source);
        break;
      case '"':
        setFlowScalarValue(token, source, "double-quoted-scalar");
        break;
      case "'":
        setFlowScalarValue(token, source, "single-quoted-scalar");
        break;
      default:
        setFlowScalarValue(token, source, "scalar");
    }
  }
  function setBlockScalarValue(token, source) {
    const he = source.indexOf(`
`);
    const head = source.substring(0, he);
    const body = source.substring(he + 1) + `
`;
    if (token.type === "block-scalar") {
      const header = token.props[0];
      if (header.type !== "block-scalar-header")
        throw new Error("Invalid block scalar header");
      header.source = head;
      token.source = body;
    } else {
      const { offset } = token;
      const indent = "indent" in token ? token.indent : -1;
      const props = [
        { type: "block-scalar-header", offset, indent, source: head }
      ];
      if (!addEndtoBlockProps(props, "end" in token ? token.end : undefined))
        props.push({ type: "newline", offset: -1, indent, source: `
` });
      for (const key of Object.keys(token))
        if (key !== "type" && key !== "offset")
          delete token[key];
      Object.assign(token, { type: "block-scalar", indent, props, source: body });
    }
  }
  function addEndtoBlockProps(props, end) {
    if (end)
      for (const st of end)
        switch (st.type) {
          case "space":
          case "comment":
            props.push(st);
            break;
          case "newline":
            props.push(st);
            return true;
        }
    return false;
  }
  function setFlowScalarValue(token, source, type) {
    switch (token.type) {
      case "scalar":
      case "double-quoted-scalar":
      case "single-quoted-scalar":
        token.type = type;
        token.source = source;
        break;
      case "block-scalar": {
        const end = token.props.slice(1);
        let oa = source.length;
        if (token.props[0].type === "block-scalar-header")
          oa -= token.props[0].source.length;
        for (const tok of end)
          tok.offset += oa;
        delete token.props;
        Object.assign(token, { type, source, end });
        break;
      }
      case "block-map":
      case "block-seq": {
        const offset = token.offset + source.length;
        const nl = { type: "newline", offset, indent: token.indent, source: `
` };
        delete token.items;
        Object.assign(token, { type, source, end: [nl] });
        break;
      }
      default: {
        const indent = "indent" in token ? token.indent : -1;
        const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
        for (const key of Object.keys(token))
          if (key !== "type" && key !== "offset")
            delete token[key];
        Object.assign(token, { type, indent, source, end });
      }
    }
  }
  exports.createScalarToken = createScalarToken;
  exports.resolveAsScalar = resolveAsScalar;
  exports.setScalarValue = setScalarValue;
});

// node_modules/yaml/dist/parse/cst-stringify.js
var require_cst_stringify = __commonJS((exports) => {
  var stringify = (cst) => ("type" in cst) ? stringifyToken(cst) : stringifyItem(cst);
  function stringifyToken(token) {
    switch (token.type) {
      case "block-scalar": {
        let res = "";
        for (const tok of token.props)
          res += stringifyToken(tok);
        return res + token.source;
      }
      case "block-map":
      case "block-seq": {
        let res = "";
        for (const item of token.items)
          res += stringifyItem(item);
        return res;
      }
      case "flow-collection": {
        let res = token.start.source;
        for (const item of token.items)
          res += stringifyItem(item);
        for (const st of token.end)
          res += st.source;
        return res;
      }
      case "document": {
        let res = stringifyItem(token);
        if (token.end)
          for (const st of token.end)
            res += st.source;
        return res;
      }
      default: {
        let res = token.source;
        if ("end" in token && token.end)
          for (const st of token.end)
            res += st.source;
        return res;
      }
    }
  }
  function stringifyItem({ start, key, sep, value }) {
    let res = "";
    for (const st of start)
      res += st.source;
    if (key)
      res += stringifyToken(key);
    if (sep)
      for (const st of sep)
        res += st.source;
    if (value)
      res += stringifyToken(value);
    return res;
  }
  exports.stringify = stringify;
});

// node_modules/yaml/dist/parse/cst-visit.js
var require_cst_visit = __commonJS((exports) => {
  var BREAK = Symbol("break visit");
  var SKIP = Symbol("skip children");
  var REMOVE = Symbol("remove item");
  function visit(cst, visitor) {
    if ("type" in cst && cst.type === "document")
      cst = { start: cst.start, value: cst.value };
    _visit(Object.freeze([]), cst, visitor);
  }
  visit.BREAK = BREAK;
  visit.SKIP = SKIP;
  visit.REMOVE = REMOVE;
  visit.itemAtPath = (cst, path) => {
    let item = cst;
    for (const [field, index] of path) {
      const tok = item?.[field];
      if (tok && "items" in tok) {
        item = tok.items[index];
      } else
        return;
    }
    return item;
  };
  visit.parentCollection = (cst, path) => {
    const parent = visit.itemAtPath(cst, path.slice(0, -1));
    const field = path[path.length - 1][0];
    const coll = parent?.[field];
    if (coll && "items" in coll)
      return coll;
    throw new Error("Parent collection not found");
  };
  function _visit(path, item, visitor) {
    let ctrl = visitor(item, path);
    if (typeof ctrl === "symbol")
      return ctrl;
    for (const field of ["key", "value"]) {
      const token = item[field];
      if (token && "items" in token) {
        for (let i = 0;i < token.items.length; ++i) {
          const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            token.items.splice(i, 1);
            i -= 1;
          }
        }
        if (typeof ctrl === "function" && field === "key")
          ctrl = ctrl(item, path);
      }
    }
    return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
  }
  exports.visit = visit;
});

// node_modules/yaml/dist/parse/cst.js
var require_cst = __commonJS((exports) => {
  var cstScalar = require_cst_scalar();
  var cstStringify = require_cst_stringify();
  var cstVisit = require_cst_visit();
  var BOM = "\uFEFF";
  var DOCUMENT = "\x02";
  var FLOW_END = "\x18";
  var SCALAR = "\x1F";
  var isCollection = (token) => !!token && ("items" in token);
  var isScalar = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
  function prettyToken(token) {
    switch (token) {
      case BOM:
        return "<BOM>";
      case DOCUMENT:
        return "<DOC>";
      case FLOW_END:
        return "<FLOW_END>";
      case SCALAR:
        return "<SCALAR>";
      default:
        return JSON.stringify(token);
    }
  }
  function tokenType(source) {
    switch (source) {
      case BOM:
        return "byte-order-mark";
      case DOCUMENT:
        return "doc-mode";
      case FLOW_END:
        return "flow-error-end";
      case SCALAR:
        return "scalar";
      case "---":
        return "doc-start";
      case "...":
        return "doc-end";
      case "":
      case `
`:
      case `\r
`:
        return "newline";
      case "-":
        return "seq-item-ind";
      case "?":
        return "explicit-key-ind";
      case ":":
        return "map-value-ind";
      case "{":
        return "flow-map-start";
      case "}":
        return "flow-map-end";
      case "[":
        return "flow-seq-start";
      case "]":
        return "flow-seq-end";
      case ",":
        return "comma";
    }
    switch (source[0]) {
      case " ":
      case "\t":
        return "space";
      case "#":
        return "comment";
      case "%":
        return "directive-line";
      case "*":
        return "alias";
      case "&":
        return "anchor";
      case "!":
        return "tag";
      case "'":
        return "single-quoted-scalar";
      case '"':
        return "double-quoted-scalar";
      case "|":
      case ">":
        return "block-scalar-header";
    }
    return null;
  }
  exports.createScalarToken = cstScalar.createScalarToken;
  exports.resolveAsScalar = cstScalar.resolveAsScalar;
  exports.setScalarValue = cstScalar.setScalarValue;
  exports.stringify = cstStringify.stringify;
  exports.visit = cstVisit.visit;
  exports.BOM = BOM;
  exports.DOCUMENT = DOCUMENT;
  exports.FLOW_END = FLOW_END;
  exports.SCALAR = SCALAR;
  exports.isCollection = isCollection;
  exports.isScalar = isScalar;
  exports.prettyToken = prettyToken;
  exports.tokenType = tokenType;
});

// node_modules/yaml/dist/parse/lexer.js
var require_lexer = __commonJS((exports) => {
  var cst = require_cst();
  function isEmpty(ch) {
    switch (ch) {
      case undefined:
      case " ":
      case `
`:
      case "\r":
      case "\t":
        return true;
      default:
        return false;
    }
  }
  var hexDigits = new Set("0123456789ABCDEFabcdef");
  var tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
  var flowIndicatorChars = new Set(",[]{}");
  var invalidAnchorChars = new Set(` ,[]{}
\r	`);
  var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);

  class Lexer {
    constructor() {
      this.atEnd = false;
      this.blockScalarIndent = -1;
      this.blockScalarKeep = false;
      this.buffer = "";
      this.flowKey = false;
      this.flowLevel = 0;
      this.indentNext = 0;
      this.indentValue = 0;
      this.lineEndPos = null;
      this.next = null;
      this.pos = 0;
    }
    *lex(source, incomplete = false) {
      if (source) {
        if (typeof source !== "string")
          throw TypeError("source is not a string");
        this.buffer = this.buffer ? this.buffer + source : source;
        this.lineEndPos = null;
      }
      this.atEnd = !incomplete;
      let next = this.next ?? "stream";
      while (next && (incomplete || this.hasChars(1)))
        next = yield* this.parseNext(next);
    }
    atLineEnd() {
      let i = this.pos;
      let ch = this.buffer[i];
      while (ch === " " || ch === "\t")
        ch = this.buffer[++i];
      if (!ch || ch === "#" || ch === `
`)
        return true;
      if (ch === "\r")
        return this.buffer[i + 1] === `
`;
      return false;
    }
    charAt(n) {
      return this.buffer[this.pos + n];
    }
    continueScalar(offset) {
      let ch = this.buffer[offset];
      if (this.indentNext > 0) {
        let indent = 0;
        while (ch === " ")
          ch = this.buffer[++indent + offset];
        if (ch === "\r") {
          const next = this.buffer[indent + offset + 1];
          if (next === `
` || !next && !this.atEnd)
            return offset + indent + 1;
        }
        return ch === `
` || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
      }
      if (ch === "-" || ch === ".") {
        const dt = this.buffer.substr(offset, 3);
        if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
          return -1;
      }
      return offset;
    }
    getLine() {
      let end = this.lineEndPos;
      if (typeof end !== "number" || end !== -1 && end < this.pos) {
        end = this.buffer.indexOf(`
`, this.pos);
        this.lineEndPos = end;
      }
      if (end === -1)
        return this.atEnd ? this.buffer.substring(this.pos) : null;
      if (this.buffer[end - 1] === "\r")
        end -= 1;
      return this.buffer.substring(this.pos, end);
    }
    hasChars(n) {
      return this.pos + n <= this.buffer.length;
    }
    setNext(state) {
      this.buffer = this.buffer.substring(this.pos);
      this.pos = 0;
      this.lineEndPos = null;
      this.next = state;
      return null;
    }
    peek(n) {
      return this.buffer.substr(this.pos, n);
    }
    *parseNext(next) {
      switch (next) {
        case "stream":
          return yield* this.parseStream();
        case "line-start":
          return yield* this.parseLineStart();
        case "block-start":
          return yield* this.parseBlockStart();
        case "doc":
          return yield* this.parseDocument();
        case "flow":
          return yield* this.parseFlowCollection();
        case "quoted-scalar":
          return yield* this.parseQuotedScalar();
        case "block-scalar":
          return yield* this.parseBlockScalar();
        case "plain-scalar":
          return yield* this.parsePlainScalar();
      }
    }
    *parseStream() {
      let line = this.getLine();
      if (line === null)
        return this.setNext("stream");
      if (line[0] === cst.BOM) {
        yield* this.pushCount(1);
        line = line.substring(1);
      }
      if (line[0] === "%") {
        let dirEnd = line.length;
        let cs = line.indexOf("#");
        while (cs !== -1) {
          const ch = line[cs - 1];
          if (ch === " " || ch === "\t") {
            dirEnd = cs - 1;
            break;
          } else {
            cs = line.indexOf("#", cs + 1);
          }
        }
        while (true) {
          const ch = line[dirEnd - 1];
          if (ch === " " || ch === "\t")
            dirEnd -= 1;
          else
            break;
        }
        const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
        yield* this.pushCount(line.length - n);
        this.pushNewline();
        return "stream";
      }
      if (this.atLineEnd()) {
        const sp = yield* this.pushSpaces(true);
        yield* this.pushCount(line.length - sp);
        yield* this.pushNewline();
        return "stream";
      }
      yield cst.DOCUMENT;
      return yield* this.parseLineStart();
    }
    *parseLineStart() {
      const ch = this.charAt(0);
      if (!ch && !this.atEnd)
        return this.setNext("line-start");
      if (ch === "-" || ch === ".") {
        if (!this.atEnd && !this.hasChars(4))
          return this.setNext("line-start");
        const s = this.peek(3);
        if ((s === "---" || s === "...") && isEmpty(this.charAt(3))) {
          yield* this.pushCount(3);
          this.indentValue = 0;
          this.indentNext = 0;
          return s === "---" ? "doc" : "stream";
        }
      }
      this.indentValue = yield* this.pushSpaces(false);
      if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
        this.indentNext = this.indentValue;
      return yield* this.parseBlockStart();
    }
    *parseBlockStart() {
      const [ch0, ch1] = this.peek(2);
      if (!ch1 && !this.atEnd)
        return this.setNext("block-start");
      if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
        const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
        this.indentNext = this.indentValue + 1;
        this.indentValue += n;
        return yield* this.parseBlockStart();
      }
      return "doc";
    }
    *parseDocument() {
      yield* this.pushSpaces(true);
      const line = this.getLine();
      if (line === null)
        return this.setNext("doc");
      let n = yield* this.pushIndicators();
      switch (line[n]) {
        case "#":
          yield* this.pushCount(line.length - n);
        case undefined:
          yield* this.pushNewline();
          return yield* this.parseLineStart();
        case "{":
        case "[":
          yield* this.pushCount(1);
          this.flowKey = false;
          this.flowLevel = 1;
          return "flow";
        case "}":
        case "]":
          yield* this.pushCount(1);
          return "doc";
        case "*":
          yield* this.pushUntil(isNotAnchorChar);
          return "doc";
        case '"':
        case "'":
          return yield* this.parseQuotedScalar();
        case "|":
        case ">":
          n += yield* this.parseBlockScalarHeader();
          n += yield* this.pushSpaces(true);
          yield* this.pushCount(line.length - n);
          yield* this.pushNewline();
          return yield* this.parseBlockScalar();
        default:
          return yield* this.parsePlainScalar();
      }
    }
    *parseFlowCollection() {
      let nl, sp;
      let indent = -1;
      do {
        nl = yield* this.pushNewline();
        if (nl > 0) {
          sp = yield* this.pushSpaces(false);
          this.indentValue = indent = sp;
        } else {
          sp = 0;
        }
        sp += yield* this.pushSpaces(true);
      } while (nl + sp > 0);
      const line = this.getLine();
      if (line === null)
        return this.setNext("flow");
      if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
        const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
        if (!atFlowEndMarker) {
          this.flowLevel = 0;
          yield cst.FLOW_END;
          return yield* this.parseLineStart();
        }
      }
      let n = 0;
      while (line[n] === ",") {
        n += yield* this.pushCount(1);
        n += yield* this.pushSpaces(true);
        this.flowKey = false;
      }
      n += yield* this.pushIndicators();
      switch (line[n]) {
        case undefined:
          return "flow";
        case "#":
          yield* this.pushCount(line.length - n);
          return "flow";
        case "{":
        case "[":
          yield* this.pushCount(1);
          this.flowKey = false;
          this.flowLevel += 1;
          return "flow";
        case "}":
        case "]":
          yield* this.pushCount(1);
          this.flowKey = true;
          this.flowLevel -= 1;
          return this.flowLevel ? "flow" : "doc";
        case "*":
          yield* this.pushUntil(isNotAnchorChar);
          return "flow";
        case '"':
        case "'":
          this.flowKey = true;
          return yield* this.parseQuotedScalar();
        case ":": {
          const next = this.charAt(1);
          if (this.flowKey || isEmpty(next) || next === ",") {
            this.flowKey = false;
            yield* this.pushCount(1);
            yield* this.pushSpaces(true);
            return "flow";
          }
        }
        default:
          this.flowKey = false;
          return yield* this.parsePlainScalar();
      }
    }
    *parseQuotedScalar() {
      const quote = this.charAt(0);
      let end = this.buffer.indexOf(quote, this.pos + 1);
      if (quote === "'") {
        while (end !== -1 && this.buffer[end + 1] === "'")
          end = this.buffer.indexOf("'", end + 2);
      } else {
        while (end !== -1) {
          let n = 0;
          while (this.buffer[end - 1 - n] === "\\")
            n += 1;
          if (n % 2 === 0)
            break;
          end = this.buffer.indexOf('"', end + 1);
        }
      }
      const qb = this.buffer.substring(0, end);
      let nl = qb.indexOf(`
`, this.pos);
      if (nl !== -1) {
        while (nl !== -1) {
          const cs = this.continueScalar(nl + 1);
          if (cs === -1)
            break;
          nl = qb.indexOf(`
`, cs);
        }
        if (nl !== -1) {
          end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
        }
      }
      if (end === -1) {
        if (!this.atEnd)
          return this.setNext("quoted-scalar");
        end = this.buffer.length;
      }
      yield* this.pushToIndex(end + 1, false);
      return this.flowLevel ? "flow" : "doc";
    }
    *parseBlockScalarHeader() {
      this.blockScalarIndent = -1;
      this.blockScalarKeep = false;
      let i = this.pos;
      while (true) {
        const ch = this.buffer[++i];
        if (ch === "+")
          this.blockScalarKeep = true;
        else if (ch > "0" && ch <= "9")
          this.blockScalarIndent = Number(ch) - 1;
        else if (ch !== "-")
          break;
      }
      return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
    }
    *parseBlockScalar() {
      let nl = this.pos - 1;
      let indent = 0;
      let ch;
      loop:
        for (let i2 = this.pos;ch = this.buffer[i2]; ++i2) {
          switch (ch) {
            case " ":
              indent += 1;
              break;
            case `
`:
              nl = i2;
              indent = 0;
              break;
            case "\r": {
              const next = this.buffer[i2 + 1];
              if (!next && !this.atEnd)
                return this.setNext("block-scalar");
              if (next === `
`)
                break;
            }
            default:
              break loop;
          }
        }
      if (!ch && !this.atEnd)
        return this.setNext("block-scalar");
      if (indent >= this.indentNext) {
        if (this.blockScalarIndent === -1)
          this.indentNext = indent;
        else {
          this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
        }
        do {
          const cs = this.continueScalar(nl + 1);
          if (cs === -1)
            break;
          nl = this.buffer.indexOf(`
`, cs);
        } while (nl !== -1);
        if (nl === -1) {
          if (!this.atEnd)
            return this.setNext("block-scalar");
          nl = this.buffer.length;
        }
      }
      let i = nl + 1;
      ch = this.buffer[i];
      while (ch === " ")
        ch = this.buffer[++i];
      if (ch === "\t") {
        while (ch === "\t" || ch === " " || ch === "\r" || ch === `
`)
          ch = this.buffer[++i];
        nl = i - 1;
      } else if (!this.blockScalarKeep) {
        do {
          let i2 = nl - 1;
          let ch2 = this.buffer[i2];
          if (ch2 === "\r")
            ch2 = this.buffer[--i2];
          const lastChar = i2;
          while (ch2 === " ")
            ch2 = this.buffer[--i2];
          if (ch2 === `
` && i2 >= this.pos && i2 + 1 + indent > lastChar)
            nl = i2;
          else
            break;
        } while (true);
      }
      yield cst.SCALAR;
      yield* this.pushToIndex(nl + 1, true);
      return yield* this.parseLineStart();
    }
    *parsePlainScalar() {
      const inFlow = this.flowLevel > 0;
      let end = this.pos - 1;
      let i = this.pos - 1;
      let ch;
      while (ch = this.buffer[++i]) {
        if (ch === ":") {
          const next = this.buffer[i + 1];
          if (isEmpty(next) || inFlow && flowIndicatorChars.has(next))
            break;
          end = i;
        } else if (isEmpty(ch)) {
          let next = this.buffer[i + 1];
          if (ch === "\r") {
            if (next === `
`) {
              i += 1;
              ch = `
`;
              next = this.buffer[i + 1];
            } else
              end = i;
          }
          if (next === "#" || inFlow && flowIndicatorChars.has(next))
            break;
          if (ch === `
`) {
            const cs = this.continueScalar(i + 1);
            if (cs === -1)
              break;
            i = Math.max(i, cs - 2);
          }
        } else {
          if (inFlow && flowIndicatorChars.has(ch))
            break;
          end = i;
        }
      }
      if (!ch && !this.atEnd)
        return this.setNext("plain-scalar");
      yield cst.SCALAR;
      yield* this.pushToIndex(end + 1, true);
      return inFlow ? "flow" : "doc";
    }
    *pushCount(n) {
      if (n > 0) {
        yield this.buffer.substr(this.pos, n);
        this.pos += n;
        return n;
      }
      return 0;
    }
    *pushToIndex(i, allowEmpty) {
      const s = this.buffer.slice(this.pos, i);
      if (s) {
        yield s;
        this.pos += s.length;
        return s.length;
      } else if (allowEmpty)
        yield "";
      return 0;
    }
    *pushIndicators() {
      switch (this.charAt(0)) {
        case "!":
          return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        case "&":
          return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        case "-":
        case "?":
        case ":": {
          const inFlow = this.flowLevel > 0;
          const ch1 = this.charAt(1);
          if (isEmpty(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
            if (!inFlow)
              this.indentNext = this.indentValue + 1;
            else if (this.flowKey)
              this.flowKey = false;
            return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          }
        }
      }
      return 0;
    }
    *pushTag() {
      if (this.charAt(1) === "<") {
        let i = this.pos + 2;
        let ch = this.buffer[i];
        while (!isEmpty(ch) && ch !== ">")
          ch = this.buffer[++i];
        return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
      } else {
        let i = this.pos + 1;
        let ch = this.buffer[i];
        while (ch) {
          if (tagChars.has(ch))
            ch = this.buffer[++i];
          else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) {
            ch = this.buffer[i += 3];
          } else
            break;
        }
        return yield* this.pushToIndex(i, false);
      }
    }
    *pushNewline() {
      const ch = this.buffer[this.pos];
      if (ch === `
`)
        return yield* this.pushCount(1);
      else if (ch === "\r" && this.charAt(1) === `
`)
        return yield* this.pushCount(2);
      else
        return 0;
    }
    *pushSpaces(allowTabs) {
      let i = this.pos - 1;
      let ch;
      do {
        ch = this.buffer[++i];
      } while (ch === " " || allowTabs && ch === "\t");
      const n = i - this.pos;
      if (n > 0) {
        yield this.buffer.substr(this.pos, n);
        this.pos = i;
      }
      return n;
    }
    *pushUntil(test) {
      let i = this.pos;
      let ch = this.buffer[i];
      while (!test(ch))
        ch = this.buffer[++i];
      return yield* this.pushToIndex(i, false);
    }
  }
  exports.Lexer = Lexer;
});

// node_modules/yaml/dist/parse/line-counter.js
var require_line_counter = __commonJS((exports) => {
  class LineCounter {
    constructor() {
      this.lineStarts = [];
      this.addNewLine = (offset) => this.lineStarts.push(offset);
      this.linePos = (offset) => {
        let low = 0;
        let high = this.lineStarts.length;
        while (low < high) {
          const mid = low + high >> 1;
          if (this.lineStarts[mid] < offset)
            low = mid + 1;
          else
            high = mid;
        }
        if (this.lineStarts[low] === offset)
          return { line: low + 1, col: 1 };
        if (low === 0)
          return { line: 0, col: offset };
        const start = this.lineStarts[low - 1];
        return { line: low, col: offset - start + 1 };
      };
    }
  }
  exports.LineCounter = LineCounter;
});

// node_modules/yaml/dist/parse/parser.js
var require_parser = __commonJS((exports) => {
  var node_process = __require("process");
  var cst = require_cst();
  var lexer = require_lexer();
  function includesToken(list, type) {
    for (let i = 0;i < list.length; ++i)
      if (list[i].type === type)
        return true;
    return false;
  }
  function findNonEmptyIndex(list) {
    for (let i = 0;i < list.length; ++i) {
      switch (list[i].type) {
        case "space":
        case "comment":
        case "newline":
          break;
        default:
          return i;
      }
    }
    return -1;
  }
  function isFlowToken(token) {
    switch (token?.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
      case "flow-collection":
        return true;
      default:
        return false;
    }
  }
  function getPrevProps(parent) {
    switch (parent.type) {
      case "document":
        return parent.start;
      case "block-map": {
        const it = parent.items[parent.items.length - 1];
        return it.sep ?? it.start;
      }
      case "block-seq":
        return parent.items[parent.items.length - 1].start;
      default:
        return [];
    }
  }
  function getFirstKeyStartProps(prev) {
    if (prev.length === 0)
      return [];
    let i = prev.length;
    loop:
      while (--i >= 0) {
        switch (prev[i].type) {
          case "doc-start":
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
          case "newline":
            break loop;
        }
      }
    while (prev[++i]?.type === "space") {}
    return prev.splice(i, prev.length);
  }
  function fixFlowSeqItems(fc) {
    if (fc.start.type === "flow-seq-start") {
      for (const it of fc.items) {
        if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
          if (it.key)
            it.value = it.key;
          delete it.key;
          if (isFlowToken(it.value)) {
            if (it.value.end)
              Array.prototype.push.apply(it.value.end, it.sep);
            else
              it.value.end = it.sep;
          } else
            Array.prototype.push.apply(it.start, it.sep);
          delete it.sep;
        }
      }
    }
  }

  class Parser {
    constructor(onNewLine) {
      this.atNewLine = true;
      this.atScalar = false;
      this.indent = 0;
      this.offset = 0;
      this.onKeyLine = false;
      this.stack = [];
      this.source = "";
      this.type = "";
      this.lexer = new lexer.Lexer;
      this.onNewLine = onNewLine;
    }
    *parse(source, incomplete = false) {
      if (this.onNewLine && this.offset === 0)
        this.onNewLine(0);
      for (const lexeme of this.lexer.lex(source, incomplete))
        yield* this.next(lexeme);
      if (!incomplete)
        yield* this.end();
    }
    *next(source) {
      this.source = source;
      if (node_process.env.LOG_TOKENS)
        console.log("|", cst.prettyToken(source));
      if (this.atScalar) {
        this.atScalar = false;
        yield* this.step();
        this.offset += source.length;
        return;
      }
      const type = cst.tokenType(source);
      if (!type) {
        const message = `Not a YAML token: ${source}`;
        yield* this.pop({ type: "error", offset: this.offset, message, source });
        this.offset += source.length;
      } else if (type === "scalar") {
        this.atNewLine = false;
        this.atScalar = true;
        this.type = "scalar";
      } else {
        this.type = type;
        yield* this.step();
        switch (type) {
          case "newline":
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine)
              this.onNewLine(this.offset + source.length);
            break;
          case "space":
            if (this.atNewLine && source[0] === " ")
              this.indent += source.length;
            break;
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
            if (this.atNewLine)
              this.indent += source.length;
            break;
          case "doc-mode":
          case "flow-error-end":
            return;
          default:
            this.atNewLine = false;
        }
        this.offset += source.length;
      }
    }
    *end() {
      while (this.stack.length > 0)
        yield* this.pop();
    }
    get sourceToken() {
      const st = {
        type: this.type,
        offset: this.offset,
        indent: this.indent,
        source: this.source
      };
      return st;
    }
    *step() {
      const top = this.peek(1);
      if (this.type === "doc-end" && top?.type !== "doc-end") {
        while (this.stack.length > 0)
          yield* this.pop();
        this.stack.push({
          type: "doc-end",
          offset: this.offset,
          source: this.source
        });
        return;
      }
      if (!top)
        return yield* this.stream();
      switch (top.type) {
        case "document":
          return yield* this.document(top);
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return yield* this.scalar(top);
        case "block-scalar":
          return yield* this.blockScalar(top);
        case "block-map":
          return yield* this.blockMap(top);
        case "block-seq":
          return yield* this.blockSequence(top);
        case "flow-collection":
          return yield* this.flowCollection(top);
        case "doc-end":
          return yield* this.documentEnd(top);
      }
      yield* this.pop();
    }
    peek(n) {
      return this.stack[this.stack.length - n];
    }
    *pop(error) {
      const token = error ?? this.stack.pop();
      if (!token) {
        const message = "Tried to pop an empty stack";
        yield { type: "error", offset: this.offset, source: "", message };
      } else if (this.stack.length === 0) {
        yield token;
      } else {
        const top = this.peek(1);
        if (token.type === "block-scalar") {
          token.indent = "indent" in top ? top.indent : 0;
        } else if (token.type === "flow-collection" && top.type === "document") {
          token.indent = 0;
        }
        if (token.type === "flow-collection")
          fixFlowSeqItems(token);
        switch (top.type) {
          case "document":
            top.value = token;
            break;
          case "block-scalar":
            top.props.push(token);
            break;
          case "block-map": {
            const it = top.items[top.items.length - 1];
            if (it.value) {
              top.items.push({ start: [], key: token, sep: [] });
              this.onKeyLine = true;
              return;
            } else if (it.sep) {
              it.value = token;
            } else {
              Object.assign(it, { key: token, sep: [] });
              this.onKeyLine = !it.explicitKey;
              return;
            }
            break;
          }
          case "block-seq": {
            const it = top.items[top.items.length - 1];
            if (it.value)
              top.items.push({ start: [], value: token });
            else
              it.value = token;
            break;
          }
          case "flow-collection": {
            const it = top.items[top.items.length - 1];
            if (!it || it.value)
              top.items.push({ start: [], key: token, sep: [] });
            else if (it.sep)
              it.value = token;
            else
              Object.assign(it, { key: token, sep: [] });
            return;
          }
          default:
            yield* this.pop();
            yield* this.pop(token);
        }
        if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
          const last = token.items[token.items.length - 1];
          if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
            if (top.type === "document")
              top.end = last.start;
            else
              top.items.push({ start: last.start });
            token.items.splice(-1, 1);
          }
        }
      }
    }
    *stream() {
      switch (this.type) {
        case "directive-line":
          yield { type: "directive", offset: this.offset, source: this.source };
          return;
        case "byte-order-mark":
        case "space":
        case "comment":
        case "newline":
          yield this.sourceToken;
          return;
        case "doc-mode":
        case "doc-start": {
          const doc = {
            type: "document",
            offset: this.offset,
            start: []
          };
          if (this.type === "doc-start")
            doc.start.push(this.sourceToken);
          this.stack.push(doc);
          return;
        }
      }
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML stream`,
        source: this.source
      };
    }
    *document(doc) {
      if (doc.value)
        return yield* this.lineEnd(doc);
      switch (this.type) {
        case "doc-start": {
          if (findNonEmptyIndex(doc.start) !== -1) {
            yield* this.pop();
            yield* this.step();
          } else
            doc.start.push(this.sourceToken);
          return;
        }
        case "anchor":
        case "tag":
        case "space":
        case "comment":
        case "newline":
          doc.start.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(doc);
      if (bv)
        this.stack.push(bv);
      else {
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML document`,
          source: this.source
        };
      }
    }
    *scalar(scalar) {
      if (this.type === "map-value-ind") {
        const prev = getPrevProps(this.peek(2));
        const start = getFirstKeyStartProps(prev);
        let sep;
        if (scalar.end) {
          sep = scalar.end;
          sep.push(this.sourceToken);
          delete scalar.end;
        } else
          sep = [this.sourceToken];
        const map = {
          type: "block-map",
          offset: scalar.offset,
          indent: scalar.indent,
          items: [{ start, key: scalar, sep }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map;
      } else
        yield* this.lineEnd(scalar);
    }
    *blockScalar(scalar) {
      switch (this.type) {
        case "space":
        case "comment":
        case "newline":
          scalar.props.push(this.sourceToken);
          return;
        case "scalar":
          scalar.source = this.source;
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine) {
            let nl = this.source.indexOf(`
`) + 1;
            while (nl !== 0) {
              this.onNewLine(this.offset + nl);
              nl = this.source.indexOf(`
`, nl) + 1;
            }
          }
          yield* this.pop();
          break;
        default:
          yield* this.pop();
          yield* this.step();
      }
    }
    *blockMap(map) {
      const it = map.items[map.items.length - 1];
      switch (this.type) {
        case "newline":
          this.onKeyLine = false;
          if (it.value) {
            const end = "end" in it.value ? it.value.end : undefined;
            const last = Array.isArray(end) ? end[end.length - 1] : undefined;
            if (last?.type === "comment")
              end?.push(this.sourceToken);
            else
              map.items.push({ start: [this.sourceToken] });
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            it.start.push(this.sourceToken);
          }
          return;
        case "space":
        case "comment":
          if (it.value) {
            map.items.push({ start: [this.sourceToken] });
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            if (this.atIndentedComment(it.start, map.indent)) {
              const prev = map.items[map.items.length - 2];
              const end = prev?.value?.end;
              if (Array.isArray(end)) {
                Array.prototype.push.apply(end, it.start);
                end.push(this.sourceToken);
                map.items.pop();
                return;
              }
            }
            it.start.push(this.sourceToken);
          }
          return;
      }
      if (this.indent >= map.indent) {
        const atMapIndent = !this.onKeyLine && this.indent === map.indent;
        const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
        let start = [];
        if (atNextItem && it.sep && !it.value) {
          const nl = [];
          for (let i = 0;i < it.sep.length; ++i) {
            const st = it.sep[i];
            switch (st.type) {
              case "newline":
                nl.push(i);
                break;
              case "space":
                break;
              case "comment":
                if (st.indent > map.indent)
                  nl.length = 0;
                break;
              default:
                nl.length = 0;
            }
          }
          if (nl.length >= 2)
            start = it.sep.splice(nl[1]);
        }
        switch (this.type) {
          case "anchor":
          case "tag":
            if (atNextItem || it.value) {
              start.push(this.sourceToken);
              map.items.push({ start });
              this.onKeyLine = true;
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              it.start.push(this.sourceToken);
            }
            return;
          case "explicit-key-ind":
            if (!it.sep && !it.explicitKey) {
              it.start.push(this.sourceToken);
              it.explicitKey = true;
            } else if (atNextItem || it.value) {
              start.push(this.sourceToken);
              map.items.push({ start, explicitKey: true });
            } else {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: [this.sourceToken], explicitKey: true }]
              });
            }
            this.onKeyLine = true;
            return;
          case "map-value-ind":
            if (it.explicitKey) {
              if (!it.sep) {
                if (includesToken(it.start, "newline")) {
                  Object.assign(it, { key: null, sep: [this.sourceToken] });
                } else {
                  const start2 = getFirstKeyStartProps(it.start);
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                  });
                }
              } else if (it.value) {
                map.items.push({ start: [], key: null, sep: [this.sourceToken] });
              } else if (includesToken(it.sep, "map-value-ind")) {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start, key: null, sep: [this.sourceToken] }]
                });
              } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                const start2 = getFirstKeyStartProps(it.start);
                const key = it.key;
                const sep = it.sep;
                sep.push(this.sourceToken);
                delete it.key;
                delete it.sep;
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: start2, key, sep }]
                });
              } else if (start.length > 0) {
                it.sep = it.sep.concat(start, this.sourceToken);
              } else {
                it.sep.push(this.sourceToken);
              }
            } else {
              if (!it.sep) {
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              } else if (it.value || atNextItem) {
                map.items.push({ start, key: null, sep: [this.sourceToken] });
              } else if (includesToken(it.sep, "map-value-ind")) {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [], key: null, sep: [this.sourceToken] }]
                });
              } else {
                it.sep.push(this.sourceToken);
              }
            }
            this.onKeyLine = true;
            return;
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar": {
            const fs = this.flowScalar(this.type);
            if (atNextItem || it.value) {
              map.items.push({ start, key: fs, sep: [] });
              this.onKeyLine = true;
            } else if (it.sep) {
              this.stack.push(fs);
            } else {
              Object.assign(it, { key: fs, sep: [] });
              this.onKeyLine = true;
            }
            return;
          }
          default: {
            const bv = this.startBlockValue(map);
            if (bv) {
              if (bv.type === "block-seq") {
                if (!it.explicitKey && it.sep && !includesToken(it.sep, "newline")) {
                  yield* this.pop({
                    type: "error",
                    offset: this.offset,
                    message: "Unexpected block-seq-ind on same line with key",
                    source: this.source
                  });
                  return;
                }
              } else if (atMapIndent) {
                map.items.push({ start });
              }
              this.stack.push(bv);
              return;
            }
          }
        }
      }
      yield* this.pop();
      yield* this.step();
    }
    *blockSequence(seq) {
      const it = seq.items[seq.items.length - 1];
      switch (this.type) {
        case "newline":
          if (it.value) {
            const end = "end" in it.value ? it.value.end : undefined;
            const last = Array.isArray(end) ? end[end.length - 1] : undefined;
            if (last?.type === "comment")
              end?.push(this.sourceToken);
            else
              seq.items.push({ start: [this.sourceToken] });
          } else
            it.start.push(this.sourceToken);
          return;
        case "space":
        case "comment":
          if (it.value)
            seq.items.push({ start: [this.sourceToken] });
          else {
            if (this.atIndentedComment(it.start, seq.indent)) {
              const prev = seq.items[seq.items.length - 2];
              const end = prev?.value?.end;
              if (Array.isArray(end)) {
                Array.prototype.push.apply(end, it.start);
                end.push(this.sourceToken);
                seq.items.pop();
                return;
              }
            }
            it.start.push(this.sourceToken);
          }
          return;
        case "anchor":
        case "tag":
          if (it.value || this.indent <= seq.indent)
            break;
          it.start.push(this.sourceToken);
          return;
        case "seq-item-ind":
          if (this.indent !== seq.indent)
            break;
          if (it.value || includesToken(it.start, "seq-item-ind"))
            seq.items.push({ start: [this.sourceToken] });
          else
            it.start.push(this.sourceToken);
          return;
      }
      if (this.indent > seq.indent) {
        const bv = this.startBlockValue(seq);
        if (bv) {
          this.stack.push(bv);
          return;
        }
      }
      yield* this.pop();
      yield* this.step();
    }
    *flowCollection(fc) {
      const it = fc.items[fc.items.length - 1];
      if (this.type === "flow-error-end") {
        let top;
        do {
          yield* this.pop();
          top = this.peek(1);
        } while (top?.type === "flow-collection");
      } else if (fc.end.length === 0) {
        switch (this.type) {
          case "comma":
          case "explicit-key-ind":
            if (!it || it.sep)
              fc.items.push({ start: [this.sourceToken] });
            else
              it.start.push(this.sourceToken);
            return;
          case "map-value-ind":
            if (!it || it.value)
              fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
            else if (it.sep)
              it.sep.push(this.sourceToken);
            else
              Object.assign(it, { key: null, sep: [this.sourceToken] });
            return;
          case "space":
          case "comment":
          case "newline":
          case "anchor":
          case "tag":
            if (!it || it.value)
              fc.items.push({ start: [this.sourceToken] });
            else if (it.sep)
              it.sep.push(this.sourceToken);
            else
              it.start.push(this.sourceToken);
            return;
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar": {
            const fs = this.flowScalar(this.type);
            if (!it || it.value)
              fc.items.push({ start: [], key: fs, sep: [] });
            else if (it.sep)
              this.stack.push(fs);
            else
              Object.assign(it, { key: fs, sep: [] });
            return;
          }
          case "flow-map-end":
          case "flow-seq-end":
            fc.end.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(fc);
        if (bv)
          this.stack.push(bv);
        else {
          yield* this.pop();
          yield* this.step();
        }
      } else {
        const parent = this.peek(2);
        if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
          yield* this.pop();
          yield* this.step();
        } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
          const prev = getPrevProps(parent);
          const start = getFirstKeyStartProps(prev);
          fixFlowSeqItems(fc);
          const sep = fc.end.splice(1, fc.end.length);
          sep.push(this.sourceToken);
          const map = {
            type: "block-map",
            offset: fc.offset,
            indent: fc.indent,
            items: [{ start, key: fc, sep }]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map;
        } else {
          yield* this.lineEnd(fc);
        }
      }
    }
    flowScalar(type) {
      if (this.onNewLine) {
        let nl = this.source.indexOf(`
`) + 1;
        while (nl !== 0) {
          this.onNewLine(this.offset + nl);
          nl = this.source.indexOf(`
`, nl) + 1;
        }
      }
      return {
        type,
        offset: this.offset,
        indent: this.indent,
        source: this.source
      };
    }
    startBlockValue(parent) {
      switch (this.type) {
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return this.flowScalar(this.type);
        case "block-scalar-header":
          return {
            type: "block-scalar",
            offset: this.offset,
            indent: this.indent,
            props: [this.sourceToken],
            source: ""
          };
        case "flow-map-start":
        case "flow-seq-start":
          return {
            type: "flow-collection",
            offset: this.offset,
            indent: this.indent,
            start: this.sourceToken,
            items: [],
            end: []
          };
        case "seq-item-ind":
          return {
            type: "block-seq",
            offset: this.offset,
            indent: this.indent,
            items: [{ start: [this.sourceToken] }]
          };
        case "explicit-key-ind": {
          this.onKeyLine = true;
          const prev = getPrevProps(parent);
          const start = getFirstKeyStartProps(prev);
          start.push(this.sourceToken);
          return {
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start, explicitKey: true }]
          };
        }
        case "map-value-ind": {
          this.onKeyLine = true;
          const prev = getPrevProps(parent);
          const start = getFirstKeyStartProps(prev);
          return {
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start, key: null, sep: [this.sourceToken] }]
          };
        }
      }
      return null;
    }
    atIndentedComment(start, indent) {
      if (this.type !== "comment")
        return false;
      if (this.indent <= indent)
        return false;
      return start.every((st) => st.type === "newline" || st.type === "space");
    }
    *documentEnd(docEnd) {
      if (this.type !== "doc-mode") {
        if (docEnd.end)
          docEnd.end.push(this.sourceToken);
        else
          docEnd.end = [this.sourceToken];
        if (this.type === "newline")
          yield* this.pop();
      }
    }
    *lineEnd(token) {
      switch (this.type) {
        case "comma":
        case "doc-start":
        case "doc-end":
        case "flow-seq-end":
        case "flow-map-end":
        case "map-value-ind":
          yield* this.pop();
          yield* this.step();
          break;
        case "newline":
          this.onKeyLine = false;
        case "space":
        case "comment":
        default:
          if (token.end)
            token.end.push(this.sourceToken);
          else
            token.end = [this.sourceToken];
          if (this.type === "newline")
            yield* this.pop();
      }
    }
  }
  exports.Parser = Parser;
});

// node_modules/yaml/dist/public-api.js
var require_public_api = __commonJS((exports) => {
  var composer = require_composer();
  var Document = require_Document();
  var errors = require_errors();
  var log = require_log();
  var identity = require_identity();
  var lineCounter = require_line_counter();
  var parser = require_parser();
  function parseOptions(options) {
    const prettyErrors = options.prettyErrors !== false;
    const lineCounter$1 = options.lineCounter || prettyErrors && new lineCounter.LineCounter || null;
    return { lineCounter: lineCounter$1, prettyErrors };
  }
  function parseAllDocuments(source, options = {}) {
    const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
    const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
    const composer$1 = new composer.Composer(options);
    const docs = Array.from(composer$1.compose(parser$1.parse(source)));
    if (prettyErrors && lineCounter2)
      for (const doc of docs) {
        doc.errors.forEach(errors.prettifyError(source, lineCounter2));
        doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
      }
    if (docs.length > 0)
      return docs;
    return Object.assign([], { empty: true }, composer$1.streamInfo());
  }
  function parseDocument(source, options = {}) {
    const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
    const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
    const composer$1 = new composer.Composer(options);
    let doc = null;
    for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {
      if (!doc)
        doc = _doc;
      else if (doc.options.logLevel !== "silent") {
        doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
        break;
      }
    }
    if (prettyErrors && lineCounter2) {
      doc.errors.forEach(errors.prettifyError(source, lineCounter2));
      doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
    }
    return doc;
  }
  function parse(src, reviver, options) {
    let _reviver = undefined;
    if (typeof reviver === "function") {
      _reviver = reviver;
    } else if (options === undefined && reviver && typeof reviver === "object") {
      options = reviver;
    }
    const doc = parseDocument(src, options);
    if (!doc)
      return null;
    doc.warnings.forEach((warning) => log.warn(doc.options.logLevel, warning));
    if (doc.errors.length > 0) {
      if (doc.options.logLevel !== "silent")
        throw doc.errors[0];
      else
        doc.errors = [];
    }
    return doc.toJS(Object.assign({ reviver: _reviver }, options));
  }
  function stringify(value, replacer, options) {
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer)) {
      _replacer = replacer;
    } else if (options === undefined && replacer) {
      options = replacer;
    }
    if (typeof options === "string")
      options = options.length;
    if (typeof options === "number") {
      const indent = Math.round(options);
      options = indent < 1 ? undefined : indent > 8 ? { indent: 8 } : { indent };
    }
    if (value === undefined) {
      const { keepUndefined } = options ?? replacer ?? {};
      if (!keepUndefined)
        return;
    }
    if (identity.isDocument(value) && !_replacer)
      return value.toString(options);
    return new Document.Document(value, _replacer, options).toString(options);
  }
  exports.parse = parse;
  exports.parseAllDocuments = parseAllDocuments;
  exports.parseDocument = parseDocument;
  exports.stringify = stringify;
});

// node_modules/yaml/dist/index.js
var require_dist = __commonJS((exports) => {
  var composer = require_composer();
  var Document = require_Document();
  var Schema = require_Schema();
  var errors = require_errors();
  var Alias = require_Alias();
  var identity = require_identity();
  var Pair = require_Pair();
  var Scalar = require_Scalar();
  var YAMLMap = require_YAMLMap();
  var YAMLSeq = require_YAMLSeq();
  var cst = require_cst();
  var lexer = require_lexer();
  var lineCounter = require_line_counter();
  var parser = require_parser();
  var publicApi = require_public_api();
  var visit = require_visit();
  exports.Composer = composer.Composer;
  exports.Document = Document.Document;
  exports.Schema = Schema.Schema;
  exports.YAMLError = errors.YAMLError;
  exports.YAMLParseError = errors.YAMLParseError;
  exports.YAMLWarning = errors.YAMLWarning;
  exports.Alias = Alias.Alias;
  exports.isAlias = identity.isAlias;
  exports.isCollection = identity.isCollection;
  exports.isDocument = identity.isDocument;
  exports.isMap = identity.isMap;
  exports.isNode = identity.isNode;
  exports.isPair = identity.isPair;
  exports.isScalar = identity.isScalar;
  exports.isSeq = identity.isSeq;
  exports.Pair = Pair.Pair;
  exports.Scalar = Scalar.Scalar;
  exports.YAMLMap = YAMLMap.YAMLMap;
  exports.YAMLSeq = YAMLSeq.YAMLSeq;
  exports.CST = cst;
  exports.Lexer = lexer.Lexer;
  exports.LineCounter = lineCounter.LineCounter;
  exports.Parser = parser.Parser;
  exports.parse = publicApi.parse;
  exports.parseAllDocuments = publicApi.parseAllDocuments;
  exports.parseDocument = publicApi.parseDocument;
  exports.stringify = publicApi.stringify;
  exports.visit = visit.visit;
  exports.visitAsync = visit.visitAsync;
});

// node_modules/sisteransi/src/index.js
var require_src = __commonJS((exports, module) => {
  var ESC = "\x1B";
  var CSI = `${ESC}[`;
  var beep = "\x07";
  var cursor = {
    to(x, y) {
      if (!y)
        return `${CSI}${x + 1}G`;
      return `${CSI}${y + 1};${x + 1}H`;
    },
    move(x, y) {
      let ret = "";
      if (x < 0)
        ret += `${CSI}${-x}D`;
      else if (x > 0)
        ret += `${CSI}${x}C`;
      if (y < 0)
        ret += `${CSI}${-y}A`;
      else if (y > 0)
        ret += `${CSI}${y}B`;
      return ret;
    },
    up: (count = 1) => `${CSI}${count}A`,
    down: (count = 1) => `${CSI}${count}B`,
    forward: (count = 1) => `${CSI}${count}C`,
    backward: (count = 1) => `${CSI}${count}D`,
    nextLine: (count = 1) => `${CSI}E`.repeat(count),
    prevLine: (count = 1) => `${CSI}F`.repeat(count),
    left: `${CSI}G`,
    hide: `${CSI}?25l`,
    show: `${CSI}?25h`,
    save: `${ESC}7`,
    restore: `${ESC}8`
  };
  var scroll = {
    up: (count = 1) => `${CSI}S`.repeat(count),
    down: (count = 1) => `${CSI}T`.repeat(count)
  };
  var erase = {
    screen: `${CSI}2J`,
    up: (count = 1) => `${CSI}1J`.repeat(count),
    down: (count = 1) => `${CSI}J`.repeat(count),
    line: `${CSI}2K`,
    lineEnd: `${CSI}K`,
    lineStart: `${CSI}1K`,
    lines(count) {
      let clear = "";
      for (let i = 0;i < count; i++)
        clear += this.line + (i < count - 1 ? cursor.up() : "");
      if (count)
        clear += cursor.left;
      return clear;
    }
  };
  module.exports = { cursor, scroll, erase, beep };
});

// node_modules/picocolors/picocolors.js
var require_picocolors = __commonJS((exports, module) => {
  var p = process || {};
  var argv = p.argv || [];
  var env = p.env || {};
  var isColorSupported = !(!!env.NO_COLOR || argv.includes("--no-color")) && (!!env.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env.TERM !== "dumb" || !!env.CI);
  var formatter = (open, close, replace = open) => (input) => {
    let string = "" + input, index = string.indexOf(close, open.length);
    return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
  };
  var replaceClose = (string, close, replace, index) => {
    let result = "", cursor = 0;
    do {
      result += string.substring(cursor, index) + replace;
      cursor = index + close.length;
      index = string.indexOf(close, cursor);
    } while (~index);
    return result + string.substring(cursor);
  };
  var createColors = (enabled = isColorSupported) => {
    let f = enabled ? formatter : () => String;
    return {
      isColorSupported: enabled,
      reset: f("\x1B[0m", "\x1B[0m"),
      bold: f("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
      dim: f("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
      italic: f("\x1B[3m", "\x1B[23m"),
      underline: f("\x1B[4m", "\x1B[24m"),
      inverse: f("\x1B[7m", "\x1B[27m"),
      hidden: f("\x1B[8m", "\x1B[28m"),
      strikethrough: f("\x1B[9m", "\x1B[29m"),
      black: f("\x1B[30m", "\x1B[39m"),
      red: f("\x1B[31m", "\x1B[39m"),
      green: f("\x1B[32m", "\x1B[39m"),
      yellow: f("\x1B[33m", "\x1B[39m"),
      blue: f("\x1B[34m", "\x1B[39m"),
      magenta: f("\x1B[35m", "\x1B[39m"),
      cyan: f("\x1B[36m", "\x1B[39m"),
      white: f("\x1B[37m", "\x1B[39m"),
      gray: f("\x1B[90m", "\x1B[39m"),
      bgBlack: f("\x1B[40m", "\x1B[49m"),
      bgRed: f("\x1B[41m", "\x1B[49m"),
      bgGreen: f("\x1B[42m", "\x1B[49m"),
      bgYellow: f("\x1B[43m", "\x1B[49m"),
      bgBlue: f("\x1B[44m", "\x1B[49m"),
      bgMagenta: f("\x1B[45m", "\x1B[49m"),
      bgCyan: f("\x1B[46m", "\x1B[49m"),
      bgWhite: f("\x1B[47m", "\x1B[49m"),
      blackBright: f("\x1B[90m", "\x1B[39m"),
      redBright: f("\x1B[91m", "\x1B[39m"),
      greenBright: f("\x1B[92m", "\x1B[39m"),
      yellowBright: f("\x1B[93m", "\x1B[39m"),
      blueBright: f("\x1B[94m", "\x1B[39m"),
      magentaBright: f("\x1B[95m", "\x1B[39m"),
      cyanBright: f("\x1B[96m", "\x1B[39m"),
      whiteBright: f("\x1B[97m", "\x1B[39m"),
      bgBlackBright: f("\x1B[100m", "\x1B[49m"),
      bgRedBright: f("\x1B[101m", "\x1B[49m"),
      bgGreenBright: f("\x1B[102m", "\x1B[49m"),
      bgYellowBright: f("\x1B[103m", "\x1B[49m"),
      bgBlueBright: f("\x1B[104m", "\x1B[49m"),
      bgMagentaBright: f("\x1B[105m", "\x1B[49m"),
      bgCyanBright: f("\x1B[106m", "\x1B[49m"),
      bgWhiteBright: f("\x1B[107m", "\x1B[49m")
    };
  };
  module.exports = createColors();
  module.exports.createColors = createColors;
});

// src/cli/ui.ts
import { EOL } from "node:os";
var UI;
var init_ui = __esm(() => {
  ((UI) => {
    UI.Style = {
      TEXT_HIGHLIGHT: "\x1B[96m",
      TEXT_HIGHLIGHT_BOLD: "\x1B[96m\x1B[1m",
      TEXT_DIM: "\x1B[90m",
      TEXT_DIM_BOLD: "\x1B[90m\x1B[1m",
      TEXT_NORMAL: "\x1B[0m",
      TEXT_NORMAL_BOLD: "\x1B[1m",
      TEXT_WARNING: "\x1B[93m",
      TEXT_WARNING_BOLD: "\x1B[93m\x1B[1m",
      TEXT_DANGER: "\x1B[91m",
      TEXT_DANGER_BOLD: "\x1B[91m\x1B[1m",
      TEXT_SUCCESS: "\x1B[92m",
      TEXT_SUCCESS_BOLD: "\x1B[92m\x1B[1m",
      TEXT_INFO: "\x1B[94m",
      TEXT_INFO_BOLD: "\x1B[94m\x1B[1m"
    };
    function println(...message) {
      process.stderr.write(message.join(" ") + EOL);
    }
    UI.println = println;
    function print(...message) {
      process.stderr.write(message.join(" "));
    }
    UI.print = print;
    function error(message) {
      println(`${UI.Style.TEXT_DANGER_BOLD}Error: ${UI.Style.TEXT_NORMAL}${message}`);
    }
    UI.error = error;
    function success(message) {
      println(`${UI.Style.TEXT_SUCCESS_BOLD} ${UI.Style.TEXT_NORMAL}${message}`);
    }
    UI.success = success;
    function info(message) {
      println(`${UI.Style.TEXT_INFO_BOLD} ${UI.Style.TEXT_NORMAL}${message}`);
    }
    UI.info = info;
    function warn(message) {
      println(`${UI.Style.TEXT_WARNING_BOLD}! ${UI.Style.TEXT_NORMAL}${message}`);
    }
    UI.warn = warn;
    function header(title) {
      println();
      println(UI.Style.TEXT_HIGHLIGHT_BOLD + title + UI.Style.TEXT_NORMAL);
      println(UI.Style.TEXT_DIM + "".repeat(50) + UI.Style.TEXT_NORMAL);
    }
    UI.header = header;
  })(UI ||= {});
});

// src/install/init.ts
var exports_init = {};
__export(exports_init, {
  initConfig: () => initConfig
});
import { existsSync as existsSync2 } from "node:fs";
import { writeFile } from "node:fs/promises";
import { join as join4 } from "node:path";
async function initConfig(flags) {
  const configDir = join4(process.cwd(), ".ai-eng");
  const configPath = join4(configDir, "config.yaml");
  if (existsSync2(configPath) && !flags.overwrite) {
    UI.error("Configuration file already exists:");
    console.error(`  ${configPath}`);
    console.error("Use --overwrite to replace it, or edit the existing file.");
    process.exit(1);
  }
  if (flags.interactive) {
    console.log("  Interactive mode requires additional dependencies.");
    console.log("  npm install @clack/prompts");
    console.log(`For now, creating config with defaults...
`);
  }
  try {
    const yamlContent = import_yaml2.default.stringify(CONFIG_TEMPLATE, {
      indent: 2,
      lineWidth: 0
    });
    await writeFile(configPath, yamlContent, "utf-8");
    console.log(" Initialized .ai-eng/config.yaml with defaults");
    console.log(`
\uD83D\uDCCB Next steps:`);
    console.log("  1. Edit .ai-eng/config.yaml to customize settings");
    console.log("  2. Set up AI models and backends");
    console.log("  3. Configure quality gates for your project");
    console.log(`  4. Run 'ai-eng ralph "your task"' to start development`);
  } catch (error) {
    console.error("Failed to write configuration file");
    process.exit(1);
  }
}
var import_yaml2, CONFIG_TEMPLATE;
var init_init = __esm(() => {
  init_ui();
  import_yaml2 = __toESM(require_dist(), 1);
  CONFIG_TEMPLATE = {
    version: 1,
    runner: {
      backend: "opencode",
      review: "opencode",
      artifactsDir: ".ai-eng/runs",
      maxIters: 3,
      printLogs: false,
      logLevel: "INFO"
    },
    loop: {
      maxCycles: 50,
      cycleRetries: 2,
      checkpointFrequency: 1,
      stuckThreshold: 5
    },
    debug: {
      work: false
    },
    opencode: {
      model: "claude-3-5-sonnet-latest",
      temperature: 0.2,
      promptTimeoutMs: 120000
    },
    anthropic: {
      enabled: false,
      model: "claude-3-5-sonnet-latest"
    },
    gates: {
      lint: { command: "bun run lint" },
      typecheck: { command: "bun run typecheck" },
      test: { command: "bun test" },
      build: { command: "bun run build" },
      acceptance: { command: "git diff --name-only" }
    },
    models: {
      research: "github-copilot/gpt-5.2",
      planning: "github-copilot/gpt-5.2",
      exploration: "github-copilot/gpt-5.2",
      coding: "github-copilot/gpt-5.2",
      default: "github-copilot/gpt-5.2"
    },
    notifications: {
      discord: {
        enabled: false,
        username: "Ralph",
        webhook: {
          source: "env",
          envVar: "DISCORD_WEBHOOK_URL"
        }
      }
    },
    ui: {
      silent: false
    }
  };
});

// src/install/install.ts
var exports_install = {};
__export(exports_install, {
  runInstaller: () => runInstaller
});
import fs2 from "node:fs";
import path2 from "node:path";
import { fileURLToPath } from "node:url";
async function cleanNamespacedDirectory(baseDir, subdir, namespace, silent = false) {
  const dir = path2.join(baseDir, subdir, namespace);
  if (fs2.existsSync(dir)) {
    fs2.rmSync(dir, { recursive: true, force: true });
    if (!silent) {
      console.log(`   Cleaned existing ${subdir}/${namespace}/`);
    }
  }
}
async function cleanAiEngSkills(targetOpenCodeDir, distOpenCodeDir, silent = false) {
  const targetSkillDir = path2.join(targetOpenCodeDir, "skill");
  const distSkillDir = path2.join(distOpenCodeDir, "skill");
  if (!fs2.existsSync(distSkillDir))
    return;
  const aiEngSkillNames = fs2.readdirSync(distSkillDir, { withFileTypes: true }).filter((entry) => entry.isDirectory()).map((entry) => entry.name);
  if (aiEngSkillNames.length === 0)
    return;
  let cleanedCount = 0;
  for (const skillName of aiEngSkillNames) {
    const skillPath = path2.join(targetSkillDir, skillName);
    if (fs2.existsSync(skillPath)) {
      fs2.rmSync(skillPath, { recursive: true, force: true });
      cleanedCount++;
    }
  }
  if (!silent && cleanedCount > 0) {
    console.log(`   Cleaned ${cleanedCount} existing ai-eng skills`);
  }
}
function isPluginReferenced(configPath) {
  try {
    const configContent = fs2.readFileSync(configPath, "utf-8");
    const config = JSON.parse(configContent);
    if (Array.isArray(config.plugin)) {
      return config.plugin.includes("ai-eng-system");
    }
    return false;
  } catch {
    return false;
  }
}
function findOpenCodeConfig(projectDir) {
  const homeDir = process.env.HOME || process.env.USERPROFILE || "";
  const projectConfig = path2.join(projectDir, ".opencode", "opencode.jsonc");
  if (fs2.existsSync(projectConfig)) {
    return { path: projectConfig, isGlobal: false };
  }
  const globalConfig = path2.join(homeDir, ".config", "opencode", "opencode.jsonc");
  if (fs2.existsSync(globalConfig)) {
    return { path: globalConfig, isGlobal: true };
  }
  return null;
}
function detectInstallationScope(projectDir) {
  const config = findOpenCodeConfig(projectDir);
  if (config)
    return config.isGlobal ? "global" : "project";
  if (fs2.existsSync(path2.join(projectDir, "package.json"))) {
    return "project";
  }
  return "global";
}
async function runInstaller(flags) {
  const projectDir = process.cwd();
  const homeDir = process.env.HOME || process.env.USERPROFILE || "";
  const distOpenCodeDir = path2.join(ROOT2, "dist", ".opencode");
  let scope = flags.scope;
  if (!scope || scope === "auto") {
    const detected = detectInstallationScope(projectDir);
    if (!detected) {
      console.log(" Could not detect installation scope. Use --scope project|global");
      process.exit(1);
    }
    scope = detected;
  }
  const targetOpenCodeDir = scope === "global" ? path2.join(homeDir, ".config", "opencode") : path2.join(projectDir, ".opencode");
  if (flags.verbose) {
    console.log(`Installing to: ${targetOpenCodeDir}`);
    console.log(`Scope: ${scope}`);
  }
  if (scope === "project") {
    const opencodeDir = path2.join(projectDir, ".opencode");
    if (!fs2.existsSync(opencodeDir)) {
      console.log(" No .opencode/ directory found in project");
      console.log("   Run 'opencode init' first or use --scope global");
      process.exit(1);
    }
  }
  const config = findOpenCodeConfig(projectDir);
  if (config && !isPluginReferenced(config.path)) {
    console.log("  opencode.jsonc does not reference ai-eng-system plugin");
    console.log("   Add 'ai-eng-system' to the plugin array in opencode.jsonc");
  }
  if (flags.dryRun) {
    console.log("\uD83D\uDD0D dry-run: Would install the following files:");
    console.log(`   Commands -> ${targetOpenCodeDir}/command/${NAMESPACE_PREFIX}/`);
    console.log(`   Agents   -> ${targetOpenCodeDir}/agent/${NAMESPACE_PREFIX}/`);
    console.log(`   Skills   -> ${targetOpenCodeDir}/skill/`);
    return;
  }
  const commandsDir = path2.join(targetOpenCodeDir, "command", NAMESPACE_PREFIX);
  const distCommandsDir = path2.join(distOpenCodeDir, "command", NAMESPACE_PREFIX);
  if (fs2.existsSync(distCommandsDir)) {
    await cleanNamespacedDirectory(targetOpenCodeDir, "command", NAMESPACE_PREFIX);
    fs2.cpSync(distCommandsDir, commandsDir, { recursive: true });
    console.log(`   Installed commands to ${commandsDir}`);
  }
  const agentsDir = path2.join(targetOpenCodeDir, "agent", NAMESPACE_PREFIX);
  const distAgentsDir = path2.join(distOpenCodeDir, "agent", NAMESPACE_PREFIX);
  if (fs2.existsSync(distAgentsDir)) {
    await cleanNamespacedDirectory(targetOpenCodeDir, "agent", NAMESPACE_PREFIX);
    fs2.cpSync(distAgentsDir, agentsDir, { recursive: true });
    console.log(`   Installed agents to ${agentsDir}`);
  }
  const skillsDir = path2.join(targetOpenCodeDir, "skill");
  const distSkillsDir = path2.join(distOpenCodeDir, "skill");
  if (fs2.existsSync(distSkillsDir)) {
    await cleanAiEngSkills(targetOpenCodeDir, distOpenCodeDir);
    fs2.cpSync(distSkillsDir, skillsDir, { recursive: true });
    console.log(`   Installed skills to ${skillsDir}`);
  }
  console.log(`
 Installation complete!`);
  console.log("   Restart OpenCode or Claude Code to use new commands and agents.");
}
var __filename2, __dirname2, ROOT2, NAMESPACE_PREFIX = "ai-eng";
var init_install = __esm(() => {
  __filename2 = fileURLToPath(import.meta.url);
  __dirname2 = path2.dirname(__filename2);
  ROOT2 = path2.dirname(__dirname2);
});

// src/cli/run.ts
import { parseArgs } from "node:util";

// src/config/loadConfig.ts
var import_yaml = __toESM(require_dist(), 1);
import { readFile } from "node:fs/promises";
import { join } from "node:path";

// src/config/schema.ts
var DEFAULT_CONFIG = {
  version: 1,
  runner: {
    backend: "opencode",
    review: "opencode",
    artifactsDir: ".ai-eng/runs",
    maxIters: 3,
    printLogs: false,
    logLevel: "INFO"
  },
  loop: {
    maxCycles: 50,
    cycleRetries: 2,
    checkpointFrequency: 1,
    stuckThreshold: 5
  },
  debug: {
    work: false
  },
  opencode: {
    model: "claude-3-5-sonnet-latest",
    temperature: 0.2,
    serverUrl: undefined,
    directory: undefined,
    promptTimeoutMs: 120000
  },
  anthropic: {
    enabled: false,
    model: "claude-3-5-sonnet-latest"
  },
  gates: {
    lint: { command: "bun run lint" },
    typecheck: { command: "bun run typecheck" },
    test: { command: "bun test" },
    build: { command: "bun run build" },
    acceptance: { command: "git diff --name-only" }
  },
  models: {
    research: "github-copilot/gpt-5.2",
    planning: "github-copilot/gpt-5.2",
    exploration: "github-copilot/gpt-5.2",
    coding: "github-copilot/gpt-5.2",
    default: "github-copilot/gpt-5.2"
  },
  notifications: {
    discord: {
      enabled: false,
      username: "Ralph",
      avatarUrl: undefined,
      webhook: {
        source: "env",
        envVar: "DISCORD_WEBHOOK_URL"
      }
    }
  },
  ui: {
    silent: false
  }
};

// src/config/loadConfig.ts
var ROOT = process.env.TEST_ROOT ?? process.cwd();
function applyEnvOverrides(config) {
  if (process.env.OPENCODE_URL) {
    config.opencode.serverUrl = process.env.OPENCODE_URL;
  }
  if (process.env.OPENCODE_DIRECTORY) {
    config.opencode.directory = process.env.OPENCODE_DIRECTORY;
  }
  if (process.env.OPENCODE_PROMPT_TIMEOUT_MS) {
    const timeout = Number.parseInt(process.env.OPENCODE_PROMPT_TIMEOUT_MS, 10);
    if (Number.isNaN(timeout)) {
      config.opencode.promptTimeoutMs = timeout;
    }
  }
  if (process.env.DISCORD_BOT_USERNAME) {
    config.notifications.discord.username = process.env.DISCORD_BOT_USERNAME;
  }
  if (process.env.DISCORD_BOT_AVATAR_URL) {
    config.notifications.discord.avatarUrl = process.env.DISCORD_BOT_AVATAR_URL;
  }
  if (process.env.AI_ENG_SILENT) {
    config.ui.silent = process.env.AI_ENG_SILENT === "1" || process.env.AI_ENG_SILENT === "true";
  }
  if (process.env.AI_ENG_CYCLE_RETRIES) {
    const retries = Number.parseInt(process.env.AI_ENG_CYCLE_RETRIES, 10);
    if (!Number.isNaN(retries)) {
      config.loop.cycleRetries = retries;
    }
  }
  if (process.env.AI_ENG_DEBUG_WORK) {
    config.debug.work = process.env.AI_ENG_DEBUG_WORK === "1" || process.env.AI_ENG_DEBUG_WORK === "true";
  }
  if (process.env.AI_ENG_TEST_CMD) {
    config.gates.test.command = process.env.AI_ENG_TEST_CMD;
  }
  if (process.env.AI_ENG_LINT_CMD) {
    config.gates.lint.command = process.env.AI_ENG_LINT_CMD;
  }
  if (process.env.AI_ENG_ACCEPTANCE_CMD) {
    config.gates.acceptance.command = process.env.AI_ENG_ACCEPTANCE_CMD;
  }
  if (process.env.AI_ENG_TYPECHECK_CMD) {
    config.gates.typecheck.command = process.env.AI_ENG_TYPECHECK_CMD;
  }
  if (process.env.AI_ENG_BUILD_CMD) {
    config.gates.build.command = process.env.AI_ENG_BUILD_CMD;
  }
}
function mergeGateConfig(existing, incoming) {
  if (typeof incoming === "string") {
    return { command: incoming };
  }
  return {
    command: incoming.command ?? existing.command
  };
}
async function loadConfig(flags) {
  const config = {
    version: DEFAULT_CONFIG.version,
    runner: { ...DEFAULT_CONFIG.runner },
    loop: { ...DEFAULT_CONFIG.loop },
    debug: { ...DEFAULT_CONFIG.debug },
    opencode: { ...DEFAULT_CONFIG.opencode },
    anthropic: { ...DEFAULT_CONFIG.anthropic },
    gates: {
      lint: { ...DEFAULT_CONFIG.gates.lint },
      typecheck: { ...DEFAULT_CONFIG.gates.typecheck },
      test: { ...DEFAULT_CONFIG.gates.test },
      build: { ...DEFAULT_CONFIG.gates.build },
      acceptance: { ...DEFAULT_CONFIG.gates.acceptance }
    },
    models: { ...DEFAULT_CONFIG.models },
    notifications: {
      discord: { ...DEFAULT_CONFIG.notifications.discord }
    },
    ui: { ...DEFAULT_CONFIG.ui }
  };
  const configPath = join(ROOT, ".ai-eng", "config.yaml");
  try {
    const configContent = await readFile(configPath, "utf-8");
    const userConfig = import_yaml.default.parse(configContent);
    if (userConfig.version) {
      config.version = userConfig.version;
    }
    if (userConfig.runner) {
      config.runner = { ...config.runner, ...userConfig.runner };
    }
    if (userConfig.loop) {
      config.loop = { ...config.loop, ...userConfig.loop };
    }
    if (userConfig.debug) {
      config.debug = { ...config.debug, ...userConfig.debug };
    }
    if (userConfig.opencode) {
      config.opencode = { ...config.opencode, ...userConfig.opencode };
    }
    if (userConfig.anthropic) {
      config.anthropic = { ...config.anthropic, ...userConfig.anthropic };
    }
    if (userConfig.gates) {
      if (userConfig.gates.lint) {
        config.gates.lint = mergeGateConfig(config.gates.lint, userConfig.gates.lint);
      }
      if (userConfig.gates.typecheck) {
        config.gates.typecheck = mergeGateConfig(config.gates.typecheck, userConfig.gates.typecheck);
      }
      if (userConfig.gates.test) {
        config.gates.test = mergeGateConfig(config.gates.test, userConfig.gates.test);
      }
      if (userConfig.gates.build) {
        config.gates.build = mergeGateConfig(config.gates.build, userConfig.gates.build);
      }
      if (userConfig.gates.acceptance) {
        config.gates.acceptance = mergeGateConfig(config.gates.acceptance, userConfig.gates.acceptance);
      }
    }
    if (userConfig.models) {
      config.models = { ...config.models, ...userConfig.models };
    }
    if (userConfig.notifications) {
      if (userConfig.notifications.discord) {
        config.notifications.discord = {
          ...config.notifications.discord,
          ...userConfig.notifications.discord
        };
      }
    }
    if (userConfig.ui) {
      config.ui = { ...config.ui, ...userConfig.ui };
    }
  } catch (error) {
    if (!(error instanceof Error && error.message.includes("ENOENT"))) {
      console.warn(`Warning: Failed to load config from ${configPath}, using defaults`);
    }
  }
  applyEnvOverrides(config);
  if (flags.maxIters !== undefined) {
    config.runner.maxIters = flags.maxIters;
  }
  if (flags.review !== undefined) {
    config.runner.review = flags.review;
  }
  if (flags.maxCycles !== undefined) {
    config.loop.maxCycles = flags.maxCycles;
  }
  if (flags.stuckThreshold !== undefined) {
    config.loop.stuckThreshold = flags.stuckThreshold;
  }
  if (flags.checkpointFrequency !== undefined) {
    config.loop.checkpointFrequency = flags.checkpointFrequency;
  }
  if (flags.printLogs !== undefined) {
    config.runner.printLogs = flags.printLogs;
  }
  if (flags.logLevel !== undefined) {
    config.runner.logLevel = flags.logLevel;
  }
  if (flags.verbose) {
    config.runner.logLevel = "DEBUG";
  }
  if (flags.workingDir !== undefined) {
    config.opencode.directory = flags.workingDir;
  }
  if (flags.dryRun !== undefined) {}
  return config;
}

// src/util/log.ts
import fs from "node:fs/promises";
import path from "node:path";
var Log;
((Log) => {
  const levelPriority = {
    DEBUG: 0,
    INFO: 1,
    WARN: 2,
    ERROR: 3
  };
  let currentLevel = "INFO";
  let logPath = "";
  let write = (msg) => process.stderr.write(msg);
  function shouldLog(level) {
    return levelPriority[level] >= levelPriority[currentLevel];
  }
  function file() {
    return logPath;
  }
  Log.file = file;
  async function init(options) {
    if (options.level)
      currentLevel = options.level;
    const stderrWriter = (msg) => {
      process.stderr.write(msg);
    };
    if (options.logDir) {
      const timestamp = new Date().toISOString().replace(/[:.]/g, "-").slice(0, -1);
      logPath = path.join(options.logDir, `ralph-${timestamp}.log`);
      await fs.mkdir(options.logDir, { recursive: true });
      const file2 = Bun.file(logPath);
      const fileWriter = file2.writer();
      write = (msg) => {
        if (options.print) {
          stderrWriter(msg);
        }
        fileWriter.write(msg);
        fileWriter.flush();
      };
    } else if (options.print) {
      write = stderrWriter;
    }
  }
  Log.init = init;
  function formatExtra(extra) {
    if (!extra)
      return "";
    const extraStr = Object.entries(extra).map(([k, v]) => `${k}=${typeof v === "object" ? JSON.stringify(v) : v}`).join(" ");
    return extraStr ? ` ${extraStr}` : "";
  }
  function create(tags) {
    const tagStr = tags ? Object.entries(tags).map(([k, v]) => `${k}=${v}`).join(" ") : "";
    const tagStrWithSpace = tagStr ? `${tagStr} ` : "";
    return {
      debug(message, extra) {
        if (shouldLog("DEBUG")) {
          write(`DEBUG ${new Date().toISOString()} ${tagStr}${message}${formatExtra(extra)}
`);
        }
      },
      info(message, extra) {
        if (shouldLog("INFO")) {
          write(`INFO  ${new Date().toISOString()} ${tagStr}${message}${formatExtra(extra)}
`);
        }
      },
      warn(message, extra) {
        if (shouldLog("WARN")) {
          write(`WARN  ${new Date().toISOString()} ${tagStr}${message}${formatExtra(extra)}
`);
        }
      },
      error(message, extra) {
        if (shouldLog("ERROR")) {
          write(`ERROR ${new Date().toISOString()} ${tagStr}${message}${formatExtra(extra)}
`);
        }
      }
    };
  }
  Log.create = create;
  Log.Default = create({ service: "ralph" });
})(Log ||= {});

// node_modules/@clack/core/dist/index.mjs
var import_sisteransi = __toESM(require_src(), 1);
import { stdin as j, stdout as M } from "node:process";
import * as g from "node:readline";
import O from "node:readline";
import { Writable as X } from "node:stream";
function DD({ onlyFirst: e = false } = {}) {
  const t = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?(?:\\u0007|\\u001B\\u005C|\\u009C))", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"].join("|");
  return new RegExp(t, e ? undefined : "g");
}
var uD = DD();
function P(e) {
  if (typeof e != "string")
    throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``);
  return e.replace(uD, "");
}
function L(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var W = { exports: {} };
(function(e) {
  var u = {};
  e.exports = u, u.eastAsianWidth = function(F) {
    var s = F.charCodeAt(0), i = F.length == 2 ? F.charCodeAt(1) : 0, D = s;
    return 55296 <= s && s <= 56319 && 56320 <= i && i <= 57343 && (s &= 1023, i &= 1023, D = s << 10 | i, D += 65536), D == 12288 || 65281 <= D && D <= 65376 || 65504 <= D && D <= 65510 ? "F" : D == 8361 || 65377 <= D && D <= 65470 || 65474 <= D && D <= 65479 || 65482 <= D && D <= 65487 || 65490 <= D && D <= 65495 || 65498 <= D && D <= 65500 || 65512 <= D && D <= 65518 ? "H" : 4352 <= D && D <= 4447 || 4515 <= D && D <= 4519 || 4602 <= D && D <= 4607 || 9001 <= D && D <= 9002 || 11904 <= D && D <= 11929 || 11931 <= D && D <= 12019 || 12032 <= D && D <= 12245 || 12272 <= D && D <= 12283 || 12289 <= D && D <= 12350 || 12353 <= D && D <= 12438 || 12441 <= D && D <= 12543 || 12549 <= D && D <= 12589 || 12593 <= D && D <= 12686 || 12688 <= D && D <= 12730 || 12736 <= D && D <= 12771 || 12784 <= D && D <= 12830 || 12832 <= D && D <= 12871 || 12880 <= D && D <= 13054 || 13056 <= D && D <= 19903 || 19968 <= D && D <= 42124 || 42128 <= D && D <= 42182 || 43360 <= D && D <= 43388 || 44032 <= D && D <= 55203 || 55216 <= D && D <= 55238 || 55243 <= D && D <= 55291 || 63744 <= D && D <= 64255 || 65040 <= D && D <= 65049 || 65072 <= D && D <= 65106 || 65108 <= D && D <= 65126 || 65128 <= D && D <= 65131 || 110592 <= D && D <= 110593 || 127488 <= D && D <= 127490 || 127504 <= D && D <= 127546 || 127552 <= D && D <= 127560 || 127568 <= D && D <= 127569 || 131072 <= D && D <= 194367 || 177984 <= D && D <= 196605 || 196608 <= D && D <= 262141 ? "W" : 32 <= D && D <= 126 || 162 <= D && D <= 163 || 165 <= D && D <= 166 || D == 172 || D == 175 || 10214 <= D && D <= 10221 || 10629 <= D && D <= 10630 ? "Na" : D == 161 || D == 164 || 167 <= D && D <= 168 || D == 170 || 173 <= D && D <= 174 || 176 <= D && D <= 180 || 182 <= D && D <= 186 || 188 <= D && D <= 191 || D == 198 || D == 208 || 215 <= D && D <= 216 || 222 <= D && D <= 225 || D == 230 || 232 <= D && D <= 234 || 236 <= D && D <= 237 || D == 240 || 242 <= D && D <= 243 || 247 <= D && D <= 250 || D == 252 || D == 254 || D == 257 || D == 273 || D == 275 || D == 283 || 294 <= D && D <= 295 || D == 299 || 305 <= D && D <= 307 || D == 312 || 319 <= D && D <= 322 || D == 324 || 328 <= D && D <= 331 || D == 333 || 338 <= D && D <= 339 || 358 <= D && D <= 359 || D == 363 || D == 462 || D == 464 || D == 466 || D == 468 || D == 470 || D == 472 || D == 474 || D == 476 || D == 593 || D == 609 || D == 708 || D == 711 || 713 <= D && D <= 715 || D == 717 || D == 720 || 728 <= D && D <= 731 || D == 733 || D == 735 || 768 <= D && D <= 879 || 913 <= D && D <= 929 || 931 <= D && D <= 937 || 945 <= D && D <= 961 || 963 <= D && D <= 969 || D == 1025 || 1040 <= D && D <= 1103 || D == 1105 || D == 8208 || 8211 <= D && D <= 8214 || 8216 <= D && D <= 8217 || 8220 <= D && D <= 8221 || 8224 <= D && D <= 8226 || 8228 <= D && D <= 8231 || D == 8240 || 8242 <= D && D <= 8243 || D == 8245 || D == 8251 || D == 8254 || D == 8308 || D == 8319 || 8321 <= D && D <= 8324 || D == 8364 || D == 8451 || D == 8453 || D == 8457 || D == 8467 || D == 8470 || 8481 <= D && D <= 8482 || D == 8486 || D == 8491 || 8531 <= D && D <= 8532 || 8539 <= D && D <= 8542 || 8544 <= D && D <= 8555 || 8560 <= D && D <= 8569 || D == 8585 || 8592 <= D && D <= 8601 || 8632 <= D && D <= 8633 || D == 8658 || D == 8660 || D == 8679 || D == 8704 || 8706 <= D && D <= 8707 || 8711 <= D && D <= 8712 || D == 8715 || D == 8719 || D == 8721 || D == 8725 || D == 8730 || 8733 <= D && D <= 8736 || D == 8739 || D == 8741 || 8743 <= D && D <= 8748 || D == 8750 || 8756 <= D && D <= 8759 || 8764 <= D && D <= 8765 || D == 8776 || D == 8780 || D == 8786 || 8800 <= D && D <= 8801 || 8804 <= D && D <= 8807 || 8810 <= D && D <= 8811 || 8814 <= D && D <= 8815 || 8834 <= D && D <= 8835 || 8838 <= D && D <= 8839 || D == 8853 || D == 8857 || D == 8869 || D == 8895 || D == 8978 || 9312 <= D && D <= 9449 || 9451 <= D && D <= 9547 || 9552 <= D && D <= 9587 || 9600 <= D && D <= 9615 || 9618 <= D && D <= 9621 || 9632 <= D && D <= 9633 || 9635 <= D && D <= 9641 || 9650 <= D && D <= 9651 || 9654 <= D && D <= 9655 || 9660 <= D && D <= 9661 || 9664 <= D && D <= 9665 || 9670 <= D && D <= 9672 || D == 9675 || 9678 <= D && D <= 9681 || 9698 <= D && D <= 9701 || D == 9711 || 9733 <= D && D <= 9734 || D == 9737 || 9742 <= D && D <= 9743 || 9748 <= D && D <= 9749 || D == 9756 || D == 9758 || D == 9792 || D == 9794 || 9824 <= D && D <= 9825 || 9827 <= D && D <= 9829 || 9831 <= D && D <= 9834 || 9836 <= D && D <= 9837 || D == 9839 || 9886 <= D && D <= 9887 || 9918 <= D && D <= 9919 || 9924 <= D && D <= 9933 || 9935 <= D && D <= 9953 || D == 9955 || 9960 <= D && D <= 9983 || D == 10045 || D == 10071 || 10102 <= D && D <= 10111 || 11093 <= D && D <= 11097 || 12872 <= D && D <= 12879 || 57344 <= D && D <= 63743 || 65024 <= D && D <= 65039 || D == 65533 || 127232 <= D && D <= 127242 || 127248 <= D && D <= 127277 || 127280 <= D && D <= 127337 || 127344 <= D && D <= 127386 || 917760 <= D && D <= 917999 || 983040 <= D && D <= 1048573 || 1048576 <= D && D <= 1114109 ? "A" : "N";
  }, u.characterLength = function(F) {
    var s = this.eastAsianWidth(F);
    return s == "F" || s == "W" || s == "A" ? 2 : 1;
  };
  function t(F) {
    return F.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]|[^\uD800-\uDFFF]/g) || [];
  }
  u.length = function(F) {
    for (var s = t(F), i = 0, D = 0;D < s.length; D++)
      i = i + this.characterLength(s[D]);
    return i;
  }, u.slice = function(F, s, i) {
    textLen = u.length(F), s = s || 0, i = i || 1, s < 0 && (s = textLen + s), i < 0 && (i = textLen + i);
    for (var D = "", C = 0, n = t(F), E = 0;E < n.length; E++) {
      var a = n[E], o = u.length(a);
      if (C >= s - (o == 2 ? 1 : 0))
        if (C + o <= i)
          D += a;
        else
          break;
      C += o;
    }
    return D;
  };
})(W);
var tD = W.exports;
var eD = L(tD);
var FD = function() {
  return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
};
var sD = L(FD);
function p(e, u = {}) {
  if (typeof e != "string" || e.length === 0 || (u = { ambiguousIsNarrow: true, ...u }, e = P(e), e.length === 0))
    return 0;
  e = e.replace(sD(), "  ");
  const t = u.ambiguousIsNarrow ? 1 : 2;
  let F = 0;
  for (const s of e) {
    const i = s.codePointAt(0);
    if (i <= 31 || i >= 127 && i <= 159 || i >= 768 && i <= 879)
      continue;
    switch (eD.eastAsianWidth(s)) {
      case "F":
      case "W":
        F += 2;
        break;
      case "A":
        F += t;
        break;
      default:
        F += 1;
    }
  }
  return F;
}
var w = 10;
var N = (e = 0) => (u) => `\x1B[${u + e}m`;
var I = (e = 0) => (u) => `\x1B[${38 + e};5;${u}m`;
var R = (e = 0) => (u, t, F) => `\x1B[${38 + e};2;${u};${t};${F}m`;
var r = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], overline: [53, 55], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], blackBright: [90, 39], gray: [90, 39], grey: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgGray: [100, 49], bgGrey: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } };
Object.keys(r.modifier);
var iD = Object.keys(r.color);
var CD = Object.keys(r.bgColor);
[...iD, ...CD];
function rD() {
  const e = new Map;
  for (const [u, t] of Object.entries(r)) {
    for (const [F, s] of Object.entries(t))
      r[F] = { open: `\x1B[${s[0]}m`, close: `\x1B[${s[1]}m` }, t[F] = r[F], e.set(s[0], s[1]);
    Object.defineProperty(r, u, { value: t, enumerable: false });
  }
  return Object.defineProperty(r, "codes", { value: e, enumerable: false }), r.color.close = "\x1B[39m", r.bgColor.close = "\x1B[49m", r.color.ansi = N(), r.color.ansi256 = I(), r.color.ansi16m = R(), r.bgColor.ansi = N(w), r.bgColor.ansi256 = I(w), r.bgColor.ansi16m = R(w), Object.defineProperties(r, { rgbToAnsi256: { value: (u, t, F) => u === t && t === F ? u < 8 ? 16 : u > 248 ? 231 : Math.round((u - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(u / 255 * 5) + 6 * Math.round(t / 255 * 5) + Math.round(F / 255 * 5), enumerable: false }, hexToRgb: { value: (u) => {
    const t = /[a-f\d]{6}|[a-f\d]{3}/i.exec(u.toString(16));
    if (!t)
      return [0, 0, 0];
    let [F] = t;
    F.length === 3 && (F = [...F].map((i) => i + i).join(""));
    const s = Number.parseInt(F, 16);
    return [s >> 16 & 255, s >> 8 & 255, s & 255];
  }, enumerable: false }, hexToAnsi256: { value: (u) => r.rgbToAnsi256(...r.hexToRgb(u)), enumerable: false }, ansi256ToAnsi: { value: (u) => {
    if (u < 8)
      return 30 + u;
    if (u < 16)
      return 90 + (u - 8);
    let t, F, s;
    if (u >= 232)
      t = ((u - 232) * 10 + 8) / 255, F = t, s = t;
    else {
      u -= 16;
      const C = u % 36;
      t = Math.floor(u / 36) / 5, F = Math.floor(C / 6) / 5, s = C % 6 / 5;
    }
    const i = Math.max(t, F, s) * 2;
    if (i === 0)
      return 30;
    let D = 30 + (Math.round(s) << 2 | Math.round(F) << 1 | Math.round(t));
    return i === 2 && (D += 60), D;
  }, enumerable: false }, rgbToAnsi: { value: (u, t, F) => r.ansi256ToAnsi(r.rgbToAnsi256(u, t, F)), enumerable: false }, hexToAnsi: { value: (u) => r.ansi256ToAnsi(r.hexToAnsi256(u)), enumerable: false } }), r;
}
var ED = rD();
var d = new Set(["\x1B", ""]);
var oD = 39;
var y = "\x07";
var V = "[";
var nD = "]";
var G = "m";
var _ = `${nD}8;;`;
var z = (e) => `${d.values().next().value}${V}${e}${G}`;
var K = (e) => `${d.values().next().value}${_}${e}${y}`;
var aD = (e) => e.split(" ").map((u) => p(u));
var k = (e, u, t) => {
  const F = [...u];
  let s = false, i = false, D = p(P(e[e.length - 1]));
  for (const [C, n] of F.entries()) {
    const E = p(n);
    if (D + E <= t ? e[e.length - 1] += n : (e.push(n), D = 0), d.has(n) && (s = true, i = F.slice(C + 1).join("").startsWith(_)), s) {
      i ? n === y && (s = false, i = false) : n === G && (s = false);
      continue;
    }
    D += E, D === t && C < F.length - 1 && (e.push(""), D = 0);
  }
  !D && e[e.length - 1].length > 0 && e.length > 1 && (e[e.length - 2] += e.pop());
};
var hD = (e) => {
  const u = e.split(" ");
  let t = u.length;
  for (;t > 0 && !(p(u[t - 1]) > 0); )
    t--;
  return t === u.length ? e : u.slice(0, t).join(" ") + u.slice(t).join("");
};
var lD = (e, u, t = {}) => {
  if (t.trim !== false && e.trim() === "")
    return "";
  let F = "", s, i;
  const D = aD(e);
  let C = [""];
  for (const [E, a] of e.split(" ").entries()) {
    t.trim !== false && (C[C.length - 1] = C[C.length - 1].trimStart());
    let o = p(C[C.length - 1]);
    if (E !== 0 && (o >= u && (t.wordWrap === false || t.trim === false) && (C.push(""), o = 0), (o > 0 || t.trim === false) && (C[C.length - 1] += " ", o++)), t.hard && D[E] > u) {
      const c = u - o, f = 1 + Math.floor((D[E] - c - 1) / u);
      Math.floor((D[E] - 1) / u) < f && C.push(""), k(C, a, u);
      continue;
    }
    if (o + D[E] > u && o > 0 && D[E] > 0) {
      if (t.wordWrap === false && o < u) {
        k(C, a, u);
        continue;
      }
      C.push("");
    }
    if (o + D[E] > u && t.wordWrap === false) {
      k(C, a, u);
      continue;
    }
    C[C.length - 1] += a;
  }
  t.trim !== false && (C = C.map((E) => hD(E)));
  const n = [...C.join(`
`)];
  for (const [E, a] of n.entries()) {
    if (F += a, d.has(a)) {
      const { groups: c } = new RegExp(`(?:\\${V}(?<code>\\d+)m|\\${_}(?<uri>.*)${y})`).exec(n.slice(E).join("")) || { groups: {} };
      if (c.code !== undefined) {
        const f = Number.parseFloat(c.code);
        s = f === oD ? undefined : f;
      } else
        c.uri !== undefined && (i = c.uri.length === 0 ? undefined : c.uri);
    }
    const o = ED.codes.get(Number(s));
    n[E + 1] === `
` ? (i && (F += K("")), s && o && (F += z(o))) : a === `
` && (s && o && (F += z(s)), i && (F += K(i)));
  }
  return F;
};
function Y(e, u, t) {
  return String(e).normalize().replace(/\r\n/g, `
`).split(`
`).map((F) => lD(F, u, t)).join(`
`);
}
var xD = ["up", "down", "left", "right", "space", "enter", "cancel"];
var B = { actions: new Set(xD), aliases: new Map([["k", "up"], ["j", "down"], ["h", "left"], ["l", "right"], ["\x03", "cancel"], ["escape", "cancel"]]) };
function $(e, u) {
  if (typeof e == "string")
    return B.aliases.get(e) === u;
  for (const t of e)
    if (t !== undefined && $(t, u))
      return true;
  return false;
}
function BD(e, u) {
  if (e === u)
    return;
  const t = e.split(`
`), F = u.split(`
`), s = [];
  for (let i = 0;i < Math.max(t.length, F.length); i++)
    t[i] !== F[i] && s.push(i);
  return s;
}
var AD = globalThis.process.platform.startsWith("win");
var S = Symbol("clack:cancel");
function pD(e) {
  return e === S;
}
function m(e, u) {
  const t = e;
  t.isTTY && t.setRawMode(u);
}
function fD({ input: e = j, output: u = M, overwrite: t = true, hideCursor: F = true } = {}) {
  const s = g.createInterface({ input: e, output: u, prompt: "", tabSize: 1 });
  g.emitKeypressEvents(e, s), e.isTTY && e.setRawMode(true);
  const i = (D, { name: C, sequence: n }) => {
    const E = String(D);
    if ($([E, C, n], "cancel")) {
      F && u.write(import_sisteransi.cursor.show), process.exit(0);
      return;
    }
    if (!t)
      return;
    const a = C === "return" ? 0 : -1, o = C === "return" ? -1 : 0;
    g.moveCursor(u, a, o, () => {
      g.clearLine(u, 1, () => {
        e.once("keypress", i);
      });
    });
  };
  return F && u.write(import_sisteransi.cursor.hide), e.once("keypress", i), () => {
    e.off("keypress", i), F && u.write(import_sisteransi.cursor.show), e.isTTY && !AD && e.setRawMode(false), s.terminal = false, s.close();
  };
}
var gD = Object.defineProperty;
var vD = (e, u, t) => (u in e) ? gD(e, u, { enumerable: true, configurable: true, writable: true, value: t }) : e[u] = t;
var h = (e, u, t) => (vD(e, typeof u != "symbol" ? u + "" : u, t), t);

class x {
  constructor(u, t = true) {
    h(this, "input"), h(this, "output"), h(this, "_abortSignal"), h(this, "rl"), h(this, "opts"), h(this, "_render"), h(this, "_track", false), h(this, "_prevFrame", ""), h(this, "_subscribers", new Map), h(this, "_cursor", 0), h(this, "state", "initial"), h(this, "error", ""), h(this, "value");
    const { input: F = j, output: s = M, render: i, signal: D, ...C } = u;
    this.opts = C, this.onKeypress = this.onKeypress.bind(this), this.close = this.close.bind(this), this.render = this.render.bind(this), this._render = i.bind(this), this._track = t, this._abortSignal = D, this.input = F, this.output = s;
  }
  unsubscribe() {
    this._subscribers.clear();
  }
  setSubscriber(u, t) {
    const F = this._subscribers.get(u) ?? [];
    F.push(t), this._subscribers.set(u, F);
  }
  on(u, t) {
    this.setSubscriber(u, { cb: t });
  }
  once(u, t) {
    this.setSubscriber(u, { cb: t, once: true });
  }
  emit(u, ...t) {
    const F = this._subscribers.get(u) ?? [], s = [];
    for (const i of F)
      i.cb(...t), i.once && s.push(() => F.splice(F.indexOf(i), 1));
    for (const i of s)
      i();
  }
  prompt() {
    return new Promise((u, t) => {
      if (this._abortSignal) {
        if (this._abortSignal.aborted)
          return this.state = "cancel", this.close(), u(S);
        this._abortSignal.addEventListener("abort", () => {
          this.state = "cancel", this.close();
        }, { once: true });
      }
      const F = new X;
      F._write = (s, i, D) => {
        this._track && (this.value = this.rl?.line.replace(/\t/g, ""), this._cursor = this.rl?.cursor ?? 0, this.emit("value", this.value)), D();
      }, this.input.pipe(F), this.rl = O.createInterface({ input: this.input, output: F, tabSize: 2, prompt: "", escapeCodeTimeout: 50, terminal: true }), O.emitKeypressEvents(this.input, this.rl), this.rl.prompt(), this.opts.initialValue !== undefined && this._track && this.rl.write(this.opts.initialValue), this.input.on("keypress", this.onKeypress), m(this.input, true), this.output.on("resize", this.render), this.render(), this.once("submit", () => {
        this.output.write(import_sisteransi.cursor.show), this.output.off("resize", this.render), m(this.input, false), u(this.value);
      }), this.once("cancel", () => {
        this.output.write(import_sisteransi.cursor.show), this.output.off("resize", this.render), m(this.input, false), u(S);
      });
    });
  }
  onKeypress(u, t) {
    if (this.state === "error" && (this.state = "active"), t?.name && (!this._track && B.aliases.has(t.name) && this.emit("cursor", B.aliases.get(t.name)), B.actions.has(t.name) && this.emit("cursor", t.name)), u && (u.toLowerCase() === "y" || u.toLowerCase() === "n") && this.emit("confirm", u.toLowerCase() === "y"), u === "\t" && this.opts.placeholder && (this.value || (this.rl?.write(this.opts.placeholder), this.emit("value", this.opts.placeholder))), u && this.emit("key", u.toLowerCase()), t?.name === "return") {
      if (this.opts.validate) {
        const F = this.opts.validate(this.value);
        F && (this.error = F instanceof Error ? F.message : F, this.state = "error", this.rl?.write(this.value));
      }
      this.state !== "error" && (this.state = "submit");
    }
    $([u, t?.name, t?.sequence], "cancel") && (this.state = "cancel"), (this.state === "submit" || this.state === "cancel") && this.emit("finalize"), this.render(), (this.state === "submit" || this.state === "cancel") && this.close();
  }
  close() {
    this.input.unpipe(), this.input.removeListener("keypress", this.onKeypress), this.output.write(`
`), m(this.input, false), this.rl?.close(), this.rl = undefined, this.emit(`${this.state}`, this.value), this.unsubscribe();
  }
  restoreCursor() {
    const u = Y(this._prevFrame, process.stdout.columns, { hard: true }).split(`
`).length - 1;
    this.output.write(import_sisteransi.cursor.move(-999, u * -1));
  }
  render() {
    const u = Y(this._render(this) ?? "", process.stdout.columns, { hard: true });
    if (u !== this._prevFrame) {
      if (this.state === "initial")
        this.output.write(import_sisteransi.cursor.hide);
      else {
        const t = BD(this._prevFrame, u);
        if (this.restoreCursor(), t && t?.length === 1) {
          const F = t[0];
          this.output.write(import_sisteransi.cursor.move(0, F)), this.output.write(import_sisteransi.erase.lines(1));
          const s = u.split(`
`);
          this.output.write(s[F]), this._prevFrame = u, this.output.write(import_sisteransi.cursor.move(0, s.length - F - 1));
          return;
        }
        if (t && t?.length > 1) {
          const F = t[0];
          this.output.write(import_sisteransi.cursor.move(0, F)), this.output.write(import_sisteransi.erase.down());
          const s = u.split(`
`).slice(F);
          this.output.write(s.join(`
`)), this._prevFrame = u;
          return;
        }
        this.output.write(import_sisteransi.erase.down());
      }
      this.output.write(u), this.state === "initial" && (this.state = "active"), this._prevFrame = u;
    }
  }
}
var A;
A = new WeakMap;
var OD = Object.defineProperty;
var PD = (e, u, t) => (u in e) ? OD(e, u, { enumerable: true, configurable: true, writable: true, value: t }) : e[u] = t;
var J = (e, u, t) => (PD(e, typeof u != "symbol" ? u + "" : u, t), t);

class LD extends x {
  constructor(u) {
    super(u, false), J(this, "options"), J(this, "cursor", 0), this.options = u.options, this.cursor = this.options.findIndex(({ value: t }) => t === u.initialValue), this.cursor === -1 && (this.cursor = 0), this.changeValue(), this.on("cursor", (t) => {
      switch (t) {
        case "left":
        case "up":
          this.cursor = this.cursor === 0 ? this.options.length - 1 : this.cursor - 1;
          break;
        case "down":
        case "right":
          this.cursor = this.cursor === this.options.length - 1 ? 0 : this.cursor + 1;
          break;
      }
      this.changeValue();
    });
  }
  get _value() {
    return this.options[this.cursor];
  }
  changeValue() {
    this.value = this._value.value;
  }
}

// node_modules/@clack/prompts/dist/index.mjs
var import_picocolors = __toESM(require_picocolors(), 1);
var import_sisteransi2 = __toESM(require_src(), 1);
import y2 from "node:process";
function ce() {
  return y2.platform !== "win32" ? y2.env.TERM !== "linux" : !!y2.env.CI || !!y2.env.WT_SESSION || !!y2.env.TERMINUS_SUBLIME || y2.env.ConEmuTask === "{cmd::Cmder}" || y2.env.TERM_PROGRAM === "Terminus-Sublime" || y2.env.TERM_PROGRAM === "vscode" || y2.env.TERM === "xterm-256color" || y2.env.TERM === "alacritty" || y2.env.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}
var V2 = ce();
var u = (t, n) => V2 ? t : n;
var le = u("", "*");
var L2 = u("", "x");
var W2 = u("", "x");
var C = u("", "o");
var ue = u("", "T");
var o = u("", "|");
var d2 = u("", "");
var k2 = u("", ">");
var P2 = u("", " ");
var A2 = u("", "[]");
var T = u("", "[+]");
var F = u("", "[ ]");
var $e = u("", "");
var _2 = u("", "-");
var me = u("", "+");
var de = u("", "+");
var pe = u("", "+");
var q = u("", "");
var D = u("", "*");
var U = u("", "!");
var K2 = u("", "x");
var b2 = (t) => {
  switch (t) {
    case "initial":
    case "active":
      return import_picocolors.default.cyan(le);
    case "cancel":
      return import_picocolors.default.red(L2);
    case "error":
      return import_picocolors.default.yellow(W2);
    case "submit":
      return import_picocolors.default.green(C);
  }
};
var G2 = (t) => {
  const { cursor: n, options: r2, style: i } = t, s = t.maxItems ?? Number.POSITIVE_INFINITY, c = Math.max(process.stdout.rows - 4, 0), a = Math.min(c, Math.max(s, 5));
  let l2 = 0;
  n >= l2 + a - 3 ? l2 = Math.max(Math.min(n - a + 3, r2.length - a), 0) : n < l2 + 2 && (l2 = Math.max(n - 2, 0));
  const $2 = a < r2.length && l2 > 0, g2 = a < r2.length && l2 + a < r2.length;
  return r2.slice(l2, l2 + a).map((p2, v, f) => {
    const j2 = v === 0 && $2, E = v === f.length - 1 && g2;
    return j2 || E ? import_picocolors.default.dim("...") : i(p2, v + l2 === n);
  });
};
var ve = (t) => {
  const n = (r2, i) => {
    const s = r2.label ?? String(r2.value);
    switch (i) {
      case "selected":
        return `${import_picocolors.default.dim(s)}`;
      case "active":
        return `${import_picocolors.default.green(k2)} ${s} ${r2.hint ? import_picocolors.default.dim(`(${r2.hint})`) : ""}`;
      case "cancelled":
        return `${import_picocolors.default.strikethrough(import_picocolors.default.dim(s))}`;
      default:
        return `${import_picocolors.default.dim(P2)} ${import_picocolors.default.dim(s)}`;
    }
  };
  return new LD({ options: t.options, initialValue: t.initialValue, render() {
    const r2 = `${import_picocolors.default.gray(o)}
${b2(this.state)}  ${t.message}
`;
    switch (this.state) {
      case "submit":
        return `${r2}${import_picocolors.default.gray(o)}  ${n(this.options[this.cursor], "selected")}`;
      case "cancel":
        return `${r2}${import_picocolors.default.gray(o)}  ${n(this.options[this.cursor], "cancelled")}
${import_picocolors.default.gray(o)}`;
      default:
        return `${r2}${import_picocolors.default.cyan(o)}  ${G2({ cursor: this.cursor, options: this.options, maxItems: t.maxItems, style: (i, s) => n(i, s ? "active" : "inactive") }).join(`
${import_picocolors.default.cyan(o)}  `)}
${import_picocolors.default.cyan(d2)}
`;
    }
  } }).prompt();
};
var Se = (t = "") => {
  process.stdout.write(`${import_picocolors.default.gray(o)}
${import_picocolors.default.gray(d2)}  ${t}

`);
};
var J2 = `${import_picocolors.default.gray(o)}  `;
var Y2 = ({ indicator: t = "dots" } = {}) => {
  const n = V2 ? ["", "", "", ""] : ["", "o", "O", "0"], r2 = V2 ? 80 : 120, i = process.env.CI === "true";
  let s, c, a = false, l2 = "", $2, g2 = performance.now();
  const p2 = (m2) => {
    const h2 = m2 > 1 ? "Something went wrong" : "Canceled";
    a && N2(h2, m2);
  }, v = () => p2(2), f = () => p2(1), j2 = () => {
    process.on("uncaughtExceptionMonitor", v), process.on("unhandledRejection", v), process.on("SIGINT", f), process.on("SIGTERM", f), process.on("exit", p2);
  }, E = () => {
    process.removeListener("uncaughtExceptionMonitor", v), process.removeListener("unhandledRejection", v), process.removeListener("SIGINT", f), process.removeListener("SIGTERM", f), process.removeListener("exit", p2);
  }, B2 = () => {
    if ($2 === undefined)
      return;
    i && process.stdout.write(`
`);
    const m2 = $2.split(`
`);
    process.stdout.write(import_sisteransi2.cursor.move(-999, m2.length - 1)), process.stdout.write(import_sisteransi2.erase.down(m2.length));
  }, R2 = (m2) => m2.replace(/\.+$/, ""), O2 = (m2) => {
    const h2 = (performance.now() - m2) / 1000, w2 = Math.floor(h2 / 60), I2 = Math.floor(h2 % 60);
    return w2 > 0 ? `[${w2}m ${I2}s]` : `[${I2}s]`;
  }, H = (m2 = "") => {
    a = true, s = fD(), l2 = R2(m2), g2 = performance.now(), process.stdout.write(`${import_picocolors.default.gray(o)}
`);
    let h2 = 0, w2 = 0;
    j2(), c = setInterval(() => {
      if (i && l2 === $2)
        return;
      B2(), $2 = l2;
      const I2 = import_picocolors.default.magenta(n[h2]);
      if (i)
        process.stdout.write(`${I2}  ${l2}...`);
      else if (t === "timer")
        process.stdout.write(`${I2}  ${l2} ${O2(g2)}`);
      else {
        const z2 = ".".repeat(Math.floor(w2)).slice(0, 3);
        process.stdout.write(`${I2}  ${l2}${z2}`);
      }
      h2 = h2 + 1 < n.length ? h2 + 1 : 0, w2 = w2 < n.length ? w2 + 0.125 : 0;
    }, r2);
  }, N2 = (m2 = "", h2 = 0) => {
    a = false, clearInterval(c), B2();
    const w2 = h2 === 0 ? import_picocolors.default.green(C) : h2 === 1 ? import_picocolors.default.red(L2) : import_picocolors.default.red(W2);
    l2 = R2(m2 ?? l2), t === "timer" ? process.stdout.write(`${w2}  ${l2} ${O2(g2)}
`) : process.stdout.write(`${w2}  ${l2}
`), E(), s();
  };
  return { start: H, stop: N2, message: (m2 = "") => {
    l2 = R2(m2 ?? l2);
  } };
};

// src/backends/opencode/client.ts
import { createServer } from "node:net";
// node_modules/@opencode-ai/sdk/dist/gen/core/serverSentEvents.gen.js
var createSseClient = ({ onSseError, onSseEvent, responseTransformer, responseValidator, sseDefaultRetryDelay, sseMaxRetryAttempts, sseMaxRetryDelay, sseSleepFn, url, ...options }) => {
  let lastEventId;
  const sleep = sseSleepFn ?? ((ms) => new Promise((resolve) => setTimeout(resolve, ms)));
  const createStream = async function* () {
    let retryDelay = sseDefaultRetryDelay ?? 3000;
    let attempt = 0;
    const signal = options.signal ?? new AbortController().signal;
    while (true) {
      if (signal.aborted)
        break;
      attempt++;
      const headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers);
      if (lastEventId !== undefined) {
        headers.set("Last-Event-ID", lastEventId);
      }
      try {
        const response = await fetch(url, { ...options, headers, signal });
        if (!response.ok)
          throw new Error(`SSE failed: ${response.status} ${response.statusText}`);
        if (!response.body)
          throw new Error("No body in SSE response");
        const reader = response.body.pipeThrough(new TextDecoderStream).getReader();
        let buffer = "";
        const abortHandler = () => {
          try {
            reader.cancel();
          } catch {}
        };
        signal.addEventListener("abort", abortHandler);
        try {
          while (true) {
            const { done, value } = await reader.read();
            if (done)
              break;
            buffer += value;
            const chunks = buffer.split(`

`);
            buffer = chunks.pop() ?? "";
            for (const chunk of chunks) {
              const lines = chunk.split(`
`);
              const dataLines = [];
              let eventName;
              for (const line of lines) {
                if (line.startsWith("data:")) {
                  dataLines.push(line.replace(/^data:\s*/, ""));
                } else if (line.startsWith("event:")) {
                  eventName = line.replace(/^event:\s*/, "");
                } else if (line.startsWith("id:")) {
                  lastEventId = line.replace(/^id:\s*/, "");
                } else if (line.startsWith("retry:")) {
                  const parsed = Number.parseInt(line.replace(/^retry:\s*/, ""), 10);
                  if (!Number.isNaN(parsed)) {
                    retryDelay = parsed;
                  }
                }
              }
              let data;
              let parsedJson = false;
              if (dataLines.length) {
                const rawData = dataLines.join(`
`);
                try {
                  data = JSON.parse(rawData);
                  parsedJson = true;
                } catch {
                  data = rawData;
                }
              }
              if (parsedJson) {
                if (responseValidator) {
                  await responseValidator(data);
                }
                if (responseTransformer) {
                  data = await responseTransformer(data);
                }
              }
              onSseEvent?.({
                data,
                event: eventName,
                id: lastEventId,
                retry: retryDelay
              });
              if (dataLines.length) {
                yield data;
              }
            }
          }
        } finally {
          signal.removeEventListener("abort", abortHandler);
          reader.releaseLock();
        }
        break;
      } catch (error) {
        onSseError?.(error);
        if (sseMaxRetryAttempts !== undefined && attempt >= sseMaxRetryAttempts) {
          break;
        }
        const backoff = Math.min(retryDelay * 2 ** (attempt - 1), sseMaxRetryDelay ?? 30000);
        await sleep(backoff);
      }
    }
  };
  const stream = createStream();
  return { stream };
};

// node_modules/@opencode-ai/sdk/dist/gen/core/auth.gen.js
var getAuthToken = async (auth, callback) => {
  const token = typeof callback === "function" ? await callback(auth) : callback;
  if (!token) {
    return;
  }
  if (auth.scheme === "bearer") {
    return `Bearer ${token}`;
  }
  if (auth.scheme === "basic") {
    return `Basic ${btoa(token)}`;
  }
  return token;
};

// node_modules/@opencode-ai/sdk/dist/gen/core/bodySerializer.gen.js
var jsonBodySerializer = {
  bodySerializer: (body) => JSON.stringify(body, (_key, value) => typeof value === "bigint" ? value.toString() : value)
};

// node_modules/@opencode-ai/sdk/dist/gen/core/pathSerializer.gen.js
var separatorArrayExplode = (style) => {
  switch (style) {
    case "label":
      return ".";
    case "matrix":
      return ";";
    case "simple":
      return ",";
    default:
      return "&";
  }
};
var separatorArrayNoExplode = (style) => {
  switch (style) {
    case "form":
      return ",";
    case "pipeDelimited":
      return "|";
    case "spaceDelimited":
      return "%20";
    default:
      return ",";
  }
};
var separatorObjectExplode = (style) => {
  switch (style) {
    case "label":
      return ".";
    case "matrix":
      return ";";
    case "simple":
      return ",";
    default:
      return "&";
  }
};
var serializeArrayParam = ({ allowReserved, explode, name, style, value }) => {
  if (!explode) {
    const joinedValues2 = (allowReserved ? value : value.map((v) => encodeURIComponent(v))).join(separatorArrayNoExplode(style));
    switch (style) {
      case "label":
        return `.${joinedValues2}`;
      case "matrix":
        return `;${name}=${joinedValues2}`;
      case "simple":
        return joinedValues2;
      default:
        return `${name}=${joinedValues2}`;
    }
  }
  const separator = separatorArrayExplode(style);
  const joinedValues = value.map((v) => {
    if (style === "label" || style === "simple") {
      return allowReserved ? v : encodeURIComponent(v);
    }
    return serializePrimitiveParam({
      allowReserved,
      name,
      value: v
    });
  }).join(separator);
  return style === "label" || style === "matrix" ? separator + joinedValues : joinedValues;
};
var serializePrimitiveParam = ({ allowReserved, name, value }) => {
  if (value === undefined || value === null) {
    return "";
  }
  if (typeof value === "object") {
    throw new Error("Deeply-nested arrays/objects arent supported. Provide your own `querySerializer()` to handle these.");
  }
  return `${name}=${allowReserved ? value : encodeURIComponent(value)}`;
};
var serializeObjectParam = ({ allowReserved, explode, name, style, value, valueOnly }) => {
  if (value instanceof Date) {
    return valueOnly ? value.toISOString() : `${name}=${value.toISOString()}`;
  }
  if (style !== "deepObject" && !explode) {
    let values = [];
    Object.entries(value).forEach(([key, v]) => {
      values = [...values, key, allowReserved ? v : encodeURIComponent(v)];
    });
    const joinedValues2 = values.join(",");
    switch (style) {
      case "form":
        return `${name}=${joinedValues2}`;
      case "label":
        return `.${joinedValues2}`;
      case "matrix":
        return `;${name}=${joinedValues2}`;
      default:
        return joinedValues2;
    }
  }
  const separator = separatorObjectExplode(style);
  const joinedValues = Object.entries(value).map(([key, v]) => serializePrimitiveParam({
    allowReserved,
    name: style === "deepObject" ? `${name}[${key}]` : key,
    value: v
  })).join(separator);
  return style === "label" || style === "matrix" ? separator + joinedValues : joinedValues;
};

// node_modules/@opencode-ai/sdk/dist/gen/core/utils.gen.js
var PATH_PARAM_RE = /\{[^{}]+\}/g;
var defaultPathSerializer = ({ path: path2, url: _url }) => {
  let url = _url;
  const matches = _url.match(PATH_PARAM_RE);
  if (matches) {
    for (const match of matches) {
      let explode = false;
      let name = match.substring(1, match.length - 1);
      let style = "simple";
      if (name.endsWith("*")) {
        explode = true;
        name = name.substring(0, name.length - 1);
      }
      if (name.startsWith(".")) {
        name = name.substring(1);
        style = "label";
      } else if (name.startsWith(";")) {
        name = name.substring(1);
        style = "matrix";
      }
      const value = path2[name];
      if (value === undefined || value === null) {
        continue;
      }
      if (Array.isArray(value)) {
        url = url.replace(match, serializeArrayParam({ explode, name, style, value }));
        continue;
      }
      if (typeof value === "object") {
        url = url.replace(match, serializeObjectParam({
          explode,
          name,
          style,
          value,
          valueOnly: true
        }));
        continue;
      }
      if (style === "matrix") {
        url = url.replace(match, `;${serializePrimitiveParam({
          name,
          value
        })}`);
        continue;
      }
      const replaceValue = encodeURIComponent(style === "label" ? `.${value}` : value);
      url = url.replace(match, replaceValue);
    }
  }
  return url;
};
var getUrl = ({ baseUrl, path: path2, query, querySerializer, url: _url }) => {
  const pathUrl = _url.startsWith("/") ? _url : `/${_url}`;
  let url = (baseUrl ?? "") + pathUrl;
  if (path2) {
    url = defaultPathSerializer({ path: path2, url });
  }
  let search = query ? querySerializer(query) : "";
  if (search.startsWith("?")) {
    search = search.substring(1);
  }
  if (search) {
    url += `?${search}`;
  }
  return url;
};

// node_modules/@opencode-ai/sdk/dist/gen/client/utils.gen.js
var createQuerySerializer = ({ allowReserved, array, object } = {}) => {
  const querySerializer = (queryParams) => {
    const search = [];
    if (queryParams && typeof queryParams === "object") {
      for (const name in queryParams) {
        const value = queryParams[name];
        if (value === undefined || value === null) {
          continue;
        }
        if (Array.isArray(value)) {
          const serializedArray = serializeArrayParam({
            allowReserved,
            explode: true,
            name,
            style: "form",
            value,
            ...array
          });
          if (serializedArray)
            search.push(serializedArray);
        } else if (typeof value === "object") {
          const serializedObject = serializeObjectParam({
            allowReserved,
            explode: true,
            name,
            style: "deepObject",
            value,
            ...object
          });
          if (serializedObject)
            search.push(serializedObject);
        } else {
          const serializedPrimitive = serializePrimitiveParam({
            allowReserved,
            name,
            value
          });
          if (serializedPrimitive)
            search.push(serializedPrimitive);
        }
      }
    }
    return search.join("&");
  };
  return querySerializer;
};
var getParseAs = (contentType) => {
  if (!contentType) {
    return "stream";
  }
  const cleanContent = contentType.split(";")[0]?.trim();
  if (!cleanContent) {
    return;
  }
  if (cleanContent.startsWith("application/json") || cleanContent.endsWith("+json")) {
    return "json";
  }
  if (cleanContent === "multipart/form-data") {
    return "formData";
  }
  if (["application/", "audio/", "image/", "video/"].some((type) => cleanContent.startsWith(type))) {
    return "blob";
  }
  if (cleanContent.startsWith("text/")) {
    return "text";
  }
  return;
};
var checkForExistence = (options, name) => {
  if (!name) {
    return false;
  }
  if (options.headers.has(name) || options.query?.[name] || options.headers.get("Cookie")?.includes(`${name}=`)) {
    return true;
  }
  return false;
};
var setAuthParams = async ({ security, ...options }) => {
  for (const auth of security) {
    if (checkForExistence(options, auth.name)) {
      continue;
    }
    const token = await getAuthToken(auth, options.auth);
    if (!token) {
      continue;
    }
    const name = auth.name ?? "Authorization";
    switch (auth.in) {
      case "query":
        if (!options.query) {
          options.query = {};
        }
        options.query[name] = token;
        break;
      case "cookie":
        options.headers.append("Cookie", `${name}=${token}`);
        break;
      case "header":
      default:
        options.headers.set(name, token);
        break;
    }
  }
};
var buildUrl = (options) => getUrl({
  baseUrl: options.baseUrl,
  path: options.path,
  query: options.query,
  querySerializer: typeof options.querySerializer === "function" ? options.querySerializer : createQuerySerializer(options.querySerializer),
  url: options.url
});
var mergeConfigs = (a, b3) => {
  const config = { ...a, ...b3 };
  if (config.baseUrl?.endsWith("/")) {
    config.baseUrl = config.baseUrl.substring(0, config.baseUrl.length - 1);
  }
  config.headers = mergeHeaders(a.headers, b3.headers);
  return config;
};
var mergeHeaders = (...headers) => {
  const mergedHeaders = new Headers;
  for (const header of headers) {
    if (!header || typeof header !== "object") {
      continue;
    }
    const iterator = header instanceof Headers ? header.entries() : Object.entries(header);
    for (const [key, value] of iterator) {
      if (value === null) {
        mergedHeaders.delete(key);
      } else if (Array.isArray(value)) {
        for (const v of value) {
          mergedHeaders.append(key, v);
        }
      } else if (value !== undefined) {
        mergedHeaders.set(key, typeof value === "object" ? JSON.stringify(value) : value);
      }
    }
  }
  return mergedHeaders;
};

class Interceptors {
  _fns;
  constructor() {
    this._fns = [];
  }
  clear() {
    this._fns = [];
  }
  getInterceptorIndex(id) {
    if (typeof id === "number") {
      return this._fns[id] ? id : -1;
    } else {
      return this._fns.indexOf(id);
    }
  }
  exists(id) {
    const index = this.getInterceptorIndex(id);
    return !!this._fns[index];
  }
  eject(id) {
    const index = this.getInterceptorIndex(id);
    if (this._fns[index]) {
      this._fns[index] = null;
    }
  }
  update(id, fn) {
    const index = this.getInterceptorIndex(id);
    if (this._fns[index]) {
      this._fns[index] = fn;
      return id;
    } else {
      return false;
    }
  }
  use(fn) {
    this._fns = [...this._fns, fn];
    return this._fns.length - 1;
  }
}
var createInterceptors = () => ({
  error: new Interceptors,
  request: new Interceptors,
  response: new Interceptors
});
var defaultQuerySerializer = createQuerySerializer({
  allowReserved: false,
  array: {
    explode: true,
    style: "form"
  },
  object: {
    explode: true,
    style: "deepObject"
  }
});
var defaultHeaders = {
  "Content-Type": "application/json"
};
var createConfig = (override = {}) => ({
  ...jsonBodySerializer,
  headers: defaultHeaders,
  parseAs: "auto",
  querySerializer: defaultQuerySerializer,
  ...override
});

// node_modules/@opencode-ai/sdk/dist/gen/client/client.gen.js
var createClient = (config = {}) => {
  let _config = mergeConfigs(createConfig(), config);
  const getConfig = () => ({ ..._config });
  const setConfig = (config2) => {
    _config = mergeConfigs(_config, config2);
    return getConfig();
  };
  const interceptors = createInterceptors();
  const beforeRequest = async (options) => {
    const opts = {
      ..._config,
      ...options,
      fetch: options.fetch ?? _config.fetch ?? globalThis.fetch,
      headers: mergeHeaders(_config.headers, options.headers),
      serializedBody: undefined
    };
    if (opts.security) {
      await setAuthParams({
        ...opts,
        security: opts.security
      });
    }
    if (opts.requestValidator) {
      await opts.requestValidator(opts);
    }
    if (opts.body && opts.bodySerializer) {
      opts.serializedBody = opts.bodySerializer(opts.body);
    }
    if (opts.serializedBody === undefined || opts.serializedBody === "") {
      opts.headers.delete("Content-Type");
    }
    const url = buildUrl(opts);
    return { opts, url };
  };
  const request = async (options) => {
    const { opts, url } = await beforeRequest(options);
    const requestInit = {
      redirect: "follow",
      ...opts,
      body: opts.serializedBody
    };
    let request2 = new Request(url, requestInit);
    for (const fn of interceptors.request._fns) {
      if (fn) {
        request2 = await fn(request2, opts);
      }
    }
    const _fetch = opts.fetch;
    let response = await _fetch(request2);
    for (const fn of interceptors.response._fns) {
      if (fn) {
        response = await fn(response, request2, opts);
      }
    }
    const result = {
      request: request2,
      response
    };
    if (response.ok) {
      if (response.status === 204 || response.headers.get("Content-Length") === "0") {
        return opts.responseStyle === "data" ? {} : {
          data: {},
          ...result
        };
      }
      const parseAs = (opts.parseAs === "auto" ? getParseAs(response.headers.get("Content-Type")) : opts.parseAs) ?? "json";
      let data;
      switch (parseAs) {
        case "arrayBuffer":
        case "blob":
        case "formData":
        case "json":
        case "text":
          data = await response[parseAs]();
          break;
        case "stream":
          return opts.responseStyle === "data" ? response.body : {
            data: response.body,
            ...result
          };
      }
      if (parseAs === "json") {
        if (opts.responseValidator) {
          await opts.responseValidator(data);
        }
        if (opts.responseTransformer) {
          data = await opts.responseTransformer(data);
        }
      }
      return opts.responseStyle === "data" ? data : {
        data,
        ...result
      };
    }
    const textError = await response.text();
    let jsonError;
    try {
      jsonError = JSON.parse(textError);
    } catch {}
    const error = jsonError ?? textError;
    let finalError = error;
    for (const fn of interceptors.error._fns) {
      if (fn) {
        finalError = await fn(error, response, request2, opts);
      }
    }
    finalError = finalError || {};
    if (opts.throwOnError) {
      throw finalError;
    }
    return opts.responseStyle === "data" ? undefined : {
      error: finalError,
      ...result
    };
  };
  const makeMethod = (method) => {
    const fn = (options) => request({ ...options, method });
    fn.sse = async (options) => {
      const { opts, url } = await beforeRequest(options);
      return createSseClient({
        ...opts,
        body: opts.body,
        headers: opts.headers,
        method,
        url
      });
    };
    return fn;
  };
  return {
    buildUrl,
    connect: makeMethod("CONNECT"),
    delete: makeMethod("DELETE"),
    get: makeMethod("GET"),
    getConfig,
    head: makeMethod("HEAD"),
    interceptors,
    options: makeMethod("OPTIONS"),
    patch: makeMethod("PATCH"),
    post: makeMethod("POST"),
    put: makeMethod("PUT"),
    request,
    setConfig,
    trace: makeMethod("TRACE")
  };
};
// node_modules/@opencode-ai/sdk/dist/gen/core/params.gen.js
var extraPrefixesMap = {
  $body_: "body",
  $headers_: "headers",
  $path_: "path",
  $query_: "query"
};
var extraPrefixes = Object.entries(extraPrefixesMap);
// node_modules/@opencode-ai/sdk/dist/gen/client.gen.js
var client = createClient(createConfig({
  baseUrl: "http://localhost:4096"
}));

// node_modules/@opencode-ai/sdk/dist/gen/sdk.gen.js
class _HeyApiClient {
  _client = client;
  constructor(args) {
    if (args?.client) {
      this._client = args.client;
    }
  }
}

class Global extends _HeyApiClient {
  event(options) {
    return (options?.client ?? this._client).get.sse({
      url: "/global/event",
      ...options
    });
  }
}

class Project extends _HeyApiClient {
  list(options) {
    return (options?.client ?? this._client).get({
      url: "/project",
      ...options
    });
  }
  current(options) {
    return (options?.client ?? this._client).get({
      url: "/project/current",
      ...options
    });
  }
}

class Pty extends _HeyApiClient {
  list(options) {
    return (options?.client ?? this._client).get({
      url: "/pty",
      ...options
    });
  }
  create(options) {
    return (options?.client ?? this._client).post({
      url: "/pty",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers
      }
    });
  }
  remove(options) {
    return (options.client ?? this._client).delete({
      url: "/pty/{id}",
      ...options
    });
  }
  get(options) {
    return (options.client ?? this._client).get({
      url: "/pty/{id}",
      ...options
    });
  }
  update(options) {
    return (options.client ?? this._client).put({
      url: "/pty/{id}",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers
      }
    });
  }
  connect(options) {
    return (options.client ?? this._client).get({
      url: "/pty/{id}/connect",
      ...options
    });
  }
}

class Config extends _HeyApiClient {
  get(options) {
    return (options?.client ?? this._client).get({
      url: "/config",
      ...options
    });
  }
  update(options) {
    return (options?.client ?? this._client).patch({
      url: "/config",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers
      }
    });
  }
  providers(options) {
    return (options?.client ?? this._client).get({
      url: "/config/providers",
      ...options
    });
  }
}

class Tool extends _HeyApiClient {
  ids(options) {
    return (options?.client ?? this._client).get({
      url: "/experimental/tool/ids",
      ...options
    });
  }
  list(options) {
    return (options.client ?? this._client).get({
      url: "/experimental/tool",
      ...options
    });
  }
}

class Instance extends _HeyApiClient {
  dispose(options) {
    return (options?.client ?? this._client).post({
      url: "/instance/dispose",
      ...options
    });
  }
}

class Path extends _HeyApiClient {
  get(options) {
    return (options?.client ?? this._client).get({
      url: "/path",
      ...options
    });
  }
}

class Vcs extends _HeyApiClient {
  get(options) {
    return (options?.client ?? this._client).get({
      url: "/vcs",
      ...options
    });
  }
}

class Session extends _HeyApiClient {
  list(options) {
    return (options?.client ?? this._client).get({
      url: "/session",
      ...options
    });
  }
  create(options) {
    return (options?.client ?? this._client).post({
      url: "/session",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers
      }
    });
  }
  status(options) {
    return (options?.client ?? this._client).get({
      url: "/session/status",
      ...options
    });
  }
  delete(options) {
    return (options.client ?? this._client).delete({
      url: "/session/{id}",
      ...options
    });
  }
  get(options) {
    return (options.client ?? this._client).get({
      url: "/session/{id}",
      ...options
    });
  }
  update(options) {
    return (options.client ?? this._client).patch({
      url: "/session/{id}",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers
      }
    });
  }
  children(options) {
    return (options.client ?? this._client).get({
      url: "/session/{id}/children",
      ...options
    });
  }
  todo(options) {
    return (options.client ?? this._client).get({
      url: "/session/{id}/todo",
      ...options
    });
  }
  init(options) {
    return (options.client ?? this._client).post({
      url: "/session/{id}/init",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers
      }
    });
  }
  fork(options) {
    return (options.client ?? this._client).post({
      url: "/session/{id}/fork",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers
      }
    });
  }
  abort(options) {
    return (options.client ?? this._client).post({
      url: "/session/{id}/abort",
      ...options
    });
  }
  unshare(options) {
    return (options.client ?? this._client).delete({
      url: "/session/{id}/share",
      ...options
    });
  }
  share(options) {
    return (options.client ?? this._client).post({
      url: "/session/{id}/share",
      ...options
    });
  }
  diff(options) {
    return (options.client ?? this._client).get({
      url: "/session/{id}/diff",
      ...options
    });
  }
  summarize(options) {
    return (options.client ?? this._client).post({
      url: "/session/{id}/summarize",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers
      }
    });
  }
  messages(options) {
    return (options.client ?? this._client).get({
      url: "/session/{id}/message",
      ...options
    });
  }
  prompt(options) {
    return (options.client ?? this._client).post({
      url: "/session/{id}/message",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers
      }
    });
  }
  message(options) {
    return (options.client ?? this._client).get({
      url: "/session/{id}/message/{messageID}",
      ...options
    });
  }
  promptAsync(options) {
    return (options.client ?? this._client).post({
      url: "/session/{id}/prompt_async",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers
      }
    });
  }
  command(options) {
    return (options.client ?? this._client).post({
      url: "/session/{id}/command",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers
      }
    });
  }
  shell(options) {
    return (options.client ?? this._client).post({
      url: "/session/{id}/shell",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers
      }
    });
  }
  revert(options) {
    return (options.client ?? this._client).post({
      url: "/session/{id}/revert",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers
      }
    });
  }
  unrevert(options) {
    return (options.client ?? this._client).post({
      url: "/session/{id}/unrevert",
      ...options
    });
  }
}

class Command extends _HeyApiClient {
  list(options) {
    return (options?.client ?? this._client).get({
      url: "/command",
      ...options
    });
  }
}

class Oauth extends _HeyApiClient {
  authorize(options) {
    return (options.client ?? this._client).post({
      url: "/provider/{id}/oauth/authorize",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers
      }
    });
  }
  callback(options) {
    return (options.client ?? this._client).post({
      url: "/provider/{id}/oauth/callback",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers
      }
    });
  }
}

class Provider extends _HeyApiClient {
  list(options) {
    return (options?.client ?? this._client).get({
      url: "/provider",
      ...options
    });
  }
  auth(options) {
    return (options?.client ?? this._client).get({
      url: "/provider/auth",
      ...options
    });
  }
  oauth = new Oauth({ client: this._client });
}

class Find extends _HeyApiClient {
  text(options) {
    return (options.client ?? this._client).get({
      url: "/find",
      ...options
    });
  }
  files(options) {
    return (options.client ?? this._client).get({
      url: "/find/file",
      ...options
    });
  }
  symbols(options) {
    return (options.client ?? this._client).get({
      url: "/find/symbol",
      ...options
    });
  }
}

class File extends _HeyApiClient {
  list(options) {
    return (options.client ?? this._client).get({
      url: "/file",
      ...options
    });
  }
  read(options) {
    return (options.client ?? this._client).get({
      url: "/file/content",
      ...options
    });
  }
  status(options) {
    return (options?.client ?? this._client).get({
      url: "/file/status",
      ...options
    });
  }
}

class App extends _HeyApiClient {
  log(options) {
    return (options?.client ?? this._client).post({
      url: "/log",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers
      }
    });
  }
  agents(options) {
    return (options?.client ?? this._client).get({
      url: "/agent",
      ...options
    });
  }
}

class Auth extends _HeyApiClient {
  remove(options) {
    return (options.client ?? this._client).delete({
      url: "/mcp/{name}/auth",
      ...options
    });
  }
  start(options) {
    return (options.client ?? this._client).post({
      url: "/mcp/{name}/auth",
      ...options
    });
  }
  callback(options) {
    return (options.client ?? this._client).post({
      url: "/mcp/{name}/auth/callback",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers
      }
    });
  }
  authenticate(options) {
    return (options.client ?? this._client).post({
      url: "/mcp/{name}/auth/authenticate",
      ...options
    });
  }
  set(options) {
    return (options.client ?? this._client).put({
      url: "/auth/{id}",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers
      }
    });
  }
}

class Mcp extends _HeyApiClient {
  status(options) {
    return (options?.client ?? this._client).get({
      url: "/mcp",
      ...options
    });
  }
  add(options) {
    return (options?.client ?? this._client).post({
      url: "/mcp",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers
      }
    });
  }
  connect(options) {
    return (options.client ?? this._client).post({
      url: "/mcp/{name}/connect",
      ...options
    });
  }
  disconnect(options) {
    return (options.client ?? this._client).post({
      url: "/mcp/{name}/disconnect",
      ...options
    });
  }
  auth = new Auth({ client: this._client });
}

class Lsp extends _HeyApiClient {
  status(options) {
    return (options?.client ?? this._client).get({
      url: "/lsp",
      ...options
    });
  }
}

class Formatter extends _HeyApiClient {
  status(options) {
    return (options?.client ?? this._client).get({
      url: "/formatter",
      ...options
    });
  }
}

class Control extends _HeyApiClient {
  next(options) {
    return (options?.client ?? this._client).get({
      url: "/tui/control/next",
      ...options
    });
  }
  response(options) {
    return (options?.client ?? this._client).post({
      url: "/tui/control/response",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers
      }
    });
  }
}

class Tui extends _HeyApiClient {
  appendPrompt(options) {
    return (options?.client ?? this._client).post({
      url: "/tui/append-prompt",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers
      }
    });
  }
  openHelp(options) {
    return (options?.client ?? this._client).post({
      url: "/tui/open-help",
      ...options
    });
  }
  openSessions(options) {
    return (options?.client ?? this._client).post({
      url: "/tui/open-sessions",
      ...options
    });
  }
  openThemes(options) {
    return (options?.client ?? this._client).post({
      url: "/tui/open-themes",
      ...options
    });
  }
  openModels(options) {
    return (options?.client ?? this._client).post({
      url: "/tui/open-models",
      ...options
    });
  }
  submitPrompt(options) {
    return (options?.client ?? this._client).post({
      url: "/tui/submit-prompt",
      ...options
    });
  }
  clearPrompt(options) {
    return (options?.client ?? this._client).post({
      url: "/tui/clear-prompt",
      ...options
    });
  }
  executeCommand(options) {
    return (options?.client ?? this._client).post({
      url: "/tui/execute-command",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers
      }
    });
  }
  showToast(options) {
    return (options?.client ?? this._client).post({
      url: "/tui/show-toast",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers
      }
    });
  }
  publish(options) {
    return (options?.client ?? this._client).post({
      url: "/tui/publish",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers
      }
    });
  }
  control = new Control({ client: this._client });
}

class Event extends _HeyApiClient {
  subscribe(options) {
    return (options?.client ?? this._client).get.sse({
      url: "/event",
      ...options
    });
  }
}

class OpencodeClient extends _HeyApiClient {
  postSessionIdPermissionsPermissionId(options) {
    return (options.client ?? this._client).post({
      url: "/session/{id}/permissions/{permissionID}",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers
      }
    });
  }
  global = new Global({ client: this._client });
  project = new Project({ client: this._client });
  pty = new Pty({ client: this._client });
  config = new Config({ client: this._client });
  tool = new Tool({ client: this._client });
  instance = new Instance({ client: this._client });
  path = new Path({ client: this._client });
  vcs = new Vcs({ client: this._client });
  session = new Session({ client: this._client });
  command = new Command({ client: this._client });
  provider = new Provider({ client: this._client });
  find = new Find({ client: this._client });
  file = new File({ client: this._client });
  app = new App({ client: this._client });
  mcp = new Mcp({ client: this._client });
  lsp = new Lsp({ client: this._client });
  formatter = new Formatter({ client: this._client });
  tui = new Tui({ client: this._client });
  auth = new Auth({ client: this._client });
  event = new Event({ client: this._client });
}

// node_modules/@opencode-ai/sdk/dist/client.js
function createOpencodeClient(config) {
  if (!config?.fetch) {
    const customFetch = (req) => {
      req.timeout = false;
      return fetch(req);
    };
    config = {
      ...config,
      fetch: customFetch
    };
  }
  if (config?.directory) {
    config.headers = {
      ...config.headers,
      "x-opencode-directory": config.directory
    };
  }
  const client2 = createClient(config);
  return new OpencodeClient({ client: client2 });
}
// node_modules/@opencode-ai/sdk/dist/server.js
import { spawn } from "node:child_process";
async function createOpencodeServer(options) {
  options = Object.assign({
    hostname: "127.0.0.1",
    port: 4096,
    timeout: 5000
  }, options ?? {});
  const args = [`serve`, `--hostname=${options.hostname}`, `--port=${options.port}`];
  if (options.config?.logLevel)
    args.push(`--log-level=${options.config.logLevel}`);
  const proc = spawn(`opencode`, args, {
    signal: options.signal,
    env: {
      ...process.env,
      OPENCODE_CONFIG_CONTENT: JSON.stringify(options.config ?? {})
    }
  });
  const url = await new Promise((resolve, reject) => {
    const id = setTimeout(() => {
      reject(new Error(`Timeout waiting for server to start after ${options.timeout}ms`));
    }, options.timeout);
    let output = "";
    proc.stdout?.on("data", (chunk) => {
      output += chunk.toString();
      const lines = output.split(`
`);
      for (const line of lines) {
        if (line.startsWith("opencode server listening")) {
          const match = line.match(/on\s+(https?:\/\/[^\s]+)/);
          if (!match) {
            throw new Error(`Failed to parse server url from output: ${line}`);
          }
          clearTimeout(id);
          resolve(match[1]);
          return;
        }
      }
    });
    proc.stderr?.on("data", (chunk) => {
      output += chunk.toString();
    });
    proc.on("exit", (code) => {
      clearTimeout(id);
      let msg = `Server exited with code ${code}`;
      if (output.trim()) {
        msg += `
Server output: ${output}`;
      }
      reject(new Error(msg));
    });
    proc.on("error", (error) => {
      clearTimeout(id);
      reject(error);
    });
    if (options.signal) {
      options.signal.addEventListener("abort", () => {
        clearTimeout(id);
        reject(new Error("Aborted"));
      });
    }
  });
  return {
    url,
    close() {
      proc.kill();
    }
  };
}
// node_modules/@opencode-ai/sdk/dist/index.js
async function createOpencode(options) {
  const server2 = await createOpencodeServer({
    ...options
  });
  const client3 = createOpencodeClient({
    baseUrl: server2.url
  });
  return {
    client: client3,
    server: server2
  };
}

// src/backends/opencode/client.ts
var log = Log.create({ service: "opencode-client" });

class OpenCodeClient {
  client;
  timeout;
  retryAttempts;
  activeSessions;
  promptTimeout;
  directory = process.cwd();
  server = null;
  serverStartupTimeout;
  constructor(client3, server2, config = {}) {
    this.client = client3;
    this.server = server2;
    this.timeout = config.timeout || 30000;
    this.retryAttempts = config.retryAttempts || 3;
    const envPromptTimeout = Number.parseInt(process.env.OPENCODE_PROMPT_TIMEOUT_MS ?? "", 10);
    const resolvedPromptTimeout = Number.isFinite(envPromptTimeout) ? envPromptTimeout : undefined;
    this.promptTimeout = config.promptTimeout ?? resolvedPromptTimeout ?? 120000;
    this.directory = config.directory || process.env.OPENCODE_DIRECTORY || process.cwd();
    this.serverStartupTimeout = config.serverStartupTimeout || 1e4;
    this.activeSessions = new Map;
    log.debug("OpenCodeClient initialized", {
      hasOwnServer: !!this.server,
      timeout: this.timeout,
      serverStartupTimeout: this.serverStartupTimeout
    });
  }
  static async getAvailablePort() {
    try {
      const defaultPort = 4096;
      const isDefaultAvailable = await OpenCodeClient.isPortAvailable(defaultPort);
      if (!isDefaultAvailable) {
        log.info("Existing server detected on port 4096; spawning isolated server on dynamic port");
      } else {
        log.debug("Default port 4096 is available but avoiding it for isolation");
      }
      const dynamicPort = await OpenCodeClient.findAvailablePort();
      log.info(`Spawning isolated server on dynamic port: ${dynamicPort}`);
      return dynamicPort;
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      log.error("Failed to select OpenCode server port", {
        error: errorMsg
      });
      throw new Error(`Failed to select OpenCode server port: ${errorMsg}`);
    }
  }
  static async isPortAvailable(port) {
    return new Promise((resolve) => {
      const server2 = createServer();
      server2.listen(port, () => {
        server2.once("close", () => resolve(true));
        server2.close();
      });
      server2.on("error", () => resolve(false));
    });
  }
  static async findAvailablePort() {
    return new Promise((resolve, reject) => {
      const server2 = createServer();
      server2.listen(0, () => {
        const address = server2.address();
        if (address && typeof address === "object") {
          server2.once("close", () => resolve(address.port));
          server2.close();
        } else {
          reject(new Error("Failed to get server address"));
        }
      });
      server2.on("error", reject);
    });
  }
  static async create(config = {}) {
    try {
      if (config.client) {
        log.info("Creating OpenCodeClient with custom client instance");
        return new OpenCodeClient(config.client, null, config);
      }
      if (config.existingServerUrl) {
        log.info("Connecting to existing OpenCode server", {
          url: config.existingServerUrl
        });
        try {
          const client4 = createOpencodeClient({
            baseUrl: config.existingServerUrl
          });
          log.debug("Verifying connection to existing server...");
          return new OpenCodeClient(client4, null, config);
        } catch (error) {
          const errorMsg = error instanceof Error ? error.message : String(error);
          log.error("Failed to connect to existing server", {
            url: config.existingServerUrl,
            error: errorMsg
          });
          throw error;
        }
      }
      log.info("Spawning new OpenCode server...", {
        timeout: config.serverStartupTimeout || 1e4
      });
      const availablePort = await OpenCodeClient.getAvailablePort();
      const { client: client3, server: server2 } = await createOpencode({
        timeout: config.serverStartupTimeout || 1e4,
        port: availablePort
      });
      log.info("OpenCode server started successfully");
      return new OpenCodeClient(client3, server2, config);
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      log.error("Failed to create OpenCodeClient", { error: errorMsg });
      throw new Error(`Failed to create OpenCodeClient: ${errorMsg}`);
    }
  }
  async createSession(prompt) {
    try {
      const result = await this.client.session.create({
        body: {
          title: "ai-eng ralph session"
        }
      });
      if (!result.data) {
        throw new Error(`Failed to create OpenCode session: ${JSON.stringify(result.error)}`);
      }
      const sdkSession = result.data;
      let pendingInitialPrompt = prompt.trim();
      const buildFirstMessage = (message) => {
        if (!pendingInitialPrompt)
          return message;
        const combined = `${pendingInitialPrompt}

---

${message}`;
        pendingInitialPrompt = "";
        return combined;
      };
      const toolInvocations = [];
      const session = {
        id: sdkSession.id || this.generateSessionId(),
        _toolInvocations: toolInvocations,
        sendMessage: async (message) => {
          return this.handleSendMessage(sdkSession.id, buildFirstMessage(message));
        },
        sendMessageStream: async (message) => {
          return this.handleSendMessageStream(sdkSession.id, buildFirstMessage(message), toolInvocations);
        },
        close: async () => {
          return this.handleSessionClose(sdkSession.id);
        }
      };
      this.activeSessions.set(session.id, session);
      return session;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Failed to create OpenCode session: ${errorMessage}`);
    }
  }
  async sendMessage(sessionId, message) {
    const session = this.activeSessions.get(sessionId);
    if (!session) {
      throw new Error(`Session not found: ${sessionId}`);
    }
    return this.handleSendMessage(sessionId, message);
  }
  async closeSession(sessionId) {
    const session = this.activeSessions.get(sessionId);
    if (!session) {
      throw new Error(`Session not found: ${sessionId}`);
    }
    await this.handleSessionClose(sessionId);
    this.activeSessions.delete(sessionId);
  }
  getActiveSessions() {
    return Array.from(this.activeSessions.keys());
  }
  isSessionActive(sessionId) {
    return this.activeSessions.has(sessionId);
  }
  async closeAllSessions() {
    const closePromises = Array.from(this.activeSessions.keys()).map((sessionId) => this.handleSessionClose(sessionId).catch((error) => {
      const errorMsg = error instanceof Error ? error.message : String(error);
      log.warn("Error closing session", {
        sessionId,
        error: errorMsg
      });
    }));
    await Promise.all(closePromises);
    this.activeSessions.clear();
  }
  async handleSendMessageStream(sessionId, message, toolInvocations) {
    let lastError = null;
    const supportsEventStreaming = typeof this.client?.session?.promptAsync === "function" && typeof this.client?.event?.subscribe === "function";
    for (let attempt = 1;attempt <= this.retryAttempts; attempt++) {
      try {
        const stream = new TransformStream;
        const writer = stream.writable.getWriter();
        let finalized = false;
        const closeOnce = async () => {
          if (finalized)
            return;
          finalized = true;
          try {
            await writer.close();
          } catch {}
        };
        const abortOnce = async (err) => {
          if (finalized)
            return;
          finalized = true;
          try {
            await writer.abort(err);
          } catch {}
        };
        if (!supportsEventStreaming) {
          const promptPromise = this.client.session.prompt({
            body: {
              messageID: this.generateMessageId(),
              parts: [
                {
                  type: "text",
                  text: message
                }
              ]
            },
            path: {
              id: sessionId
            },
            query: {
              directory: this.directory
            }
          });
          const streamingTask2 = (async () => {
            try {
              const result = await promptPromise;
              if (!result.data) {
                throw new Error(`Invalid response from OpenCode: ${JSON.stringify(result.error)}`);
              }
              const response = result.data;
              const textPart = response.parts?.find((part) => part.type === "text");
              const finalContent = textPart?.text || "No content received";
              const chunks = this.splitIntoChunks(finalContent, 10);
              const encoder2 = new TextEncoder;
              for (const chunk of chunks) {
                await writer.write(encoder2.encode(chunk));
                await new Promise((resolve) => setTimeout(resolve, 50));
              }
              await closeOnce();
              return { content: finalContent };
            } catch (error) {
              await abortOnce(error);
              throw error;
            }
          })();
          return {
            stream: stream.readable,
            complete: streamingTask2
          };
        }
        const encoder = new TextEncoder;
        const idleTimeoutError = new Error(`Prompt idle timeout after ${this.promptTimeout}ms`);
        const hardTimeoutError = new Error(`Prompt hard timeout after ${this.promptTimeout * 5}ms`);
        const controller = new AbortController;
        let idleTimer;
        let hardTimer;
        let bytesWritten = 0;
        let lastProgressTime = Date.now();
        let idleTimedOut = false;
        const startHardTimer = () => {
          if (hardTimer)
            clearTimeout(hardTimer);
          hardTimer = setTimeout(() => {
            log.warn("Hard timeout reached, aborting", {
              sessionId,
              timeoutMs: this.promptTimeout * 5
            });
            try {
              controller.abort(hardTimeoutError);
            } catch {}
          }, this.promptTimeout * 5);
        };
        const resetIdleTimer = () => {
          if (idleTimer)
            clearTimeout(idleTimer);
          idleTimer = setTimeout(() => {
            idleTimedOut = true;
            log.warn("Idle timeout reached, aborting", {
              sessionId,
              timeoutMs: this.promptTimeout,
              bytesWritten,
              lastProgressMsAgo: Date.now() - lastProgressTime
            });
            try {
              controller.abort(idleTimeoutError);
            } catch {}
          }, this.promptTimeout);
        };
        const streamingTask = (async () => {
          try {
            startHardTimer();
            resetIdleTimer();
            const userMessageId = this.generateMessageId();
            log.debug("Sending prompt to OpenCode", {
              sessionId,
              messageLength: message.length,
              userMessageId
            });
            await this.client.session.promptAsync({
              body: {
                messageID: userMessageId,
                parts: [
                  {
                    type: "text",
                    text: message
                  }
                ]
              },
              path: {
                id: sessionId
              },
              query: {
                directory: this.directory
              },
              signal: controller.signal
            });
            log.debug("Subscribing to events", {
              sessionId,
              directory: this.directory
            });
            const eventsResult = await this.client.event.subscribe({
              query: {
                directory: this.directory
              },
              signal: controller.signal
            });
            let assistantMessageId2 = null;
            let content = "";
            let emittedText = "";
            let eventCount = 0;
            log.debug("Starting event stream processing", {
              sessionId
            });
            for await (const event of eventsResult.stream) {
              eventCount++;
              log.debug("Received event", {
                sessionId,
                eventType: event?.type,
                eventCount,
                hasProperties: !!event?.properties,
                controllerAborted: controller.signal.aborted
              });
              if (controller.signal.aborted) {
                log.debug("Controller aborted, breaking event loop", {
                  sessionId,
                  eventCount
                });
                break;
              }
              if (!event || typeof event !== "object") {
                log.debug("Skipping non-object event", {
                  sessionId,
                  eventCount
                });
                continue;
              }
              if (event.type === "message.updated") {
                const info = event.properties?.info;
                log.debug("Message updated event", {
                  sessionId,
                  eventCount,
                  infoRole: info?.role,
                  infoSessionId: info?.sessionID,
                  infoParentId: info?.parentID,
                  infoId: info?.id,
                  isRelevantSession: info?.sessionID === sessionId,
                  isAssistant: info?.role === "assistant",
                  isReplyToUser: info?.parentID === userMessageId
                });
                if (info?.role === "assistant" && info?.sessionID === sessionId && info?.parentID === userMessageId) {
                  assistantMessageId2 = info.id;
                  log.debug("Identified assistant message (exact parentID match)", {
                    sessionId,
                    assistantMessageId: assistantMessageId2
                  });
                } else if (!assistantMessageId2 && info?.role === "assistant" && info?.sessionID === sessionId) {
                  log.debug("Identified assistant message (fallback - no exact parentID match)", {
                    sessionId,
                    assistantMessageId: info.id,
                    infoParentId: info?.parentID,
                    userMessageId
                  });
                  assistantMessageId2 = info.id;
                }
                if (info?.role === "assistant" && info?.sessionID === sessionId) {
                  lastProgressTime = Date.now();
                  resetIdleTimer();
                }
                if (assistantMessageId2 && info?.id === assistantMessageId2) {
                  if (info?.error) {
                    const errName = info.error.name || "OpenCodeError";
                    const errMsg = info.error.data?.message || JSON.stringify(info.error.data || {});
                    log.error("Assistant error in message", {
                      sessionId,
                      errorName: errName,
                      errorMessage: errMsg
                    });
                    throw new Error(`${errName}: ${errMsg}`);
                  }
                  if (info?.time?.completed) {
                    log.debug("Assistant message completed", {
                      sessionId,
                      assistantMessageId: assistantMessageId2,
                      completedAt: info.time.completed
                    });
                    break;
                  }
                }
                continue;
              }
              if (event.type === "message.part.updated") {
                const part = event.properties?.part;
                log.debug("Message part updated", {
                  sessionId,
                  eventCount,
                  hasPart: !!part,
                  partType: part?.type,
                  partSessionId: part?.sessionID,
                  partMessageId: part?.messageID,
                  assistantMessageId: assistantMessageId2,
                  isRelevant: assistantMessageId2 && part?.sessionID === sessionId && part?.messageID === assistantMessageId2
                });
                if (!assistantMessageId2)
                  continue;
                if (part?.type === "tool" && toolInvocations) {
                  const toolId = part.toolId || part.id || `tool-${eventCount}`;
                  const toolName = part.toolName || part.name || "unknown";
                  const toolInput = part.input || part.parameters || {};
                  const existingToolIndex = toolInvocations.findIndex((t) => t.id === toolId);
                  const now = new Date().toISOString();
                  if (existingToolIndex >= 0) {
                    const existing = toolInvocations[existingToolIndex];
                    existing.output = part.result ?? part.output ?? existing.output;
                    existing.status = part.status === "error" ? "error" : "ok";
                    existing.error = part.error ?? existing.error;
                    existing.completedAt = part.completedAt ?? now;
                    log.debug("Tool invocation updated", {
                      sessionId,
                      toolId,
                      toolName,
                      status: existing.status
                    });
                  } else {
                    const toolInvocation = {
                      id: toolId,
                      name: toolName,
                      input: toolInput,
                      output: part.result ?? part.output,
                      status: part.status === "error" ? "error" : "ok",
                      error: part.error,
                      startedAt: part.startedAt ?? now,
                      completedAt: part.completedAt
                    };
                    toolInvocations.push(toolInvocation);
                    log.debug("Tool invocation started", {
                      sessionId,
                      toolId,
                      toolName,
                      input: JSON.stringify(toolInput).slice(0, 200)
                    });
                  }
                  if (part.sessionID !== sessionId || part.messageID !== assistantMessageId2) {} else {
                    lastProgressTime = Date.now();
                    resetIdleTimer();
                  }
                  continue;
                }
                if (!part || part.type !== "text")
                  continue;
                if (part.sessionID !== sessionId)
                  continue;
                if (part.messageID !== assistantMessageId2)
                  continue;
                const rawDelta = event.properties?.delta;
                let deltaText;
                if (typeof part.text === "string") {
                  const next = part.text;
                  if (next.startsWith(emittedText)) {
                    deltaText = next.slice(emittedText.length);
                    emittedText = next;
                  } else if (emittedText.startsWith(next)) {
                    deltaText = "";
                  } else {
                    deltaText = next;
                    emittedText += next;
                  }
                } else if (typeof rawDelta === "string") {
                  deltaText = rawDelta;
                  emittedText += rawDelta;
                }
                if (!deltaText)
                  continue;
                lastProgressTime = Date.now();
                bytesWritten += deltaText.length;
                resetIdleTimer();
                log.debug("Writing delta to stream", {
                  sessionId,
                  deltaLength: deltaText.length,
                  totalBytesWritten: bytesWritten,
                  contentLength: content.length
                });
                content += deltaText;
                await writer.write(encoder.encode(deltaText));
              }
            }
            log.debug("Event stream ended", {
              sessionId,
              eventCount,
              totalBytesWritten: bytesWritten,
              contentLength: content.length,
              controllerAborted: controller.signal.aborted,
              idleTimedOut,
              assistantMessageIdFound: !!assistantMessageId2
            });
            await closeOnce();
            return {
              content: content || "No content received",
              diagnostics: {
                bytesWritten,
                contentLength: content.length,
                idleTimedOut,
                assistantMessageIdFound: !!assistantMessageId2,
                eventCount
              }
            };
          } catch (error) {
            log.error("Streaming task error", {
              sessionId,
              error: error instanceof Error ? error.message : String(error),
              controllerAborted: controller.signal.aborted,
              bytesWritten,
              idleTimedOut,
              assistantMessageIdFound: !!assistantMessageId
            });
            if (controller.signal.aborted) {
              await abortOnce(idleTimeoutError);
              throw idleTimeoutError;
            }
            await abortOnce(error);
            throw error;
          } finally {
            if (idleTimer)
              clearTimeout(idleTimer);
            if (hardTimer)
              clearTimeout(hardTimer);
            try {
              if (!controller.signal.aborted)
                controller.abort();
            } catch {}
          }
        })();
        return {
          stream: stream.readable,
          complete: streamingTask
        };
      } catch (error) {
        lastError = error instanceof Error ? error : new Error(String(error));
        const isRateLimit = this.isRateLimitError(lastError);
        if (attempt === this.retryAttempts) {
          break;
        }
        const delay = this.getBackoffDelay(attempt, isRateLimit);
        log.warn("OpenCode attempt failed; retrying", {
          attempt,
          retryAttempts: this.retryAttempts,
          delayMs: delay,
          isRateLimit,
          error: lastError.message
        });
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }
    throw new Error(`Failed to stream message after ${this.retryAttempts} attempts: ${lastError?.message || "Unknown error"}`);
  }
  splitIntoChunks(text, chunkSize) {
    const chunks = [];
    for (let i = 0;i < text.length; i += chunkSize) {
      chunks.push(text.slice(i, i + chunkSize));
    }
    return chunks.length > 0 ? chunks : [text];
  }
  async handleSendMessage(sessionId, message) {
    let lastError = null;
    for (let attempt = 1;attempt <= this.retryAttempts; attempt++) {
      try {
        const timeoutError = new Error(`Prompt timeout after ${this.promptTimeout}ms`);
        const controller = new AbortController;
        const timer = setTimeout(() => {
          try {
            controller.abort(timeoutError);
          } catch {}
        }, this.promptTimeout);
        let result;
        try {
          result = await this.client.session.prompt({
            body: {
              messageID: this.generateMessageId(),
              parts: [
                {
                  type: "text",
                  text: message
                }
              ]
            },
            path: {
              id: sessionId
            },
            query: {
              directory: this.directory
            },
            signal: controller.signal
          });
        } catch (error) {
          if (controller.signal.aborted) {
            throw timeoutError;
          }
          throw error;
        } finally {
          clearTimeout(timer);
        }
        if (!result.data) {
          throw new Error(`Invalid response from OpenCode: ${JSON.stringify(result.error)}`);
        }
        const response = result.data;
        const textPart = response.parts?.find((part) => part.type === "text");
        return { content: textPart?.text || "No content received" };
      } catch (error) {
        lastError = error instanceof Error ? error : new Error(String(error));
        const isRateLimit = this.isRateLimitError(lastError);
        if (attempt === this.retryAttempts) {
          break;
        }
        const delay = this.getBackoffDelay(attempt, isRateLimit);
        log.warn("OpenCode attempt failed; retrying", {
          attempt,
          retryAttempts: this.retryAttempts,
          delayMs: delay,
          isRateLimit,
          error: lastError.message
        });
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }
    throw new Error(`Failed to send message after ${this.retryAttempts} attempts: ${lastError?.message || "Unknown error"}`);
  }
  isRateLimitError(error) {
    const err = error;
    return err.status === 429 || /rate limit|quota|overloaded|capacity/i.test(error.message);
  }
  getBackoffDelay(attempt, isRateLimit) {
    const base = isRateLimit ? 5000 : 1000;
    const exponential = base * 2 ** (attempt - 1);
    const jitter = Math.random() * 1000;
    return Math.min(exponential + jitter, 60000);
  }
  async handleSessionClose(sessionId) {
    try {
      log.debug("Session closed", { sessionId });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      log.warn("Failed to close session", {
        sessionId,
        error: errorMessage
      });
    }
  }
  generateSessionId() {
    return `session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
  generateMessageId() {
    return `msg_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;
  }
  async cleanup() {
    try {
      log.debug("Starting cleanup...", {
        activeSessions: this.activeSessions.size,
        hasServer: !!this.server
      });
      await this.closeAllSessions();
      if (this.server) {
        log.info("Closing spawned OpenCode server");
        try {
          this.server.close();
          this.server = null;
          log.info("OpenCode server closed successfully");
        } catch (error) {
          const errorMsg = error instanceof Error ? error.message : String(error);
          log.error("Error closing OpenCode server", {
            error: errorMsg
          });
        }
      } else {
        log.debug("No spawned server to close (connected to existing server)");
      }
      log.info("Cleanup complete");
      return;
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      log.error("Error during OpenCode client cleanup", {
        error: errorMsg
      });
      return;
    }
  }
}

// src/execution/ralph-loop.ts
import { execSync } from "node:child_process";
import { createHash } from "node:crypto";
import { readFile as readFile2, readdir } from "node:fs/promises";
import { join as join3 } from "node:path";
init_ui();

// src/prompt-optimization/analyzer.ts
var COMPLEXITY_KEYWORDS = {
  debug: ["debug", "fix", "error", "bug", "issue", "problem", "troubleshoot"],
  design: [
    "design",
    "architecture",
    "architect",
    "structure",
    "pattern",
    "approach"
  ],
  optimize: [
    "optimize",
    "improve",
    "performance",
    "efficient",
    "fast",
    "scale"
  ],
  implement: ["implement", "build", "create", "develop", "write", "code"],
  complex: ["complex", "challenge", "difficult", "advanced", "sophisticated"]
};
var DOMAIN_KEYWORDS = {
  security: [
    "auth",
    "authentication",
    "jwt",
    "oauth",
    "password",
    "encrypt",
    "decrypt",
    "security",
    "token",
    "session",
    "csrf",
    "xss",
    "injection",
    "vulnerability",
    "hack",
    "attack"
  ],
  frontend: [
    "react",
    "vue",
    "angular",
    "component",
    "css",
    "html",
    "ui",
    "ux",
    "render",
    "state",
    "hook",
    "props",
    "dom",
    "frontend",
    "client"
  ],
  backend: [
    "api",
    "server",
    "endpoint",
    "database",
    "query",
    "backend",
    "service",
    "microservice",
    "rest",
    "graphql",
    "http",
    "request",
    "response"
  ],
  database: [
    "sql",
    "postgresql",
    "mysql",
    "mongodb",
    "redis",
    "query",
    "index",
    "schema",
    "migration",
    "database",
    "db",
    "join",
    "transaction",
    "orm"
  ],
  devops: [
    "deploy",
    "ci/cd",
    "docker",
    "kubernetes",
    "k8s",
    "pipeline",
    "infrastructure",
    "aws",
    "gcp",
    "azure",
    "terraform",
    "ansible",
    "jenkins",
    "devops",
    "ops"
  ],
  architecture: [
    "architecture",
    "design",
    "pattern",
    "microservices",
    "monolith",
    "scalability",
    "system",
    "distributed",
    "architect",
    "high-level"
  ],
  testing: [
    "test",
    "spec",
    "unit test",
    "integration test",
    "e2e",
    "jest",
    "cypress",
    "playwright",
    "testing",
    "tdd",
    "coverage",
    "mock",
    "stub"
  ],
  general: []
};
var SIMPLE_PATTERNS = [
  /^(hello|hi|hey|greetings|good morning|good evening)/i,
  /^(thanks|thank you|thx)/i,
  /^(yes|no|ok|sure|alright)/i,
  /^(what|how|why|when|where|who|which)\s+\w+\??$/i,
  /^(help|assist)\s*$/i
];
function calculateComplexityScore(prompt) {
  const words = prompt.split(/\s+/);
  const wordCount = words.length;
  let score = 0;
  if (wordCount < 5)
    score += 0;
  else if (wordCount < 10)
    score += 3;
  else if (wordCount < 20)
    score += 6;
  else
    score += 10;
  const lowerPrompt = prompt.toLowerCase();
  for (const category of Object.values(COMPLEXITY_KEYWORDS)) {
    for (const keyword of category) {
      if (lowerPrompt.includes(keyword)) {
        score += 2;
        break;
      }
    }
  }
  const questionMarks = (prompt.match(/\?/g) || []).length;
  score -= Math.min(questionMarks * 2, 5);
  const techTerms = words.filter((word) => {
    const lower = word.toLowerCase();
    return /\w{4,}/.test(word) && !["this", "that", "with", "from", "into"].includes(lower);
  });
  score += Math.min(techTerms.length * 0.5, 5);
  return Math.max(0, Math.min(20, score));
}
function scoreToComplexity(score) {
  if (score < 5)
    return "simple";
  if (score < 12)
    return "medium";
  return "complex";
}
function isSimplePrompt(prompt) {
  for (const pattern of SIMPLE_PATTERNS) {
    if (pattern.test(prompt.trim())) {
      return true;
    }
  }
  return false;
}
function detectDomain(prompt) {
  const lowerPrompt = prompt.toLowerCase();
  const scores = {
    security: 0,
    frontend: 0,
    backend: 0,
    database: 0,
    devops: 0,
    architecture: 0,
    testing: 0,
    general: 0
  };
  for (const [domain, keywords] of Object.entries(DOMAIN_KEYWORDS)) {
    for (const keyword of keywords) {
      if (lowerPrompt.includes(keyword)) {
        scores[domain]++;
      }
    }
  }
  let bestDomain = "general";
  let bestScore = 0;
  for (const [domain, score] of Object.entries(scores)) {
    if (score > bestScore) {
      bestScore = score;
      bestDomain = domain;
    }
  }
  return bestDomain;
}
function extractKeywords(prompt) {
  const keywords = [];
  const lowerPrompt = prompt.toLowerCase();
  for (const [category, terms] of Object.entries(COMPLEXITY_KEYWORDS)) {
    for (const term of terms) {
      if (lowerPrompt.includes(term) && !keywords.includes(term)) {
        keywords.push(term);
      }
    }
  }
  for (const [domain, terms] of Object.entries(DOMAIN_KEYWORDS)) {
    for (const term of terms) {
      if (lowerPrompt.includes(term) && !keywords.includes(term)) {
        keywords.push(term);
      }
    }
  }
  return keywords;
}
function identifyMissingContext(prompt, domain) {
  const missing = [];
  const lowerPrompt = prompt.toLowerCase();
  if (lowerPrompt.includes("fix") || lowerPrompt.includes("debug") || lowerPrompt.includes("error")) {
    if (!lowerPrompt.includes("error") && !lowerPrompt.includes("exception")) {
      missing.push("error message or stack trace");
    }
    if (!/\.(js|ts|py|go|java|rb|php)/i.test(prompt)) {
      missing.push("file or code location");
    }
  }
  const techKeywords = [
    "javascript",
    "typescript",
    "python",
    "go",
    "java",
    "rust",
    "react",
    "vue",
    "angular",
    "node",
    "express",
    "django",
    "flask"
  ];
  const hasTech = techKeywords.some((tech) => lowerPrompt.includes(tech));
  if (!hasTech && !/\.(js|ts|py|go|java|rb|php)/i.test(prompt)) {
    missing.push("technology stack");
  }
  if (domain === "security") {
    if (!lowerPrompt.includes("jwt") && !lowerPrompt.includes("oauth") && !lowerPrompt.includes("session")) {
      missing.push("authentication method (JWT, OAuth, session, etc.)");
    }
  }
  if (domain === "database") {
    if (!lowerPrompt.includes("sql") && !lowerPrompt.includes("mysql") && !lowerPrompt.includes("postgresql") && !lowerPrompt.includes("mongodb")) {
      missing.push("database type");
    }
    if (!lowerPrompt.includes("index")) {
      missing.push("index information");
    }
  }
  return missing;
}
function suggestTechniques(complexity, domain) {
  const techniques = [];
  techniques.push("analysis");
  if (complexity === "medium" || complexity === "complex") {
    techniques.push("expert_persona");
  }
  if (complexity === "medium" || complexity === "complex") {
    techniques.push("reasoning_chain");
  }
  if (complexity === "medium" || complexity === "complex") {
    techniques.push("stakes_language");
  }
  if (complexity === "complex") {
    techniques.push("challenge_framing");
  }
  if (complexity === "medium" || complexity === "complex") {
    techniques.push("self_evaluation");
  }
  return techniques;
}
function analyzePrompt(prompt) {
  if (isSimplePrompt(prompt)) {
    return {
      complexity: "simple",
      domain: "general",
      keywords: [],
      missingContext: [],
      suggestedTechniques: ["analysis"]
    };
  }
  const complexityScore = calculateComplexityScore(prompt);
  const complexity = scoreToComplexity(complexityScore);
  const domain = detectDomain(prompt);
  const keywords = extractKeywords(prompt);
  const missingContext = identifyMissingContext(prompt, domain);
  const suggestedTechniques = suggestTechniques(complexity, domain);
  return {
    complexity,
    domain,
    keywords,
    missingContext,
    suggestedTechniques
  };
}

// src/prompt-optimization/techniques.ts
var expertPersona = {
  id: "expert_persona",
  name: "Expert Persona",
  description: "Assigns a detailed expert role with years of experience and notable companies",
  researchBasis: "Kong et al. 2023: 24%  84% accuracy improvement",
  appliesTo: ["medium", "complex"],
  generate: (context) => {
    if (context.preferences.customPersonas[context.domain]) {
      return context.preferences.customPersonas[context.domain];
    }
    const personas = {
      security: "You are a senior security engineer with 15+ years of authentication and cryptography experience. You have worked at Auth0, Okta, and AWS IAM, building production-grade authentication systems handling millions of users.",
      frontend: "You are a senior frontend architect with 12+ years of React, Vue, and TypeScript experience. You have built large-scale applications at Vercel, Stripe, and Airbnb, focusing on performance, accessibility, and developer experience.",
      backend: "You are a senior backend engineer with 15+ years of distributed systems and API design experience. You have built microservices architectures at Netflix, Google, and Stripe, handling billions of requests.",
      database: "You are a senior database architect with 15+ years of PostgreSQL, MySQL, and distributed database experience. You have optimized databases at CockroachDB, PlanetScale, and AWS, handling petabytes of data.",
      devops: "You are a senior platform engineer with 12+ years of Kubernetes, CI/CD, and infrastructure experience. You have built deployment pipelines at GitLab, CircleCI, and AWS, managing thousands of services.",
      architecture: "You are a principal software architect with 20+ years of system design experience. You have architected large-scale systems at Amazon, Microsoft, and Google, handling complex requirements and constraints.",
      testing: "You are a senior QA architect with 12+ years of test automation and quality engineering experience. You have built testing frameworks at Selenium, Cypress, and Playwright, ensuring production quality.",
      general: "You are a senior software engineer with 15+ years of full-stack development experience. You have built production applications at top technology companies, following best practices and industry standards."
    };
    return personas[context.domain] || personas.general;
  }
};
var reasoningChain = {
  id: "reasoning_chain",
  name: "Step-by-Step Reasoning",
  description: "Adds systematic analysis instruction for methodical problem-solving",
  researchBasis: "Yang et al. 2023 (Google DeepMind): 34%  80% accuracy",
  appliesTo: ["medium", "complex"],
  generate: (context) => {
    const baseInstruction = "Take a deep breath and analyze this step by step.";
    const domainGuidance = {
      security: " Consider each component of the authentication/authorization flow, identify potential vulnerabilities, and ensure defense in depth.",
      frontend: " Consider component hierarchy, state management, performance implications, and accessibility requirements.",
      backend: " Consider API design, data flow, error handling, scalability, and edge cases.",
      database: " Consider query execution plans, indexing strategies, data consistency, and performance implications.",
      devops: " Consider infrastructure as code, deployment strategies, monitoring, and rollback procedures.",
      architecture: " Consider system constraints, trade-offs, scalability, reliability, and maintainability.",
      testing: " Consider test coverage, edge cases, integration points, and test maintainability.",
      general: " Consider each component systematically, identify dependencies, and ensure thorough coverage."
    };
    return baseInstruction + (domainGuidance[context.domain] || domainGuidance.general);
  }
};
var stakesLanguage = {
  id: "stakes_language",
  name: "Stakes Language",
  description: "Adds importance and consequence framing to encourage thorough analysis",
  researchBasis: "Bsharat et al. 2023 (MBZUAI): +45% quality improvement",
  appliesTo: ["medium", "complex"],
  generate: (context) => {
    const stakes = {
      security: "This is critical to production security. A thorough, secure solution is essential to protect users and data.",
      frontend: "This directly impacts user experience and business metrics. Quality, performance, and accessibility are essential.",
      backend: "This affects system reliability and scalability. A robust, performant solution is essential for production.",
      database: "This impacts data integrity and system performance. An optimized, reliable solution is essential.",
      devops: "This affects deployment reliability and system stability. A well-tested, safe solution is essential for production.",
      architecture: "This affects long-term system maintainability and scalability. A well-designed solution is essential.",
      testing: "This affects production quality and user experience. Comprehensive testing is essential to prevent regressions.",
      general: "This is important for the project's success. A thorough, complete solution is essential."
    };
    return stakes[context.domain] || stakes.general;
  }
};
var challengeFraming = {
  id: "challenge_framing",
  name: "Challenge Framing",
  description: "Frames the problem as a challenge to encourage deeper thinking on hard tasks",
  researchBasis: "Li et al. 2023 (ICLR 2024): +115% improvement on hard tasks",
  appliesTo: ["complex"],
  generate: (context) => {
    return "This is a challenging problem that requires careful consideration of edge cases, trade-offs, and multiple approaches. Don't settle for the first solution - explore alternatives and justify your choices.";
  }
};
var selfEvaluation = {
  id: "self_evaluation",
  name: "Self-Evaluation Request",
  description: "Requests confidence rating and assumption identification for quality assurance",
  researchBasis: "Improves response calibration and identifies uncertainties",
  appliesTo: ["medium", "complex"],
  generate: (context) => {
    let evaluation = "After providing your solution:";
    evaluation += `

1. Rate your confidence in this solution from 0-1.`;
    evaluation += `
2. Identify any assumptions you made.`;
    evaluation += `
3. Note any limitations or potential issues.`;
    if (context.domain === "security" || context.domain === "database" || context.domain === "devops") {
      evaluation += `
4. Suggest how to test or validate this solution.`;
    }
    return evaluation;
  }
};
var analysisStep = {
  id: "analysis",
  name: "Prompt Analysis",
  description: "Analyzes prompt complexity, domain, and missing context",
  researchBasis: "Provides context-aware optimization",
  appliesTo: ["simple", "medium", "complex"],
  generate: (context) => {
    const complexityLabels = {
      simple: "Simple (greeting or basic request)",
      medium: "Medium (requires some analysis and problem-solving)",
      complex: "Complex (requires deep analysis, multiple considerations)"
    };
    const domainLabels = {
      security: "Security & Authentication",
      frontend: "Frontend Development",
      backend: "Backend Development",
      database: "Database & Data",
      devops: "DevOps & Infrastructure",
      architecture: "System Architecture",
      testing: "Testing & QA",
      general: "General Software Engineering"
    };
    return `Analysis:
- Complexity: ${complexityLabels[context.complexity]}
- Domain: ${domainLabels[context.domain] || domainLabels.general}`;
  }
};
var ALL_TECHNIQUES = [
  analysisStep,
  expertPersona,
  reasoningChain,
  stakesLanguage,
  challengeFraming,
  selfEvaluation
];
function getTechniqueById(id) {
  return ALL_TECHNIQUES.find((t) => t.id === id);
}

// src/prompt-optimization/optimizer.ts
function generateId() {
  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}
var DEFAULT_CONFIG2 = {
  enabled: true,
  autoApprove: false,
  verbosity: "normal",
  defaultTechniques: [
    "analysis",
    "expert_persona",
    "reasoning_chain",
    "stakes_language",
    "self_evaluation"
  ],
  skipForSimplePrompts: false,
  escapePrefix: "!"
};
var DEFAULT_PREFERENCES = {
  skipTechniques: [],
  customPersonas: {
    security: "",
    frontend: "",
    backend: "",
    database: "",
    devops: "",
    architecture: "",
    testing: "",
    general: ""
  },
  autoApproveDefault: false,
  verbosityDefault: "normal"
};

class PromptOptimizer {
  config;
  preferences;
  constructor(config = {}, preferences = {}) {
    this.config = { ...DEFAULT_CONFIG2, ...config };
    this.preferences = { ...DEFAULT_PREFERENCES, ...preferences };
  }
  updateConfig(updates) {
    this.config = { ...this.config, ...updates };
  }
  updatePreferences(updates) {
    this.preferences = { ...this.preferences, ...updates };
  }
  getConfig() {
    return { ...this.config };
  }
  getPreferences() {
    return { ...this.preferences };
  }
  shouldSkipOptimization(prompt) {
    return prompt.startsWith(this.config.escapePrefix);
  }
  stripEscapePrefix(prompt) {
    return prompt.slice(this.config.escapePrefix.length).trim();
  }
  shouldSkipForComplexity(complexity) {
    if (!this.config.skipForSimplePrompts) {
      return false;
    }
    return complexity === "simple";
  }
  createSession(prompt) {
    if (this.shouldSkipOptimization(prompt)) {
      const stripped = this.stripEscapePrefix(prompt);
      return {
        id: generateId(),
        originalPrompt: stripped,
        complexity: "simple",
        domain: "general",
        steps: [],
        finalPrompt: stripped,
        verbosity: this.config.verbosity,
        autoApprove: this.config.autoApprove,
        preferences: this.preferences,
        createdAt: new Date
      };
    }
    const analysis = analyzePrompt(prompt);
    if (this.shouldSkipForComplexity(analysis.complexity)) {
      return {
        id: generateId(),
        originalPrompt: prompt,
        complexity: analysis.complexity,
        domain: analysis.domain,
        steps: [],
        finalPrompt: prompt,
        verbosity: this.config.verbosity,
        autoApprove: this.config.autoApprove,
        preferences: this.preferences,
        createdAt: new Date
      };
    }
    const steps = this.generateSteps(analysis);
    const finalPrompt = this.buildFinalPrompt(prompt, steps);
    return {
      id: generateId(),
      originalPrompt: prompt,
      complexity: analysis.complexity,
      domain: analysis.domain,
      steps,
      finalPrompt,
      verbosity: this.config.verbosity,
      autoApprove: this.config.autoApprove,
      preferences: this.preferences,
      createdAt: new Date
    };
  }
  generateSteps(analysis) {
    const steps = [];
    let stepId = 1;
    for (const techniqueId of analysis.suggestedTechniques) {
      if (this.preferences.skipTechniques.includes(techniqueId)) {
        continue;
      }
      const technique = getTechniqueById(techniqueId);
      if (!technique) {
        continue;
      }
      const context = {
        originalPrompt: "",
        complexity: analysis.complexity,
        domain: analysis.domain,
        previousSteps: steps,
        preferences: this.preferences
      };
      steps.push({
        id: stepId++,
        technique: techniqueId,
        name: technique.name,
        description: technique.description,
        content: technique.generate(context),
        status: "pending",
        skippable: techniqueId !== "analysis",
        appliesTo: technique.appliesTo,
        researchBasis: technique.researchBasis
      });
    }
    if (this.config.autoApprove) {
      for (const step of steps) {
        step.status = "approved";
      }
    }
    return steps;
  }
  buildFinalPrompt(originalPrompt, steps) {
    const approvedSteps = steps.filter((s) => s.status === "approved" || s.status === "modified");
    if (approvedSteps.length === 0) {
      return originalPrompt;
    }
    const parts = [];
    for (const step of approvedSteps) {
      const content = step.modifiedContent || step.content;
      if (content) {
        parts.push(content);
      }
    }
    parts.push(`

Task: ${originalPrompt}`);
    return parts.join(`

`);
  }
  updateFinalPrompt(session) {
    session.finalPrompt = this.buildFinalPrompt(session.originalPrompt, session.steps);
  }
  approveStep(session, stepId) {
    const step = session.steps.find((s) => s.id === stepId);
    if (step) {
      step.status = "approved";
      this.updateFinalPrompt(session);
    }
  }
  rejectStep(session, stepId) {
    const step = session.steps.find((s) => s.id === stepId);
    if (step) {
      step.status = "rejected";
      this.updateFinalPrompt(session);
    }
  }
  modifyStep(session, stepId, newContent) {
    const step = session.steps.find((s) => s.id === stepId);
    if (step) {
      step.modifiedContent = newContent;
      step.status = "modified";
      this.updateFinalPrompt(session);
    }
  }
  approveAll(session) {
    for (const step of session.steps) {
      if (step.status === "pending") {
        step.status = "approved";
      }
    }
    this.updateFinalPrompt(session);
  }
  skipOptimization(session) {
    for (const step of session.steps) {
      if (step.technique !== "analysis") {
        step.status = "rejected";
      }
    }
    this.updateFinalPrompt(session);
  }
  saveSkipPreference(techniqueId) {
    if (!this.preferences.skipTechniques.includes(techniqueId)) {
      this.preferences.skipTechniques.push(techniqueId);
    }
  }
  saveCustomPersona(domain, persona) {
    this.preferences.customPersonas[domain] = persona;
  }
  toggleAutoApprove(enabled) {
    this.config.autoApprove = enabled !== undefined ? enabled : !this.config.autoApprove;
  }
  setVerbosity(verbosity) {
    this.config.verbosity = verbosity;
  }
  calculateExpectedImprovement(session) {
    const approvedTechniques = session.steps.filter((s) => s.status === "approved" || s.status === "modified");
    const techniquesApplied = approvedTechniques.map((s) => s.technique);
    const improvementMap = {
      analysis: 5,
      expert_persona: 60,
      reasoning_chain: 46,
      stakes_language: 45,
      challenge_framing: 115,
      self_evaluation: 10
    };
    let totalImprovement = 0;
    for (const techniqueId of techniquesApplied) {
      totalImprovement += improvementMap[techniqueId] || 0;
    }
    const effectiveImprovement = Math.min(totalImprovement, 150);
    return {
      qualityImprovement: effectiveImprovement,
      techniquesApplied,
      researchBasis: "Combined research-backed techniques (MBZUAI, Google DeepMind, ICLR 2024)"
    };
  }
  getSessionSummary(session) {
    const improvement = this.calculateExpectedImprovement(session);
    const approvedCount = session.steps.filter((s) => s.status === "approved" || s.status === "modified").length;
    return `Optimization Session ${session.id}
` + `  Complexity: ${session.complexity}
` + `  Domain: ${session.domain}
` + `  Steps Applied: ${approvedCount}/${session.steps.length}
` + `  Expected Improvement: ~${improvement.qualityImprovement}%`;
  }
}

// src/util/discord-webhook.ts
var log2 = Log.create({ service: "discord-webhook" });

class DiscordWebhookClient {
  webhookUrl;
  username;
  avatarUrl;
  enabled = false;
  constructor(options) {
    this.webhookUrl = options.webhookUrl;
    this.username = options.username ?? "Ralph";
    this.avatarUrl = options.avatarUrl;
    this.enabled = true;
    if (!this.webhookUrl || !this.isValidWebhookUrl(this.webhookUrl)) {
      log2.warn("Invalid Discord webhook URL, notifications disabled", {
        webhookUrl: this.maskWebhookUrl(this.webhookUrl)
      });
      this.enabled = false;
    }
    log2.info("Discord webhook client initialized", {
      enabled: this.enabled,
      username: this.username
    });
  }
  isValidWebhookUrl(url) {
    return /^https:\/\/discord(?:app)?\.com\/api\/webhooks\/\d+\/[a-zA-Z0-9_-]+$/.test(url);
  }
  maskWebhookUrl(url) {
    if (!url)
      return "(not set)";
    return url.replace(/\/[a-zA-Z0-9_-]+$/, "/********");
  }
  async send(message) {
    if (!this.enabled) {
      log2.debug("Discord notifications disabled, skipping send");
      return false;
    }
    try {
      const payload = {
        content: message.content,
        username: message.username ?? this.username,
        avatarUrl: message.avatarUrl ?? this.avatarUrl,
        tts: message.tts ?? false,
        embeds: message.embeds
      };
      log2.debug("Sending Discord notification", {
        hasContent: !!message.content,
        embedCount: message.embeds?.length ?? 0
      });
      const response = await fetch(this.webhookUrl, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(payload)
      });
      if (!response.ok) {
        const errorText = await response.text();
        log2.error("Discord webhook request failed", {
          status: response.status,
          statusText: response.statusText,
          error: errorText
        });
        return false;
      }
      log2.debug("Discord notification sent successfully");
      return true;
    } catch (error) {
      log2.error("Failed to send Discord notification", {
        error: error instanceof Error ? error.message : String(error)
      });
      return false;
    }
  }
  async notify(content) {
    return this.send({ content });
  }
  async notifyWithEmbed(embed, content) {
    return this.send({
      content,
      embeds: [embed]
    });
  }
  async notifyCycleStart(cycleNumber, maxCycles, prompt) {
    const embed = {
      title: `\uD83D\uDD04 Cycle ${cycleNumber}/${maxCycles} Started`,
      description: `\`\`\`
${prompt.slice(0, 500)}${prompt.length > 500 ? "..." : ""}
\`\`\``,
      color: 5793266,
      timestamp: new Date().toISOString(),
      fields: [
        {
          name: "\uD83D\uDCCB Phase",
          value: "Research  Specify  Plan  Work  Review",
          inline: true
        },
        {
          name: " Status",
          value: "Running",
          inline: true
        }
      ]
    };
    return this.notifyWithEmbed(embed, `\uD83D\uDE80 **Ralph Cycle ${cycleNumber}/${maxCycles} Started**`);
  }
  async notifyCycleComplete(cycleNumber, completedCycles, summary, durationMs) {
    const durationMinutes = Math.floor(durationMs / 60000);
    const durationSeconds = Math.floor(durationMs % 60000 / 1000);
    const embed = {
      title: ` Cycle ${cycleNumber} Completed`,
      description: summary.slice(0, 2000) || "No summary available",
      color: 5763719,
      timestamp: new Date().toISOString(),
      fields: [
        {
          name: "\uD83D\uDCCA Progress",
          value: `${completedCycles} cycles completed`,
          inline: true
        },
        {
          name: " Duration",
          value: `${durationMinutes}m ${durationSeconds}s`,
          inline: true
        }
      ]
    };
    return this.notifyWithEmbed(embed, ` **Ralph Cycle ${cycleNumber} Complete**`);
  }
  async notifyPhaseComplete(cycleNumber, phase, summary) {
    const embed = {
      title: `\uD83D\uDCDD Phase Complete: ${phase}`,
      description: summary.slice(0, 1000),
      color: 16705372,
      timestamp: new Date().toISOString(),
      fields: [
        {
          name: "\uD83D\uDD04 Cycle",
          value: String(cycleNumber),
          inline: true
        }
      ]
    };
    return this.notifyWithEmbed(embed);
  }
  async notifyError(cycleNumber, phase, error) {
    const embed = {
      title: ` Error in Cycle ${cycleNumber}`,
      description: `**Phase:** ${phase}

**Error:**
\`\`\`
${error.slice(0, 1500)}
\`\`\``,
      color: 15548997,
      timestamp: new Date().toISOString()
    };
    return this.notifyWithEmbed(embed, "\uD83D\uDEA8 **Ralph Error**");
  }
  async notifyTimeout(cycleNumber, phase, timeoutMs) {
    const timeoutMinutes = Math.floor(timeoutMs / 60000);
    const embed = {
      title: ` Timeout in Cycle ${cycleNumber}`,
      description: `**Phase:** ${phase}
**Timeout:** ${timeoutMinutes} minutes`,
      color: 15418782,
      timestamp: new Date().toISOString()
    };
    return this.notifyWithEmbed(embed, " **Ralph Timeout**");
  }
  async notifyRunComplete(totalCycles, durationMs, finalSummary) {
    const durationHours = Math.floor(durationMs / 3600000);
    const durationMinutes = Math.floor(durationMs % 3600000 / 60000);
    const embed = {
      title: "\uD83C\uDFC1 Run Complete",
      description: finalSummary.slice(0, 2000),
      color: 5763719,
      timestamp: new Date().toISOString(),
      fields: [
        {
          name: "\uD83D\uDD04 Total Cycles",
          value: String(totalCycles),
          inline: true
        },
        {
          name: " Total Duration",
          value: durationHours > 0 ? `${durationHours}h ${durationMinutes}m` : `${durationMinutes}m`,
          inline: true
        }
      ]
    };
    return this.notifyWithEmbed(embed, "\uD83C\uDFC1 **Ralph Run Complete**");
  }
  async notifyStuckOrAborted(cycleNumber, reason) {
    const embed = {
      title: `\uD83D\uDED1 Run ${reason}`,
      description: `Cycle ${cycleNumber} reached stuck threshold or was aborted`,
      color: 5793266,
      timestamp: new Date().toISOString()
    };
    return this.notifyWithEmbed(embed, `\uD83D\uDED1 **Ralph ${reason}**`);
  }
}
function createDiscordWebhookFromEnv() {
  const webhookUrl = process.env.DISCORD_WEBHOOK_URL?.trim();
  if (!webhookUrl) {
    log2.debug("No DISCORD_WEBHOOK_URL env var set, Discord notifications disabled");
    return null;
  }
  return new DiscordWebhookClient({
    webhookUrl,
    username: process.env.DISCORD_BOT_USERNAME ?? "Ralph",
    avatarUrl: process.env.DISCORD_BOT_AVATAR_URL
  });
}

// src/execution/flow-store.ts
import { existsSync, mkdirSync, readFileSync, writeFileSync } from "node:fs";
import { join as join2 } from "node:path";

// src/execution/flow-types.ts
var FLOW_SCHEMA_VERSION = "1.0.0";

// src/execution/flow-store.ts
var log3 = Log.create({ service: "flow-store" });

class FlowStore {
  flowDir;
  runId;
  constructor(options) {
    this.flowDir = options.flowDir;
    this.runId = options.runId;
  }
  get basePath() {
    return join2(this.flowDir, this.runId, ".flow");
  }
  path(relPath) {
    return join2(this.basePath, relPath);
  }
  initialize() {
    const dirs = ["iterations", "contexts", "gates"];
    for (const dir of dirs) {
      const dirPath = this.path(dir);
      if (!existsSync(dirPath)) {
        mkdirSync(dirPath, { recursive: true });
        log3.debug("Created directory", { path: dirPath });
      }
    }
    log3.info("Flow store initialized", {
      runId: this.runId,
      basePath: this.basePath
    });
  }
  exists() {
    return existsSync(this.path("state.json"));
  }
  load() {
    const statePath = this.path("state.json");
    if (!existsSync(statePath)) {
      return null;
    }
    try {
      const content = readFileSync(statePath, "utf-8");
      const state = JSON.parse(content);
      if (state.schemaVersion !== FLOW_SCHEMA_VERSION) {
        log3.warn("Flow schema version mismatch", {
          expected: FLOW_SCHEMA_VERSION,
          found: state.schemaVersion
        });
      }
      log3.info("Loaded flow state", {
        runId: state.runId,
        status: state.status,
        currentCycle: state.currentCycle
      });
      return state;
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      log3.error("Failed to load flow state", { error: errorMsg });
      return null;
    }
  }
  createInitialState(options) {
    const now = new Date().toISOString();
    const state = {
      schemaVersion: FLOW_SCHEMA_VERSION,
      runId: this.runId,
      prompt: options.prompt,
      status: "pending" /* PENDING */,
      completionPromise: options.completionPromise,
      maxCycles: options.maxCycles,
      stuckThreshold: options.stuckThreshold,
      gates: options.gates,
      currentCycle: 0,
      completedCycles: 0,
      failedCycles: 0,
      stuckCount: 0,
      createdAt: now,
      updatedAt: now
    };
    this.saveState(state);
    return state;
  }
  saveState(state) {
    const statePath = this.path("state.json");
    state.updatedAt = new Date().toISOString();
    writeFileSync(statePath, JSON.stringify(state, null, 2));
    log3.debug("Saved flow state", { runId: state.runId });
  }
  saveCheckpoint(state, lastPhaseOutputs) {
    const checkpointPath = this.path("checkpoint.json");
    const checkpoint = {
      schemaVersion: FLOW_SCHEMA_VERSION,
      runId: state.runId,
      cycleNumber: state.currentCycle,
      timestamp: new Date().toISOString(),
      state,
      lastPhaseOutputs
    };
    writeFileSync(checkpointPath, JSON.stringify(checkpoint, null, 2));
    log3.debug("Saved checkpoint", {
      runId: state.runId,
      cycle: state.currentCycle
    });
  }
  loadCheckpoint() {
    const checkpointPath = this.path("checkpoint.json");
    if (!existsSync(checkpointPath)) {
      return null;
    }
    try {
      const content = readFileSync(checkpointPath, "utf-8");
      return JSON.parse(content);
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      log3.error("Failed to load checkpoint", { error: errorMsg });
      return null;
    }
  }
  saveIteration(cycle) {
    const cyclePath = this.path(`iterations/${cycle.cycleNumber}.json`);
    writeFileSync(cyclePath, JSON.stringify(cycle, null, 2));
    const contextPath = this.path(`contexts/${cycle.cycleNumber}.md`);
    const contextContent = this.generateContextContent(cycle);
    writeFileSync(contextPath, contextContent);
    log3.debug("Saved iteration", { cycle: cycle.cycleNumber });
  }
  saveGateResults(cycleNumber, results) {
    const gatePath = this.path(`gates/${cycleNumber}.json`);
    writeFileSync(gatePath, JSON.stringify(results, null, 2));
  }
  generateContextContent(cycle) {
    const lines = [
      `# Cycle ${cycle.cycleNumber} Context`,
      "",
      `**Timestamp:** ${cycle.startTime}`,
      `**Status:** ${cycle.status}`,
      `**Completion Promise Observed:** ${cycle.completionPromiseObserved}`,
      "",
      "## Phase Summaries",
      ""
    ];
    for (const [phase, output] of Object.entries(cycle.phases)) {
      if (output) {
        lines.push(`### ${phase.toUpperCase()}`);
        lines.push("");
        lines.push(output.summary || output.response.slice(0, 500));
        lines.push("");
      }
    }
    if (cycle.gateResults.length > 0) {
      lines.push("## Gate Results");
      lines.push("");
      for (const gate of cycle.gateResults) {
        const status = gate.passed ? " PASS" : " FAIL";
        lines.push(`- **${gate.gate}:** ${status} - ${gate.message}`);
      }
      lines.push("");
    }
    if (cycle.error) {
      lines.push("## Errors");
      lines.push("");
      lines.push(cycle.error);
      lines.push("");
    }
    return lines.join(`
`);
  }
  getIteration(cycleNumber) {
    const cyclePath = this.path(`iterations/${cycleNumber}.json`);
    if (!existsSync(cyclePath)) {
      return null;
    }
    try {
      const content = readFileSync(cyclePath, "utf-8");
      return JSON.parse(content);
    } catch {
      return null;
    }
  }
  getAllIterations() {
    const iterations = [];
    let n = 1;
    while (true) {
      const cycle = this.getIteration(n);
      if (!cycle)
        break;
      iterations.push(cycle);
      n++;
    }
    return iterations;
  }
  updateStatus(status, stopReason, error) {
    const state = this.load();
    if (!state) {
      throw new Error("No flow state to update");
    }
    state.status = status;
    if (stopReason)
      state.stopReason = stopReason;
    if (error)
      state.error = error;
    if (status === "completed" /* COMPLETED */ || status === "failed" /* FAILED */) {
      state.completedAt = new Date().toISOString();
    }
    this.saveState(state);
  }
  incrementCycle() {
    const state = this.load();
    if (!state) {
      throw new Error("No flow state to update");
    }
    state.currentCycle++;
    this.saveState(state);
    return state.currentCycle;
  }
  recordFailedCycle(cycle) {
    const state = this.load();
    if (!state) {
      throw new Error("No flow state to update");
    }
    state.failedCycles++;
    state.stuckCount++;
    this.saveIteration(cycle);
    this.saveState(state);
    log3.info("Cycle failed", {
      runId: this.runId,
      cycle: cycle.cycleNumber,
      failedCycles: state.failedCycles,
      stuckCount: state.stuckCount
    });
  }
  recordSuccessfulCycle(cycle, summary) {
    const state = this.load();
    if (!state) {
      throw new Error("No flow state to update");
    }
    state.completedCycles++;
    state.stuckCount = 0;
    state.lastCheckpoint = {
      cycleNumber: cycle.cycleNumber,
      summary,
      timestamp: new Date().toISOString()
    };
    this.saveIteration(cycle);
    this.saveState(state);
    log3.info("Cycle completed", {
      runId: this.runId,
      cycle: cycle.cycleNumber,
      completedCycles: state.completedCycles
    });
  }
  cleanup() {
    log3.info("Flow store cleanup requested", { runId: this.runId });
  }
}

// src/execution/ralph-loop.ts
var log4 = Log.create({ service: "ralph-loop" });
var DEFAULT_GATES = ["test", "lint", "acceptance"];
var DEFAULT_MAX_CYCLES = 50;
var DEFAULT_STUCK_THRESHOLD = 5;
var DEFAULT_CHECKPOINT_FREQUENCY = 1;
var DEFAULT_CYCLE_RETRIES = 2;
var SECRET_PATTERNS = [
  /api[_-]?key/i,
  /token/i,
  /secret/i,
  /password/i,
  /credential/i,
  /webhook/i,
  /auth/i,
  /bearer/i,
  /private[_-]?key/i
];
function redactSecrets(text) {
  let result = text;
  for (const pattern of SECRET_PATTERNS) {
    result = result.replace(new RegExp(`${pattern.source}["']?\\s*[:=]\\s*["']?([^"'",\\s]+)`, "gi"), `${pattern.source}="[REDACTED]"`);
  }
  return result;
}
function truncateOutput(text, maxLength = 1000) {
  if (text.length <= maxLength)
    return text;
  return `${text.substring(0, maxLength)}
... [truncated ${text.length - maxLength} chars]`;
}

class RalphLoopRunner {
  config;
  flowStore;
  flags;
  baseConfig;
  optimizer;
  discordWebhook;
  constructor(flags, baseConfig, optimizer) {
    this.flags = flags;
    this.baseConfig = baseConfig;
    this.optimizer = optimizer;
    this.config = this.buildLoopConfig();
    const flowStoreOptions = {
      flowDir: this.config.flowDir,
      runId: this.config.runId
    };
    this.flowStore = new FlowStore(flowStoreOptions);
    this.discordWebhook = createDiscordWebhookFromEnv();
  }
  buildLoopConfig() {
    let completionPromise = this.flags.completionPromise ?? "";
    if (this.flags.ship) {
      completionPromise = "<promise>SHIP</promise>";
    } else if (this.flags.draft) {
      completionPromise = "";
    } else if (!completionPromise) {
      completionPromise = "";
    }
    let runId = this.flags.runId;
    if (!runId) {
      const defaultRunId = this.generateRunId();
      const defaultFlowDir = this.getDefaultFlowDir(defaultRunId);
      const checkStore = new FlowStore({
        flowDir: this.flags.workingDir ? join3(this.flags.workingDir, ".ai-eng") : ".ai-eng",
        runId: defaultRunId
      });
      runId = defaultRunId;
    }
    return {
      runId,
      prompt: this.flags.workflow ?? "",
      completionPromise,
      maxCycles: this.flags.maxCycles ?? DEFAULT_MAX_CYCLES,
      stuckThreshold: this.flags.stuckThreshold ?? DEFAULT_STUCK_THRESHOLD,
      gates: this.flags.gates ?? DEFAULT_GATES,
      checkpointFrequency: this.flags.checkpointFrequency ?? DEFAULT_CHECKPOINT_FREQUENCY,
      flowDir: this.getDefaultFlowDir(runId),
      dryRun: this.flags.dryRun ?? false,
      cycleRetries: this.baseConfig.loop?.cycleRetries ?? DEFAULT_CYCLE_RETRIES,
      debugWork: this.flags.debugWork ?? this.baseConfig.debug?.work ?? false
    };
  }
  getDefaultFlowDir(runId) {
    const artifactsDir = this.baseConfig.runner.artifactsDir;
    if (this.flags.workingDir) {
      return join3(this.flags.workingDir, artifactsDir);
    }
    return join3(process.cwd(), artifactsDir);
  }
  generateRunId() {
    const timestamp = Date.now().toString(36);
    const random = Math.random().toString(36).substring(2, 8);
    return `run-${timestamp}-${random}`;
  }
  hashOutput(output) {
    return createHash("sha256").update(output).digest("hex").substring(0, 16);
  }
  async run() {
    UI.header("Ralph Loop Runner");
    if (this.flags.resume) {
      await this.resume();
      return;
    }
    await this.startFresh();
  }
  async startFresh() {
    log4.info("Starting fresh Ralph loop", {
      runId: this.config.runId,
      prompt: this.config.prompt.substring(0, 100),
      completionPromise: this.config.completionPromise,
      maxCycles: this.config.maxCycles
    });
    this.flowStore.initialize();
    const initialState = this.flowStore.createInitialState({
      prompt: this.config.prompt,
      completionPromise: this.config.completionPromise,
      maxCycles: this.config.maxCycles,
      stuckThreshold: this.config.stuckThreshold,
      gates: this.config.gates
    });
    this.flowStore.updateStatus("running" /* RUNNING */);
    await this.runLoop();
  }
  async resume() {
    log4.info("Resuming Ralph loop", { runId: this.config.runId });
    const state = this.flowStore.load();
    if (!state) {
      throw new Error(`No flow state found for run ID: ${this.config.runId}. Cannot resume.`);
    }
    if (state.status === "completed" /* COMPLETED */) {
      UI.warn("This run has already completed.");
      UI.info(`Stop reason: ${state.stopReason}`);
      return;
    }
    if (state.status === "failed" /* FAILED */) {
      UI.warn("This run previously failed.");
      UI.info(`Error: ${state.error}`);
    }
    await this.runLoop();
  }
  async runLoop() {
    const state = this.flowStore.load();
    if (!state) {
      throw new Error("No flow state found");
    }
    UI.info(`Run ID: ${this.config.runId}`);
    UI.info(`Flow directory: ${this.flowStore.basePath}`);
    UI.info(`Completion promise: ${this.config.completionPromise || "(none)"}`);
    UI.info(`Max cycles: ${this.config.maxCycles}`);
    UI.info(`Cycle retries: ${this.config.cycleRetries}`);
    UI.info(`Stuck threshold: ${this.config.stuckThreshold}`);
    UI.info(`Debug work: ${this.config.debugWork ? "enabled" : "disabled"}`);
    UI.println();
    for (let cycleNumber = state.currentCycle + 1;cycleNumber <= this.config.maxCycles; cycleNumber++) {
      UI.header(`Cycle ${cycleNumber}/${this.config.maxCycles}`);
      const runStartTime = Date.now();
      this.discordWebhook?.notifyCycleStart(cycleNumber, this.config.maxCycles, this.config.prompt);
      let attempt = 0;
      let result = null;
      let lastError = null;
      while (attempt <= this.config.cycleRetries) {
        attempt++;
        const isRetry = attempt > 1;
        if (isRetry) {
          UI.info(`Retry attempt ${attempt}/${this.config.cycleRetries + 1}`);
          log4.info("Retrying cycle", {
            cycleNumber,
            attempt,
            lastError
          });
        }
        const client3 = await OpenCodeClient.create({
          serverStartupTimeout: 1e4
        });
        try {
          const context = await this.buildReAnchoredContext(cycleNumber, isRetry ? lastError ?? undefined : undefined);
          result = await this.executeCycle(cycleNumber, client3, context);
          if (result.success) {
            this.flowStore.recordSuccessfulCycle(result.cycleState, result.summary);
            const durationMs = Date.now() - runStartTime;
            this.discordWebhook?.notifyCycleComplete(cycleNumber, this.flowStore.load()?.completedCycles ?? cycleNumber, result.summary, durationMs);
          } else {
            this.flowStore.recordFailedCycle(result.cycleState);
            this.discordWebhook?.notifyError(cycleNumber, result.cycleState.phases[Object.keys(result.cycleState.phases).pop()]?.phase ?? "unknown", result.cycleState.error ?? "Unknown error");
          }
          if (result.success) {
            break;
          }
          const shouldRetry = this.shouldRetryFailure(result);
          if (!shouldRetry) {
            break;
          }
          lastError = result.summary;
        } catch (error) {
          const errorMsg = error instanceof Error ? error.message : String(error);
          lastError = errorMsg;
          const shouldRetry = this.shouldRetryOnError(error);
          if (shouldRetry && attempt <= this.config.cycleRetries) {
            log4.warn("Cycle error, will retry", {
              cycleNumber,
              attempt,
              error: errorMsg
            });
          } else {
            break;
          }
        } finally {
          await client3.cleanup();
        }
      }
      if (!result) {
        this.discordWebhook?.notifyStuckOrAborted(cycleNumber, "FAILED_ALL_RETRIES");
        await this.handleStop("error" /* ERROR */, `Cycle ${cycleNumber} failed after ${this.config.cycleRetries + 1} attempts: ${lastError ?? "unknown error"}`);
        return;
      }
      if (result.stopReason) {
        await this.handleStop(result.stopReason, result.summary);
        return;
      }
      const currentState = this.flowStore.load();
      if (currentState && currentState.stuckCount >= this.config.stuckThreshold) {
        this.discordWebhook?.notifyStuckOrAborted(cycleNumber, "STUCK");
        await this.handleStop("stuck" /* STUCK */, `No progress for ${this.config.stuckThreshold} consecutive cycles`);
        return;
      }
      if (cycleNumber % this.config.checkpointFrequency === 0) {
        this.flowStore.saveCheckpoint(this.flowStore.load(), result.cycleState.phases);
      }
      UI.println();
    }
    this.discordWebhook?.notifyRunComplete(state.completedCycles, Date.now() - new Date(state.createdAt).getTime(), `Completed ${state.completedCycles} cycles (max ${this.config.maxCycles})`);
    await this.handleStop("max_cycles" /* MAX_CYCLES */, "Maximum cycles reached");
  }
  shouldRetryFailure(result) {
    const failedGates = result.cycleState.gateResults.filter((g2) => !g2.passed);
    if (failedGates.length > 0) {
      return true;
    }
    const workPhase = result.cycleState.phases["work" /* WORK */];
    if (workPhase && !workPhase.response.trim()) {
      return true;
    }
    return false;
  }
  shouldRetryOnError(error) {
    if (error instanceof Error) {
      if (error.message.includes("timeout")) {
        return true;
      }
      if (error.message.includes("stream")) {
        return true;
      }
      if (error.message.includes("OpenCode")) {
        return true;
      }
    }
    return false;
  }
  async buildReAnchoredContext(cycleNumber, retryFailure) {
    const contextParts = [];
    contextParts.push(`# Original Task

${this.config.prompt}
`);
    if (retryFailure) {
      contextParts.push(`# Previous Attempt Failed

The previous attempt had an issue:
${retryFailure}

Please analyze what went wrong and try a different approach.
`);
    }
    const previousCycle = this.flowStore.getIteration(cycleNumber - 1);
    if (previousCycle) {
      contextParts.push(`# Previous Cycle (${cycleNumber - 1}) Summary

`);
      contextParts.push(previousCycle.error ? `FAILED
` : `COMPLETED
`);
      if (previousCycle.error) {
        contextParts.push(`Error: ${previousCycle.error}
`);
      }
      if (previousCycle.gateResults.length > 0) {
        contextParts.push(`
## Gate Results

`);
        for (const gate of previousCycle.gateResults) {
          const status = gate.passed ? "" : "";
          contextParts.push(`- ${status} ${gate.gate}: ${gate.message}
`);
        }
      }
      const allTools = this.collectAllTools(previousCycle);
      if (allTools.length > 0) {
        contextParts.push(`
## Tool Usage in Previous Cycle

`);
        for (const tool of allTools.slice(0, 10)) {
          const statusIcon = tool.status === "ok" ? "" : "";
          contextParts.push(`${statusIcon} ${tool.name}: ${tool.status}
`);
        }
        if (allTools.length > 10) {
          contextParts.push(`... and ${allTools.length - 10} more tools
`);
        }
      }
    }
    const state = this.flowStore.load();
    if (state?.lastCheckpoint) {
      contextParts.push(`
# Last Checkpoint

Cycle ${state.lastCheckpoint.cycleNumber}: ${state.lastCheckpoint.summary}
`);
    }
    const specsContext = await this.loadRelevantSpecs();
    if (specsContext) {
      contextParts.push(specsContext);
    }
    try {
      const gitStatus = await this.getGitStatus();
      if (gitStatus) {
        contextParts.push(`
# Git Status

${gitStatus}
`);
      }
    } catch {}
    contextParts.push(`
# Completion Criteria

Loop exits when you output exactly: ${this.config.completionPromise || "(none - will run all cycles)"}
`);
    return contextParts.join(`
`);
  }
  collectAllTools(cycle) {
    const tools = [];
    for (const phase of Object.values(cycle.phases)) {
      if (phase?.tools) {
        tools.push(...phase.tools);
      }
    }
    return tools;
  }
  async loadRelevantSpecs() {
    const specsDir = join3(process.cwd(), "specs");
    let specs;
    try {
      specs = await readdir(specsDir);
    } catch {
      return null;
    }
    const promptLower = this.config.prompt.toLowerCase();
    const promptTokens = new Set(promptLower.split(/\W+/).filter((t) => t.length > 2));
    const matches = [];
    for (const specDir of specs) {
      if (specDir.startsWith("."))
        continue;
      const specPath = join3(specsDir, specDir, "spec.md");
      try {
        const specContent = await readFile2(specPath, "utf-8");
        const specContentLower = specContent.toLowerCase();
        const titleMatch = specContent.match(/^# (.+)$/m);
        const title = titleMatch?.[1];
        let score = 0;
        const specTokens = new Set(specContentLower.split(/\W+/).filter((t) => t.length > 2));
        for (const token of promptTokens) {
          if (specTokens.has(token)) {
            score++;
          }
        }
        const dirLower = specDir.toLowerCase();
        if (promptLower.includes(dirLower) || dirLower.includes("fleettools")) {
          score += 5;
        }
        if (score > 0) {
          matches.push({ dir: specDir, score, title });
        }
      } catch {}
    }
    matches.sort((a, b3) => b3.score - a.score);
    const topMatches = matches.slice(0, 2);
    if (topMatches.length === 0) {
      return null;
    }
    const result = [`
# Relevant Specifications
`];
    for (const match of topMatches) {
      const specPath = join3(specsDir, match.dir, "spec.md");
      try {
        const specContent = await readFile2(specPath, "utf-8");
        const overviewMatch = specContent.match(/^(# .+?)(?:\n\n## Overview\n\n)([\s\S]*?)(?=\n\n## |\n\n### )/m);
        const userStoriesMatch = specContent.match(/^(## User Stories\n\n)([\s\S]*?)(?=\n\n## |\n\n### )/m);
        result.push(`
## ${match.title || match.dir}
`);
        if (overviewMatch) {
          result.push(overviewMatch[2].trim());
          result.push(`
`);
        }
        if (userStoriesMatch) {
          const stories = userStoriesMatch[2].split(/\n### /).slice(0, 3);
          result.push(`
### Key User Stories
`);
          for (const story of stories) {
            if (story.trim()) {
              result.push(`
### ${story.trim()}
`);
            }
          }
        }
        log4.debug("Loaded spec for context", {
          spec: match.dir,
          score: match.score
        });
      } catch {
        log4.warn("Failed to read spec", { spec: match.dir });
      }
    }
    return result.join(`
`);
  }
  async getGitStatus() {
    try {
      const { execSync: execSync2 } = await import("node:child_process");
      const diff = execSync2("git diff --stat", {
        encoding: "utf-8",
        cwd: process.cwd()
      });
      const status = execSync2("git status --short", {
        encoding: "utf-8",
        cwd: process.cwd()
      });
      return `\`\`\`
${diff}
${status}
\`\`\``;
    } catch {
      return null;
    }
  }
  async executeCycle(cycleNumber, client3, context) {
    const startTime = new Date().toISOString();
    const cycleState = {
      cycleNumber,
      status: "running",
      startTime,
      phases: {},
      gateResults: [],
      completionPromiseObserved: false
    };
    try {
      const session = await client3.createSession(context);
      for (const phase of [
        "research" /* RESEARCH */,
        "specify" /* SPECIFY */,
        "plan" /* PLAN */,
        "work" /* WORK */,
        "review" /* REVIEW */
      ]) {
        const phaseResult = await this.executePhase(session, phase, cycleNumber);
        if (phaseResult.error) {
          cycleState.phases[phase] = {
            phase,
            prompt: phaseResult.prompt,
            response: "",
            summary: `Error: ${phaseResult.error}`,
            timestamp: new Date().toISOString()
          };
          throw new Error(`${phase} phase failed: ${phaseResult.error}`);
        }
        cycleState.phases[phase] = {
          phase,
          prompt: phaseResult.prompt,
          response: phaseResult.response,
          summary: phaseResult.summary,
          timestamp: new Date().toISOString(),
          tools: phaseResult.tools
        };
        if (this.config.completionPromise && phaseResult.response.includes(this.config.completionPromise)) {
          cycleState.completionPromiseObserved = true;
        }
        UI.println(`${UI.Style.TEXT_DIM}   ${phase}: done${UI.Style.TEXT_NORMAL}`);
      }
      UI.println(`${UI.Style.TEXT_DIM}Running quality gates...${UI.Style.TEXT_NORMAL}`);
      const gateResults = await this.runQualityGates(cycleNumber, cycleState);
      cycleState.gateResults = gateResults;
      const requiredFailed = gateResults.find((g2) => !g2.passed && this.config.gates.includes(g2.gate));
      let failedPhaseInfo = "";
      if (requiredFailed) {
        const phasesWithGates = Object.entries(cycleState.phases);
        const lastPhase = phasesWithGates[phasesWithGates.length - 1]?.[0] ?? "unknown";
        failedPhaseInfo = `${lastPhase} gate failed`;
      }
      cycleState.status = "completed";
      cycleState.endTime = new Date().toISOString();
      cycleState.durationMs = Date.now() - new Date(startTime).getTime();
      const summary = this.generateCycleSummary(cycleState);
      if (this.config.completionPromise && cycleState.completionPromiseObserved) {
        return {
          success: true,
          cycleState,
          summary,
          stopReason: "completion_promise" /* COMPLETION_PROMISE */
        };
      }
      if (requiredFailed) {
        return {
          success: false,
          cycleState,
          summary: `${failedPhaseInfo}: ${requiredFailed.message}`,
          stopReason: "gate_failure" /* GATE_FAILURE */
        };
      }
      cycleState.outputHash = this.hashOutput(Object.values(cycleState.phases).map((p2) => p2?.response ?? "").join("|"));
      return { success: true, cycleState, summary };
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      cycleState.status = "failed";
      cycleState.endTime = new Date().toISOString();
      cycleState.durationMs = Date.now() - new Date(startTime).getTime();
      cycleState.error = errorMsg;
      return {
        success: false,
        cycleState,
        summary: `Cycle failed: ${errorMsg}`,
        stopReason: "error" /* ERROR */
      };
    }
  }
  async executePhase(session, phase, cycleNumber) {
    const phasePrompts = {
      ["research" /* RESEARCH */]: `## Phase 1: Research

Research the codebase to understand the current state. Focus on:
- File structure and key modules
- Existing patterns and conventions
- Dependencies and configurations
- Any relevant documentation

Provide a concise summary of your findings.`,
      ["specify" /* SPECIFY */]: `## Phase 2: Specify

Based on the research, create a detailed specification for the task:
- Requirements and acceptance criteria
- Technical approach
- Potential challenges and mitigation strategies
- Dependencies on existing code

Output a structured specification.`,
      ["plan" /* PLAN */]: `## Phase 3: Plan

Create an implementation plan:
- Step-by-step tasks
- Files to modify/create
- Order of operations
- Testing strategy

Output a detailed plan.`,
      ["work" /* WORK */]: `## Phase 4: Work

Execute the implementation plan. Make concrete changes to the codebase.

IMPORTANT: You MUST:
1. Use tools (Read, Write, Edit, Bash) to make actual file changes
2. Report each file you modify as you go (e.g., "Creating file X...", "Modifying Y...")
3. Run actual tests and report results
4. Ensure the final summary lists:
   - All files created/modified (with paths) OR explicitly "NO CHANGES: <reason>" if no files needed
   - All test results (pass/fail)
   - Any errors encountered and how they were resolved

If no changes are needed, explicitly state "NO CHANGES: <reason>" and why.

Provide a comprehensive summary of concrete work completed.`,
      ["review" /* REVIEW */]: `## Phase 5: Review

Review the completed work:
- Verify all acceptance criteria are met
- Check code quality and consistency
- Ensure tests pass
- Identify any remaining issues

Output: <promise>SHIP</promise> if all criteria are met, or list remaining issues.`
    };
    const prompt = phasePrompts[phase];
    const streamingResponse = await session.sendMessageStream(prompt);
    let fullResponse = "";
    const tools = [];
    UI.println(`${UI.Style.TEXT_DIM}  [${phase}]${UI.Style.TEXT_NORMAL}`);
    const reader = streamingResponse.stream.getReader();
    const decoder = new TextDecoder;
    const phaseTimeoutMs = (this.config.phaseTimeoutMs ?? (this.config.promptTimeout ?? 300000) * 5) || 900000;
    let phaseTimedOut = false;
    const watchdogTimer = setTimeout(() => {
      phaseTimedOut = true;
      log4.warn("Phase watchdog triggered", {
        cycleNumber,
        phase,
        timeoutMs: phaseTimeoutMs
      });
      reader.cancel(`Phase timeout after ${phaseTimeoutMs}ms`);
    }, phaseTimeoutMs);
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (phaseTimedOut) {
          throw new Error(`Phase ${phase} timed out after ${phaseTimeoutMs}ms (watchdog)`);
        }
        if (done)
          break;
        if (value) {
          const text = decoder.decode(value, { stream: true });
          fullResponse += text;
          UI.print(text);
        }
      }
    } catch (error) {
      if (phaseTimedOut || error instanceof Error && error.message.includes("timeout")) {
        this.discordWebhook?.notifyTimeout(cycleNumber, phase, phaseTimeoutMs);
        throw new Error(`Phase ${phase} timed out after ${phaseTimeoutMs}ms - OpenCode stream did not complete`);
      }
      throw error;
    } finally {
      clearTimeout(watchdogTimer);
      reader.releaseLock();
    }
    await streamingResponse.complete;
    const sessionTools = session._toolInvocations;
    if (sessionTools && sessionTools.length > 0) {
      tools.push(...sessionTools);
      if (this.config.debugWork) {
        for (const tool of sessionTools) {
          const redactedInput = tool.input ? redactSecrets(JSON.stringify(tool.input)) : undefined;
          const redactedOutput = tool.output ? truncateOutput(redactSecrets(tool.output)) : undefined;
          UI.println(`${UI.Style.TEXT_DIM}  [TOOL] ${tool.name}: ${tool.status}${UI.Style.TEXT_NORMAL}`);
          log4.debug("Tool invocation", {
            phase,
            tool: tool.name,
            status: tool.status,
            input: redactedInput,
            output: redactedOutput
          });
        }
      }
    }
    const summary = this.generatePhaseSummary(fullResponse);
    this.discordWebhook?.notifyPhaseComplete(cycleNumber, phase, summary);
    return {
      prompt,
      response: fullResponse,
      summary,
      tools
    };
  }
  generatePhaseSummary(response) {
    const trimmed = response.trim();
    if (trimmed.length <= 200) {
      return trimmed;
    }
    return `${trimmed.substring(0, 200)}...`;
  }
  generateCycleSummary(cycle) {
    const parts = [];
    for (const [phase, output] of Object.entries(cycle.phases)) {
      if (output) {
        parts.push(`${phase}: ${output.summary}`);
      }
    }
    return parts.join(" | ");
  }
  async runQualityGates(cycleNumber, cycle) {
    const results = [];
    const now = new Date().toISOString();
    for (const gate of this.config.gates) {
      const result = await this.runGate(gate, cycle);
      results.push({
        gate,
        passed: result.passed,
        message: result.message,
        details: result.details,
        timestamp: now
      });
      this.flowStore.saveGateResults(cycleNumber, results);
    }
    return results;
  }
  async runGate(gate, cycle) {
    const gateConfig = this.getGateConfig(gate);
    switch (gate.toLowerCase()) {
      case "test":
      case "tests": {
        const result = await this.runGateCommand("test", gateConfig.command);
        return {
          passed: result.passed,
          message: result.passed ? "All tests passed" : "Some tests failed",
          details: result.details
        };
      }
      case "lint": {
        const result = await this.runGateCommand("lint", gateConfig.command);
        return {
          passed: result.passed,
          message: result.passed ? "Linting passed" : "Linting issues found",
          details: result.details
        };
      }
      case "acceptance": {
        const passed = await this.checkAcceptance(cycle);
        return {
          passed,
          message: passed ? "Acceptance criteria met" : "Acceptance criteria not fully met"
        };
      }
      default:
        return {
          passed: false,
          message: `Unknown gate: ${gate}`
        };
    }
  }
  getGateConfig(gate) {
    const normalizedGate = gate.toLowerCase() === "tests" ? "test" : gate.toLowerCase();
    const gateKey = normalizedGate;
    const configGate = this.baseConfig.gates[gateKey];
    if (configGate && typeof configGate === "object" && "command" in configGate) {
      return configGate;
    }
    return { command: String(configGate ?? "") };
  }
  async runGateCommand(gateName, command) {
    const startTime = Date.now();
    let exitCode = null;
    let stdout = "";
    let stderr = "";
    UI.info(`  Running ${gateName}: ${command}`);
    try {
      const result = execSync(command, {
        encoding: "utf-8",
        cwd: this.flags.workingDir ?? process.cwd(),
        timeout: 120000,
        maxBuffer: 10485760
      });
      stdout = result;
      exitCode = 0;
    } catch (error) {
      if (error instanceof Error && "status" in error) {
        exitCode = error.status ?? 1;
        stderr = error instanceof Error ? error.message : String(error);
        if ("stdout" in error && error.stdout) {
          stdout = String(error.stdout);
        }
        if ("stderr" in error && error.stderr) {
          stderr = String(error.stderr);
        }
      } else {
        stderr = error instanceof Error ? error.message : String(error);
      }
    }
    const durationMs = Date.now() - startTime;
    const passed = exitCode === 0;
    log4.debug("Gate command result", {
      gate: gateName,
      command,
      exitCode,
      durationMs,
      stdoutLength: stdout.length,
      stderrLength: stderr.length
    });
    return {
      passed,
      details: {
        command,
        exitCode,
        stdout: truncateOutput(stdout, 2000),
        stderr: truncateOutput(stderr, 1000),
        durationMs
      }
    };
  }
  async checkAcceptance(cycle) {
    log4.debug("Checking acceptance criteria", {
      cycleNumber: cycle.cycleNumber
    });
    const workPhase = cycle.phases["work" /* WORK */];
    if (!workPhase) {
      log4.warn("No work phase found in cycle");
      return false;
    }
    const workResponse = workPhase.response.trim();
    if (!workResponse) {
      log4.debug("Acceptance failed: empty work response");
      return false;
    }
    const hasNoChangesMarker = /NO\s*CHANGES?[:\s]/i.test(workResponse);
    const hasProgressSignal = this.hasProgressSignal(cycle);
    if (hasNoChangesMarker) {
      const hasReason = /NO\s*CHANGES?[:\s]+[A-Z]/.test(workResponse);
      if (hasReason) {
        log4.debug("Acceptance passed: NO CHANGES with reason");
        return true;
      }
    }
    if (hasProgressSignal) {
      log4.debug("Acceptance passed: progress signal detected");
      return true;
    }
    if (workResponse.length < 20) {
      log4.debug("Acceptance failed: response too short/fluffy");
      return false;
    }
    const willPattern = /\bI (will|need to|should|must|have to|am going to)\b/i;
    if (willPattern.test(workResponse)) {
      log4.debug("Acceptance failed: response contains 'I will' pattern (no action taken)");
      return false;
    }
    const mentionsChanges = /\b(change|modify|create|update|delete|add|fix|implement|refactor|write|run|test)\b/i.test(workResponse);
    if (mentionsChanges) {
      log4.debug("Acceptance passed: response mentions actionable changes");
      return true;
    }
    log4.debug("Acceptance failed: no valid progress signal");
    return false;
  }
  hasProgressSignal(cycle) {
    const allTools = this.collectAllTools(cycle);
    if (allTools.length > 0) {
      return true;
    }
    for (const gateResult of cycle.gateResults) {
      if (gateResult.details && "command" in gateResult.details && gateResult.details.command) {
        return true;
      }
    }
    return false;
  }
  async handleStop(reason, summary) {
    const state = this.flowStore.load();
    if (state) {
      let runStatus;
      switch (reason) {
        case "completion_promise" /* COMPLETION_PROMISE */:
          runStatus = "completed" /* COMPLETED */;
          break;
        case "stuck" /* STUCK */:
          runStatus = "stuck" /* STUCK */;
          this.discordWebhook?.notifyStuckOrAborted(state.currentCycle, "STUCK");
          break;
        case "user_abort" /* USER_ABORT */:
          runStatus = "aborted" /* ABORTED */;
          this.discordWebhook?.notifyStuckOrAborted(state.currentCycle, "ABORTED");
          break;
        case "error" /* ERROR */:
          runStatus = "failed" /* FAILED */;
          break;
        default:
          runStatus = "failed" /* FAILED */;
      }
      this.flowStore.updateStatus(runStatus, reason);
    }
    UI.header("Loop Complete");
    UI.info(`Stop reason: ${reason}`);
    UI.info(`Summary: ${summary}`);
    log4.info("Ralph loop stopped", { reason, summary });
  }
}
async function createRalphLoopRunner(flags, baseConfig) {
  const optimizer = new PromptOptimizer({
    autoApprove: flags.ci ?? false,
    verbosity: flags.verbose ? "verbose" : "normal"
  });
  return new RalphLoopRunner(flags, baseConfig, optimizer);
}

// src/cli/run-cli.ts
init_ui();
var log5 = Log.create({ service: "run-cli" });
var activeClient = null;
var cleanupHandlersRegistered = false;
async function setupCleanupHandlers() {
  if (cleanupHandlersRegistered)
    return;
  cleanupHandlersRegistered = true;
  const cleanupFn = async () => {
    if (activeClient) {
      try {
        log5.info("Cleanup signal received, closing OpenCode server...");
        await activeClient.cleanup();
        log5.info("OpenCode server closed successfully");
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        log5.error("Error during cleanup", { error: errorMsg });
      }
      activeClient = null;
    }
    process.exit(0);
  };
  process.on("SIGINT", cleanupFn);
  process.on("SIGTERM", cleanupFn);
  process.on("SIGHUP", cleanupFn);
  process.on("uncaughtException", async (error) => {
    const errorMsg = error instanceof Error ? error.message : String(error);
    log5.error("Uncaught exception", {
      error: errorMsg,
      stack: error instanceof Error ? error.stack : undefined
    });
    await cleanupFn();
  });
  process.on("unhandledRejection", async (reason) => {
    const errorMsg = reason instanceof Error ? reason.message : String(reason);
    log5.error("Unhandled rejection", {
      error: errorMsg,
      stack: reason instanceof Error ? reason.stack : undefined
    });
    await cleanupFn();
  });
}
async function runCli(config, flags) {
  await setupCleanupHandlers();
  log5.info("Starting CLI execution", { workflow: flags.workflow });
  const prompt = flags.workflow;
  if (!prompt) {
    UI.error("No prompt or workflow provided");
    process.exit(1);
  }
  const optimizer = new PromptOptimizer({
    autoApprove: flags.ci ?? false,
    verbosity: flags.verbose ? "verbose" : "normal"
  });
  UI.header("Prompt Optimization");
  const session = optimizer.createSession(prompt);
  log5.debug("Created optimization session", { steps: session.steps.length });
  if (!flags.ci) {
    for (const step of session.steps) {
      const action = await ve({
        message: `Apply "${step.name}"?
  ${step.description}`,
        options: [
          {
            value: "approve",
            label: "Approve",
            hint: "Apply this optimization"
          },
          {
            value: "reject",
            label: "Reject",
            hint: "Skip this optimization"
          },
          {
            value: "skip-all",
            label: "Skip all",
            hint: "Use original prompt"
          }
        ]
      });
      if (pD(action)) {
        log5.info("User cancelled");
        process.exit(0);
      }
      if (action === "skip-all") {
        optimizer.skipOptimization(session);
        break;
      }
      if (action === "approve") {
        optimizer.approveStep(session, step.id);
      } else {
        optimizer.rejectStep(session, step.id);
      }
    }
  }
  if (flags.loop !== false) {
    await runLoopMode(config, flags, session.finalPrompt);
  } else {
    await runSingleShotMode(config, flags, session.finalPrompt);
  }
}
async function runLoopMode(config, flags, _optimizedPrompt) {
  UI.header("Ralph Loop Mode");
  UI.info("Running with fresh OpenCode sessions per iteration");
  if (flags.ship) {
    UI.info("Mode: SHIP (auto-exit when agent outputs '<promise>SHIP</promise>')");
    UI.info("Completion promise: <promise>SHIP</promise>");
  } else if (flags.draft || !flags.ship && !flags.completionPromise) {
    UI.info("Mode: DRAFT (runs for max-cycles then stops for your review)");
    UI.info("Completion promise: none (will run all cycles)");
  } else {
    UI.info("Mode: Custom completion promise");
    UI.info(`Completion promise: ${flags.completionPromise}`);
  }
  UI.info(`Max cycles: ${flags.maxCycles ?? 50}`);
  UI.info(`Stuck threshold: ${flags.stuckThreshold ?? 5}`);
  UI.println();
  try {
    const runner = await createRalphLoopRunner(flags, config);
    await runner.run();
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    log5.error("Loop execution failed", { error: message });
    UI.error(message);
    process.exit(1);
  }
  Se("Done!");
}
async function runSingleShotMode(config, flags, optimizedPrompt) {
  UI.header("Execution");
  const s = Y2();
  s.start("Connecting to OpenCode...");
  try {
    activeClient = await OpenCodeClient.create({
      existingServerUrl: process.env.OPENCODE_URL,
      serverStartupTimeout: 1e4
    });
    const openSession = await activeClient.createSession(optimizedPrompt);
    log5.info("Created OpenCode session", { id: openSession.id });
    s.stop("Connected");
    UI.println();
    UI.println(`${UI.Style.TEXT_DIM}Executing task...${UI.Style.TEXT_NORMAL}`);
    let response;
    if (!flags.noStream) {
      const streamingResponse = await openSession.sendMessageStream("Execute this task and provide a detailed result summary.");
      UI.println();
      const reader = streamingResponse.stream.getReader();
      const decoder = new TextDecoder;
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done)
            break;
          if (value) {
            const text = decoder.decode(value, { stream: true });
            UI.print(text);
          }
        }
      } finally {
        reader.releaseLock();
      }
      response = await streamingResponse.complete;
    } else {
      UI.println();
      UI.println(`${UI.Style.TEXT_DIM}Buffering response...${UI.Style.TEXT_NORMAL}`);
      response = await openSession.sendMessage("Execute this task and provide a detailed result summary.");
      UI.println();
      UI.println(response.content);
    }
    UI.println();
    UI.success("Execution complete");
    if (activeClient) {
      await activeClient.cleanup();
      activeClient = null;
    }
    log5.info("Execution complete");
  } catch (error) {
    s.stop("Connection failed");
    const message = error instanceof Error ? error.message : String(error);
    log5.error("Execution failed", { error: message });
    UI.error(message);
    if (activeClient) {
      try {
        await activeClient.cleanup();
      } catch (cleanupError) {
        const cleanupMsg = cleanupError instanceof Error ? cleanupError.message : String(cleanupError);
        log5.error("Error during error cleanup", { error: cleanupMsg });
      }
      activeClient = null;
    }
    process.exit(1);
  }
  Se("Done!");
}

// src/cli/run.ts
init_ui();
var TOP_HELP_TEXT = `
ai-eng - AI Engineering System CLI

USAGE:
  ai-eng <command> [options]
  ai-eng "prompt" [options]          # Shortcut: defaults to 'ralph'

COMMANDS:
  init [options]                     # Initialize .ai-eng/config.yaml with defaults
  ralph <prompt|workflow> [options]  # Iteration loop runner
  install [options]                  # Install OpenCode/Claude assets

GLOBAL OPTIONS:
  -h, --help                         Show this help message
  -v, --verbose                      Verbose output (DEBUG level logs)

EXAMPLES:
  ai-eng init                    # Initialize config with defaults
  ai-eng init --interactive       # Interactive config setup
  ai-eng "implement user authentication"
  ai-eng ralph "fix bug" --print-logs --log-level DEBUG
  ai-eng install --scope project
  ai-eng ralph feature-spec.yml --max-iters 5
  ai-eng ralph --tui --resume
  ai-eng ralph "make fleettools usable" --ship --max-cycles 30
  ai-eng ralph "make fleettools usable" --draft --max-cycles 10 --ci
`;
var INIT_HELP_TEXT = `
ai-eng init - Initialize .ai-eng/config.yaml with defaults

USAGE:
  ai-eng init [options]

OPTIONS:
  -i, --interactive    Interactive configuration setup
  --overwrite           Overwrite existing config file
  -h, --help          Show this help message
  -v, --verbose         Verbose output

EXAMPLES:
  ai-eng init                    # Create config with defaults
  ai-eng init --interactive       # Interactive setup with prompts
  ai-eng init --overwrite          # Replace existing config
`;
var INSTALL_HELP_TEXT = `
ai-eng install - Install OpenCode/Claude assets

USAGE:
  ai-eng install [options]

OPTIONS:
  --scope project|global|auto        Where to install (default: auto-detect)
  --dry-run                          Show what would be done without writing
  --yes                              Skip confirmation prompts
  -v, --verbose                      Verbose output

EXAMPLES:
  ai-eng install                          # Auto-detect project vs global
  ai-eng install --scope project          # Install to project .opencode/
  ai-eng install --scope global           # Install to ~/.config/opencode/
  ai-eng install --dry-run                # Preview operations
`;
var RALPH_HELP_TEXT = `
ai-eng ralph - Iteration loop runner for ai-eng-system

USAGE:
  ai-eng ralph <prompt|workflow> [options]

POSITIONAL:
  prompt/workflow    Task prompt or path to workflow specification

OPTIONS:
  --max-iters <n>     Maximum iterations (default: from config)
  --gates <g1,g2>     Comma-separated list of quality gates
  --review <mode>     Review mode: none|opencode|anthropic|both
  --resume            Resume previous run
  --run-id <id>       Specific run ID to resume
  --dry-run           Show what would be done without executing
  --ci                Run in CI mode (no interactive prompts)

  --print-logs        Print detailed logs to stderr
  --log-level <lvl>   Log level: DEBUG|INFO|WARN|ERROR (default: INFO)
  -v, --verbose       Verbose output (same as --log-level DEBUG)
  --tui               Use TUI mode instead of CLI
  --no-stream         Disable streaming output (buffered mode)

  --no-loop           Run single iteration only (disable loop mode)
  --completion <tok>  Loop exit token (required, e.g., --completion "<promise>DONE</promise>")
  --ship              Auto-exit when agent outputs "<promise>SHIP</promise>"
  --draft             Run for max-cycles then stop for your review (default behavior)
  --max-cycles <n>    Maximum loop cycles (default: 50)
  --stuck-threshold <n> Abort after N cycles with no progress (default: 5)
  --checkpoint <n>    Save checkpoint every N cycles (default: 1)
  --debug-work        Print every tool invocation input/output to console and logs

  --help              Show this help message

EXAMPLES:
  ai-eng ralph "implement user authentication"
  ai-eng ralph feature-spec.yml --max-iters 5
  ai-eng ralph "fix the bug" --print-logs --log-level DEBUG
  ai-eng ralph --tui --resume
  ai-eng ralph "make fleettools usable" --ship --max-cycles 30
  ai-eng ralph "make fleettools usable" --draft --max-cycles 10 --ci
  ai-eng ralph --no-loop "single-shot task"
`;
async function runInit(args) {
  const { values, positionals } = parseArgs({
    args,
    options: {
      interactive: { type: "boolean", short: "i" },
      overwrite: { type: "boolean" },
      help: { type: "boolean" },
      verbose: { type: "boolean", short: "v" }
    },
    allowPositionals: true
  });
  const flags = {
    interactive: values.interactive,
    overwrite: values.overwrite,
    help: values.help,
    verbose: values.verbose
  };
  if (flags.help) {
    console.log(INIT_HELP_TEXT);
    return;
  }
  await Log.init({
    print: false,
    level: flags.verbose ? "DEBUG" : "INFO",
    logDir: ".ai-eng/logs"
  });
  const { initConfig: initConfig2 } = await Promise.resolve().then(() => (init_init(), exports_init));
  await initConfig2(flags);
}
async function runInstall(args) {
  const { values, positionals } = parseArgs({
    args,
    options: {
      scope: { type: "string" },
      "dry-run": { type: "boolean" },
      yes: { type: "boolean" },
      verbose: { type: "boolean", short: "v" },
      help: { type: "boolean" }
    },
    allowPositionals: true
  });
  const flags = {
    scope: values.scope,
    dryRun: values["dry-run"],
    yes: values.yes,
    verbose: values.verbose,
    help: values.help
  };
  if (flags.help) {
    console.log(INSTALL_HELP_TEXT);
    return;
  }
  const { runInstaller: runInstaller2 } = await Promise.resolve().then(() => (init_install(), exports_install));
  await runInstaller2(flags);
}
function parseRalphFlags(args) {
  const { values, positionals } = parseArgs({
    args,
    options: {
      "max-iters": { type: "string" },
      gates: { type: "string" },
      review: { type: "string" },
      resume: { type: "boolean" },
      "run-id": { type: "string" },
      "dry-run": { type: "boolean" },
      ci: { type: "boolean" },
      help: { type: "boolean" },
      "print-logs": { type: "boolean" },
      "log-level": { type: "string" },
      verbose: { type: "boolean", short: "v" },
      tui: { type: "boolean" },
      "no-stream": { type: "boolean" },
      "no-loop": { type: "boolean" },
      completion: { type: "string" },
      ship: { type: "boolean" },
      draft: { type: "boolean" },
      "max-cycles": { type: "string" },
      "stuck-threshold": { type: "string" },
      checkpoint: { type: "string" },
      "debug-work": { type: "boolean" }
    },
    allowPositionals: true
  });
  const flags = {
    workflow: positionals[0],
    maxIters: values["max-iters"] ? Number.parseInt(values["max-iters"]) : undefined,
    gates: values.gates ? values.gates.split(",").map((g2) => g2.trim()) : undefined,
    review: values.review,
    resume: values.resume,
    runId: values["run-id"],
    dryRun: values["dry-run"],
    ci: values.ci,
    help: values.help,
    printLogs: values["print-logs"],
    logLevel: values["log-level"] ?? (values.verbose ? "DEBUG" : undefined),
    verbose: values.verbose,
    tui: values.tui,
    noStream: values["no-stream"],
    loop: !values["no-loop"],
    noLoop: values["no-loop"],
    completionPromise: values.completion,
    ship: values.ship,
    draft: values.draft,
    maxCycles: values["max-cycles"] ? Number.parseInt(values["max-cycles"]) : undefined,
    stuckThreshold: values["stuck-threshold"] ? Number.parseInt(values["stuck-threshold"]) : undefined,
    checkpointFrequency: values.checkpoint ? Number.parseInt(values.checkpoint) : undefined,
    debugWork: values["debug-work"]
  };
  return { flags, remaining: positionals.slice(1) };
}
async function runRalph(args) {
  const { flags } = parseRalphFlags(args);
  if (flags.help) {
    console.log(RALPH_HELP_TEXT);
    return;
  }
  await Log.init({
    print: flags.printLogs ?? false,
    level: flags.logLevel ?? "INFO",
    logDir: ".ai-eng/logs"
  });
  Log.Default.info("ai-eng ralph starting", {
    flags: JSON.stringify(flags)
  });
  const config = await loadConfig(flags);
  if (flags.tui) {
    UI.info("TUI mode requested - falling back to CLI mode");
    UI.info("(TUI requires: bun run --watch or full TUI setup)");
  }
  await runCli(config, flags);
}
async function main() {
  try {
    const rawArgs = process.argv.slice(2);
    if (rawArgs.length === 0 || rawArgs[0] === "--help" || rawArgs[0] === "-h") {
      console.log(TOP_HELP_TEXT);
      process.exit(0);
    }
    const subcommand = rawArgs[0];
    const subcommandArgs = rawArgs.slice(1);
    switch (subcommand) {
      case "init":
        await runInit(subcommandArgs);
        break;
      case "install":
      case "i":
        await runInstall(subcommandArgs);
        break;
      case "ralph":
      case "r":
        await runRalph(subcommandArgs);
        break;
      case "--help":
      case "-h":
        console.log(TOP_HELP_TEXT);
        break;
      default:
        await runRalph(rawArgs);
        break;
    }
  } catch (error) {
    UI.error(error instanceof Error ? error.message : String(error));
    process.exit(1);
  }
}
export {
  main as runMain
};

//# debugId=D84F3DD8B134EF4D64756E2164756E21
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9ub2Rlcy9pZGVudGl0eS5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3Zpc2l0LmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3QvZG9jL2RpcmVjdGl2ZXMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9kb2MvYW5jaG9ycy5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L2RvYy9hcHBseVJldml2ZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9ub2Rlcy90b0pTLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3Qvbm9kZXMvTm9kZS5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L25vZGVzL0FsaWFzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3Qvbm9kZXMvU2NhbGFyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3QvZG9jL2NyZWF0ZU5vZGUuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9ub2Rlcy9Db2xsZWN0aW9uLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3Qvc3RyaW5naWZ5L3N0cmluZ2lmeUNvbW1lbnQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9zdHJpbmdpZnkvZm9sZEZsb3dMaW5lcy5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3N0cmluZ2lmeS9zdHJpbmdpZnlTdHJpbmcuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9zdHJpbmdpZnkvc3RyaW5naWZ5LmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3Qvc3RyaW5naWZ5L3N0cmluZ2lmeVBhaXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9sb2cuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9zY2hlbWEveWFtbC0xLjEvbWVyZ2UuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9ub2Rlcy9hZGRQYWlyVG9KU01hcC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L25vZGVzL1BhaXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9zdHJpbmdpZnkvc3RyaW5naWZ5Q29sbGVjdGlvbi5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L25vZGVzL1lBTUxNYXAuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9zY2hlbWEvY29tbW9uL21hcC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L25vZGVzL1lBTUxTZXEuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9zY2hlbWEvY29tbW9uL3NlcS5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3NjaGVtYS9jb21tb24vc3RyaW5nLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3Qvc2NoZW1hL2NvbW1vbi9udWxsLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3Qvc2NoZW1hL2NvcmUvYm9vbC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3N0cmluZ2lmeS9zdHJpbmdpZnlOdW1iZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9zY2hlbWEvY29yZS9mbG9hdC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3NjaGVtYS9jb3JlL2ludC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3NjaGVtYS9jb3JlL3NjaGVtYS5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3NjaGVtYS9qc29uL3NjaGVtYS5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3NjaGVtYS95YW1sLTEuMS9iaW5hcnkuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9zY2hlbWEveWFtbC0xLjEvcGFpcnMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9zY2hlbWEveWFtbC0xLjEvb21hcC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3NjaGVtYS95YW1sLTEuMS9ib29sLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3Qvc2NoZW1hL3lhbWwtMS4xL2Zsb2F0LmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3Qvc2NoZW1hL3lhbWwtMS4xL2ludC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3NjaGVtYS95YW1sLTEuMS9zZXQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9zY2hlbWEveWFtbC0xLjEvdGltZXN0YW1wLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3Qvc2NoZW1hL3lhbWwtMS4xL3NjaGVtYS5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3NjaGVtYS90YWdzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3Qvc2NoZW1hL1NjaGVtYS5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3N0cmluZ2lmeS9zdHJpbmdpZnlEb2N1bWVudC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L2RvYy9Eb2N1bWVudC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L2Vycm9ycy5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L2NvbXBvc2UvcmVzb2x2ZS1wcm9wcy5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L2NvbXBvc2UvdXRpbC1jb250YWlucy1uZXdsaW5lLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3QvY29tcG9zZS91dGlsLWZsb3ctaW5kZW50LWNoZWNrLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3QvY29tcG9zZS91dGlsLW1hcC1pbmNsdWRlcy5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L2NvbXBvc2UvcmVzb2x2ZS1ibG9jay1tYXAuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9jb21wb3NlL3Jlc29sdmUtYmxvY2stc2VxLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3QvY29tcG9zZS9yZXNvbHZlLWVuZC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L2NvbXBvc2UvcmVzb2x2ZS1mbG93LWNvbGxlY3Rpb24uanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9jb21wb3NlL2NvbXBvc2UtY29sbGVjdGlvbi5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L2NvbXBvc2UvcmVzb2x2ZS1ibG9jay1zY2FsYXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9jb21wb3NlL3Jlc29sdmUtZmxvdy1zY2FsYXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9jb21wb3NlL2NvbXBvc2Utc2NhbGFyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3QvY29tcG9zZS91dGlsLWVtcHR5LXNjYWxhci1wb3NpdGlvbi5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L2NvbXBvc2UvY29tcG9zZS1ub2RlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3QvY29tcG9zZS9jb21wb3NlLWRvYy5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L2NvbXBvc2UvY29tcG9zZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9wYXJzZS9jc3Qtc2NhbGFyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3QvcGFyc2UvY3N0LXN0cmluZ2lmeS5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3BhcnNlL2NzdC12aXNpdC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3BhcnNlL2NzdC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3BhcnNlL2xleGVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3QvcGFyc2UvbGluZS1jb3VudGVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3QvcGFyc2UvcGFyc2VyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3QvcHVibGljLWFwaS5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L2luZGV4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zaXN0ZXJhbnNpL3NyYy9pbmRleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvcGljb2NvbG9ycy9waWNvY29sb3JzLmpzIiwgIi4uL3NyYy9jbGkvdWkudHMiLCAiLi4vc3JjL2luc3RhbGwvaW5pdC50cyIsICIuLi9zcmMvaW5zdGFsbC9pbnN0YWxsLnRzIiwgIi4uL3NyYy9jbGkvcnVuLnRzIiwgIi4uL3NyYy9jb25maWcvbG9hZENvbmZpZy50cyIsICIuLi9zcmMvY29uZmlnL3NjaGVtYS50cyIsICIuLi9zcmMvdXRpbC9sb2cudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BjbGFjay9jb3JlL2Rpc3QvaW5kZXgubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9AY2xhY2svcHJvbXB0cy9kaXN0L2luZGV4Lm1qcyIsICIuLi9zcmMvYmFja2VuZHMvb3BlbmNvZGUvY2xpZW50LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9Ab3BlbmNvZGUtYWkvc2RrL2Rpc3QvZ2VuL2NvcmUvc2VydmVyU2VudEV2ZW50cy5nZW4uanMiLCAiLi4vbm9kZV9tb2R1bGVzL0BvcGVuY29kZS1haS9zZGsvZGlzdC9nZW4vY29yZS9hdXRoLmdlbi5qcyIsICIuLi9ub2RlX21vZHVsZXMvQG9wZW5jb2RlLWFpL3Nkay9kaXN0L2dlbi9jb3JlL2JvZHlTZXJpYWxpemVyLmdlbi5qcyIsICIuLi9ub2RlX21vZHVsZXMvQG9wZW5jb2RlLWFpL3Nkay9kaXN0L2dlbi9jb3JlL3BhdGhTZXJpYWxpemVyLmdlbi5qcyIsICIuLi9ub2RlX21vZHVsZXMvQG9wZW5jb2RlLWFpL3Nkay9kaXN0L2dlbi9jb3JlL3V0aWxzLmdlbi5qcyIsICIuLi9ub2RlX21vZHVsZXMvQG9wZW5jb2RlLWFpL3Nkay9kaXN0L2dlbi9jbGllbnQvdXRpbHMuZ2VuLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9Ab3BlbmNvZGUtYWkvc2RrL2Rpc3QvZ2VuL2NsaWVudC9jbGllbnQuZ2VuLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9Ab3BlbmNvZGUtYWkvc2RrL2Rpc3QvZ2VuL2NvcmUvcGFyYW1zLmdlbi5qcyIsICIuLi9ub2RlX21vZHVsZXMvQG9wZW5jb2RlLWFpL3Nkay9kaXN0L2dlbi9jbGllbnQuZ2VuLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9Ab3BlbmNvZGUtYWkvc2RrL2Rpc3QvZ2VuL3Nkay5nZW4uanMiLCAiLi4vbm9kZV9tb2R1bGVzL0BvcGVuY29kZS1haS9zZGsvZGlzdC9jbGllbnQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0BvcGVuY29kZS1haS9zZGsvZGlzdC9zZXJ2ZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0BvcGVuY29kZS1haS9zZGsvZGlzdC9pbmRleC5qcyIsICIuLi9zcmMvZXhlY3V0aW9uL3JhbHBoLWxvb3AudHMiLCAiLi4vc3JjL3Byb21wdC1vcHRpbWl6YXRpb24vYW5hbHl6ZXIudHMiLCAiLi4vc3JjL3Byb21wdC1vcHRpbWl6YXRpb24vdGVjaG5pcXVlcy50cyIsICIuLi9zcmMvcHJvbXB0LW9wdGltaXphdGlvbi9vcHRpbWl6ZXIudHMiLCAiLi4vc3JjL3V0aWwvZGlzY29yZC13ZWJob29rLnRzIiwgIi4uL3NyYy9leGVjdXRpb24vZmxvdy1zdG9yZS50cyIsICIuLi9zcmMvZXhlY3V0aW9uL2Zsb3ctdHlwZXMudHMiLCAiLi4vc3JjL2NsaS9ydW4tY2xpLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWwogICAgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQUxJQVMgPSBTeW1ib2wuZm9yKCd5YW1sLmFsaWFzJyk7XG5jb25zdCBET0MgPSBTeW1ib2wuZm9yKCd5YW1sLmRvY3VtZW50Jyk7XG5jb25zdCBNQVAgPSBTeW1ib2wuZm9yKCd5YW1sLm1hcCcpO1xuY29uc3QgUEFJUiA9IFN5bWJvbC5mb3IoJ3lhbWwucGFpcicpO1xuY29uc3QgU0NBTEFSID0gU3ltYm9sLmZvcigneWFtbC5zY2FsYXInKTtcbmNvbnN0IFNFUSA9IFN5bWJvbC5mb3IoJ3lhbWwuc2VxJyk7XG5jb25zdCBOT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCd5YW1sLm5vZGUudHlwZScpO1xuY29uc3QgaXNBbGlhcyA9IChub2RlKSA9PiAhIW5vZGUgJiYgdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnICYmIG5vZGVbTk9ERV9UWVBFXSA9PT0gQUxJQVM7XG5jb25zdCBpc0RvY3VtZW50ID0gKG5vZGUpID0+ICEhbm9kZSAmJiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiYgbm9kZVtOT0RFX1RZUEVdID09PSBET0M7XG5jb25zdCBpc01hcCA9IChub2RlKSA9PiAhIW5vZGUgJiYgdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnICYmIG5vZGVbTk9ERV9UWVBFXSA9PT0gTUFQO1xuY29uc3QgaXNQYWlyID0gKG5vZGUpID0+ICEhbm9kZSAmJiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiYgbm9kZVtOT0RFX1RZUEVdID09PSBQQUlSO1xuY29uc3QgaXNTY2FsYXIgPSAobm9kZSkgPT4gISFub2RlICYmIHR5cGVvZiBub2RlID09PSAnb2JqZWN0JyAmJiBub2RlW05PREVfVFlQRV0gPT09IFNDQUxBUjtcbmNvbnN0IGlzU2VxID0gKG5vZGUpID0+ICEhbm9kZSAmJiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiYgbm9kZVtOT0RFX1RZUEVdID09PSBTRVE7XG5mdW5jdGlvbiBpc0NvbGxlY3Rpb24obm9kZSkge1xuICAgIGlmIChub2RlICYmIHR5cGVvZiBub2RlID09PSAnb2JqZWN0JylcbiAgICAgICAgc3dpdGNoIChub2RlW05PREVfVFlQRV0pIHtcbiAgICAgICAgICAgIGNhc2UgTUFQOlxuICAgICAgICAgICAgY2FzZSBTRVE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc05vZGUobm9kZSkge1xuICAgIGlmIChub2RlICYmIHR5cGVvZiBub2RlID09PSAnb2JqZWN0JylcbiAgICAgICAgc3dpdGNoIChub2RlW05PREVfVFlQRV0pIHtcbiAgICAgICAgICAgIGNhc2UgQUxJQVM6XG4gICAgICAgICAgICBjYXNlIE1BUDpcbiAgICAgICAgICAgIGNhc2UgU0NBTEFSOlxuICAgICAgICAgICAgY2FzZSBTRVE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5jb25zdCBoYXNBbmNob3IgPSAobm9kZSkgPT4gKGlzU2NhbGFyKG5vZGUpIHx8IGlzQ29sbGVjdGlvbihub2RlKSkgJiYgISFub2RlLmFuY2hvcjtcblxuZXhwb3J0cy5BTElBUyA9IEFMSUFTO1xuZXhwb3J0cy5ET0MgPSBET0M7XG5leHBvcnRzLk1BUCA9IE1BUDtcbmV4cG9ydHMuTk9ERV9UWVBFID0gTk9ERV9UWVBFO1xuZXhwb3J0cy5QQUlSID0gUEFJUjtcbmV4cG9ydHMuU0NBTEFSID0gU0NBTEFSO1xuZXhwb3J0cy5TRVEgPSBTRVE7XG5leHBvcnRzLmhhc0FuY2hvciA9IGhhc0FuY2hvcjtcbmV4cG9ydHMuaXNBbGlhcyA9IGlzQWxpYXM7XG5leHBvcnRzLmlzQ29sbGVjdGlvbiA9IGlzQ29sbGVjdGlvbjtcbmV4cG9ydHMuaXNEb2N1bWVudCA9IGlzRG9jdW1lbnQ7XG5leHBvcnRzLmlzTWFwID0gaXNNYXA7XG5leHBvcnRzLmlzTm9kZSA9IGlzTm9kZTtcbmV4cG9ydHMuaXNQYWlyID0gaXNQYWlyO1xuZXhwb3J0cy5pc1NjYWxhciA9IGlzU2NhbGFyO1xuZXhwb3J0cy5pc1NlcSA9IGlzU2VxO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vbm9kZXMvaWRlbnRpdHkuanMnKTtcblxuY29uc3QgQlJFQUsgPSBTeW1ib2woJ2JyZWFrIHZpc2l0Jyk7XG5jb25zdCBTS0lQID0gU3ltYm9sKCdza2lwIGNoaWxkcmVuJyk7XG5jb25zdCBSRU1PVkUgPSBTeW1ib2woJ3JlbW92ZSBub2RlJyk7XG4vKipcbiAqIEFwcGx5IGEgdmlzaXRvciB0byBhbiBBU1Qgbm9kZSBvciBkb2N1bWVudC5cbiAqXG4gKiBXYWxrcyB0aHJvdWdoIHRoZSB0cmVlIChkZXB0aC1maXJzdCkgc3RhcnRpbmcgZnJvbSBgbm9kZWAsIGNhbGxpbmcgYVxuICogYHZpc2l0b3JgIGZ1bmN0aW9uIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICogICAtIGBrZXlgOiBGb3Igc2VxdWVuY2UgdmFsdWVzIGFuZCBtYXAgYFBhaXJgLCB0aGUgbm9kZSdzIGluZGV4IGluIHRoZVxuICogICAgIGNvbGxlY3Rpb24uIFdpdGhpbiBhIGBQYWlyYCwgYCdrZXknYCBvciBgJ3ZhbHVlJ2AsIGNvcnJlc3BvbmRpbmdseS5cbiAqICAgICBgbnVsbGAgZm9yIHRoZSByb290IG5vZGUuXG4gKiAgIC0gYG5vZGVgOiBUaGUgY3VycmVudCBub2RlLlxuICogICAtIGBwYXRoYDogVGhlIGFuY2VzdHJ5IG9mIHRoZSBjdXJyZW50IG5vZGUuXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgdmlzaXRvciBtYXkgYmUgdXNlZCB0byBjb250cm9sIHRoZSB0cmF2ZXJzYWw6XG4gKiAgIC0gYHVuZGVmaW5lZGAgKGRlZmF1bHQpOiBEbyBub3RoaW5nIGFuZCBjb250aW51ZVxuICogICAtIGB2aXNpdC5TS0lQYDogRG8gbm90IHZpc2l0IHRoZSBjaGlsZHJlbiBvZiB0aGlzIG5vZGUsIGNvbnRpbnVlIHdpdGggbmV4dFxuICogICAgIHNpYmxpbmdcbiAqICAgLSBgdmlzaXQuQlJFQUtgOiBUZXJtaW5hdGUgdHJhdmVyc2FsIGNvbXBsZXRlbHlcbiAqICAgLSBgdmlzaXQuUkVNT1ZFYDogUmVtb3ZlIHRoZSBjdXJyZW50IG5vZGUsIHRoZW4gY29udGludWUgd2l0aCB0aGUgbmV4dCBvbmVcbiAqICAgLSBgTm9kZWA6IFJlcGxhY2UgdGhlIGN1cnJlbnQgbm9kZSwgdGhlbiBjb250aW51ZSBieSB2aXNpdGluZyBpdFxuICogICAtIGBudW1iZXJgOiBXaGlsZSBpdGVyYXRpbmcgdGhlIGl0ZW1zIG9mIGEgc2VxdWVuY2Ugb3IgbWFwLCBzZXQgdGhlIGluZGV4XG4gKiAgICAgb2YgdGhlIG5leHQgc3RlcC4gVGhpcyBpcyB1c2VmdWwgZXNwZWNpYWxseSBpZiB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnRcbiAqICAgICBub2RlIGhhcyBjaGFuZ2VkLlxuICpcbiAqIElmIGB2aXNpdG9yYCBpcyBhIHNpbmdsZSBmdW5jdGlvbiwgaXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBhbGwgdmFsdWVzXG4gKiBlbmNvdW50ZXJlZCBpbiB0aGUgdHJlZSwgaW5jbHVkaW5nIGUuZy4gYG51bGxgIHZhbHVlcy4gQWx0ZXJuYXRpdmVseSxcbiAqIHNlcGFyYXRlIHZpc2l0b3IgZnVuY3Rpb25zIG1heSBiZSBkZWZpbmVkIGZvciBlYWNoIGBNYXBgLCBgUGFpcmAsIGBTZXFgLFxuICogYEFsaWFzYCBhbmQgYFNjYWxhcmAgbm9kZS4gVG8gZGVmaW5lIHRoZSBzYW1lIHZpc2l0b3IgZnVuY3Rpb24gZm9yIG1vcmUgdGhhblxuICogb25lIG5vZGUgdHlwZSwgdXNlIHRoZSBgQ29sbGVjdGlvbmAgKG1hcCBhbmQgc2VxKSwgYFZhbHVlYCAobWFwLCBzZXEgJiBzY2FsYXIpXG4gKiBhbmQgYE5vZGVgIChhbGlhcywgbWFwLCBzZXEgJiBzY2FsYXIpIHRhcmdldHMuIE9mIGFsbCB0aGVzZSwgb25seSB0aGUgbW9zdFxuICogc3BlY2lmaWMgZGVmaW5lZCBvbmUgd2lsbCBiZSB1c2VkIGZvciBlYWNoIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIHZpc2l0KG5vZGUsIHZpc2l0b3IpIHtcbiAgICBjb25zdCB2aXNpdG9yXyA9IGluaXRWaXNpdG9yKHZpc2l0b3IpO1xuICAgIGlmIChpZGVudGl0eS5pc0RvY3VtZW50KG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGNkID0gdmlzaXRfKG51bGwsIG5vZGUuY29udGVudHMsIHZpc2l0b3JfLCBPYmplY3QuZnJlZXplKFtub2RlXSkpO1xuICAgICAgICBpZiAoY2QgPT09IFJFTU9WRSlcbiAgICAgICAgICAgIG5vZGUuY29udGVudHMgPSBudWxsO1xuICAgIH1cbiAgICBlbHNlXG4gICAgICAgIHZpc2l0XyhudWxsLCBub2RlLCB2aXNpdG9yXywgT2JqZWN0LmZyZWV6ZShbXSkpO1xufVxuLy8gV2l0aG91dCB0aGUgYGFzIHN5bWJvbGAgY2FzdHMsIFRTIGRlY2xhcmVzIHRoZXNlIGluIHRoZSBgdmlzaXRgXG4vLyBuYW1lc3BhY2UgdXNpbmcgYHZhcmAsIGJ1dCB0aGVuIGNvbXBsYWlucyBhYm91dCB0aGF0IGJlY2F1c2Vcbi8vIGB1bmlxdWUgc3ltYm9sYCBtdXN0IGJlIGBjb25zdGAuXG4vKiogVGVybWluYXRlIHZpc2l0IHRyYXZlcnNhbCBjb21wbGV0ZWx5ICovXG52aXNpdC5CUkVBSyA9IEJSRUFLO1xuLyoqIERvIG5vdCB2aXNpdCB0aGUgY2hpbGRyZW4gb2YgdGhlIGN1cnJlbnQgbm9kZSAqL1xudmlzaXQuU0tJUCA9IFNLSVA7XG4vKiogUmVtb3ZlIHRoZSBjdXJyZW50IG5vZGUgKi9cbnZpc2l0LlJFTU9WRSA9IFJFTU9WRTtcbmZ1bmN0aW9uIHZpc2l0XyhrZXksIG5vZGUsIHZpc2l0b3IsIHBhdGgpIHtcbiAgICBjb25zdCBjdHJsID0gY2FsbFZpc2l0b3Ioa2V5LCBub2RlLCB2aXNpdG9yLCBwYXRoKTtcbiAgICBpZiAoaWRlbnRpdHkuaXNOb2RlKGN0cmwpIHx8IGlkZW50aXR5LmlzUGFpcihjdHJsKSkge1xuICAgICAgICByZXBsYWNlTm9kZShrZXksIHBhdGgsIGN0cmwpO1xuICAgICAgICByZXR1cm4gdmlzaXRfKGtleSwgY3RybCwgdmlzaXRvciwgcGF0aCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY3RybCAhPT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgaWYgKGlkZW50aXR5LmlzQ29sbGVjdGlvbihub2RlKSkge1xuICAgICAgICAgICAgcGF0aCA9IE9iamVjdC5mcmVlemUocGF0aC5jb25jYXQobm9kZSkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLml0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2kgPSB2aXNpdF8oaSwgbm9kZS5pdGVtc1tpXSwgdmlzaXRvciwgcGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgICAgIGkgPSBjaSAtIDE7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2kgPT09IEJSRUFLKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQlJFQUs7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2kgPT09IFJFTU9WRSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLml0ZW1zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpZGVudGl0eS5pc1BhaXIobm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGggPSBPYmplY3QuZnJlZXplKHBhdGguY29uY2F0KG5vZGUpKTtcbiAgICAgICAgICAgIGNvbnN0IGNrID0gdmlzaXRfKCdrZXknLCBub2RlLmtleSwgdmlzaXRvciwgcGF0aCk7XG4gICAgICAgICAgICBpZiAoY2sgPT09IEJSRUFLKVxuICAgICAgICAgICAgICAgIHJldHVybiBCUkVBSztcbiAgICAgICAgICAgIGVsc2UgaWYgKGNrID09PSBSRU1PVkUpXG4gICAgICAgICAgICAgICAgbm9kZS5rZXkgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgY3YgPSB2aXNpdF8oJ3ZhbHVlJywgbm9kZS52YWx1ZSwgdmlzaXRvciwgcGF0aCk7XG4gICAgICAgICAgICBpZiAoY3YgPT09IEJSRUFLKVxuICAgICAgICAgICAgICAgIHJldHVybiBCUkVBSztcbiAgICAgICAgICAgIGVsc2UgaWYgKGN2ID09PSBSRU1PVkUpXG4gICAgICAgICAgICAgICAgbm9kZS52YWx1ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGN0cmw7XG59XG4vKipcbiAqIEFwcGx5IGFuIGFzeW5jIHZpc2l0b3IgdG8gYW4gQVNUIG5vZGUgb3IgZG9jdW1lbnQuXG4gKlxuICogV2Fsa3MgdGhyb3VnaCB0aGUgdHJlZSAoZGVwdGgtZmlyc3QpIHN0YXJ0aW5nIGZyb20gYG5vZGVgLCBjYWxsaW5nIGFcbiAqIGB2aXNpdG9yYCBmdW5jdGlvbiB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAqICAgLSBga2V5YDogRm9yIHNlcXVlbmNlIHZhbHVlcyBhbmQgbWFwIGBQYWlyYCwgdGhlIG5vZGUncyBpbmRleCBpbiB0aGVcbiAqICAgICBjb2xsZWN0aW9uLiBXaXRoaW4gYSBgUGFpcmAsIGAna2V5J2Agb3IgYCd2YWx1ZSdgLCBjb3JyZXNwb25kaW5nbHkuXG4gKiAgICAgYG51bGxgIGZvciB0aGUgcm9vdCBub2RlLlxuICogICAtIGBub2RlYDogVGhlIGN1cnJlbnQgbm9kZS5cbiAqICAgLSBgcGF0aGA6IFRoZSBhbmNlc3RyeSBvZiB0aGUgY3VycmVudCBub2RlLlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHZpc2l0b3IgbWF5IGJlIHVzZWQgdG8gY29udHJvbCB0aGUgdHJhdmVyc2FsOlxuICogICAtIGBQcm9taXNlYDogTXVzdCByZXNvbHZlIHRvIG9uZSBvZiB0aGUgZm9sbG93aW5nIHZhbHVlc1xuICogICAtIGB1bmRlZmluZWRgIChkZWZhdWx0KTogRG8gbm90aGluZyBhbmQgY29udGludWVcbiAqICAgLSBgdmlzaXQuU0tJUGA6IERvIG5vdCB2aXNpdCB0aGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlLCBjb250aW51ZSB3aXRoIG5leHRcbiAqICAgICBzaWJsaW5nXG4gKiAgIC0gYHZpc2l0LkJSRUFLYDogVGVybWluYXRlIHRyYXZlcnNhbCBjb21wbGV0ZWx5XG4gKiAgIC0gYHZpc2l0LlJFTU9WRWA6IFJlbW92ZSB0aGUgY3VycmVudCBub2RlLCB0aGVuIGNvbnRpbnVlIHdpdGggdGhlIG5leHQgb25lXG4gKiAgIC0gYE5vZGVgOiBSZXBsYWNlIHRoZSBjdXJyZW50IG5vZGUsIHRoZW4gY29udGludWUgYnkgdmlzaXRpbmcgaXRcbiAqICAgLSBgbnVtYmVyYDogV2hpbGUgaXRlcmF0aW5nIHRoZSBpdGVtcyBvZiBhIHNlcXVlbmNlIG9yIG1hcCwgc2V0IHRoZSBpbmRleFxuICogICAgIG9mIHRoZSBuZXh0IHN0ZXAuIFRoaXMgaXMgdXNlZnVsIGVzcGVjaWFsbHkgaWYgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50XG4gKiAgICAgbm9kZSBoYXMgY2hhbmdlZC5cbiAqXG4gKiBJZiBgdmlzaXRvcmAgaXMgYSBzaW5nbGUgZnVuY3Rpb24sIGl0IHdpbGwgYmUgY2FsbGVkIHdpdGggYWxsIHZhbHVlc1xuICogZW5jb3VudGVyZWQgaW4gdGhlIHRyZWUsIGluY2x1ZGluZyBlLmcuIGBudWxsYCB2YWx1ZXMuIEFsdGVybmF0aXZlbHksXG4gKiBzZXBhcmF0ZSB2aXNpdG9yIGZ1bmN0aW9ucyBtYXkgYmUgZGVmaW5lZCBmb3IgZWFjaCBgTWFwYCwgYFBhaXJgLCBgU2VxYCxcbiAqIGBBbGlhc2AgYW5kIGBTY2FsYXJgIG5vZGUuIFRvIGRlZmluZSB0aGUgc2FtZSB2aXNpdG9yIGZ1bmN0aW9uIGZvciBtb3JlIHRoYW5cbiAqIG9uZSBub2RlIHR5cGUsIHVzZSB0aGUgYENvbGxlY3Rpb25gIChtYXAgYW5kIHNlcSksIGBWYWx1ZWAgKG1hcCwgc2VxICYgc2NhbGFyKVxuICogYW5kIGBOb2RlYCAoYWxpYXMsIG1hcCwgc2VxICYgc2NhbGFyKSB0YXJnZXRzLiBPZiBhbGwgdGhlc2UsIG9ubHkgdGhlIG1vc3RcbiAqIHNwZWNpZmljIGRlZmluZWQgb25lIHdpbGwgYmUgdXNlZCBmb3IgZWFjaCBub2RlLlxuICovXG5hc3luYyBmdW5jdGlvbiB2aXNpdEFzeW5jKG5vZGUsIHZpc2l0b3IpIHtcbiAgICBjb25zdCB2aXNpdG9yXyA9IGluaXRWaXNpdG9yKHZpc2l0b3IpO1xuICAgIGlmIChpZGVudGl0eS5pc0RvY3VtZW50KG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGNkID0gYXdhaXQgdmlzaXRBc3luY18obnVsbCwgbm9kZS5jb250ZW50cywgdmlzaXRvcl8sIE9iamVjdC5mcmVlemUoW25vZGVdKSk7XG4gICAgICAgIGlmIChjZCA9PT0gUkVNT1ZFKVxuICAgICAgICAgICAgbm9kZS5jb250ZW50cyA9IG51bGw7XG4gICAgfVxuICAgIGVsc2VcbiAgICAgICAgYXdhaXQgdmlzaXRBc3luY18obnVsbCwgbm9kZSwgdmlzaXRvcl8sIE9iamVjdC5mcmVlemUoW10pKTtcbn1cbi8vIFdpdGhvdXQgdGhlIGBhcyBzeW1ib2xgIGNhc3RzLCBUUyBkZWNsYXJlcyB0aGVzZSBpbiB0aGUgYHZpc2l0YFxuLy8gbmFtZXNwYWNlIHVzaW5nIGB2YXJgLCBidXQgdGhlbiBjb21wbGFpbnMgYWJvdXQgdGhhdCBiZWNhdXNlXG4vLyBgdW5pcXVlIHN5bWJvbGAgbXVzdCBiZSBgY29uc3RgLlxuLyoqIFRlcm1pbmF0ZSB2aXNpdCB0cmF2ZXJzYWwgY29tcGxldGVseSAqL1xudmlzaXRBc3luYy5CUkVBSyA9IEJSRUFLO1xuLyoqIERvIG5vdCB2aXNpdCB0aGUgY2hpbGRyZW4gb2YgdGhlIGN1cnJlbnQgbm9kZSAqL1xudmlzaXRBc3luYy5TS0lQID0gU0tJUDtcbi8qKiBSZW1vdmUgdGhlIGN1cnJlbnQgbm9kZSAqL1xudmlzaXRBc3luYy5SRU1PVkUgPSBSRU1PVkU7XG5hc3luYyBmdW5jdGlvbiB2aXNpdEFzeW5jXyhrZXksIG5vZGUsIHZpc2l0b3IsIHBhdGgpIHtcbiAgICBjb25zdCBjdHJsID0gYXdhaXQgY2FsbFZpc2l0b3Ioa2V5LCBub2RlLCB2aXNpdG9yLCBwYXRoKTtcbiAgICBpZiAoaWRlbnRpdHkuaXNOb2RlKGN0cmwpIHx8IGlkZW50aXR5LmlzUGFpcihjdHJsKSkge1xuICAgICAgICByZXBsYWNlTm9kZShrZXksIHBhdGgsIGN0cmwpO1xuICAgICAgICByZXR1cm4gdmlzaXRBc3luY18oa2V5LCBjdHJsLCB2aXNpdG9yLCBwYXRoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjdHJsICE9PSAnc3ltYm9sJykge1xuICAgICAgICBpZiAoaWRlbnRpdHkuaXNDb2xsZWN0aW9uKG5vZGUpKSB7XG4gICAgICAgICAgICBwYXRoID0gT2JqZWN0LmZyZWV6ZShwYXRoLmNvbmNhdChub2RlKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaSA9IGF3YWl0IHZpc2l0QXN5bmNfKGksIG5vZGUuaXRlbXNbaV0sIHZpc2l0b3IsIHBhdGgpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2kgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgICAgICBpID0gY2kgLSAxO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNpID09PSBCUkVBSylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJSRUFLO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNpID09PSBSRU1PVkUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5pdGVtcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaWRlbnRpdHkuaXNQYWlyKG5vZGUpKSB7XG4gICAgICAgICAgICBwYXRoID0gT2JqZWN0LmZyZWV6ZShwYXRoLmNvbmNhdChub2RlKSk7XG4gICAgICAgICAgICBjb25zdCBjayA9IGF3YWl0IHZpc2l0QXN5bmNfKCdrZXknLCBub2RlLmtleSwgdmlzaXRvciwgcGF0aCk7XG4gICAgICAgICAgICBpZiAoY2sgPT09IEJSRUFLKVxuICAgICAgICAgICAgICAgIHJldHVybiBCUkVBSztcbiAgICAgICAgICAgIGVsc2UgaWYgKGNrID09PSBSRU1PVkUpXG4gICAgICAgICAgICAgICAgbm9kZS5rZXkgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgY3YgPSBhd2FpdCB2aXNpdEFzeW5jXygndmFsdWUnLCBub2RlLnZhbHVlLCB2aXNpdG9yLCBwYXRoKTtcbiAgICAgICAgICAgIGlmIChjdiA9PT0gQlJFQUspXG4gICAgICAgICAgICAgICAgcmV0dXJuIEJSRUFLO1xuICAgICAgICAgICAgZWxzZSBpZiAoY3YgPT09IFJFTU9WRSlcbiAgICAgICAgICAgICAgICBub2RlLnZhbHVlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3RybDtcbn1cbmZ1bmN0aW9uIGluaXRWaXNpdG9yKHZpc2l0b3IpIHtcbiAgICBpZiAodHlwZW9mIHZpc2l0b3IgPT09ICdvYmplY3QnICYmXG4gICAgICAgICh2aXNpdG9yLkNvbGxlY3Rpb24gfHwgdmlzaXRvci5Ob2RlIHx8IHZpc2l0b3IuVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIEFsaWFzOiB2aXNpdG9yLk5vZGUsXG4gICAgICAgICAgICBNYXA6IHZpc2l0b3IuTm9kZSxcbiAgICAgICAgICAgIFNjYWxhcjogdmlzaXRvci5Ob2RlLFxuICAgICAgICAgICAgU2VxOiB2aXNpdG9yLk5vZGVcbiAgICAgICAgfSwgdmlzaXRvci5WYWx1ZSAmJiB7XG4gICAgICAgICAgICBNYXA6IHZpc2l0b3IuVmFsdWUsXG4gICAgICAgICAgICBTY2FsYXI6IHZpc2l0b3IuVmFsdWUsXG4gICAgICAgICAgICBTZXE6IHZpc2l0b3IuVmFsdWVcbiAgICAgICAgfSwgdmlzaXRvci5Db2xsZWN0aW9uICYmIHtcbiAgICAgICAgICAgIE1hcDogdmlzaXRvci5Db2xsZWN0aW9uLFxuICAgICAgICAgICAgU2VxOiB2aXNpdG9yLkNvbGxlY3Rpb25cbiAgICAgICAgfSwgdmlzaXRvcik7XG4gICAgfVxuICAgIHJldHVybiB2aXNpdG9yO1xufVxuZnVuY3Rpb24gY2FsbFZpc2l0b3Ioa2V5LCBub2RlLCB2aXNpdG9yLCBwYXRoKSB7XG4gICAgaWYgKHR5cGVvZiB2aXNpdG9yID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gdmlzaXRvcihrZXksIG5vZGUsIHBhdGgpO1xuICAgIGlmIChpZGVudGl0eS5pc01hcChub2RlKSlcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuTWFwPy4oa2V5LCBub2RlLCBwYXRoKTtcbiAgICBpZiAoaWRlbnRpdHkuaXNTZXEobm9kZSkpXG4gICAgICAgIHJldHVybiB2aXNpdG9yLlNlcT8uKGtleSwgbm9kZSwgcGF0aCk7XG4gICAgaWYgKGlkZW50aXR5LmlzUGFpcihub2RlKSlcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuUGFpcj8uKGtleSwgbm9kZSwgcGF0aCk7XG4gICAgaWYgKGlkZW50aXR5LmlzU2NhbGFyKG5vZGUpKVxuICAgICAgICByZXR1cm4gdmlzaXRvci5TY2FsYXI/LihrZXksIG5vZGUsIHBhdGgpO1xuICAgIGlmIChpZGVudGl0eS5pc0FsaWFzKG5vZGUpKVxuICAgICAgICByZXR1cm4gdmlzaXRvci5BbGlhcz8uKGtleSwgbm9kZSwgcGF0aCk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VOb2RlKGtleSwgcGF0aCwgbm9kZSkge1xuICAgIGNvbnN0IHBhcmVudCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICBpZiAoaWRlbnRpdHkuaXNDb2xsZWN0aW9uKHBhcmVudCkpIHtcbiAgICAgICAgcGFyZW50Lml0ZW1zW2tleV0gPSBub2RlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpZGVudGl0eS5pc1BhaXIocGFyZW50KSkge1xuICAgICAgICBpZiAoa2V5ID09PSAna2V5JylcbiAgICAgICAgICAgIHBhcmVudC5rZXkgPSBub2RlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBwYXJlbnQudmFsdWUgPSBub2RlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpZGVudGl0eS5pc0RvY3VtZW50KHBhcmVudCkpIHtcbiAgICAgICAgcGFyZW50LmNvbnRlbnRzID0gbm9kZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHB0ID0gaWRlbnRpdHkuaXNBbGlhcyhwYXJlbnQpID8gJ2FsaWFzJyA6ICdzY2FsYXInO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZXBsYWNlIG5vZGUgd2l0aCAke3B0fSBwYXJlbnRgKTtcbiAgICB9XG59XG5cbmV4cG9ydHMudmlzaXQgPSB2aXNpdDtcbmV4cG9ydHMudmlzaXRBc3luYyA9IHZpc2l0QXN5bmM7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi4vbm9kZXMvaWRlbnRpdHkuanMnKTtcbnZhciB2aXNpdCA9IHJlcXVpcmUoJy4uL3Zpc2l0LmpzJyk7XG5cbmNvbnN0IGVzY2FwZUNoYXJzID0ge1xuICAgICchJzogJyUyMScsXG4gICAgJywnOiAnJTJDJyxcbiAgICAnWyc6ICclNUInLFxuICAgICddJzogJyU1RCcsXG4gICAgJ3snOiAnJTdCJyxcbiAgICAnfSc6ICclN0QnXG59O1xuY29uc3QgZXNjYXBlVGFnTmFtZSA9ICh0bikgPT4gdG4ucmVwbGFjZSgvWyEsW1xcXXt9XS9nLCBjaCA9PiBlc2NhcGVDaGFyc1tjaF0pO1xuY2xhc3MgRGlyZWN0aXZlcyB7XG4gICAgY29uc3RydWN0b3IoeWFtbCwgdGFncykge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRpcmVjdGl2ZXMtZW5kL2RvYy1zdGFydCBtYXJrZXIgYC0tLWAuIElmIGBudWxsYCwgYSBtYXJrZXIgbWF5IHN0aWxsIGJlXG4gICAgICAgICAqIGluY2x1ZGVkIGluIHRoZSBkb2N1bWVudCdzIHN0cmluZ2lmaWVkIHJlcHJlc2VudGF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kb2NTdGFydCA9IG51bGw7XG4gICAgICAgIC8qKiBUaGUgZG9jLWVuZCBtYXJrZXIgYC4uLmAuICAqL1xuICAgICAgICB0aGlzLmRvY0VuZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnlhbWwgPSBPYmplY3QuYXNzaWduKHt9LCBEaXJlY3RpdmVzLmRlZmF1bHRZYW1sLCB5YW1sKTtcbiAgICAgICAgdGhpcy50YWdzID0gT2JqZWN0LmFzc2lnbih7fSwgRGlyZWN0aXZlcy5kZWZhdWx0VGFncywgdGFncyk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjb3B5ID0gbmV3IERpcmVjdGl2ZXModGhpcy55YW1sLCB0aGlzLnRhZ3MpO1xuICAgICAgICBjb3B5LmRvY1N0YXJ0ID0gdGhpcy5kb2NTdGFydDtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIER1cmluZyBwYXJzaW5nLCBnZXQgYSBEaXJlY3RpdmVzIGluc3RhbmNlIGZvciB0aGUgY3VycmVudCBkb2N1bWVudCBhbmRcbiAgICAgKiB1cGRhdGUgdGhlIHN0cmVhbSBzdGF0ZSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgdmVyc2lvbidzIHNwZWMuXG4gICAgICovXG4gICAgYXREb2N1bWVudCgpIHtcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IERpcmVjdGl2ZXModGhpcy55YW1sLCB0aGlzLnRhZ3MpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMueWFtbC52ZXJzaW9uKSB7XG4gICAgICAgICAgICBjYXNlICcxLjEnOlxuICAgICAgICAgICAgICAgIHRoaXMuYXROZXh0RG9jdW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnMS4yJzpcbiAgICAgICAgICAgICAgICB0aGlzLmF0TmV4dERvY3VtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy55YW1sID0ge1xuICAgICAgICAgICAgICAgICAgICBleHBsaWNpdDogRGlyZWN0aXZlcy5kZWZhdWx0WWFtbC5leHBsaWNpdCxcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogJzEuMidcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMudGFncyA9IE9iamVjdC5hc3NpZ24oe30sIERpcmVjdGl2ZXMuZGVmYXVsdFRhZ3MpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbkVycm9yIC0gTWF5IGJlIGNhbGxlZCBldmVuIGlmIHRoZSBhY3Rpb24gd2FzIHN1Y2Nlc3NmdWxcbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgb24gc3VjY2Vzc1xuICAgICAqL1xuICAgIGFkZChsaW5lLCBvbkVycm9yKSB7XG4gICAgICAgIGlmICh0aGlzLmF0TmV4dERvY3VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnlhbWwgPSB7IGV4cGxpY2l0OiBEaXJlY3RpdmVzLmRlZmF1bHRZYW1sLmV4cGxpY2l0LCB2ZXJzaW9uOiAnMS4xJyB9O1xuICAgICAgICAgICAgdGhpcy50YWdzID0gT2JqZWN0LmFzc2lnbih7fSwgRGlyZWN0aXZlcy5kZWZhdWx0VGFncyk7XG4gICAgICAgICAgICB0aGlzLmF0TmV4dERvY3VtZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnRyaW0oKS5zcGxpdCgvWyBcXHRdKy8pO1xuICAgICAgICBjb25zdCBuYW1lID0gcGFydHMuc2hpZnQoKTtcbiAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICBjYXNlICclVEFHJzoge1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcigwLCAnJVRBRyBkaXJlY3RpdmUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSB0d28gcGFydHMnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA8IDIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IFtoYW5kbGUsIHByZWZpeF0gPSBwYXJ0cztcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ3NbaGFuZGxlXSA9IHByZWZpeDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJyVZQU1MJzoge1xuICAgICAgICAgICAgICAgIHRoaXMueWFtbC5leHBsaWNpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKDAsICclWUFNTCBkaXJlY3RpdmUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgcGFydCcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IFt2ZXJzaW9uXSA9IHBhcnRzO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uID09PSAnMS4xJyB8fCB2ZXJzaW9uID09PSAnMS4yJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnlhbWwudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNWYWxpZCA9IC9eXFxkK1xcLlxcZCskLy50ZXN0KHZlcnNpb24pO1xuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKDYsIGBVbnN1cHBvcnRlZCBZQU1MIHZlcnNpb24gJHt2ZXJzaW9ufWAsIGlzVmFsaWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBvbkVycm9yKDAsIGBVbmtub3duIGRpcmVjdGl2ZSAke25hbWV9YCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIGEgdGFnLCBtYXRjaGluZyBoYW5kbGVzIHRvIHRob3NlIGRlZmluZWQgaW4gJVRBRyBkaXJlY3RpdmVzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgUmVzb2x2ZWQgdGFnLCB3aGljaCBtYXkgYWxzbyBiZSB0aGUgbm9uLXNwZWNpZmljIHRhZyBgJyEnYCBvciBhXG4gICAgICogICBgJyFsb2NhbCdgIHRhZywgb3IgYG51bGxgIGlmIHVucmVzb2x2YWJsZS5cbiAgICAgKi9cbiAgICB0YWdOYW1lKHNvdXJjZSwgb25FcnJvcikge1xuICAgICAgICBpZiAoc291cmNlID09PSAnIScpXG4gICAgICAgICAgICByZXR1cm4gJyEnOyAvLyBub24tc3BlY2lmaWMgdGFnXG4gICAgICAgIGlmIChzb3VyY2VbMF0gIT09ICchJykge1xuICAgICAgICAgICAgb25FcnJvcihgTm90IGEgdmFsaWQgdGFnOiAke3NvdXJjZX1gKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2VbMV0gPT09ICc8Jykge1xuICAgICAgICAgICAgY29uc3QgdmVyYmF0aW0gPSBzb3VyY2Uuc2xpY2UoMiwgLTEpO1xuICAgICAgICAgICAgaWYgKHZlcmJhdGltID09PSAnIScgfHwgdmVyYmF0aW0gPT09ICchIScpIHtcbiAgICAgICAgICAgICAgICBvbkVycm9yKGBWZXJiYXRpbSB0YWdzIGFyZW4ndCByZXNvbHZlZCwgc28gJHtzb3VyY2V9IGlzIGludmFsaWQuYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc291cmNlW3NvdXJjZS5sZW5ndGggLSAxXSAhPT0gJz4nKVxuICAgICAgICAgICAgICAgIG9uRXJyb3IoJ1ZlcmJhdGltIHRhZ3MgbXVzdCBlbmQgd2l0aCBhID4nKTtcbiAgICAgICAgICAgIHJldHVybiB2ZXJiYXRpbTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbLCBoYW5kbGUsIHN1ZmZpeF0gPSBzb3VyY2UubWF0Y2goL14oLiohKShbXiFdKikkL3MpO1xuICAgICAgICBpZiAoIXN1ZmZpeClcbiAgICAgICAgICAgIG9uRXJyb3IoYFRoZSAke3NvdXJjZX0gdGFnIGhhcyBubyBzdWZmaXhgKTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gdGhpcy50YWdzW2hhbmRsZV07XG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWZpeCArIGRlY29kZVVSSUNvbXBvbmVudChzdWZmaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgb25FcnJvcihTdHJpbmcoZXJyb3IpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFuZGxlID09PSAnIScpXG4gICAgICAgICAgICByZXR1cm4gc291cmNlOyAvLyBsb2NhbCB0YWdcbiAgICAgICAgb25FcnJvcihgQ291bGQgbm90IHJlc29sdmUgdGFnOiAke3NvdXJjZX1gKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgZnVsbHkgcmVzb2x2ZWQgdGFnLCByZXR1cm5zIGl0cyBwcmludGFibGUgc3RyaW5nIGZvcm0sXG4gICAgICogdGFraW5nIGludG8gYWNjb3VudCBjdXJyZW50IHRhZyBwcmVmaXhlcyBhbmQgZGVmYXVsdHMuXG4gICAgICovXG4gICAgdGFnU3RyaW5nKHRhZykge1xuICAgICAgICBmb3IgKGNvbnN0IFtoYW5kbGUsIHByZWZpeF0gb2YgT2JqZWN0LmVudHJpZXModGhpcy50YWdzKSkge1xuICAgICAgICAgICAgaWYgKHRhZy5zdGFydHNXaXRoKHByZWZpeCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZSArIGVzY2FwZVRhZ05hbWUodGFnLnN1YnN0cmluZyhwcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhZ1swXSA9PT0gJyEnID8gdGFnIDogYCE8JHt0YWd9PmA7XG4gICAgfVxuICAgIHRvU3RyaW5nKGRvYykge1xuICAgICAgICBjb25zdCBsaW5lcyA9IHRoaXMueWFtbC5leHBsaWNpdFxuICAgICAgICAgICAgPyBbYCVZQU1MICR7dGhpcy55YW1sLnZlcnNpb24gfHwgJzEuMid9YF1cbiAgICAgICAgICAgIDogW107XG4gICAgICAgIGNvbnN0IHRhZ0VudHJpZXMgPSBPYmplY3QuZW50cmllcyh0aGlzLnRhZ3MpO1xuICAgICAgICBsZXQgdGFnTmFtZXM7XG4gICAgICAgIGlmIChkb2MgJiYgdGFnRW50cmllcy5sZW5ndGggPiAwICYmIGlkZW50aXR5LmlzTm9kZShkb2MuY29udGVudHMpKSB7XG4gICAgICAgICAgICBjb25zdCB0YWdzID0ge307XG4gICAgICAgICAgICB2aXNpdC52aXNpdChkb2MuY29udGVudHMsIChfa2V5LCBub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGlkZW50aXR5LmlzTm9kZShub2RlKSAmJiBub2RlLnRhZylcbiAgICAgICAgICAgICAgICAgICAgdGFnc1tub2RlLnRhZ10gPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0YWdOYW1lcyA9IE9iamVjdC5rZXlzKHRhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRhZ05hbWVzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgW2hhbmRsZSwgcHJlZml4XSBvZiB0YWdFbnRyaWVzKSB7XG4gICAgICAgICAgICBpZiAoaGFuZGxlID09PSAnISEnICYmIHByZWZpeCA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOicpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoIWRvYyB8fCB0YWdOYW1lcy5zb21lKHRuID0+IHRuLnN0YXJ0c1dpdGgocHJlZml4KSkpXG4gICAgICAgICAgICAgICAgbGluZXMucHVzaChgJVRBRyAke2hhbmRsZX0gJHtwcmVmaXh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xuICAgIH1cbn1cbkRpcmVjdGl2ZXMuZGVmYXVsdFlhbWwgPSB7IGV4cGxpY2l0OiBmYWxzZSwgdmVyc2lvbjogJzEuMicgfTtcbkRpcmVjdGl2ZXMuZGVmYXVsdFRhZ3MgPSB7ICchISc6ICd0YWc6eWFtbC5vcmcsMjAwMjonIH07XG5cbmV4cG9ydHMuRGlyZWN0aXZlcyA9IERpcmVjdGl2ZXM7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi4vbm9kZXMvaWRlbnRpdHkuanMnKTtcbnZhciB2aXNpdCA9IHJlcXVpcmUoJy4uL3Zpc2l0LmpzJyk7XG5cbi8qKlxuICogVmVyaWZ5IHRoYXQgdGhlIGlucHV0IHN0cmluZyBpcyBhIHZhbGlkIGFuY2hvci5cbiAqXG4gKiBXaWxsIHRocm93IG9uIGVycm9ycy5cbiAqL1xuZnVuY3Rpb24gYW5jaG9ySXNWYWxpZChhbmNob3IpIHtcbiAgICBpZiAoL1tcXHgwMC1cXHgxOVxccyxbXFxde31dLy50ZXN0KGFuY2hvcikpIHtcbiAgICAgICAgY29uc3Qgc2EgPSBKU09OLnN0cmluZ2lmeShhbmNob3IpO1xuICAgICAgICBjb25zdCBtc2cgPSBgQW5jaG9yIG11c3Qgbm90IGNvbnRhaW4gd2hpdGVzcGFjZSBvciBjb250cm9sIGNoYXJhY3RlcnM6ICR7c2F9YDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYW5jaG9yTmFtZXMocm9vdCkge1xuICAgIGNvbnN0IGFuY2hvcnMgPSBuZXcgU2V0KCk7XG4gICAgdmlzaXQudmlzaXQocm9vdCwge1xuICAgICAgICBWYWx1ZShfa2V5LCBub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5hbmNob3IpXG4gICAgICAgICAgICAgICAgYW5jaG9ycy5hZGQobm9kZS5hbmNob3IpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGFuY2hvcnM7XG59XG4vKiogRmluZCBhIG5ldyBhbmNob3IgbmFtZSB3aXRoIHRoZSBnaXZlbiBgcHJlZml4YCBhbmQgYSBvbmUtaW5kZXhlZCBzdWZmaXguICovXG5mdW5jdGlvbiBmaW5kTmV3QW5jaG9yKHByZWZpeCwgZXhjbHVkZSkge1xuICAgIGZvciAobGV0IGkgPSAxOyB0cnVlOyArK2kpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGAke3ByZWZpeH0ke2l9YDtcbiAgICAgICAgaWYgKCFleGNsdWRlLmhhcyhuYW1lKSlcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVBbmNob3JzKGRvYywgcHJlZml4KSB7XG4gICAgY29uc3QgYWxpYXNPYmplY3RzID0gW107XG4gICAgY29uc3Qgc291cmNlT2JqZWN0cyA9IG5ldyBNYXAoKTtcbiAgICBsZXQgcHJldkFuY2hvcnMgPSBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIG9uQW5jaG9yOiAoc291cmNlKSA9PiB7XG4gICAgICAgICAgICBhbGlhc09iamVjdHMucHVzaChzb3VyY2UpO1xuICAgICAgICAgICAgcHJldkFuY2hvcnMgPz8gKHByZXZBbmNob3JzID0gYW5jaG9yTmFtZXMoZG9jKSk7XG4gICAgICAgICAgICBjb25zdCBhbmNob3IgPSBmaW5kTmV3QW5jaG9yKHByZWZpeCwgcHJldkFuY2hvcnMpO1xuICAgICAgICAgICAgcHJldkFuY2hvcnMuYWRkKGFuY2hvcik7XG4gICAgICAgICAgICByZXR1cm4gYW5jaG9yO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogV2l0aCBjaXJjdWxhciByZWZlcmVuY2VzLCB0aGUgc291cmNlIG5vZGUgaXMgb25seSByZXNvbHZlZCBhZnRlciBhbGxcbiAgICAgICAgICogb2YgaXRzIGNoaWxkIG5vZGVzIGFyZS4gVGhpcyBpcyB3aHkgYW5jaG9ycyBhcmUgc2V0IG9ubHkgYWZ0ZXIgYWxsIG9mXG4gICAgICAgICAqIHRoZSBub2RlcyBoYXZlIGJlZW4gY3JlYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHNldEFuY2hvcnM6ICgpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc291cmNlIG9mIGFsaWFzT2JqZWN0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZiA9IHNvdXJjZU9iamVjdHMuZ2V0KHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZWYgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgIHJlZi5hbmNob3IgJiZcbiAgICAgICAgICAgICAgICAgICAgKGlkZW50aXR5LmlzU2NhbGFyKHJlZi5ub2RlKSB8fCBpZGVudGl0eS5pc0NvbGxlY3Rpb24ocmVmLm5vZGUpKSkge1xuICAgICAgICAgICAgICAgICAgICByZWYubm9kZS5hbmNob3IgPSByZWYuYW5jaG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0ZhaWxlZCB0byByZXNvbHZlIHJlcGVhdGVkIG9iamVjdCAodGhpcyBzaG91bGQgbm90IGhhcHBlbiknKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3Iuc291cmNlID0gc291cmNlO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNvdXJjZU9iamVjdHNcbiAgICB9O1xufVxuXG5leHBvcnRzLmFuY2hvcklzVmFsaWQgPSBhbmNob3JJc1ZhbGlkO1xuZXhwb3J0cy5hbmNob3JOYW1lcyA9IGFuY2hvck5hbWVzO1xuZXhwb3J0cy5jcmVhdGVOb2RlQW5jaG9ycyA9IGNyZWF0ZU5vZGVBbmNob3JzO1xuZXhwb3J0cy5maW5kTmV3QW5jaG9yID0gZmluZE5ld0FuY2hvcjtcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEFwcGxpZXMgdGhlIEpTT04ucGFyc2UgcmV2aXZlciBhbGdvcml0aG0gYXMgZGVmaW5lZCBpbiB0aGUgRUNNQS0yNjIgc3BlYyxcbiAqIGluIHNlY3Rpb24gMjQuNS4xLjEgXCJSdW50aW1lIFNlbWFudGljczogSW50ZXJuYWxpemVKU09OUHJvcGVydHlcIiBvZiB0aGVcbiAqIDIwMjEgZWRpdGlvbjogaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1qc29uLnBhcnNlXG4gKlxuICogSW5jbHVkZXMgZXh0ZW5zaW9ucyBmb3IgaGFuZGxpbmcgTWFwIGFuZCBTZXQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gYXBwbHlSZXZpdmVyKHJldml2ZXIsIG9iaiwga2V5LCB2YWwpIHtcbiAgICBpZiAodmFsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2MCA9IHZhbFtpXTtcbiAgICAgICAgICAgICAgICBjb25zdCB2MSA9IGFwcGx5UmV2aXZlcihyZXZpdmVyLCB2YWwsIFN0cmluZyhpKSwgdjApO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tYXJyYXktZGVsZXRlXG4gICAgICAgICAgICAgICAgaWYgKHYxID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWxbaV07XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodjEgIT09IHYwKVxuICAgICAgICAgICAgICAgICAgICB2YWxbaV0gPSB2MTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgayBvZiBBcnJheS5mcm9tKHZhbC5rZXlzKCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdjAgPSB2YWwuZ2V0KGspO1xuICAgICAgICAgICAgICAgIGNvbnN0IHYxID0gYXBwbHlSZXZpdmVyKHJldml2ZXIsIHZhbCwgaywgdjApO1xuICAgICAgICAgICAgICAgIGlmICh2MSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICB2YWwuZGVsZXRlKGspO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHYxICE9PSB2MClcbiAgICAgICAgICAgICAgICAgICAgdmFsLnNldChrLCB2MSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHYwIG9mIEFycmF5LmZyb20odmFsKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYxID0gYXBwbHlSZXZpdmVyKHJldml2ZXIsIHZhbCwgdjAsIHYwKTtcbiAgICAgICAgICAgICAgICBpZiAodjEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgdmFsLmRlbGV0ZSh2MCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodjEgIT09IHYwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbC5kZWxldGUodjApO1xuICAgICAgICAgICAgICAgICAgICB2YWwuYWRkKHYxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2MF0gb2YgT2JqZWN0LmVudHJpZXModmFsKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYxID0gYXBwbHlSZXZpdmVyKHJldml2ZXIsIHZhbCwgaywgdjApO1xuICAgICAgICAgICAgICAgIGlmICh2MSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsW2tdO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHYxICE9PSB2MClcbiAgICAgICAgICAgICAgICAgICAgdmFsW2tdID0gdjE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldml2ZXIuY2FsbChvYmosIGtleSwgdmFsKTtcbn1cblxuZXhwb3J0cy5hcHBseVJldml2ZXIgPSBhcHBseVJldml2ZXI7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eS5qcycpO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgYW55IG5vZGUgb3IgaXRzIGNvbnRlbnRzIHRvIG5hdGl2ZSBKYXZhU2NyaXB0XG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGlucHV0IHZhbHVlXG4gKiBAcGFyYW0gYXJnIC0gSWYgYHZhbHVlYCBkZWZpbmVzIGEgYHRvSlNPTigpYCBtZXRob2QsIHVzZSB0aGlzXG4gKiAgIGFzIGl0cyBmaXJzdCBhcmd1bWVudFxuICogQHBhcmFtIGN0eCAtIENvbnZlcnNpb24gY29udGV4dCwgb3JpZ2luYWxseSBzZXQgaW4gRG9jdW1lbnQjdG9KUygpLiBJZlxuICogICBgeyBrZWVwOiB0cnVlIH1gIGlzIG5vdCBzZXQsIG91dHB1dCBzaG91bGQgYmUgc3VpdGFibGUgZm9yIEpTT05cbiAqICAgc3RyaW5naWZpY2F0aW9uLlxuICovXG5mdW5jdGlvbiB0b0pTKHZhbHVlLCBhcmcsIGN0eCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodiwgaSkgPT4gdG9KUyh2LCBTdHJpbmcoaSksIGN0eCkpO1xuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWNhbGxcbiAgICAgICAgaWYgKCFjdHggfHwgIWlkZW50aXR5Lmhhc0FuY2hvcih2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9KU09OKGFyZywgY3R4KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHsgYWxpYXNDb3VudDogMCwgY291bnQ6IDEsIHJlczogdW5kZWZpbmVkIH07XG4gICAgICAgIGN0eC5hbmNob3JzLnNldCh2YWx1ZSwgZGF0YSk7XG4gICAgICAgIGN0eC5vbkNyZWF0ZSA9IHJlcyA9PiB7XG4gICAgICAgICAgICBkYXRhLnJlcyA9IHJlcztcbiAgICAgICAgICAgIGRlbGV0ZSBjdHgub25DcmVhdGU7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlcyA9IHZhbHVlLnRvSlNPTihhcmcsIGN0eCk7XG4gICAgICAgIGlmIChjdHgub25DcmVhdGUpXG4gICAgICAgICAgICBjdHgub25DcmVhdGUocmVzKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcgJiYgIWN0eD8ua2VlcClcbiAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnRzLnRvSlMgPSB0b0pTO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBhcHBseVJldml2ZXIgPSByZXF1aXJlKCcuLi9kb2MvYXBwbHlSZXZpdmVyLmpzJyk7XG52YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5LmpzJyk7XG52YXIgdG9KUyA9IHJlcXVpcmUoJy4vdG9KUy5qcycpO1xuXG5jbGFzcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IodHlwZSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaWRlbnRpdHkuTk9ERV9UWVBFLCB7IHZhbHVlOiB0eXBlIH0pO1xuICAgIH1cbiAgICAvKiogQ3JlYXRlIGEgY29weSBvZiB0aGlzIG5vZGUuICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHRoaXMpKTtcbiAgICAgICAgaWYgKHRoaXMucmFuZ2UpXG4gICAgICAgICAgICBjb3B5LnJhbmdlID0gdGhpcy5yYW5nZS5zbGljZSgpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLyoqIEEgcGxhaW4gSmF2YVNjcmlwdCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG5vZGUuICovXG4gICAgdG9KUyhkb2MsIHsgbWFwQXNNYXAsIG1heEFsaWFzQ291bnQsIG9uQW5jaG9yLCByZXZpdmVyIH0gPSB7fSkge1xuICAgICAgICBpZiAoIWlkZW50aXR5LmlzRG9jdW1lbnQoZG9jKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgZG9jdW1lbnQgYXJndW1lbnQgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgY29uc3QgY3R4ID0ge1xuICAgICAgICAgICAgYW5jaG9yczogbmV3IE1hcCgpLFxuICAgICAgICAgICAgZG9jLFxuICAgICAgICAgICAga2VlcDogdHJ1ZSxcbiAgICAgICAgICAgIG1hcEFzTWFwOiBtYXBBc01hcCA9PT0gdHJ1ZSxcbiAgICAgICAgICAgIG1hcEtleVdhcm5lZDogZmFsc2UsXG4gICAgICAgICAgICBtYXhBbGlhc0NvdW50OiB0eXBlb2YgbWF4QWxpYXNDb3VudCA9PT0gJ251bWJlcicgPyBtYXhBbGlhc0NvdW50IDogMTAwXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlcyA9IHRvSlMudG9KUyh0aGlzLCAnJywgY3R4KTtcbiAgICAgICAgaWYgKHR5cGVvZiBvbkFuY2hvciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBjb3VudCwgcmVzIH0gb2YgY3R4LmFuY2hvcnMudmFsdWVzKCkpXG4gICAgICAgICAgICAgICAgb25BbmNob3IocmVzLCBjb3VudCk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcmV2aXZlciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBhcHBseVJldml2ZXIuYXBwbHlSZXZpdmVyKHJldml2ZXIsIHsgJyc6IHJlcyB9LCAnJywgcmVzKVxuICAgICAgICAgICAgOiByZXM7XG4gICAgfVxufVxuXG5leHBvcnRzLk5vZGVCYXNlID0gTm9kZUJhc2U7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIGFuY2hvcnMgPSByZXF1aXJlKCcuLi9kb2MvYW5jaG9ycy5qcycpO1xudmFyIHZpc2l0ID0gcmVxdWlyZSgnLi4vdmlzaXQuanMnKTtcbnZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHkuanMnKTtcbnZhciBOb2RlID0gcmVxdWlyZSgnLi9Ob2RlLmpzJyk7XG52YXIgdG9KUyA9IHJlcXVpcmUoJy4vdG9KUy5qcycpO1xuXG5jbGFzcyBBbGlhcyBleHRlbmRzIE5vZGUuTm9kZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgICAgICBzdXBlcihpZGVudGl0eS5BTElBUyk7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3RhZycsIHtcbiAgICAgICAgICAgIHNldCgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsaWFzIG5vZGVzIGNhbm5vdCBoYXZlIHRhZ3MnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc29sdmUgdGhlIHZhbHVlIG9mIHRoaXMgYWxpYXMgd2l0aGluIGBkb2NgLCBmaW5kaW5nIHRoZSBsYXN0XG4gICAgICogaW5zdGFuY2Ugb2YgdGhlIGBzb3VyY2VgIGFuY2hvciBiZWZvcmUgdGhpcyBub2RlLlxuICAgICAqL1xuICAgIHJlc29sdmUoZG9jLCBjdHgpIHtcbiAgICAgICAgbGV0IG5vZGVzO1xuICAgICAgICBpZiAoY3R4Py5hbGlhc1Jlc29sdmVDYWNoZSkge1xuICAgICAgICAgICAgbm9kZXMgPSBjdHguYWxpYXNSZXNvbHZlQ2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2RlcyA9IFtdO1xuICAgICAgICAgICAgdmlzaXQudmlzaXQoZG9jLCB7XG4gICAgICAgICAgICAgICAgTm9kZTogKF9rZXksIG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkZW50aXR5LmlzQWxpYXMobm9kZSkgfHwgaWRlbnRpdHkuaGFzQW5jaG9yKG5vZGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjdHgpXG4gICAgICAgICAgICAgICAgY3R4LmFsaWFzUmVzb2x2ZUNhY2hlID0gbm9kZXM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZvdW5kID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChub2RlID09PSB0aGlzKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKG5vZGUuYW5jaG9yID09PSB0aGlzLnNvdXJjZSlcbiAgICAgICAgICAgICAgICBmb3VuZCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICB0b0pTT04oX2FyZywgY3R4KSB7XG4gICAgICAgIGlmICghY3R4KVxuICAgICAgICAgICAgcmV0dXJuIHsgc291cmNlOiB0aGlzLnNvdXJjZSB9O1xuICAgICAgICBjb25zdCB7IGFuY2hvcnMsIGRvYywgbWF4QWxpYXNDb3VudCB9ID0gY3R4O1xuICAgICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnJlc29sdmUoZG9jLCBjdHgpO1xuICAgICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gYFVucmVzb2x2ZWQgYWxpYXMgKHRoZSBhbmNob3IgbXVzdCBiZSBzZXQgYmVmb3JlIHRoZSBhbGlhcyk6ICR7dGhpcy5zb3VyY2V9YDtcbiAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhID0gYW5jaG9ycy5nZXQoc291cmNlKTtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAvLyBSZXNvbHZlIGFuY2hvcnMgZm9yIE5vZGUucHJvdG90eXBlLnRvSlMoKVxuICAgICAgICAgICAgdG9KUy50b0pTKHNvdXJjZSwgbnVsbCwgY3R4KTtcbiAgICAgICAgICAgIGRhdGEgPSBhbmNob3JzLmdldChzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoZGF0YT8ucmVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9ICdUaGlzIHNob3VsZCBub3QgaGFwcGVuOiBBbGlhcyBhbmNob3Igd2FzIG5vdCByZXNvbHZlZD8nO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heEFsaWFzQ291bnQgPj0gMCkge1xuICAgICAgICAgICAgZGF0YS5jb3VudCArPSAxO1xuICAgICAgICAgICAgaWYgKGRhdGEuYWxpYXNDb3VudCA9PT0gMClcbiAgICAgICAgICAgICAgICBkYXRhLmFsaWFzQ291bnQgPSBnZXRBbGlhc0NvdW50KGRvYywgc291cmNlLCBhbmNob3JzKTtcbiAgICAgICAgICAgIGlmIChkYXRhLmNvdW50ICogZGF0YS5hbGlhc0NvdW50ID4gbWF4QWxpYXNDb3VudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9ICdFeGNlc3NpdmUgYWxpYXMgY291bnQgaW5kaWNhdGVzIGEgcmVzb3VyY2UgZXhoYXVzdGlvbiBhdHRhY2snO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhLnJlcztcbiAgICB9XG4gICAgdG9TdHJpbmcoY3R4LCBfb25Db21tZW50LCBfb25DaG9tcEtlZXApIHtcbiAgICAgICAgY29uc3Qgc3JjID0gYCoke3RoaXMuc291cmNlfWA7XG4gICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIGFuY2hvcnMuYW5jaG9ySXNWYWxpZCh0aGlzLnNvdXJjZSk7XG4gICAgICAgICAgICBpZiAoY3R4Lm9wdGlvbnMudmVyaWZ5QWxpYXNPcmRlciAmJiAhY3R4LmFuY2hvcnMuaGFzKHRoaXMuc291cmNlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBVbnJlc29sdmVkIGFsaWFzICh0aGUgYW5jaG9yIG11c3QgYmUgc2V0IGJlZm9yZSB0aGUgYWxpYXMpOiAke3RoaXMuc291cmNlfWA7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3R4LmltcGxpY2l0S2V5KVxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtzcmN9IGA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNyYztcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRBbGlhc0NvdW50KGRvYywgbm9kZSwgYW5jaG9ycykge1xuICAgIGlmIChpZGVudGl0eS5pc0FsaWFzKG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IG5vZGUucmVzb2x2ZShkb2MpO1xuICAgICAgICBjb25zdCBhbmNob3IgPSBhbmNob3JzICYmIHNvdXJjZSAmJiBhbmNob3JzLmdldChzb3VyY2UpO1xuICAgICAgICByZXR1cm4gYW5jaG9yID8gYW5jaG9yLmNvdW50ICogYW5jaG9yLmFsaWFzQ291bnQgOiAwO1xuICAgIH1cbiAgICBlbHNlIGlmIChpZGVudGl0eS5pc0NvbGxlY3Rpb24obm9kZSkpIHtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIG5vZGUuaXRlbXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBnZXRBbGlhc0NvdW50KGRvYywgaXRlbSwgYW5jaG9ycyk7XG4gICAgICAgICAgICBpZiAoYyA+IGNvdW50KVxuICAgICAgICAgICAgICAgIGNvdW50ID0gYztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlkZW50aXR5LmlzUGFpcihub2RlKSkge1xuICAgICAgICBjb25zdCBrYyA9IGdldEFsaWFzQ291bnQoZG9jLCBub2RlLmtleSwgYW5jaG9ycyk7XG4gICAgICAgIGNvbnN0IHZjID0gZ2V0QWxpYXNDb3VudChkb2MsIG5vZGUudmFsdWUsIGFuY2hvcnMpO1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoa2MsIHZjKTtcbiAgICB9XG4gICAgcmV0dXJuIDE7XG59XG5cbmV4cG9ydHMuQWxpYXMgPSBBbGlhcztcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5LmpzJyk7XG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vTm9kZS5qcycpO1xudmFyIHRvSlMgPSByZXF1aXJlKCcuL3RvSlMuanMnKTtcblxuY29uc3QgaXNTY2FsYXJWYWx1ZSA9ICh2YWx1ZSkgPT4gIXZhbHVlIHx8ICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jyk7XG5jbGFzcyBTY2FsYXIgZXh0ZW5kcyBOb2RlLk5vZGVCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcihpZGVudGl0eS5TQ0FMQVIpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHRvSlNPTihhcmcsIGN0eCkge1xuICAgICAgICByZXR1cm4gY3R4Py5rZWVwID8gdGhpcy52YWx1ZSA6IHRvSlMudG9KUyh0aGlzLnZhbHVlLCBhcmcsIGN0eCk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHRoaXMudmFsdWUpO1xuICAgIH1cbn1cblNjYWxhci5CTE9DS19GT0xERUQgPSAnQkxPQ0tfRk9MREVEJztcblNjYWxhci5CTE9DS19MSVRFUkFMID0gJ0JMT0NLX0xJVEVSQUwnO1xuU2NhbGFyLlBMQUlOID0gJ1BMQUlOJztcblNjYWxhci5RVU9URV9ET1VCTEUgPSAnUVVPVEVfRE9VQkxFJztcblNjYWxhci5RVU9URV9TSU5HTEUgPSAnUVVPVEVfU0lOR0xFJztcblxuZXhwb3J0cy5TY2FsYXIgPSBTY2FsYXI7XG5leHBvcnRzLmlzU2NhbGFyVmFsdWUgPSBpc1NjYWxhclZhbHVlO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBBbGlhcyA9IHJlcXVpcmUoJy4uL25vZGVzL0FsaWFzLmpzJyk7XG52YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuLi9ub2Rlcy9pZGVudGl0eS5qcycpO1xudmFyIFNjYWxhciA9IHJlcXVpcmUoJy4uL25vZGVzL1NjYWxhci5qcycpO1xuXG5jb25zdCBkZWZhdWx0VGFnUHJlZml4ID0gJ3RhZzp5YW1sLm9yZywyMDAyOic7XG5mdW5jdGlvbiBmaW5kVGFnT2JqZWN0KHZhbHVlLCB0YWdOYW1lLCB0YWdzKSB7XG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0YWdzLmZpbHRlcih0ID0+IHQudGFnID09PSB0YWdOYW1lKTtcbiAgICAgICAgY29uc3QgdGFnT2JqID0gbWF0Y2guZmluZCh0ID0+ICF0LmZvcm1hdCkgPz8gbWF0Y2hbMF07XG4gICAgICAgIGlmICghdGFnT2JqKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUYWcgJHt0YWdOYW1lfSBub3QgZm91bmRgKTtcbiAgICAgICAgcmV0dXJuIHRhZ09iajtcbiAgICB9XG4gICAgcmV0dXJuIHRhZ3MuZmluZCh0ID0+IHQuaWRlbnRpZnk/Lih2YWx1ZSkgJiYgIXQuZm9ybWF0KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU5vZGUodmFsdWUsIHRhZ05hbWUsIGN0eCkge1xuICAgIGlmIChpZGVudGl0eS5pc0RvY3VtZW50KHZhbHVlKSlcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5jb250ZW50cztcbiAgICBpZiAoaWRlbnRpdHkuaXNOb2RlKHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGlmIChpZGVudGl0eS5pc1BhaXIodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IG1hcCA9IGN0eC5zY2hlbWFbaWRlbnRpdHkuTUFQXS5jcmVhdGVOb2RlPy4oY3R4LnNjaGVtYSwgbnVsbCwgY3R4KTtcbiAgICAgICAgbWFwLml0ZW1zLnB1c2godmFsdWUpO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcgfHxcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIgfHxcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBCb29sZWFuIHx8XG4gICAgICAgICh0eXBlb2YgQmlnSW50ICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEJpZ0ludCkgLy8gbm90IHN1cHBvcnRlZCBldmVyeXdoZXJlXG4gICAgKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2VyaWFsaXplanNvbnByb3BlcnR5XG4gICAgICAgIHZhbHVlID0gdmFsdWUudmFsdWVPZigpO1xuICAgIH1cbiAgICBjb25zdCB7IGFsaWFzRHVwbGljYXRlT2JqZWN0cywgb25BbmNob3IsIG9uVGFnT2JqLCBzY2hlbWEsIHNvdXJjZU9iamVjdHMgfSA9IGN0eDtcbiAgICAvLyBEZXRlY3QgZHVwbGljYXRlIHJlZmVyZW5jZXMgdG8gdGhlIHNhbWUgb2JqZWN0ICYgdXNlIEFsaWFzIG5vZGVzIGZvciBhbGxcbiAgICAvLyBhZnRlciBmaXJzdC4gVGhlIGByZWZgIHdyYXBwZXIgYWxsb3dzIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIHRvIHJlc29sdmUuXG4gICAgbGV0IHJlZiA9IHVuZGVmaW5lZDtcbiAgICBpZiAoYWxpYXNEdXBsaWNhdGVPYmplY3RzICYmIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmVmID0gc291cmNlT2JqZWN0cy5nZXQodmFsdWUpO1xuICAgICAgICBpZiAocmVmKSB7XG4gICAgICAgICAgICByZWYuYW5jaG9yID8/IChyZWYuYW5jaG9yID0gb25BbmNob3IodmFsdWUpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWxpYXMuQWxpYXMocmVmLmFuY2hvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWYgPSB7IGFuY2hvcjogbnVsbCwgbm9kZTogbnVsbCB9O1xuICAgICAgICAgICAgc291cmNlT2JqZWN0cy5zZXQodmFsdWUsIHJlZik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhZ05hbWU/LnN0YXJ0c1dpdGgoJyEhJykpXG4gICAgICAgIHRhZ05hbWUgPSBkZWZhdWx0VGFnUHJlZml4ICsgdGFnTmFtZS5zbGljZSgyKTtcbiAgICBsZXQgdGFnT2JqID0gZmluZFRhZ09iamVjdCh2YWx1ZSwgdGFnTmFtZSwgc2NoZW1hLnRhZ3MpO1xuICAgIGlmICghdGFnT2JqKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBTY2FsYXIuU2NhbGFyKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChyZWYpXG4gICAgICAgICAgICAgICAgcmVmLm5vZGUgPSBub2RlO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgdGFnT2JqID1cbiAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgTWFwXG4gICAgICAgICAgICAgICAgPyBzY2hlbWFbaWRlbnRpdHkuTUFQXVxuICAgICAgICAgICAgICAgIDogU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdCh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgPyBzY2hlbWFbaWRlbnRpdHkuU0VRXVxuICAgICAgICAgICAgICAgICAgICA6IHNjaGVtYVtpZGVudGl0eS5NQVBdO1xuICAgIH1cbiAgICBpZiAob25UYWdPYmopIHtcbiAgICAgICAgb25UYWdPYmoodGFnT2JqKTtcbiAgICAgICAgZGVsZXRlIGN0eC5vblRhZ09iajtcbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IHRhZ09iaj8uY3JlYXRlTm9kZVxuICAgICAgICA/IHRhZ09iai5jcmVhdGVOb2RlKGN0eC5zY2hlbWEsIHZhbHVlLCBjdHgpXG4gICAgICAgIDogdHlwZW9mIHRhZ09iaj8ubm9kZUNsYXNzPy5mcm9tID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IHRhZ09iai5ub2RlQ2xhc3MuZnJvbShjdHguc2NoZW1hLCB2YWx1ZSwgY3R4KVxuICAgICAgICAgICAgOiBuZXcgU2NhbGFyLlNjYWxhcih2YWx1ZSk7XG4gICAgaWYgKHRhZ05hbWUpXG4gICAgICAgIG5vZGUudGFnID0gdGFnTmFtZTtcbiAgICBlbHNlIGlmICghdGFnT2JqLmRlZmF1bHQpXG4gICAgICAgIG5vZGUudGFnID0gdGFnT2JqLnRhZztcbiAgICBpZiAocmVmKVxuICAgICAgICByZWYubm9kZSA9IG5vZGU7XG4gICAgcmV0dXJuIG5vZGU7XG59XG5cbmV4cG9ydHMuY3JlYXRlTm9kZSA9IGNyZWF0ZU5vZGU7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIGNyZWF0ZU5vZGUgPSByZXF1aXJlKCcuLi9kb2MvY3JlYXRlTm9kZS5qcycpO1xudmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eS5qcycpO1xudmFyIE5vZGUgPSByZXF1aXJlKCcuL05vZGUuanMnKTtcblxuZnVuY3Rpb24gY29sbGVjdGlvbkZyb21QYXRoKHNjaGVtYSwgcGF0aCwgdmFsdWUpIHtcbiAgICBsZXQgdiA9IHZhbHVlO1xuICAgIGZvciAobGV0IGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGNvbnN0IGsgPSBwYXRoW2ldO1xuICAgICAgICBpZiAodHlwZW9mIGsgPT09ICdudW1iZXInICYmIE51bWJlci5pc0ludGVnZXIoaykgJiYgayA+PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBhID0gW107XG4gICAgICAgICAgICBhW2tdID0gdjtcbiAgICAgICAgICAgIHYgPSBhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdiA9IG5ldyBNYXAoW1trLCB2XV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVOb2RlLmNyZWF0ZU5vZGUodiwgdW5kZWZpbmVkLCB7XG4gICAgICAgIGFsaWFzRHVwbGljYXRlT2JqZWN0czogZmFsc2UsXG4gICAgICAgIGtlZXBVbmRlZmluZWQ6IGZhbHNlLFxuICAgICAgICBvbkFuY2hvcjogKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIHNob3VsZCBub3QgaGFwcGVuLCBwbGVhc2UgcmVwb3J0IGEgYnVnLicpO1xuICAgICAgICB9LFxuICAgICAgICBzY2hlbWEsXG4gICAgICAgIHNvdXJjZU9iamVjdHM6IG5ldyBNYXAoKVxuICAgIH0pO1xufVxuLy8gVHlwZSBndWFyZCBpcyBpbnRlbnRpb25hbGx5IGEgbGl0dGxlIHdyb25nIHNvIGFzIHRvIGJlIG1vcmUgdXNlZnVsLFxuLy8gYXMgaXQgZG9lcyBub3QgY292ZXIgdW50eXBhYmxlIGVtcHR5IG5vbi1zdHJpbmcgaXRlcmFibGVzIChlLmcuIFtdKS5cbmNvbnN0IGlzRW1wdHlQYXRoID0gKHBhdGgpID0+IHBhdGggPT0gbnVsbCB8fFxuICAgICh0eXBlb2YgcGF0aCA9PT0gJ29iamVjdCcgJiYgISFwYXRoW1N5bWJvbC5pdGVyYXRvcl0oKS5uZXh0KCkuZG9uZSk7XG5jbGFzcyBDb2xsZWN0aW9uIGV4dGVuZHMgTm9kZS5Ob2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgc2NoZW1hKSB7XG4gICAgICAgIHN1cGVyKHR5cGUpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3NjaGVtYScsIHtcbiAgICAgICAgICAgIHZhbHVlOiBzY2hlbWEsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzY2hlbWEgLSBJZiBkZWZpbmVkLCBvdmVyd3JpdGVzIHRoZSBvcmlnaW5hbCdzIHNjaGVtYVxuICAgICAqL1xuICAgIGNsb25lKHNjaGVtYSkge1xuICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHRoaXMpKTtcbiAgICAgICAgaWYgKHNjaGVtYSlcbiAgICAgICAgICAgIGNvcHkuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgICBjb3B5Lml0ZW1zID0gY29weS5pdGVtcy5tYXAoaXQgPT4gaWRlbnRpdHkuaXNOb2RlKGl0KSB8fCBpZGVudGl0eS5pc1BhaXIoaXQpID8gaXQuY2xvbmUoc2NoZW1hKSA6IGl0KTtcbiAgICAgICAgaWYgKHRoaXMucmFuZ2UpXG4gICAgICAgICAgICBjb3B5LnJhbmdlID0gdGhpcy5yYW5nZS5zbGljZSgpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHZhbHVlIHRvIHRoZSBjb2xsZWN0aW9uLiBGb3IgYCEhbWFwYCBhbmQgYCEhb21hcGAgdGhlIHZhbHVlIG11c3RcbiAgICAgKiBiZSBhIFBhaXIgaW5zdGFuY2Ugb3IgYSBgeyBrZXksIHZhbHVlIH1gIG9iamVjdCwgd2hpY2ggbWF5IG5vdCBoYXZlIGEga2V5XG4gICAgICogdGhhdCBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgbWFwLlxuICAgICAqL1xuICAgIGFkZEluKHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0VtcHR5UGF0aChwYXRoKSlcbiAgICAgICAgICAgIHRoaXMuYWRkKHZhbHVlKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBba2V5LCAuLi5yZXN0XSA9IHBhdGg7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5nZXQoa2V5LCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChpZGVudGl0eS5pc0NvbGxlY3Rpb24obm9kZSkpXG4gICAgICAgICAgICAgICAgbm9kZS5hZGRJbihyZXN0LCB2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlID09PSB1bmRlZmluZWQgJiYgdGhpcy5zY2hlbWEpXG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCBjb2xsZWN0aW9uRnJvbVBhdGgodGhpcy5zY2hlbWEsIHJlc3QsIHZhbHVlKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBZQU1MIGNvbGxlY3Rpb24gYXQgJHtrZXl9LiBSZW1haW5pbmcgcGF0aDogJHtyZXN0fWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSB2YWx1ZSBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgaXRlbSB3YXMgZm91bmQgYW5kIHJlbW92ZWQuXG4gICAgICovXG4gICAgZGVsZXRlSW4ocGF0aCkge1xuICAgICAgICBjb25zdCBba2V5LCAuLi5yZXN0XSA9IHBhdGg7XG4gICAgICAgIGlmIChyZXN0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGV0ZShrZXkpO1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5nZXQoa2V5LCB0cnVlKTtcbiAgICAgICAgaWYgKGlkZW50aXR5LmlzQ29sbGVjdGlvbihub2RlKSlcbiAgICAgICAgICAgIHJldHVybiBub2RlLmRlbGV0ZUluKHJlc3QpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFlBTUwgY29sbGVjdGlvbiBhdCAke2tleX0uIFJlbWFpbmluZyBwYXRoOiAke3Jlc3R9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaXRlbSBhdCBga2V5YCwgb3IgYHVuZGVmaW5lZGAgaWYgbm90IGZvdW5kLiBCeSBkZWZhdWx0IHVud3JhcHNcbiAgICAgKiBzY2FsYXIgdmFsdWVzIGZyb20gdGhlaXIgc3Vycm91bmRpbmcgbm9kZTsgdG8gZGlzYWJsZSBzZXQgYGtlZXBTY2FsYXJgIHRvXG4gICAgICogYHRydWVgIChjb2xsZWN0aW9ucyBhcmUgYWx3YXlzIHJldHVybmVkIGludGFjdCkuXG4gICAgICovXG4gICAgZ2V0SW4ocGF0aCwga2VlcFNjYWxhcikge1xuICAgICAgICBjb25zdCBba2V5LCAuLi5yZXN0XSA9IHBhdGg7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldChrZXksIHRydWUpO1xuICAgICAgICBpZiAocmVzdC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gIWtlZXBTY2FsYXIgJiYgaWRlbnRpdHkuaXNTY2FsYXIobm9kZSkgPyBub2RlLnZhbHVlIDogbm9kZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGlkZW50aXR5LmlzQ29sbGVjdGlvbihub2RlKSA/IG5vZGUuZ2V0SW4ocmVzdCwga2VlcFNjYWxhcikgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGhhc0FsbE51bGxWYWx1ZXMoYWxsb3dTY2FsYXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuZXZlcnkobm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlkZW50aXR5LmlzUGFpcihub2RlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBuID0gbm9kZS52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiAobiA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgKGFsbG93U2NhbGFyICYmXG4gICAgICAgICAgICAgICAgICAgIGlkZW50aXR5LmlzU2NhbGFyKG4pICYmXG4gICAgICAgICAgICAgICAgICAgIG4udmFsdWUgPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAhbi5jb21tZW50QmVmb3JlICYmXG4gICAgICAgICAgICAgICAgICAgICFuLmNvbW1lbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgIW4udGFnKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGNvbGxlY3Rpb24gaW5jbHVkZXMgYSB2YWx1ZSB3aXRoIHRoZSBrZXkgYGtleWAuXG4gICAgICovXG4gICAgaGFzSW4ocGF0aCkge1xuICAgICAgICBjb25zdCBba2V5LCAuLi5yZXN0XSA9IHBhdGg7XG4gICAgICAgIGlmIChyZXN0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhcyhrZXkpO1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5nZXQoa2V5LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5LmlzQ29sbGVjdGlvbihub2RlKSA/IG5vZGUuaGFzSW4ocmVzdCkgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIHZhbHVlIGluIHRoaXMgY29sbGVjdGlvbi4gRm9yIGAhIXNldGAsIGB2YWx1ZWAgbmVlZHMgdG8gYmUgYVxuICAgICAqIGJvb2xlYW4gdG8gYWRkL3JlbW92ZSB0aGUgaXRlbSBmcm9tIHRoZSBzZXQuXG4gICAgICovXG4gICAgc2V0SW4ocGF0aCwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgW2tleSwgLi4ucmVzdF0gPSBwYXRoO1xuICAgICAgICBpZiAocmVzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0KGtleSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoaWRlbnRpdHkuaXNDb2xsZWN0aW9uKG5vZGUpKVxuICAgICAgICAgICAgICAgIG5vZGUuc2V0SW4ocmVzdCwgdmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAobm9kZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuc2NoZW1hKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgY29sbGVjdGlvbkZyb21QYXRoKHRoaXMuc2NoZW1hLCByZXN0LCB2YWx1ZSkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgWUFNTCBjb2xsZWN0aW9uIGF0ICR7a2V5fS4gUmVtYWluaW5nIHBhdGg6ICR7cmVzdH1gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0cy5Db2xsZWN0aW9uID0gQ29sbGVjdGlvbjtcbmV4cG9ydHMuY29sbGVjdGlvbkZyb21QYXRoID0gY29sbGVjdGlvbkZyb21QYXRoO1xuZXhwb3J0cy5pc0VtcHR5UGF0aCA9IGlzRW1wdHlQYXRoO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU3RyaW5naWZpZXMgYSBjb21tZW50LlxuICpcbiAqIEVtcHR5IGNvbW1lbnQgbGluZXMgYXJlIGxlZnQgZW1wdHksXG4gKiBsaW5lcyBjb25zaXN0aW5nIG9mIGEgc2luZ2xlIHNwYWNlIGFyZSByZXBsYWNlZCBieSBgI2AsXG4gKiBhbmQgYWxsIG90aGVyIGxpbmVzIGFyZSBwcmVmaXhlZCB3aXRoIGEgYCNgLlxuICovXG5jb25zdCBzdHJpbmdpZnlDb21tZW50ID0gKHN0cikgPT4gc3RyLnJlcGxhY2UoL14oPyEkKSg/OiAkKT8vZ20sICcjJyk7XG5mdW5jdGlvbiBpbmRlbnRDb21tZW50KGNvbW1lbnQsIGluZGVudCkge1xuICAgIGlmICgvXlxcbiskLy50ZXN0KGNvbW1lbnQpKVxuICAgICAgICByZXR1cm4gY29tbWVudC5zdWJzdHJpbmcoMSk7XG4gICAgcmV0dXJuIGluZGVudCA/IGNvbW1lbnQucmVwbGFjZSgvXig/ISAqJCkvZ20sIGluZGVudCkgOiBjb21tZW50O1xufVxuY29uc3QgbGluZUNvbW1lbnQgPSAoc3RyLCBpbmRlbnQsIGNvbW1lbnQpID0+IHN0ci5lbmRzV2l0aCgnXFxuJylcbiAgICA/IGluZGVudENvbW1lbnQoY29tbWVudCwgaW5kZW50KVxuICAgIDogY29tbWVudC5pbmNsdWRlcygnXFxuJylcbiAgICAgICAgPyAnXFxuJyArIGluZGVudENvbW1lbnQoY29tbWVudCwgaW5kZW50KVxuICAgICAgICA6IChzdHIuZW5kc1dpdGgoJyAnKSA/ICcnIDogJyAnKSArIGNvbW1lbnQ7XG5cbmV4cG9ydHMuaW5kZW50Q29tbWVudCA9IGluZGVudENvbW1lbnQ7XG5leHBvcnRzLmxpbmVDb21tZW50ID0gbGluZUNvbW1lbnQ7XG5leHBvcnRzLnN0cmluZ2lmeUNvbW1lbnQgPSBzdHJpbmdpZnlDb21tZW50O1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEZPTERfRkxPVyA9ICdmbG93JztcbmNvbnN0IEZPTERfQkxPQ0sgPSAnYmxvY2snO1xuY29uc3QgRk9MRF9RVU9URUQgPSAncXVvdGVkJztcbi8qKlxuICogVHJpZXMgdG8ga2VlcCBpbnB1dCBhdCB1cCB0byBgbGluZVdpZHRoYCBjaGFyYWN0ZXJzLCBzcGxpdHRpbmcgb25seSBvbiBzcGFjZXNcbiAqIG5vdCBmb2xsb3dlZCBieSBuZXdsaW5lcyBvciBzcGFjZXMgdW5sZXNzIGBtb2RlYCBpcyBgJ3F1b3RlZCdgLiBMaW5lcyBhcmVcbiAqIHRlcm1pbmF0ZWQgd2l0aCBgXFxuYCBhbmQgc3RhcnRlZCB3aXRoIGBpbmRlbnRgLlxuICovXG5mdW5jdGlvbiBmb2xkRmxvd0xpbmVzKHRleHQsIGluZGVudCwgbW9kZSA9ICdmbG93JywgeyBpbmRlbnRBdFN0YXJ0LCBsaW5lV2lkdGggPSA4MCwgbWluQ29udGVudFdpZHRoID0gMjAsIG9uRm9sZCwgb25PdmVyZmxvdyB9ID0ge30pIHtcbiAgICBpZiAoIWxpbmVXaWR0aCB8fCBsaW5lV2lkdGggPCAwKVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICBpZiAobGluZVdpZHRoIDwgbWluQ29udGVudFdpZHRoKVxuICAgICAgICBtaW5Db250ZW50V2lkdGggPSAwO1xuICAgIGNvbnN0IGVuZFN0ZXAgPSBNYXRoLm1heCgxICsgbWluQ29udGVudFdpZHRoLCAxICsgbGluZVdpZHRoIC0gaW5kZW50Lmxlbmd0aCk7XG4gICAgaWYgKHRleHQubGVuZ3RoIDw9IGVuZFN0ZXApXG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIGNvbnN0IGZvbGRzID0gW107XG4gICAgY29uc3QgZXNjYXBlZEZvbGRzID0ge307XG4gICAgbGV0IGVuZCA9IGxpbmVXaWR0aCAtIGluZGVudC5sZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBpbmRlbnRBdFN0YXJ0ID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoaW5kZW50QXRTdGFydCA+IGxpbmVXaWR0aCAtIE1hdGgubWF4KDIsIG1pbkNvbnRlbnRXaWR0aCkpXG4gICAgICAgICAgICBmb2xkcy5wdXNoKDApO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBlbmQgPSBsaW5lV2lkdGggLSBpbmRlbnRBdFN0YXJ0O1xuICAgIH1cbiAgICBsZXQgc3BsaXQgPSB1bmRlZmluZWQ7XG4gICAgbGV0IHByZXYgPSB1bmRlZmluZWQ7XG4gICAgbGV0IG92ZXJmbG93ID0gZmFsc2U7XG4gICAgbGV0IGkgPSAtMTtcbiAgICBsZXQgZXNjU3RhcnQgPSAtMTtcbiAgICBsZXQgZXNjRW5kID0gLTE7XG4gICAgaWYgKG1vZGUgPT09IEZPTERfQkxPQ0spIHtcbiAgICAgICAgaSA9IGNvbnN1bWVNb3JlSW5kZW50ZWRMaW5lcyh0ZXh0LCBpLCBpbmRlbnQubGVuZ3RoKTtcbiAgICAgICAgaWYgKGkgIT09IC0xKVxuICAgICAgICAgICAgZW5kID0gaSArIGVuZFN0ZXA7XG4gICAgfVxuICAgIGZvciAobGV0IGNoOyAoY2ggPSB0ZXh0WyhpICs9IDEpXSk7KSB7XG4gICAgICAgIGlmIChtb2RlID09PSBGT0xEX1FVT1RFRCAmJiBjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICBlc2NTdGFydCA9IGk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRleHRbaSArIDFdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gNTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnVSc6XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gOTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXNjRW5kID0gaTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ggPT09ICdcXG4nKSB7XG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gRk9MRF9CTE9DSylcbiAgICAgICAgICAgICAgICBpID0gY29uc3VtZU1vcmVJbmRlbnRlZExpbmVzKHRleHQsIGksIGluZGVudC5sZW5ndGgpO1xuICAgICAgICAgICAgZW5kID0gaSArIGluZGVudC5sZW5ndGggKyBlbmRTdGVwO1xuICAgICAgICAgICAgc3BsaXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICcgJyAmJlxuICAgICAgICAgICAgICAgIHByZXYgJiZcbiAgICAgICAgICAgICAgICBwcmV2ICE9PSAnICcgJiZcbiAgICAgICAgICAgICAgICBwcmV2ICE9PSAnXFxuJyAmJlxuICAgICAgICAgICAgICAgIHByZXYgIT09ICdcXHQnKSB7XG4gICAgICAgICAgICAgICAgLy8gc3BhY2Ugc3Vycm91bmRlZCBieSBub24tc3BhY2UgY2FuIGJlIHJlcGxhY2VkIHdpdGggbmV3bGluZSArIGluZGVudFxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSB0ZXh0W2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0ICE9PSAnICcgJiYgbmV4dCAhPT0gJ1xcbicgJiYgbmV4dCAhPT0gJ1xcdCcpXG4gICAgICAgICAgICAgICAgICAgIHNwbGl0ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID49IGVuZCkge1xuICAgICAgICAgICAgICAgIGlmIChzcGxpdCkge1xuICAgICAgICAgICAgICAgICAgICBmb2xkcy5wdXNoKHNwbGl0KTtcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gc3BsaXQgKyBlbmRTdGVwO1xuICAgICAgICAgICAgICAgICAgICBzcGxpdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobW9kZSA9PT0gRk9MRF9RVU9URUQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hpdGUtc3BhY2UgY29sbGVjdGVkIGF0IGVuZCBtYXkgc3RyZXRjaCBwYXN0IGxpbmVXaWR0aFxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocHJldiA9PT0gJyAnIHx8IHByZXYgPT09ICdcXHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ID0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaCA9IHRleHRbKGkgKz0gMSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEFjY291bnQgZm9yIG5ld2xpbmUgZXNjYXBlLCBidXQgZG9uJ3QgYnJlYWsgcHJlY2VkaW5nIGVzY2FwZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBqID0gaSA+IGVzY0VuZCArIDEgPyBpIC0gMiA6IGVzY1N0YXJ0IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQmFpbCBvdXQgaWYgbGluZVdpZHRoICYgbWluQ29udGVudFdpZHRoIGFyZSBzaG9ydGVyIHRoYW4gYW4gZXNjYXBlIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXNjYXBlZEZvbGRzW2pdKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgICAgICAgICAgICAgIGZvbGRzLnB1c2goaik7XG4gICAgICAgICAgICAgICAgICAgIGVzY2FwZWRGb2xkc1tqXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IGogKyBlbmRTdGVwO1xuICAgICAgICAgICAgICAgICAgICBzcGxpdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJldiA9IGNoO1xuICAgIH1cbiAgICBpZiAob3ZlcmZsb3cgJiYgb25PdmVyZmxvdylcbiAgICAgICAgb25PdmVyZmxvdygpO1xuICAgIGlmIChmb2xkcy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIGlmIChvbkZvbGQpXG4gICAgICAgIG9uRm9sZCgpO1xuICAgIGxldCByZXMgPSB0ZXh0LnNsaWNlKDAsIGZvbGRzWzBdKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZvbGRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGZvbGQgPSBmb2xkc1tpXTtcbiAgICAgICAgY29uc3QgZW5kID0gZm9sZHNbaSArIDFdIHx8IHRleHQubGVuZ3RoO1xuICAgICAgICBpZiAoZm9sZCA9PT0gMClcbiAgICAgICAgICAgIHJlcyA9IGBcXG4ke2luZGVudH0ke3RleHQuc2xpY2UoMCwgZW5kKX1gO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtb2RlID09PSBGT0xEX1FVT1RFRCAmJiBlc2NhcGVkRm9sZHNbZm9sZF0pXG4gICAgICAgICAgICAgICAgcmVzICs9IGAke3RleHRbZm9sZF19XFxcXGA7XG4gICAgICAgICAgICByZXMgKz0gYFxcbiR7aW5kZW50fSR7dGV4dC5zbGljZShmb2xkICsgMSwgZW5kKX1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIFByZXN1bWVzIGBpICsgMWAgaXMgYXQgdGhlIHN0YXJ0IG9mIGEgbGluZVxuICogQHJldHVybnMgaW5kZXggb2YgbGFzdCBuZXdsaW5lIGluIG1vcmUtaW5kZW50ZWQgYmxvY2tcbiAqL1xuZnVuY3Rpb24gY29uc3VtZU1vcmVJbmRlbnRlZExpbmVzKHRleHQsIGksIGluZGVudCkge1xuICAgIGxldCBlbmQgPSBpO1xuICAgIGxldCBzdGFydCA9IGkgKyAxO1xuICAgIGxldCBjaCA9IHRleHRbc3RhcnRdO1xuICAgIHdoaWxlIChjaCA9PT0gJyAnIHx8IGNoID09PSAnXFx0Jykge1xuICAgICAgICBpZiAoaSA8IHN0YXJ0ICsgaW5kZW50KSB7XG4gICAgICAgICAgICBjaCA9IHRleHRbKytpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBjaCA9IHRleHRbKytpXTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGNoICYmIGNoICE9PSAnXFxuJyk7XG4gICAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgIGNoID0gdGV4dFtzdGFydF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVuZDtcbn1cblxuZXhwb3J0cy5GT0xEX0JMT0NLID0gRk9MRF9CTE9DSztcbmV4cG9ydHMuRk9MRF9GTE9XID0gRk9MRF9GTE9XO1xuZXhwb3J0cy5GT0xEX1FVT1RFRCA9IEZPTERfUVVPVEVEO1xuZXhwb3J0cy5mb2xkRmxvd0xpbmVzID0gZm9sZEZsb3dMaW5lcztcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgU2NhbGFyID0gcmVxdWlyZSgnLi4vbm9kZXMvU2NhbGFyLmpzJyk7XG52YXIgZm9sZEZsb3dMaW5lcyA9IHJlcXVpcmUoJy4vZm9sZEZsb3dMaW5lcy5qcycpO1xuXG5jb25zdCBnZXRGb2xkT3B0aW9ucyA9IChjdHgsIGlzQmxvY2spID0+ICh7XG4gICAgaW5kZW50QXRTdGFydDogaXNCbG9jayA/IGN0eC5pbmRlbnQubGVuZ3RoIDogY3R4LmluZGVudEF0U3RhcnQsXG4gICAgbGluZVdpZHRoOiBjdHgub3B0aW9ucy5saW5lV2lkdGgsXG4gICAgbWluQ29udGVudFdpZHRoOiBjdHgub3B0aW9ucy5taW5Db250ZW50V2lkdGhcbn0pO1xuLy8gQWxzbyBjaGVja3MgZm9yIGxpbmVzIHN0YXJ0aW5nIHdpdGggJSwgYXMgcGFyc2luZyB0aGUgb3V0cHV0IGFzIFlBTUwgMS4xIHdpbGxcbi8vIHByZXN1bWUgdGhhdCdzIHN0YXJ0aW5nIGEgbmV3IGRvY3VtZW50LlxuY29uc3QgY29udGFpbnNEb2N1bWVudE1hcmtlciA9IChzdHIpID0+IC9eKCV8LS0tfFxcLlxcLlxcLikvbS50ZXN0KHN0cik7XG5mdW5jdGlvbiBsaW5lTGVuZ3RoT3ZlckxpbWl0KHN0ciwgbGluZVdpZHRoLCBpbmRlbnRMZW5ndGgpIHtcbiAgICBpZiAoIWxpbmVXaWR0aCB8fCBsaW5lV2lkdGggPCAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgbGltaXQgPSBsaW5lV2lkdGggLSBpbmRlbnRMZW5ndGg7XG4gICAgY29uc3Qgc3RyTGVuID0gc3RyLmxlbmd0aDtcbiAgICBpZiAoc3RyTGVuIDw9IGxpbWl0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDAsIHN0YXJ0ID0gMDsgaSA8IHN0ckxlbjsgKytpKSB7XG4gICAgICAgIGlmIChzdHJbaV0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICBpZiAoaSAtIHN0YXJ0ID4gbGltaXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgaWYgKHN0ckxlbiAtIHN0YXJ0IDw9IGxpbWl0KVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGRvdWJsZVF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KSB7XG4gICAgY29uc3QganNvbiA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICBpZiAoY3R4Lm9wdGlvbnMuZG91YmxlUXVvdGVkQXNKU09OKVxuICAgICAgICByZXR1cm4ganNvbjtcbiAgICBjb25zdCB7IGltcGxpY2l0S2V5IH0gPSBjdHg7XG4gICAgY29uc3QgbWluTXVsdGlMaW5lTGVuZ3RoID0gY3R4Lm9wdGlvbnMuZG91YmxlUXVvdGVkTWluTXVsdGlMaW5lTGVuZ3RoO1xuICAgIGNvbnN0IGluZGVudCA9IGN0eC5pbmRlbnQgfHwgKGNvbnRhaW5zRG9jdW1lbnRNYXJrZXIodmFsdWUpID8gJyAgJyA6ICcnKTtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgY2ggPSBqc29uW2ldOyBjaDsgY2ggPSBqc29uWysraV0pIHtcbiAgICAgICAgaWYgKGNoID09PSAnICcgJiYganNvbltpICsgMV0gPT09ICdcXFxcJyAmJiBqc29uW2kgKyAyXSA9PT0gJ24nKSB7XG4gICAgICAgICAgICAvLyBzcGFjZSBiZWZvcmUgbmV3bGluZSBuZWVkcyB0byBiZSBlc2NhcGVkIHRvIG5vdCBiZSBmb2xkZWRcbiAgICAgICAgICAgIHN0ciArPSBqc29uLnNsaWNlKHN0YXJ0LCBpKSArICdcXFxcICc7XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICBzdGFydCA9IGk7XG4gICAgICAgICAgICBjaCA9ICdcXFxcJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ggPT09ICdcXFxcJylcbiAgICAgICAgICAgIHN3aXRjaCAoanNvbltpICsgMV0pIHtcbiAgICAgICAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGpzb24uc2xpY2Uoc3RhcnQsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IGpzb24uc3Vic3RyKGkgKyAyLCA0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzAwMDAnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFwwJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnMDAwNyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXGEnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcwMDBiJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcdic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzAwMWInOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFxlJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnMDA4NSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXE4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcwMGEwJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcXyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzIwMjgnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFxMJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnMjAyOSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXFAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5zdWJzdHIoMCwgMikgPT09ICcwMCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFx4JyArIGNvZGUuc3Vic3RyKDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0ganNvbi5zdWJzdHIoaSwgNik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgICAgICAgICBpZiAoaW1wbGljaXRLZXkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb25baSArIDJdID09PSAnXCInIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uLmxlbmd0aCA8IG1pbk11bHRpTGluZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9sZGluZyB3aWxsIGVhdCBmaXJzdCBuZXdsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0ganNvbi5zbGljZShzdGFydCwgaSkgKyAnXFxuXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChqc29uW2kgKyAyXSA9PT0gJ1xcXFwnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbltpICsgM10gPT09ICduJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25baSArIDRdICE9PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBpbmRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGFjZSBhZnRlciBuZXdsaW5lIG5lZWRzIHRvIGJlIGVzY2FwZWQgdG8gbm90IGJlIGZvbGRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25baSArIDJdID09PSAnICcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBzdHIgPSBzdGFydCA/IHN0ciArIGpzb24uc2xpY2Uoc3RhcnQpIDoganNvbjtcbiAgICByZXR1cm4gaW1wbGljaXRLZXlcbiAgICAgICAgPyBzdHJcbiAgICAgICAgOiBmb2xkRmxvd0xpbmVzLmZvbGRGbG93TGluZXMoc3RyLCBpbmRlbnQsIGZvbGRGbG93TGluZXMuRk9MRF9RVU9URUQsIGdldEZvbGRPcHRpb25zKGN0eCwgZmFsc2UpKTtcbn1cbmZ1bmN0aW9uIHNpbmdsZVF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KSB7XG4gICAgaWYgKGN0eC5vcHRpb25zLnNpbmdsZVF1b3RlID09PSBmYWxzZSB8fFxuICAgICAgICAoY3R4LmltcGxpY2l0S2V5ICYmIHZhbHVlLmluY2x1ZGVzKCdcXG4nKSkgfHxcbiAgICAgICAgL1sgXFx0XVxcbnxcXG5bIFxcdF0vLnRlc3QodmFsdWUpIC8vIHNpbmdsZSBxdW90ZWQgc3RyaW5nIGNhbid0IGhhdmUgbGVhZGluZyBvciB0cmFpbGluZyB3aGl0ZXNwYWNlIGFyb3VuZCBuZXdsaW5lXG4gICAgKVxuICAgICAgICByZXR1cm4gZG91YmxlUXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpO1xuICAgIGNvbnN0IGluZGVudCA9IGN0eC5pbmRlbnQgfHwgKGNvbnRhaW5zRG9jdW1lbnRNYXJrZXIodmFsdWUpID8gJyAgJyA6ICcnKTtcbiAgICBjb25zdCByZXMgPSBcIidcIiArIHZhbHVlLnJlcGxhY2UoLycvZywgXCInJ1wiKS5yZXBsYWNlKC9cXG4rL2csIGAkJlxcbiR7aW5kZW50fWApICsgXCInXCI7XG4gICAgcmV0dXJuIGN0eC5pbXBsaWNpdEtleVxuICAgICAgICA/IHJlc1xuICAgICAgICA6IGZvbGRGbG93TGluZXMuZm9sZEZsb3dMaW5lcyhyZXMsIGluZGVudCwgZm9sZEZsb3dMaW5lcy5GT0xEX0ZMT1csIGdldEZvbGRPcHRpb25zKGN0eCwgZmFsc2UpKTtcbn1cbmZ1bmN0aW9uIHF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KSB7XG4gICAgY29uc3QgeyBzaW5nbGVRdW90ZSB9ID0gY3R4Lm9wdGlvbnM7XG4gICAgbGV0IHFzO1xuICAgIGlmIChzaW5nbGVRdW90ZSA9PT0gZmFsc2UpXG4gICAgICAgIHFzID0gZG91YmxlUXVvdGVkU3RyaW5nO1xuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBoYXNEb3VibGUgPSB2YWx1ZS5pbmNsdWRlcygnXCInKTtcbiAgICAgICAgY29uc3QgaGFzU2luZ2xlID0gdmFsdWUuaW5jbHVkZXMoXCInXCIpO1xuICAgICAgICBpZiAoaGFzRG91YmxlICYmICFoYXNTaW5nbGUpXG4gICAgICAgICAgICBxcyA9IHNpbmdsZVF1b3RlZFN0cmluZztcbiAgICAgICAgZWxzZSBpZiAoaGFzU2luZ2xlICYmICFoYXNEb3VibGUpXG4gICAgICAgICAgICBxcyA9IGRvdWJsZVF1b3RlZFN0cmluZztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcXMgPSBzaW5nbGVRdW90ZSA/IHNpbmdsZVF1b3RlZFN0cmluZyA6IGRvdWJsZVF1b3RlZFN0cmluZztcbiAgICB9XG4gICAgcmV0dXJuIHFzKHZhbHVlLCBjdHgpO1xufVxuLy8gVGhlIG5lZ2F0aXZlIGxvb2tiZWhpbmQgYXZvaWRzIGEgcG9seW5vbWlhbCBzZWFyY2gsXG4vLyBidXQgaXNuJ3Qgc3VwcG9ydGVkIHlldCBvbiBTYWZhcmk6IGh0dHBzOi8vY2FuaXVzZS5jb20vanMtcmVnZXhwLWxvb2tiZWhpbmRcbmxldCBibG9ja0VuZE5ld2xpbmVzO1xudHJ5IHtcbiAgICBibG9ja0VuZE5ld2xpbmVzID0gbmV3IFJlZ0V4cCgnKF58KD88IVxcbikpXFxuKyg/IVxcbnwkKScsICdnJyk7XG59XG5jYXRjaCB7XG4gICAgYmxvY2tFbmROZXdsaW5lcyA9IC9cXG4rKD8hXFxufCQpL2c7XG59XG5mdW5jdGlvbiBibG9ja1N0cmluZyh7IGNvbW1lbnQsIHR5cGUsIHZhbHVlIH0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgIGNvbnN0IHsgYmxvY2tRdW90ZSwgY29tbWVudFN0cmluZywgbGluZVdpZHRoIH0gPSBjdHgub3B0aW9ucztcbiAgICAvLyAxLiBCbG9jayBjYW4ndCBlbmQgaW4gd2hpdGVzcGFjZSB1bmxlc3MgdGhlIGxhc3QgbGluZSBpcyBub24tZW1wdHkuXG4gICAgLy8gMi4gU3RyaW5ncyBjb25zaXN0aW5nIG9mIG9ubHkgd2hpdGVzcGFjZSBhcmUgYmVzdCByZW5kZXJlZCBleHBsaWNpdGx5LlxuICAgIGlmICghYmxvY2tRdW90ZSB8fCAvXFxuW1xcdCBdKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBxdW90ZWRTdHJpbmcodmFsdWUsIGN0eCk7XG4gICAgfVxuICAgIGNvbnN0IGluZGVudCA9IGN0eC5pbmRlbnQgfHxcbiAgICAgICAgKGN0eC5mb3JjZUJsb2NrSW5kZW50IHx8IGNvbnRhaW5zRG9jdW1lbnRNYXJrZXIodmFsdWUpID8gJyAgJyA6ICcnKTtcbiAgICBjb25zdCBsaXRlcmFsID0gYmxvY2tRdW90ZSA9PT0gJ2xpdGVyYWwnXG4gICAgICAgID8gdHJ1ZVxuICAgICAgICA6IGJsb2NrUXVvdGUgPT09ICdmb2xkZWQnIHx8IHR5cGUgPT09IFNjYWxhci5TY2FsYXIuQkxPQ0tfRk9MREVEXG4gICAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgICA6IHR5cGUgPT09IFNjYWxhci5TY2FsYXIuQkxPQ0tfTElURVJBTFxuICAgICAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgICAgIDogIWxpbmVMZW5ndGhPdmVyTGltaXQodmFsdWUsIGxpbmVXaWR0aCwgaW5kZW50Lmxlbmd0aCk7XG4gICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgcmV0dXJuIGxpdGVyYWwgPyAnfFxcbicgOiAnPlxcbic7XG4gICAgLy8gZGV0ZXJtaW5lIGNob21waW5nIGZyb20gd2hpdGVzcGFjZSBhdCB2YWx1ZSBlbmRcbiAgICBsZXQgY2hvbXA7XG4gICAgbGV0IGVuZFN0YXJ0O1xuICAgIGZvciAoZW5kU3RhcnQgPSB2YWx1ZS5sZW5ndGg7IGVuZFN0YXJ0ID4gMDsgLS1lbmRTdGFydCkge1xuICAgICAgICBjb25zdCBjaCA9IHZhbHVlW2VuZFN0YXJ0IC0gMV07XG4gICAgICAgIGlmIChjaCAhPT0gJ1xcbicgJiYgY2ggIT09ICdcXHQnICYmIGNoICE9PSAnICcpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgbGV0IGVuZCA9IHZhbHVlLnN1YnN0cmluZyhlbmRTdGFydCk7XG4gICAgY29uc3QgZW5kTmxQb3MgPSBlbmQuaW5kZXhPZignXFxuJyk7XG4gICAgaWYgKGVuZE5sUG9zID09PSAtMSkge1xuICAgICAgICBjaG9tcCA9ICctJzsgLy8gc3RyaXBcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgPT09IGVuZCB8fCBlbmRObFBvcyAhPT0gZW5kLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgY2hvbXAgPSAnKyc7IC8vIGtlZXBcbiAgICAgICAgaWYgKG9uQ2hvbXBLZWVwKVxuICAgICAgICAgICAgb25DaG9tcEtlZXAoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNob21wID0gJyc7IC8vIGNsaXBcbiAgICB9XG4gICAgaWYgKGVuZCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIC1lbmQubGVuZ3RoKTtcbiAgICAgICAgaWYgKGVuZFtlbmQubGVuZ3RoIC0gMV0gPT09ICdcXG4nKVxuICAgICAgICAgICAgZW5kID0gZW5kLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgZW5kID0gZW5kLnJlcGxhY2UoYmxvY2tFbmROZXdsaW5lcywgYCQmJHtpbmRlbnR9YCk7XG4gICAgfVxuICAgIC8vIGRldGVybWluZSBpbmRlbnQgaW5kaWNhdG9yIGZyb20gd2hpdGVzcGFjZSBhdCB2YWx1ZSBzdGFydFxuICAgIGxldCBzdGFydFdpdGhTcGFjZSA9IGZhbHNlO1xuICAgIGxldCBzdGFydEVuZDtcbiAgICBsZXQgc3RhcnRObFBvcyA9IC0xO1xuICAgIGZvciAoc3RhcnRFbmQgPSAwOyBzdGFydEVuZCA8IHZhbHVlLmxlbmd0aDsgKytzdGFydEVuZCkge1xuICAgICAgICBjb25zdCBjaCA9IHZhbHVlW3N0YXJ0RW5kXTtcbiAgICAgICAgaWYgKGNoID09PSAnICcpXG4gICAgICAgICAgICBzdGFydFdpdGhTcGFjZSA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAnXFxuJylcbiAgICAgICAgICAgIHN0YXJ0TmxQb3MgPSBzdGFydEVuZDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxldCBzdGFydCA9IHZhbHVlLnN1YnN0cmluZygwLCBzdGFydE5sUG9zIDwgc3RhcnRFbmQgPyBzdGFydE5sUG9zICsgMSA6IHN0YXJ0RW5kKTtcbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoc3RhcnQubGVuZ3RoKTtcbiAgICAgICAgc3RhcnQgPSBzdGFydC5yZXBsYWNlKC9cXG4rL2csIGAkJiR7aW5kZW50fWApO1xuICAgIH1cbiAgICBjb25zdCBpbmRlbnRTaXplID0gaW5kZW50ID8gJzInIDogJzEnOyAvLyByb290IGlzIGF0IC0xXG4gICAgLy8gTGVhZGluZyB8IG9yID4gaXMgYWRkZWQgbGF0ZXJcbiAgICBsZXQgaGVhZGVyID0gKHN0YXJ0V2l0aFNwYWNlID8gaW5kZW50U2l6ZSA6ICcnKSArIGNob21wO1xuICAgIGlmIChjb21tZW50KSB7XG4gICAgICAgIGhlYWRlciArPSAnICcgKyBjb21tZW50U3RyaW5nKGNvbW1lbnQucmVwbGFjZSgvID9bXFxyXFxuXSsvZywgJyAnKSk7XG4gICAgICAgIGlmIChvbkNvbW1lbnQpXG4gICAgICAgICAgICBvbkNvbW1lbnQoKTtcbiAgICB9XG4gICAgaWYgKCFsaXRlcmFsKSB7XG4gICAgICAgIGNvbnN0IGZvbGRlZFZhbHVlID0gdmFsdWVcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXG4rL2csICdcXG4kJicpXG4gICAgICAgICAgICAucmVwbGFjZSgvKD86XnxcXG4pKFtcXHQgXS4qKSg/OihbXFxuXFx0IF0qKVxcbig/IVtcXG5cXHQgXSkpPy9nLCAnJDEkMicpIC8vIG1vcmUtaW5kZW50ZWQgbGluZXMgYXJlbid0IGZvbGRlZFxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgXiBtb3JlLWluZC4gXiBlbXB0eSAgICAgXiBjYXB0dXJlIG5leHQgZW1wdHkgbGluZXMgb25seSBhdCBlbmQgb2YgaW5kZW50XG4gICAgICAgICAgICAucmVwbGFjZSgvXFxuKy9nLCBgJCYke2luZGVudH1gKTtcbiAgICAgICAgbGV0IGxpdGVyYWxGYWxsYmFjayA9IGZhbHNlO1xuICAgICAgICBjb25zdCBmb2xkT3B0aW9ucyA9IGdldEZvbGRPcHRpb25zKGN0eCwgdHJ1ZSk7XG4gICAgICAgIGlmIChibG9ja1F1b3RlICE9PSAnZm9sZGVkJyAmJiB0eXBlICE9PSBTY2FsYXIuU2NhbGFyLkJMT0NLX0ZPTERFRCkge1xuICAgICAgICAgICAgZm9sZE9wdGlvbnMub25PdmVyZmxvdyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBsaXRlcmFsRmFsbGJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib2R5ID0gZm9sZEZsb3dMaW5lcy5mb2xkRmxvd0xpbmVzKGAke3N0YXJ0fSR7Zm9sZGVkVmFsdWV9JHtlbmR9YCwgaW5kZW50LCBmb2xkRmxvd0xpbmVzLkZPTERfQkxPQ0ssIGZvbGRPcHRpb25zKTtcbiAgICAgICAgaWYgKCFsaXRlcmFsRmFsbGJhY2spXG4gICAgICAgICAgICByZXR1cm4gYD4ke2hlYWRlcn1cXG4ke2luZGVudH0ke2JvZHl9YDtcbiAgICB9XG4gICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXG4rL2csIGAkJiR7aW5kZW50fWApO1xuICAgIHJldHVybiBgfCR7aGVhZGVyfVxcbiR7aW5kZW50fSR7c3RhcnR9JHt2YWx1ZX0ke2VuZH1gO1xufVxuZnVuY3Rpb24gcGxhaW5TdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgY29uc3QgeyB0eXBlLCB2YWx1ZSB9ID0gaXRlbTtcbiAgICBjb25zdCB7IGFjdHVhbFN0cmluZywgaW1wbGljaXRLZXksIGluZGVudCwgaW5kZW50U3RlcCwgaW5GbG93IH0gPSBjdHg7XG4gICAgaWYgKChpbXBsaWNpdEtleSAmJiB2YWx1ZS5pbmNsdWRlcygnXFxuJykpIHx8XG4gICAgICAgIChpbkZsb3cgJiYgL1tbXFxde30sXS8udGVzdCh2YWx1ZSkpKSB7XG4gICAgICAgIHJldHVybiBxdW90ZWRTdHJpbmcodmFsdWUsIGN0eCk7XG4gICAgfVxuICAgIGlmICgvXltcXG5cXHQgLFtcXF17fSMmKiF8PidcIiVAYF18Xls/LV0kfF5bPy1dWyBcXHRdfFtcXG46XVsgXFx0XXxbIFxcdF1cXG58W1xcblxcdCBdI3xbXFxuXFx0IDpdJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgLy8gbm90IGFsbG93ZWQ6XG4gICAgICAgIC8vIC0gJy0nIG9yICc/J1xuICAgICAgICAvLyAtIHN0YXJ0IHdpdGggYW4gaW5kaWNhdG9yIGNoYXJhY3RlciAoZXhjZXB0IFs/Oi1dKSBvciAvWz8tXSAvXG4gICAgICAgIC8vIC0gJ1xcbiAnLCAnOiAnIG9yICcgXFxuJyBhbnl3aGVyZVxuICAgICAgICAvLyAtICcjJyBub3QgcHJlY2VkZWQgYnkgYSBub24tc3BhY2UgY2hhclxuICAgICAgICAvLyAtIGVuZCB3aXRoICcgJyBvciAnOidcbiAgICAgICAgcmV0dXJuIGltcGxpY2l0S2V5IHx8IGluRmxvdyB8fCAhdmFsdWUuaW5jbHVkZXMoJ1xcbicpXG4gICAgICAgICAgICA/IHF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KVxuICAgICAgICAgICAgOiBibG9ja1N0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgIH1cbiAgICBpZiAoIWltcGxpY2l0S2V5ICYmXG4gICAgICAgICFpbkZsb3cgJiZcbiAgICAgICAgdHlwZSAhPT0gU2NhbGFyLlNjYWxhci5QTEFJTiAmJlxuICAgICAgICB2YWx1ZS5pbmNsdWRlcygnXFxuJykpIHtcbiAgICAgICAgLy8gV2hlcmUgYWxsb3dlZCAmIHR5cGUgbm90IHNldCBleHBsaWNpdGx5LCBwcmVmZXIgYmxvY2sgc3R5bGUgZm9yIG11bHRpbGluZSBzdHJpbmdzXG4gICAgICAgIHJldHVybiBibG9ja1N0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgIH1cbiAgICBpZiAoY29udGFpbnNEb2N1bWVudE1hcmtlcih2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGluZGVudCA9PT0gJycpIHtcbiAgICAgICAgICAgIGN0eC5mb3JjZUJsb2NrSW5kZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBibG9ja1N0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGltcGxpY2l0S2V5ICYmIGluZGVudCA9PT0gaW5kZW50U3RlcCkge1xuICAgICAgICAgICAgcmV0dXJuIHF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzdHIgPSB2YWx1ZS5yZXBsYWNlKC9cXG4rL2csIGAkJlxcbiR7aW5kZW50fWApO1xuICAgIC8vIFZlcmlmeSB0aGF0IG91dHB1dCB3aWxsIGJlIHBhcnNlZCBhcyBhIHN0cmluZywgYXMgZS5nLiBwbGFpbiBudW1iZXJzIGFuZFxuICAgIC8vIGJvb2xlYW5zIGdldCBwYXJzZWQgd2l0aCB0aG9zZSB0eXBlcyBpbiB2MS4yIChlLmcuICc0MicsICd0cnVlJyAmICcwLjllLTMnKSxcbiAgICAvLyBhbmQgb3RoZXJzIGluIHYxLjEuXG4gICAgaWYgKGFjdHVhbFN0cmluZykge1xuICAgICAgICBjb25zdCB0ZXN0ID0gKHRhZykgPT4gdGFnLmRlZmF1bHQgJiYgdGFnLnRhZyAhPT0gJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicgJiYgdGFnLnRlc3Q/LnRlc3Qoc3RyKTtcbiAgICAgICAgY29uc3QgeyBjb21wYXQsIHRhZ3MgfSA9IGN0eC5kb2Muc2NoZW1hO1xuICAgICAgICBpZiAodGFncy5zb21lKHRlc3QpIHx8IGNvbXBhdD8uc29tZSh0ZXN0KSlcbiAgICAgICAgICAgIHJldHVybiBxdW90ZWRTdHJpbmcodmFsdWUsIGN0eCk7XG4gICAgfVxuICAgIHJldHVybiBpbXBsaWNpdEtleVxuICAgICAgICA/IHN0clxuICAgICAgICA6IGZvbGRGbG93TGluZXMuZm9sZEZsb3dMaW5lcyhzdHIsIGluZGVudCwgZm9sZEZsb3dMaW5lcy5GT0xEX0ZMT1csIGdldEZvbGRPcHRpb25zKGN0eCwgZmFsc2UpKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVN0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICBjb25zdCB7IGltcGxpY2l0S2V5LCBpbkZsb3cgfSA9IGN0eDtcbiAgICBjb25zdCBzcyA9IHR5cGVvZiBpdGVtLnZhbHVlID09PSAnc3RyaW5nJ1xuICAgICAgICA/IGl0ZW1cbiAgICAgICAgOiBPYmplY3QuYXNzaWduKHt9LCBpdGVtLCB7IHZhbHVlOiBTdHJpbmcoaXRlbS52YWx1ZSkgfSk7XG4gICAgbGV0IHsgdHlwZSB9ID0gaXRlbTtcbiAgICBpZiAodHlwZSAhPT0gU2NhbGFyLlNjYWxhci5RVU9URV9ET1VCTEUpIHtcbiAgICAgICAgLy8gZm9yY2UgZG91YmxlIHF1b3RlcyBvbiBjb250cm9sIGNoYXJhY3RlcnMgJiB1bnBhaXJlZCBzdXJyb2dhdGVzXG4gICAgICAgIGlmICgvW1xceDAwLVxceDA4XFx4MGItXFx4MWZcXHg3Zi1cXHg5ZlxcdXtEODAwfS1cXHV7REZGRn1dL3UudGVzdChzcy52YWx1ZSkpXG4gICAgICAgICAgICB0eXBlID0gU2NhbGFyLlNjYWxhci5RVU9URV9ET1VCTEU7XG4gICAgfVxuICAgIGNvbnN0IF9zdHJpbmdpZnkgPSAoX3R5cGUpID0+IHtcbiAgICAgICAgc3dpdGNoIChfdHlwZSkge1xuICAgICAgICAgICAgY2FzZSBTY2FsYXIuU2NhbGFyLkJMT0NLX0ZPTERFRDpcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyLlNjYWxhci5CTE9DS19MSVRFUkFMOlxuICAgICAgICAgICAgICAgIHJldHVybiBpbXBsaWNpdEtleSB8fCBpbkZsb3dcbiAgICAgICAgICAgICAgICAgICAgPyBxdW90ZWRTdHJpbmcoc3MudmFsdWUsIGN0eCkgLy8gYmxvY2tzIGFyZSBub3QgdmFsaWQgaW5zaWRlIGZsb3cgY29udGFpbmVyc1xuICAgICAgICAgICAgICAgICAgICA6IGJsb2NrU3RyaW5nKHNzLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXIuU2NhbGFyLlFVT1RFX0RPVUJMRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gZG91YmxlUXVvdGVkU3RyaW5nKHNzLnZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXIuU2NhbGFyLlFVT1RFX1NJTkdMRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gc2luZ2xlUXVvdGVkU3RyaW5nKHNzLnZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXIuU2NhbGFyLlBMQUlOOlxuICAgICAgICAgICAgICAgIHJldHVybiBwbGFpblN0cmluZyhzcywgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGxldCByZXMgPSBfc3RyaW5naWZ5KHR5cGUpO1xuICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgeyBkZWZhdWx0S2V5VHlwZSwgZGVmYXVsdFN0cmluZ1R5cGUgfSA9IGN0eC5vcHRpb25zO1xuICAgICAgICBjb25zdCB0ID0gKGltcGxpY2l0S2V5ICYmIGRlZmF1bHRLZXlUeXBlKSB8fCBkZWZhdWx0U3RyaW5nVHlwZTtcbiAgICAgICAgcmVzID0gX3N0cmluZ2lmeSh0KTtcbiAgICAgICAgaWYgKHJlcyA9PT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGVmYXVsdCBzdHJpbmcgdHlwZSAke3R9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmV4cG9ydHMuc3RyaW5naWZ5U3RyaW5nID0gc3RyaW5naWZ5U3RyaW5nO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBhbmNob3JzID0gcmVxdWlyZSgnLi4vZG9jL2FuY2hvcnMuanMnKTtcbnZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4uL25vZGVzL2lkZW50aXR5LmpzJyk7XG52YXIgc3RyaW5naWZ5Q29tbWVudCA9IHJlcXVpcmUoJy4vc3RyaW5naWZ5Q29tbWVudC5qcycpO1xudmFyIHN0cmluZ2lmeVN0cmluZyA9IHJlcXVpcmUoJy4vc3RyaW5naWZ5U3RyaW5nLmpzJyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0cmluZ2lmeUNvbnRleHQoZG9jLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0ID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGJsb2NrUXVvdGU6IHRydWUsXG4gICAgICAgIGNvbW1lbnRTdHJpbmc6IHN0cmluZ2lmeUNvbW1lbnQuc3RyaW5naWZ5Q29tbWVudCxcbiAgICAgICAgZGVmYXVsdEtleVR5cGU6IG51bGwsXG4gICAgICAgIGRlZmF1bHRTdHJpbmdUeXBlOiAnUExBSU4nLFxuICAgICAgICBkaXJlY3RpdmVzOiBudWxsLFxuICAgICAgICBkb3VibGVRdW90ZWRBc0pTT046IGZhbHNlLFxuICAgICAgICBkb3VibGVRdW90ZWRNaW5NdWx0aUxpbmVMZW5ndGg6IDQwLFxuICAgICAgICBmYWxzZVN0cjogJ2ZhbHNlJyxcbiAgICAgICAgZmxvd0NvbGxlY3Rpb25QYWRkaW5nOiB0cnVlLFxuICAgICAgICBpbmRlbnRTZXE6IHRydWUsXG4gICAgICAgIGxpbmVXaWR0aDogODAsXG4gICAgICAgIG1pbkNvbnRlbnRXaWR0aDogMjAsXG4gICAgICAgIG51bGxTdHI6ICdudWxsJyxcbiAgICAgICAgc2ltcGxlS2V5czogZmFsc2UsXG4gICAgICAgIHNpbmdsZVF1b3RlOiBudWxsLFxuICAgICAgICB0cnVlU3RyOiAndHJ1ZScsXG4gICAgICAgIHZlcmlmeUFsaWFzT3JkZXI6IHRydWVcbiAgICB9LCBkb2Muc2NoZW1hLnRvU3RyaW5nT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgbGV0IGluRmxvdztcbiAgICBzd2l0Y2ggKG9wdC5jb2xsZWN0aW9uU3R5bGUpIHtcbiAgICAgICAgY2FzZSAnYmxvY2snOlxuICAgICAgICAgICAgaW5GbG93ID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZmxvdyc6XG4gICAgICAgICAgICBpbkZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpbkZsb3cgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBhbmNob3JzOiBuZXcgU2V0KCksXG4gICAgICAgIGRvYyxcbiAgICAgICAgZmxvd0NvbGxlY3Rpb25QYWRkaW5nOiBvcHQuZmxvd0NvbGxlY3Rpb25QYWRkaW5nID8gJyAnIDogJycsXG4gICAgICAgIGluZGVudDogJycsXG4gICAgICAgIGluZGVudFN0ZXA6IHR5cGVvZiBvcHQuaW5kZW50ID09PSAnbnVtYmVyJyA/ICcgJy5yZXBlYXQob3B0LmluZGVudCkgOiAnICAnLFxuICAgICAgICBpbkZsb3csXG4gICAgICAgIG9wdGlvbnM6IG9wdFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRUYWdPYmplY3QodGFncywgaXRlbSkge1xuICAgIGlmIChpdGVtLnRhZykge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHRhZ3MuZmlsdGVyKHQgPT4gdC50YWcgPT09IGl0ZW0udGFnKTtcbiAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA+IDApXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2guZmluZCh0ID0+IHQuZm9ybWF0ID09PSBpdGVtLmZvcm1hdCkgPz8gbWF0Y2hbMF07XG4gICAgfVxuICAgIGxldCB0YWdPYmogPSB1bmRlZmluZWQ7XG4gICAgbGV0IG9iajtcbiAgICBpZiAoaWRlbnRpdHkuaXNTY2FsYXIoaXRlbSkpIHtcbiAgICAgICAgb2JqID0gaXRlbS52YWx1ZTtcbiAgICAgICAgbGV0IG1hdGNoID0gdGFncy5maWx0ZXIodCA9PiB0LmlkZW50aWZ5Py4ob2JqKSk7XG4gICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXN0TWF0Y2ggPSBtYXRjaC5maWx0ZXIodCA9PiB0LnRlc3QpO1xuICAgICAgICAgICAgaWYgKHRlc3RNYXRjaC5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgIG1hdGNoID0gdGVzdE1hdGNoO1xuICAgICAgICB9XG4gICAgICAgIHRhZ09iaiA9XG4gICAgICAgICAgICBtYXRjaC5maW5kKHQgPT4gdC5mb3JtYXQgPT09IGl0ZW0uZm9ybWF0KSA/PyBtYXRjaC5maW5kKHQgPT4gIXQuZm9ybWF0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9iaiA9IGl0ZW07XG4gICAgICAgIHRhZ09iaiA9IHRhZ3MuZmluZCh0ID0+IHQubm9kZUNsYXNzICYmIG9iaiBpbnN0YW5jZW9mIHQubm9kZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKCF0YWdPYmopIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IG9iaj8uY29uc3RydWN0b3I/Lm5hbWUgPz8gKG9iaiA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBvYmopO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRhZyBub3QgcmVzb2x2ZWQgZm9yICR7bmFtZX0gdmFsdWVgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhZ09iajtcbn1cbi8vIG5lZWRzIHRvIGJlIGNhbGxlZCBiZWZvcmUgdmFsdWUgc3RyaW5naWZpZXIgdG8gYWxsb3cgZm9yIGNpcmN1bGFyIGFuY2hvciByZWZzXG5mdW5jdGlvbiBzdHJpbmdpZnlQcm9wcyhub2RlLCB0YWdPYmosIHsgYW5jaG9yczogYW5jaG9ycyQxLCBkb2MgfSkge1xuICAgIGlmICghZG9jLmRpcmVjdGl2ZXMpXG4gICAgICAgIHJldHVybiAnJztcbiAgICBjb25zdCBwcm9wcyA9IFtdO1xuICAgIGNvbnN0IGFuY2hvciA9IChpZGVudGl0eS5pc1NjYWxhcihub2RlKSB8fCBpZGVudGl0eS5pc0NvbGxlY3Rpb24obm9kZSkpICYmIG5vZGUuYW5jaG9yO1xuICAgIGlmIChhbmNob3IgJiYgYW5jaG9ycy5hbmNob3JJc1ZhbGlkKGFuY2hvcikpIHtcbiAgICAgICAgYW5jaG9ycyQxLmFkZChhbmNob3IpO1xuICAgICAgICBwcm9wcy5wdXNoKGAmJHthbmNob3J9YCk7XG4gICAgfVxuICAgIGNvbnN0IHRhZyA9IG5vZGUudGFnID8/ICh0YWdPYmouZGVmYXVsdCA/IG51bGwgOiB0YWdPYmoudGFnKTtcbiAgICBpZiAodGFnKVxuICAgICAgICBwcm9wcy5wdXNoKGRvYy5kaXJlY3RpdmVzLnRhZ1N0cmluZyh0YWcpKTtcbiAgICByZXR1cm4gcHJvcHMuam9pbignICcpO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5KGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgIGlmIChpZGVudGl0eS5pc1BhaXIoaXRlbSkpXG4gICAgICAgIHJldHVybiBpdGVtLnRvU3RyaW5nKGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG4gICAgaWYgKGlkZW50aXR5LmlzQWxpYXMoaXRlbSkpIHtcbiAgICAgICAgaWYgKGN0eC5kb2MuZGlyZWN0aXZlcylcbiAgICAgICAgICAgIHJldHVybiBpdGVtLnRvU3RyaW5nKGN0eCk7XG4gICAgICAgIGlmIChjdHgucmVzb2x2ZWRBbGlhc2VzPy5oYXMoaXRlbSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbm5vdCBzdHJpbmdpZnkgY2lyY3VsYXIgc3RydWN0dXJlIHdpdGhvdXQgYWxpYXMgbm9kZXNgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjdHgucmVzb2x2ZWRBbGlhc2VzKVxuICAgICAgICAgICAgICAgIGN0eC5yZXNvbHZlZEFsaWFzZXMuYWRkKGl0ZW0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGN0eC5yZXNvbHZlZEFsaWFzZXMgPSBuZXcgU2V0KFtpdGVtXSk7XG4gICAgICAgICAgICBpdGVtID0gaXRlbS5yZXNvbHZlKGN0eC5kb2MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCB0YWdPYmogPSB1bmRlZmluZWQ7XG4gICAgY29uc3Qgbm9kZSA9IGlkZW50aXR5LmlzTm9kZShpdGVtKVxuICAgICAgICA/IGl0ZW1cbiAgICAgICAgOiBjdHguZG9jLmNyZWF0ZU5vZGUoaXRlbSwgeyBvblRhZ09iajogbyA9PiAodGFnT2JqID0gbykgfSk7XG4gICAgdGFnT2JqID8/ICh0YWdPYmogPSBnZXRUYWdPYmplY3QoY3R4LmRvYy5zY2hlbWEudGFncywgbm9kZSkpO1xuICAgIGNvbnN0IHByb3BzID0gc3RyaW5naWZ5UHJvcHMobm9kZSwgdGFnT2JqLCBjdHgpO1xuICAgIGlmIChwcm9wcy5sZW5ndGggPiAwKVxuICAgICAgICBjdHguaW5kZW50QXRTdGFydCA9IChjdHguaW5kZW50QXRTdGFydCA/PyAwKSArIHByb3BzLmxlbmd0aCArIDE7XG4gICAgY29uc3Qgc3RyID0gdHlwZW9mIHRhZ09iai5zdHJpbmdpZnkgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyB0YWdPYmouc3RyaW5naWZ5KG5vZGUsIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcClcbiAgICAgICAgOiBpZGVudGl0eS5pc1NjYWxhcihub2RlKVxuICAgICAgICAgICAgPyBzdHJpbmdpZnlTdHJpbmcuc3RyaW5naWZ5U3RyaW5nKG5vZGUsIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcClcbiAgICAgICAgICAgIDogbm9kZS50b1N0cmluZyhjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgIGlmICghcHJvcHMpXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgcmV0dXJuIGlkZW50aXR5LmlzU2NhbGFyKG5vZGUpIHx8IHN0clswXSA9PT0gJ3snIHx8IHN0clswXSA9PT0gJ1snXG4gICAgICAgID8gYCR7cHJvcHN9ICR7c3RyfWBcbiAgICAgICAgOiBgJHtwcm9wc31cXG4ke2N0eC5pbmRlbnR9JHtzdHJ9YDtcbn1cblxuZXhwb3J0cy5jcmVhdGVTdHJpbmdpZnlDb250ZXh0ID0gY3JlYXRlU3RyaW5naWZ5Q29udGV4dDtcbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4uL25vZGVzL2lkZW50aXR5LmpzJyk7XG52YXIgU2NhbGFyID0gcmVxdWlyZSgnLi4vbm9kZXMvU2NhbGFyLmpzJyk7XG52YXIgc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9zdHJpbmdpZnkuanMnKTtcbnZhciBzdHJpbmdpZnlDb21tZW50ID0gcmVxdWlyZSgnLi9zdHJpbmdpZnlDb21tZW50LmpzJyk7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVBhaXIoeyBrZXksIHZhbHVlIH0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgIGNvbnN0IHsgYWxsTnVsbFZhbHVlcywgZG9jLCBpbmRlbnQsIGluZGVudFN0ZXAsIG9wdGlvbnM6IHsgY29tbWVudFN0cmluZywgaW5kZW50U2VxLCBzaW1wbGVLZXlzIH0gfSA9IGN0eDtcbiAgICBsZXQga2V5Q29tbWVudCA9IChpZGVudGl0eS5pc05vZGUoa2V5KSAmJiBrZXkuY29tbWVudCkgfHwgbnVsbDtcbiAgICBpZiAoc2ltcGxlS2V5cykge1xuICAgICAgICBpZiAoa2V5Q29tbWVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaXRoIHNpbXBsZSBrZXlzLCBrZXkgbm9kZXMgY2Fubm90IGhhdmUgY29tbWVudHMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWRlbnRpdHkuaXNDb2xsZWN0aW9uKGtleSkgfHwgKCFpZGVudGl0eS5pc05vZGUoa2V5KSAmJiB0eXBlb2Yga2V5ID09PSAnb2JqZWN0JykpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9ICdXaXRoIHNpbXBsZSBrZXlzLCBjb2xsZWN0aW9uIGNhbm5vdCBiZSB1c2VkIGFzIGEga2V5IHZhbHVlJztcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBleHBsaWNpdEtleSA9ICFzaW1wbGVLZXlzICYmXG4gICAgICAgICgha2V5IHx8XG4gICAgICAgICAgICAoa2V5Q29tbWVudCAmJiB2YWx1ZSA9PSBudWxsICYmICFjdHguaW5GbG93KSB8fFxuICAgICAgICAgICAgaWRlbnRpdHkuaXNDb2xsZWN0aW9uKGtleSkgfHxcbiAgICAgICAgICAgIChpZGVudGl0eS5pc1NjYWxhcihrZXkpXG4gICAgICAgICAgICAgICAgPyBrZXkudHlwZSA9PT0gU2NhbGFyLlNjYWxhci5CTE9DS19GT0xERUQgfHwga2V5LnR5cGUgPT09IFNjYWxhci5TY2FsYXIuQkxPQ0tfTElURVJBTFxuICAgICAgICAgICAgICAgIDogdHlwZW9mIGtleSA9PT0gJ29iamVjdCcpKTtcbiAgICBjdHggPSBPYmplY3QuYXNzaWduKHt9LCBjdHgsIHtcbiAgICAgICAgYWxsTnVsbFZhbHVlczogZmFsc2UsXG4gICAgICAgIGltcGxpY2l0S2V5OiAhZXhwbGljaXRLZXkgJiYgKHNpbXBsZUtleXMgfHwgIWFsbE51bGxWYWx1ZXMpLFxuICAgICAgICBpbmRlbnQ6IGluZGVudCArIGluZGVudFN0ZXBcbiAgICB9KTtcbiAgICBsZXQga2V5Q29tbWVudERvbmUgPSBmYWxzZTtcbiAgICBsZXQgY2hvbXBLZWVwID0gZmFsc2U7XG4gICAgbGV0IHN0ciA9IHN0cmluZ2lmeS5zdHJpbmdpZnkoa2V5LCBjdHgsICgpID0+IChrZXlDb21tZW50RG9uZSA9IHRydWUpLCAoKSA9PiAoY2hvbXBLZWVwID0gdHJ1ZSkpO1xuICAgIGlmICghZXhwbGljaXRLZXkgJiYgIWN0eC5pbkZsb3cgJiYgc3RyLmxlbmd0aCA+IDEwMjQpIHtcbiAgICAgICAgaWYgKHNpbXBsZUtleXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dpdGggc2ltcGxlIGtleXMsIHNpbmdsZSBsaW5lIHNjYWxhciBtdXN0IG5vdCBzcGFuIG1vcmUgdGhhbiAxMDI0IGNoYXJhY3RlcnMnKTtcbiAgICAgICAgZXhwbGljaXRLZXkgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY3R4LmluRmxvdykge1xuICAgICAgICBpZiAoYWxsTnVsbFZhbHVlcyB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoa2V5Q29tbWVudERvbmUgJiYgb25Db21tZW50KVxuICAgICAgICAgICAgICAgIG9uQ29tbWVudCgpO1xuICAgICAgICAgICAgcmV0dXJuIHN0ciA9PT0gJycgPyAnPycgOiBleHBsaWNpdEtleSA/IGA/ICR7c3RyfWAgOiBzdHI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoKGFsbE51bGxWYWx1ZXMgJiYgIXNpbXBsZUtleXMpIHx8ICh2YWx1ZSA9PSBudWxsICYmIGV4cGxpY2l0S2V5KSkge1xuICAgICAgICBzdHIgPSBgPyAke3N0cn1gO1xuICAgICAgICBpZiAoa2V5Q29tbWVudCAmJiAha2V5Q29tbWVudERvbmUpIHtcbiAgICAgICAgICAgIHN0ciArPSBzdHJpbmdpZnlDb21tZW50LmxpbmVDb21tZW50KHN0ciwgY3R4LmluZGVudCwgY29tbWVudFN0cmluZyhrZXlDb21tZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hvbXBLZWVwICYmIG9uQ2hvbXBLZWVwKVxuICAgICAgICAgICAgb25DaG9tcEtlZXAoKTtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgaWYgKGtleUNvbW1lbnREb25lKVxuICAgICAgICBrZXlDb21tZW50ID0gbnVsbDtcbiAgICBpZiAoZXhwbGljaXRLZXkpIHtcbiAgICAgICAgaWYgKGtleUNvbW1lbnQpXG4gICAgICAgICAgICBzdHIgKz0gc3RyaW5naWZ5Q29tbWVudC5saW5lQ29tbWVudChzdHIsIGN0eC5pbmRlbnQsIGNvbW1lbnRTdHJpbmcoa2V5Q29tbWVudCkpO1xuICAgICAgICBzdHIgPSBgPyAke3N0cn1cXG4ke2luZGVudH06YDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0ciA9IGAke3N0cn06YDtcbiAgICAgICAgaWYgKGtleUNvbW1lbnQpXG4gICAgICAgICAgICBzdHIgKz0gc3RyaW5naWZ5Q29tbWVudC5saW5lQ29tbWVudChzdHIsIGN0eC5pbmRlbnQsIGNvbW1lbnRTdHJpbmcoa2V5Q29tbWVudCkpO1xuICAgIH1cbiAgICBsZXQgdnNiLCB2Y2IsIHZhbHVlQ29tbWVudDtcbiAgICBpZiAoaWRlbnRpdHkuaXNOb2RlKHZhbHVlKSkge1xuICAgICAgICB2c2IgPSAhIXZhbHVlLnNwYWNlQmVmb3JlO1xuICAgICAgICB2Y2IgPSB2YWx1ZS5jb21tZW50QmVmb3JlO1xuICAgICAgICB2YWx1ZUNvbW1lbnQgPSB2YWx1ZS5jb21tZW50O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdnNiID0gZmFsc2U7XG4gICAgICAgIHZjYiA9IG51bGw7XG4gICAgICAgIHZhbHVlQ29tbWVudCA9IG51bGw7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgdmFsdWUgPSBkb2MuY3JlYXRlTm9kZSh2YWx1ZSk7XG4gICAgfVxuICAgIGN0eC5pbXBsaWNpdEtleSA9IGZhbHNlO1xuICAgIGlmICghZXhwbGljaXRLZXkgJiYgIWtleUNvbW1lbnQgJiYgaWRlbnRpdHkuaXNTY2FsYXIodmFsdWUpKVxuICAgICAgICBjdHguaW5kZW50QXRTdGFydCA9IHN0ci5sZW5ndGggKyAxO1xuICAgIGNob21wS2VlcCA9IGZhbHNlO1xuICAgIGlmICghaW5kZW50U2VxICYmXG4gICAgICAgIGluZGVudFN0ZXAubGVuZ3RoID49IDIgJiZcbiAgICAgICAgIWN0eC5pbkZsb3cgJiZcbiAgICAgICAgIWV4cGxpY2l0S2V5ICYmXG4gICAgICAgIGlkZW50aXR5LmlzU2VxKHZhbHVlKSAmJlxuICAgICAgICAhdmFsdWUuZmxvdyAmJlxuICAgICAgICAhdmFsdWUudGFnICYmXG4gICAgICAgICF2YWx1ZS5hbmNob3IpIHtcbiAgICAgICAgLy8gSWYgaW5kZW50U2VxID09PSBmYWxzZSwgY29uc2lkZXIgJy0gJyBhcyBwYXJ0IG9mIGluZGVudGF0aW9uIHdoZXJlIHBvc3NpYmxlXG4gICAgICAgIGN0eC5pbmRlbnQgPSBjdHguaW5kZW50LnN1YnN0cmluZygyKTtcbiAgICB9XG4gICAgbGV0IHZhbHVlQ29tbWVudERvbmUgPSBmYWxzZTtcbiAgICBjb25zdCB2YWx1ZVN0ciA9IHN0cmluZ2lmeS5zdHJpbmdpZnkodmFsdWUsIGN0eCwgKCkgPT4gKHZhbHVlQ29tbWVudERvbmUgPSB0cnVlKSwgKCkgPT4gKGNob21wS2VlcCA9IHRydWUpKTtcbiAgICBsZXQgd3MgPSAnICc7XG4gICAgaWYgKGtleUNvbW1lbnQgfHwgdnNiIHx8IHZjYikge1xuICAgICAgICB3cyA9IHZzYiA/ICdcXG4nIDogJyc7XG4gICAgICAgIGlmICh2Y2IpIHtcbiAgICAgICAgICAgIGNvbnN0IGNzID0gY29tbWVudFN0cmluZyh2Y2IpO1xuICAgICAgICAgICAgd3MgKz0gYFxcbiR7c3RyaW5naWZ5Q29tbWVudC5pbmRlbnRDb21tZW50KGNzLCBjdHguaW5kZW50KX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZVN0ciA9PT0gJycgJiYgIWN0eC5pbkZsb3cpIHtcbiAgICAgICAgICAgIGlmICh3cyA9PT0gJ1xcbicgJiYgdmFsdWVDb21tZW50KVxuICAgICAgICAgICAgICAgIHdzID0gJ1xcblxcbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3cyArPSBgXFxuJHtjdHguaW5kZW50fWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoIWV4cGxpY2l0S2V5ICYmIGlkZW50aXR5LmlzQ29sbGVjdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgdnMwID0gdmFsdWVTdHJbMF07XG4gICAgICAgIGNvbnN0IG5sMCA9IHZhbHVlU3RyLmluZGV4T2YoJ1xcbicpO1xuICAgICAgICBjb25zdCBoYXNOZXdsaW5lID0gbmwwICE9PSAtMTtcbiAgICAgICAgY29uc3QgZmxvdyA9IGN0eC5pbkZsb3cgPz8gdmFsdWUuZmxvdyA/PyB2YWx1ZS5pdGVtcy5sZW5ndGggPT09IDA7XG4gICAgICAgIGlmIChoYXNOZXdsaW5lIHx8ICFmbG93KSB7XG4gICAgICAgICAgICBsZXQgaGFzUHJvcHNMaW5lID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoaGFzTmV3bGluZSAmJiAodnMwID09PSAnJicgfHwgdnMwID09PSAnIScpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNwMCA9IHZhbHVlU3RyLmluZGV4T2YoJyAnKTtcbiAgICAgICAgICAgICAgICBpZiAodnMwID09PSAnJicgJiZcbiAgICAgICAgICAgICAgICAgICAgc3AwICE9PSAtMSAmJlxuICAgICAgICAgICAgICAgICAgICBzcDAgPCBubDAgJiZcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVTdHJbc3AwICsgMV0gPT09ICchJykge1xuICAgICAgICAgICAgICAgICAgICBzcDAgPSB2YWx1ZVN0ci5pbmRleE9mKCcgJywgc3AwICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzcDAgPT09IC0xIHx8IG5sMCA8IHNwMClcbiAgICAgICAgICAgICAgICAgICAgaGFzUHJvcHNMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGFzUHJvcHNMaW5lKVxuICAgICAgICAgICAgICAgIHdzID0gYFxcbiR7Y3R4LmluZGVudH1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlU3RyID09PSAnJyB8fCB2YWx1ZVN0clswXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgd3MgPSAnJztcbiAgICB9XG4gICAgc3RyICs9IHdzICsgdmFsdWVTdHI7XG4gICAgaWYgKGN0eC5pbkZsb3cpIHtcbiAgICAgICAgaWYgKHZhbHVlQ29tbWVudERvbmUgJiYgb25Db21tZW50KVxuICAgICAgICAgICAgb25Db21tZW50KCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlQ29tbWVudCAmJiAhdmFsdWVDb21tZW50RG9uZSkge1xuICAgICAgICBzdHIgKz0gc3RyaW5naWZ5Q29tbWVudC5saW5lQ29tbWVudChzdHIsIGN0eC5pbmRlbnQsIGNvbW1lbnRTdHJpbmcodmFsdWVDb21tZW50KSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNob21wS2VlcCAmJiBvbkNob21wS2VlcCkge1xuICAgICAgICBvbkNob21wS2VlcCgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuXG5leHBvcnRzLnN0cmluZ2lmeVBhaXIgPSBzdHJpbmdpZnlQYWlyO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBub2RlX3Byb2Nlc3MgPSByZXF1aXJlKCdwcm9jZXNzJyk7XG5cbmZ1bmN0aW9uIGRlYnVnKGxvZ0xldmVsLCAuLi5tZXNzYWdlcykge1xuICAgIGlmIChsb2dMZXZlbCA9PT0gJ2RlYnVnJylcbiAgICAgICAgY29uc29sZS5sb2coLi4ubWVzc2FnZXMpO1xufVxuZnVuY3Rpb24gd2Fybihsb2dMZXZlbCwgd2FybmluZykge1xuICAgIGlmIChsb2dMZXZlbCA9PT0gJ2RlYnVnJyB8fCBsb2dMZXZlbCA9PT0gJ3dhcm4nKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZV9wcm9jZXNzLmVtaXRXYXJuaW5nID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgbm9kZV9wcm9jZXNzLmVtaXRXYXJuaW5nKHdhcm5pbmcpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjb25zb2xlLndhcm4od2FybmluZyk7XG4gICAgfVxufVxuXG5leHBvcnRzLmRlYnVnID0gZGVidWc7XG5leHBvcnRzLndhcm4gPSB3YXJuO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4uLy4uL25vZGVzL2lkZW50aXR5LmpzJyk7XG52YXIgU2NhbGFyID0gcmVxdWlyZSgnLi4vLi4vbm9kZXMvU2NhbGFyLmpzJyk7XG5cbi8vIElmIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggYSBtZXJnZSBrZXkgaXMgYSBzaW5nbGUgbWFwcGluZyBub2RlLCBlYWNoIG9mXG4vLyBpdHMga2V5L3ZhbHVlIHBhaXJzIGlzIGluc2VydGVkIGludG8gdGhlIGN1cnJlbnQgbWFwcGluZywgdW5sZXNzIHRoZSBrZXlcbi8vIGFscmVhZHkgZXhpc3RzIGluIGl0LiBJZiB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBtZXJnZSBrZXkgaXMgYVxuLy8gc2VxdWVuY2UsIHRoZW4gdGhpcyBzZXF1ZW5jZSBpcyBleHBlY3RlZCB0byBjb250YWluIG1hcHBpbmcgbm9kZXMgYW5kIGVhY2hcbi8vIG9mIHRoZXNlIG5vZGVzIGlzIG1lcmdlZCBpbiB0dXJuIGFjY29yZGluZyB0byBpdHMgb3JkZXIgaW4gdGhlIHNlcXVlbmNlLlxuLy8gS2V5cyBpbiBtYXBwaW5nIG5vZGVzIGVhcmxpZXIgaW4gdGhlIHNlcXVlbmNlIG92ZXJyaWRlIGtleXMgc3BlY2lmaWVkIGluXG4vLyBsYXRlciBtYXBwaW5nIG5vZGVzLiAtLSBodHRwOi8veWFtbC5vcmcvdHlwZS9tZXJnZS5odG1sXG5jb25zdCBNRVJHRV9LRVkgPSAnPDwnO1xuY29uc3QgbWVyZ2UgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlID09PSBNRVJHRV9LRVkgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcgJiYgdmFsdWUuZGVzY3JpcHRpb24gPT09IE1FUkdFX0tFWSksXG4gICAgZGVmYXVsdDogJ2tleScsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6bWVyZ2UnLFxuICAgIHRlc3Q6IC9ePDwkLyxcbiAgICByZXNvbHZlOiAoKSA9PiBPYmplY3QuYXNzaWduKG5ldyBTY2FsYXIuU2NhbGFyKFN5bWJvbChNRVJHRV9LRVkpKSwge1xuICAgICAgICBhZGRUb0pTTWFwOiBhZGRNZXJnZVRvSlNNYXBcbiAgICB9KSxcbiAgICBzdHJpbmdpZnk6ICgpID0+IE1FUkdFX0tFWVxufTtcbmNvbnN0IGlzTWVyZ2VLZXkgPSAoY3R4LCBrZXkpID0+IChtZXJnZS5pZGVudGlmeShrZXkpIHx8XG4gICAgKGlkZW50aXR5LmlzU2NhbGFyKGtleSkgJiZcbiAgICAgICAgKCFrZXkudHlwZSB8fCBrZXkudHlwZSA9PT0gU2NhbGFyLlNjYWxhci5QTEFJTikgJiZcbiAgICAgICAgbWVyZ2UuaWRlbnRpZnkoa2V5LnZhbHVlKSkpICYmXG4gICAgY3R4Py5kb2Muc2NoZW1hLnRhZ3Muc29tZSh0YWcgPT4gdGFnLnRhZyA9PT0gbWVyZ2UudGFnICYmIHRhZy5kZWZhdWx0KTtcbmZ1bmN0aW9uIGFkZE1lcmdlVG9KU01hcChjdHgsIG1hcCwgdmFsdWUpIHtcbiAgICB2YWx1ZSA9IGN0eCAmJiBpZGVudGl0eS5pc0FsaWFzKHZhbHVlKSA/IHZhbHVlLnJlc29sdmUoY3R4LmRvYykgOiB2YWx1ZTtcbiAgICBpZiAoaWRlbnRpdHkuaXNTZXEodmFsdWUpKVxuICAgICAgICBmb3IgKGNvbnN0IGl0IG9mIHZhbHVlLml0ZW1zKVxuICAgICAgICAgICAgbWVyZ2VWYWx1ZShjdHgsIG1hcCwgaXQpO1xuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICBmb3IgKGNvbnN0IGl0IG9mIHZhbHVlKVxuICAgICAgICAgICAgbWVyZ2VWYWx1ZShjdHgsIG1hcCwgaXQpO1xuICAgIGVsc2VcbiAgICAgICAgbWVyZ2VWYWx1ZShjdHgsIG1hcCwgdmFsdWUpO1xufVxuZnVuY3Rpb24gbWVyZ2VWYWx1ZShjdHgsIG1hcCwgdmFsdWUpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBjdHggJiYgaWRlbnRpdHkuaXNBbGlhcyh2YWx1ZSkgPyB2YWx1ZS5yZXNvbHZlKGN0eC5kb2MpIDogdmFsdWU7XG4gICAgaWYgKCFpZGVudGl0eS5pc01hcChzb3VyY2UpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01lcmdlIHNvdXJjZXMgbXVzdCBiZSBtYXBzIG9yIG1hcCBhbGlhc2VzJyk7XG4gICAgY29uc3Qgc3JjTWFwID0gc291cmNlLnRvSlNPTihudWxsLCBjdHgsIE1hcCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc3JjTWFwKSB7XG4gICAgICAgIGlmIChtYXAgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgIGlmICghbWFwLmhhcyhrZXkpKVxuICAgICAgICAgICAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWFwIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICBtYXAuYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIGtleSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtYXAsIGtleSwge1xuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFwO1xufVxuXG5leHBvcnRzLmFkZE1lcmdlVG9KU01hcCA9IGFkZE1lcmdlVG9KU01hcDtcbmV4cG9ydHMuaXNNZXJnZUtleSA9IGlzTWVyZ2VLZXk7XG5leHBvcnRzLm1lcmdlID0gbWVyZ2U7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIGxvZyA9IHJlcXVpcmUoJy4uL2xvZy5qcycpO1xudmFyIG1lcmdlID0gcmVxdWlyZSgnLi4vc2NoZW1hL3lhbWwtMS4xL21lcmdlLmpzJyk7XG52YXIgc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi4vc3RyaW5naWZ5L3N0cmluZ2lmeS5qcycpO1xudmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eS5qcycpO1xudmFyIHRvSlMgPSByZXF1aXJlKCcuL3RvSlMuanMnKTtcblxuZnVuY3Rpb24gYWRkUGFpclRvSlNNYXAoY3R4LCBtYXAsIHsga2V5LCB2YWx1ZSB9KSB7XG4gICAgaWYgKGlkZW50aXR5LmlzTm9kZShrZXkpICYmIGtleS5hZGRUb0pTTWFwKVxuICAgICAgICBrZXkuYWRkVG9KU01hcChjdHgsIG1hcCwgdmFsdWUpO1xuICAgIC8vIFRPRE86IFNob3VsZCBkcm9wIHRoaXMgc3BlY2lhbCBjYXNlIGZvciBiYXJlIDw8IGhhbmRsaW5nXG4gICAgZWxzZSBpZiAobWVyZ2UuaXNNZXJnZUtleShjdHgsIGtleSkpXG4gICAgICAgIG1lcmdlLmFkZE1lcmdlVG9KU01hcChjdHgsIG1hcCwgdmFsdWUpO1xuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBqc0tleSA9IHRvSlMudG9KUyhrZXksICcnLCBjdHgpO1xuICAgICAgICBpZiAobWFwIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICBtYXAuc2V0KGpzS2V5LCB0b0pTLnRvSlModmFsdWUsIGpzS2V5LCBjdHgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtYXAgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgIG1hcC5hZGQoanNLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc3RyaW5nS2V5ID0gc3RyaW5naWZ5S2V5KGtleSwganNLZXksIGN0eCk7XG4gICAgICAgICAgICBjb25zdCBqc1ZhbHVlID0gdG9KUy50b0pTKHZhbHVlLCBzdHJpbmdLZXksIGN0eCk7XG4gICAgICAgICAgICBpZiAoc3RyaW5nS2V5IGluIG1hcClcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWFwLCBzdHJpbmdLZXksIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGpzVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtYXBbc3RyaW5nS2V5XSA9IGpzVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeUtleShrZXksIGpzS2V5LCBjdHgpIHtcbiAgICBpZiAoanNLZXkgPT09IG51bGwpXG4gICAgICAgIHJldHVybiAnJztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWJhc2UtdG8tc3RyaW5nXG4gICAgaWYgKHR5cGVvZiBqc0tleSAhPT0gJ29iamVjdCcpXG4gICAgICAgIHJldHVybiBTdHJpbmcoanNLZXkpO1xuICAgIGlmIChpZGVudGl0eS5pc05vZGUoa2V5KSAmJiBjdHg/LmRvYykge1xuICAgICAgICBjb25zdCBzdHJDdHggPSBzdHJpbmdpZnkuY3JlYXRlU3RyaW5naWZ5Q29udGV4dChjdHguZG9jLCB7fSk7XG4gICAgICAgIHN0ckN0eC5hbmNob3JzID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgY3R4LmFuY2hvcnMua2V5cygpKVxuICAgICAgICAgICAgc3RyQ3R4LmFuY2hvcnMuYWRkKG5vZGUuYW5jaG9yKTtcbiAgICAgICAgc3RyQ3R4LmluRmxvdyA9IHRydWU7XG4gICAgICAgIHN0ckN0eC5pblN0cmluZ2lmeUtleSA9IHRydWU7XG4gICAgICAgIGNvbnN0IHN0cktleSA9IGtleS50b1N0cmluZyhzdHJDdHgpO1xuICAgICAgICBpZiAoIWN0eC5tYXBLZXlXYXJuZWQpIHtcbiAgICAgICAgICAgIGxldCBqc29uU3RyID0gSlNPTi5zdHJpbmdpZnkoc3RyS2V5KTtcbiAgICAgICAgICAgIGlmIChqc29uU3RyLmxlbmd0aCA+IDQwKVxuICAgICAgICAgICAgICAgIGpzb25TdHIgPSBqc29uU3RyLnN1YnN0cmluZygwLCAzNikgKyAnLi4uXCInO1xuICAgICAgICAgICAgbG9nLndhcm4oY3R4LmRvYy5vcHRpb25zLmxvZ0xldmVsLCBgS2V5cyB3aXRoIGNvbGxlY3Rpb24gdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWQgZHVlIHRvIEpTIE9iamVjdCByZXN0cmljdGlvbnM6ICR7anNvblN0cn0uIFNldCBtYXBBc01hcDogdHJ1ZSB0byB1c2Ugb2JqZWN0IGtleXMuYCk7XG4gICAgICAgICAgICBjdHgubWFwS2V5V2FybmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyS2V5O1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoanNLZXkpO1xufVxuXG5leHBvcnRzLmFkZFBhaXJUb0pTTWFwID0gYWRkUGFpclRvSlNNYXA7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIGNyZWF0ZU5vZGUgPSByZXF1aXJlKCcuLi9kb2MvY3JlYXRlTm9kZS5qcycpO1xudmFyIHN0cmluZ2lmeVBhaXIgPSByZXF1aXJlKCcuLi9zdHJpbmdpZnkvc3RyaW5naWZ5UGFpci5qcycpO1xudmFyIGFkZFBhaXJUb0pTTWFwID0gcmVxdWlyZSgnLi9hZGRQYWlyVG9KU01hcC5qcycpO1xudmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eS5qcycpO1xuXG5mdW5jdGlvbiBjcmVhdGVQYWlyKGtleSwgdmFsdWUsIGN0eCkge1xuICAgIGNvbnN0IGsgPSBjcmVhdGVOb2RlLmNyZWF0ZU5vZGUoa2V5LCB1bmRlZmluZWQsIGN0eCk7XG4gICAgY29uc3QgdiA9IGNyZWF0ZU5vZGUuY3JlYXRlTm9kZSh2YWx1ZSwgdW5kZWZpbmVkLCBjdHgpO1xuICAgIHJldHVybiBuZXcgUGFpcihrLCB2KTtcbn1cbmNsYXNzIFBhaXIge1xuICAgIGNvbnN0cnVjdG9yKGtleSwgdmFsdWUgPSBudWxsKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpZGVudGl0eS5OT0RFX1RZUEUsIHsgdmFsdWU6IGlkZW50aXR5LlBBSVIgfSk7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGNsb25lKHNjaGVtYSkge1xuICAgICAgICBsZXQgeyBrZXksIHZhbHVlIH0gPSB0aGlzO1xuICAgICAgICBpZiAoaWRlbnRpdHkuaXNOb2RlKGtleSkpXG4gICAgICAgICAgICBrZXkgPSBrZXkuY2xvbmUoc2NoZW1hKTtcbiAgICAgICAgaWYgKGlkZW50aXR5LmlzTm9kZSh2YWx1ZSkpXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmNsb25lKHNjaGVtYSk7XG4gICAgICAgIHJldHVybiBuZXcgUGFpcihrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgdG9KU09OKF8sIGN0eCkge1xuICAgICAgICBjb25zdCBwYWlyID0gY3R4Py5tYXBBc01hcCA/IG5ldyBNYXAoKSA6IHt9O1xuICAgICAgICByZXR1cm4gYWRkUGFpclRvSlNNYXAuYWRkUGFpclRvSlNNYXAoY3R4LCBwYWlyLCB0aGlzKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgICAgIHJldHVybiBjdHg/LmRvY1xuICAgICAgICAgICAgPyBzdHJpbmdpZnlQYWlyLnN0cmluZ2lmeVBhaXIodGhpcywgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKVxuICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICB9XG59XG5cbmV4cG9ydHMuUGFpciA9IFBhaXI7XG5leHBvcnRzLmNyZWF0ZVBhaXIgPSBjcmVhdGVQYWlyO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4uL25vZGVzL2lkZW50aXR5LmpzJyk7XG52YXIgc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9zdHJpbmdpZnkuanMnKTtcbnZhciBzdHJpbmdpZnlDb21tZW50ID0gcmVxdWlyZSgnLi9zdHJpbmdpZnlDb21tZW50LmpzJyk7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUNvbGxlY3Rpb24oY29sbGVjdGlvbiwgY3R4LCBvcHRpb25zKSB7XG4gICAgY29uc3QgZmxvdyA9IGN0eC5pbkZsb3cgPz8gY29sbGVjdGlvbi5mbG93O1xuICAgIGNvbnN0IHN0cmluZ2lmeSA9IGZsb3cgPyBzdHJpbmdpZnlGbG93Q29sbGVjdGlvbiA6IHN0cmluZ2lmeUJsb2NrQ29sbGVjdGlvbjtcbiAgICByZXR1cm4gc3RyaW5naWZ5KGNvbGxlY3Rpb24sIGN0eCwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlCbG9ja0NvbGxlY3Rpb24oeyBjb21tZW50LCBpdGVtcyB9LCBjdHgsIHsgYmxvY2tJdGVtUHJlZml4LCBmbG93Q2hhcnMsIGl0ZW1JbmRlbnQsIG9uQ2hvbXBLZWVwLCBvbkNvbW1lbnQgfSkge1xuICAgIGNvbnN0IHsgaW5kZW50LCBvcHRpb25zOiB7IGNvbW1lbnRTdHJpbmcgfSB9ID0gY3R4O1xuICAgIGNvbnN0IGl0ZW1DdHggPSBPYmplY3QuYXNzaWduKHt9LCBjdHgsIHsgaW5kZW50OiBpdGVtSW5kZW50LCB0eXBlOiBudWxsIH0pO1xuICAgIGxldCBjaG9tcEtlZXAgPSBmYWxzZTsgLy8gZmxhZyBmb3IgdGhlIHByZWNlZGluZyBub2RlJ3Mgc3RhdHVzXG4gICAgY29uc3QgbGluZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgbGV0IGNvbW1lbnQgPSBudWxsO1xuICAgICAgICBpZiAoaWRlbnRpdHkuaXNOb2RlKGl0ZW0pKSB7XG4gICAgICAgICAgICBpZiAoIWNob21wS2VlcCAmJiBpdGVtLnNwYWNlQmVmb3JlKVxuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goJycpO1xuICAgICAgICAgICAgYWRkQ29tbWVudEJlZm9yZShjdHgsIGxpbmVzLCBpdGVtLmNvbW1lbnRCZWZvcmUsIGNob21wS2VlcCk7XG4gICAgICAgICAgICBpZiAoaXRlbS5jb21tZW50KVxuICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBpdGVtLmNvbW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaWRlbnRpdHkuaXNQYWlyKGl0ZW0pKSB7XG4gICAgICAgICAgICBjb25zdCBpayA9IGlkZW50aXR5LmlzTm9kZShpdGVtLmtleSkgPyBpdGVtLmtleSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoaWspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNob21wS2VlcCAmJiBpay5zcGFjZUJlZm9yZSlcbiAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaCgnJyk7XG4gICAgICAgICAgICAgICAgYWRkQ29tbWVudEJlZm9yZShjdHgsIGxpbmVzLCBpay5jb21tZW50QmVmb3JlLCBjaG9tcEtlZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNob21wS2VlcCA9IGZhbHNlO1xuICAgICAgICBsZXQgc3RyID0gc3RyaW5naWZ5LnN0cmluZ2lmeShpdGVtLCBpdGVtQ3R4LCAoKSA9PiAoY29tbWVudCA9IG51bGwpLCAoKSA9PiAoY2hvbXBLZWVwID0gdHJ1ZSkpO1xuICAgICAgICBpZiAoY29tbWVudClcbiAgICAgICAgICAgIHN0ciArPSBzdHJpbmdpZnlDb21tZW50LmxpbmVDb21tZW50KHN0ciwgaXRlbUluZGVudCwgY29tbWVudFN0cmluZyhjb21tZW50KSk7XG4gICAgICAgIGlmIChjaG9tcEtlZXAgJiYgY29tbWVudClcbiAgICAgICAgICAgIGNob21wS2VlcCA9IGZhbHNlO1xuICAgICAgICBsaW5lcy5wdXNoKGJsb2NrSXRlbVByZWZpeCArIHN0cik7XG4gICAgfVxuICAgIGxldCBzdHI7XG4gICAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzdHIgPSBmbG93Q2hhcnMuc3RhcnQgKyBmbG93Q2hhcnMuZW5kO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RyID0gbGluZXNbMF07XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgICAgICAgIHN0ciArPSBsaW5lID8gYFxcbiR7aW5kZW50fSR7bGluZX1gIDogJ1xcbic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgICAgc3RyICs9ICdcXG4nICsgc3RyaW5naWZ5Q29tbWVudC5pbmRlbnRDb21tZW50KGNvbW1lbnRTdHJpbmcoY29tbWVudCksIGluZGVudCk7XG4gICAgICAgIGlmIChvbkNvbW1lbnQpXG4gICAgICAgICAgICBvbkNvbW1lbnQoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hvbXBLZWVwICYmIG9uQ2hvbXBLZWVwKVxuICAgICAgICBvbkNob21wS2VlcCgpO1xuICAgIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlGbG93Q29sbGVjdGlvbih7IGl0ZW1zIH0sIGN0eCwgeyBmbG93Q2hhcnMsIGl0ZW1JbmRlbnQgfSkge1xuICAgIGNvbnN0IHsgaW5kZW50LCBpbmRlbnRTdGVwLCBmbG93Q29sbGVjdGlvblBhZGRpbmc6IGZjUGFkZGluZywgb3B0aW9uczogeyBjb21tZW50U3RyaW5nIH0gfSA9IGN0eDtcbiAgICBpdGVtSW5kZW50ICs9IGluZGVudFN0ZXA7XG4gICAgY29uc3QgaXRlbUN0eCA9IE9iamVjdC5hc3NpZ24oe30sIGN0eCwge1xuICAgICAgICBpbmRlbnQ6IGl0ZW1JbmRlbnQsXG4gICAgICAgIGluRmxvdzogdHJ1ZSxcbiAgICAgICAgdHlwZTogbnVsbFxuICAgIH0pO1xuICAgIGxldCByZXFOZXdsaW5lID0gZmFsc2U7XG4gICAgbGV0IGxpbmVzQXRWYWx1ZSA9IDA7XG4gICAgY29uc3QgbGluZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgbGV0IGNvbW1lbnQgPSBudWxsO1xuICAgICAgICBpZiAoaWRlbnRpdHkuaXNOb2RlKGl0ZW0pKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5zcGFjZUJlZm9yZSlcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICAgICAgICAgIGFkZENvbW1lbnRCZWZvcmUoY3R4LCBsaW5lcywgaXRlbS5jb21tZW50QmVmb3JlLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoaXRlbS5jb21tZW50KVxuICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBpdGVtLmNvbW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaWRlbnRpdHkuaXNQYWlyKGl0ZW0pKSB7XG4gICAgICAgICAgICBjb25zdCBpayA9IGlkZW50aXR5LmlzTm9kZShpdGVtLmtleSkgPyBpdGVtLmtleSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoaWspIHtcbiAgICAgICAgICAgICAgICBpZiAoaWsuc3BhY2VCZWZvcmUpXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goJycpO1xuICAgICAgICAgICAgICAgIGFkZENvbW1lbnRCZWZvcmUoY3R4LCBsaW5lcywgaWsuY29tbWVudEJlZm9yZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmIChpay5jb21tZW50KVxuICAgICAgICAgICAgICAgICAgICByZXFOZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGl2ID0gaWRlbnRpdHkuaXNOb2RlKGl0ZW0udmFsdWUpID8gaXRlbS52YWx1ZSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoaXYpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXYuY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IGl2LmNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGl2LmNvbW1lbnRCZWZvcmUpXG4gICAgICAgICAgICAgICAgICAgIHJlcU5ld2xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbS52YWx1ZSA9PSBudWxsICYmIGlrPy5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgY29tbWVudCA9IGlrLmNvbW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbW1lbnQpXG4gICAgICAgICAgICByZXFOZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgbGV0IHN0ciA9IHN0cmluZ2lmeS5zdHJpbmdpZnkoaXRlbSwgaXRlbUN0eCwgKCkgPT4gKGNvbW1lbnQgPSBudWxsKSk7XG4gICAgICAgIGlmIChpIDwgaXRlbXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgIHN0ciArPSAnLCc7XG4gICAgICAgIGlmIChjb21tZW50KVxuICAgICAgICAgICAgc3RyICs9IHN0cmluZ2lmeUNvbW1lbnQubGluZUNvbW1lbnQoc3RyLCBpdGVtSW5kZW50LCBjb21tZW50U3RyaW5nKGNvbW1lbnQpKTtcbiAgICAgICAgaWYgKCFyZXFOZXdsaW5lICYmIChsaW5lcy5sZW5ndGggPiBsaW5lc0F0VmFsdWUgfHwgc3RyLmluY2x1ZGVzKCdcXG4nKSkpXG4gICAgICAgICAgICByZXFOZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgbGluZXMucHVzaChzdHIpO1xuICAgICAgICBsaW5lc0F0VmFsdWUgPSBsaW5lcy5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gZmxvd0NoYXJzO1xuICAgIGlmIChsaW5lcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHN0YXJ0ICsgZW5kO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFyZXFOZXdsaW5lKSB7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBsaW5lcy5yZWR1Y2UoKHN1bSwgbGluZSkgPT4gc3VtICsgbGluZS5sZW5ndGggKyAyLCAyKTtcbiAgICAgICAgICAgIHJlcU5ld2xpbmUgPSBjdHgub3B0aW9ucy5saW5lV2lkdGggPiAwICYmIGxlbiA+IGN0eC5vcHRpb25zLmxpbmVXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxTmV3bGluZSkge1xuICAgICAgICAgICAgbGV0IHN0ciA9IHN0YXJ0O1xuICAgICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKVxuICAgICAgICAgICAgICAgIHN0ciArPSBsaW5lID8gYFxcbiR7aW5kZW50U3RlcH0ke2luZGVudH0ke2xpbmV9YCA6ICdcXG4nO1xuICAgICAgICAgICAgcmV0dXJuIGAke3N0cn1cXG4ke2luZGVudH0ke2VuZH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGAke3N0YXJ0fSR7ZmNQYWRkaW5nfSR7bGluZXMuam9pbignICcpfSR7ZmNQYWRkaW5nfSR7ZW5kfWA7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBhZGRDb21tZW50QmVmb3JlKHsgaW5kZW50LCBvcHRpb25zOiB7IGNvbW1lbnRTdHJpbmcgfSB9LCBsaW5lcywgY29tbWVudCwgY2hvbXBLZWVwKSB7XG4gICAgaWYgKGNvbW1lbnQgJiYgY2hvbXBLZWVwKVxuICAgICAgICBjb21tZW50ID0gY29tbWVudC5yZXBsYWNlKC9eXFxuKy8sICcnKTtcbiAgICBpZiAoY29tbWVudCkge1xuICAgICAgICBjb25zdCBpYyA9IHN0cmluZ2lmeUNvbW1lbnQuaW5kZW50Q29tbWVudChjb21tZW50U3RyaW5nKGNvbW1lbnQpLCBpbmRlbnQpO1xuICAgICAgICBsaW5lcy5wdXNoKGljLnRyaW1TdGFydCgpKTsgLy8gQXZvaWQgZG91YmxlIGluZGVudCBvbiBmaXJzdCBsaW5lXG4gICAgfVxufVxuXG5leHBvcnRzLnN0cmluZ2lmeUNvbGxlY3Rpb24gPSBzdHJpbmdpZnlDb2xsZWN0aW9uO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vc3RyaW5naWZ5L3N0cmluZ2lmeUNvbGxlY3Rpb24uanMnKTtcbnZhciBhZGRQYWlyVG9KU01hcCA9IHJlcXVpcmUoJy4vYWRkUGFpclRvSlNNYXAuanMnKTtcbnZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi9Db2xsZWN0aW9uLmpzJyk7XG52YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5LmpzJyk7XG52YXIgUGFpciA9IHJlcXVpcmUoJy4vUGFpci5qcycpO1xudmFyIFNjYWxhciA9IHJlcXVpcmUoJy4vU2NhbGFyLmpzJyk7XG5cbmZ1bmN0aW9uIGZpbmRQYWlyKGl0ZW1zLCBrZXkpIHtcbiAgICBjb25zdCBrID0gaWRlbnRpdHkuaXNTY2FsYXIoa2V5KSA/IGtleS52YWx1ZSA6IGtleTtcbiAgICBmb3IgKGNvbnN0IGl0IG9mIGl0ZW1zKSB7XG4gICAgICAgIGlmIChpZGVudGl0eS5pc1BhaXIoaXQpKSB7XG4gICAgICAgICAgICBpZiAoaXQua2V5ID09PSBrZXkgfHwgaXQua2V5ID09PSBrKVxuICAgICAgICAgICAgICAgIHJldHVybiBpdDtcbiAgICAgICAgICAgIGlmIChpZGVudGl0eS5pc1NjYWxhcihpdC5rZXkpICYmIGl0LmtleS52YWx1ZSA9PT0gaylcbiAgICAgICAgICAgICAgICByZXR1cm4gaXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmNsYXNzIFlBTUxNYXAgZXh0ZW5kcyBDb2xsZWN0aW9uLkNvbGxlY3Rpb24ge1xuICAgIHN0YXRpYyBnZXQgdGFnTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICd0YWc6eWFtbC5vcmcsMjAwMjptYXAnO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEpIHtcbiAgICAgICAgc3VwZXIoaWRlbnRpdHkuTUFQLCBzY2hlbWEpO1xuICAgICAgICB0aGlzLml0ZW1zID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgZ2VuZXJpYyBjb2xsZWN0aW9uIHBhcnNpbmcgbWV0aG9kIHRoYXQgY2FuIGJlIGV4dGVuZGVkXG4gICAgICogdG8gb3RoZXIgbm9kZSBjbGFzc2VzIHRoYXQgaW5oZXJpdCBmcm9tIFlBTUxNYXBcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShzY2hlbWEsIG9iaiwgY3R4KSB7XG4gICAgICAgIGNvbnN0IHsga2VlcFVuZGVmaW5lZCwgcmVwbGFjZXIgfSA9IGN0eDtcbiAgICAgICAgY29uc3QgbWFwID0gbmV3IHRoaXMoc2NoZW1hKTtcbiAgICAgICAgY29uc3QgYWRkID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSByZXBsYWNlci5jYWxsKG9iaiwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlcGxhY2VyKSAmJiAhcmVwbGFjZXIuaW5jbHVkZXMoa2V5KSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCB8fCBrZWVwVW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKFBhaXIuY3JlYXRlUGFpcihrZXksIHZhbHVlLCBjdHgpKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygb2JqKVxuICAgICAgICAgICAgICAgIGFkZChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpXG4gICAgICAgICAgICAgICAgYWRkKGtleSwgb2JqW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLnNvcnRNYXBFbnRyaWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtYXAuaXRlbXMuc29ydChzY2hlbWEuc29ydE1hcEVudHJpZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSB2YWx1ZSB0byB0aGUgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvdmVyd3JpdGUgLSBJZiBub3Qgc2V0IGB0cnVlYCwgdXNpbmcgYSBrZXkgdGhhdCBpcyBhbHJlYWR5IGluIHRoZVxuICAgICAqICAgY29sbGVjdGlvbiB3aWxsIHRocm93LiBPdGhlcndpc2UsIG92ZXJ3cml0ZXMgdGhlIHByZXZpb3VzIHZhbHVlLlxuICAgICAqL1xuICAgIGFkZChwYWlyLCBvdmVyd3JpdGUpIHtcbiAgICAgICAgbGV0IF9wYWlyO1xuICAgICAgICBpZiAoaWRlbnRpdHkuaXNQYWlyKHBhaXIpKVxuICAgICAgICAgICAgX3BhaXIgPSBwYWlyO1xuICAgICAgICBlbHNlIGlmICghcGFpciB8fCB0eXBlb2YgcGFpciAhPT0gJ29iamVjdCcgfHwgISgna2V5JyBpbiBwYWlyKSkge1xuICAgICAgICAgICAgLy8gSW4gVHlwZVNjcmlwdCwgdGhpcyBuZXZlciBoYXBwZW5zLlxuICAgICAgICAgICAgX3BhaXIgPSBuZXcgUGFpci5QYWlyKHBhaXIsIHBhaXI/LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBfcGFpciA9IG5ldyBQYWlyLlBhaXIocGFpci5rZXksIHBhaXIudmFsdWUpO1xuICAgICAgICBjb25zdCBwcmV2ID0gZmluZFBhaXIodGhpcy5pdGVtcywgX3BhaXIua2V5KTtcbiAgICAgICAgY29uc3Qgc29ydEVudHJpZXMgPSB0aGlzLnNjaGVtYT8uc29ydE1hcEVudHJpZXM7XG4gICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICBpZiAoIW92ZXJ3cml0ZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleSAke19wYWlyLmtleX0gYWxyZWFkeSBzZXRgKTtcbiAgICAgICAgICAgIC8vIEZvciBzY2FsYXJzLCBrZWVwIHRoZSBvbGQgbm9kZSAmIGl0cyBjb21tZW50cyBhbmQgYW5jaG9yc1xuICAgICAgICAgICAgaWYgKGlkZW50aXR5LmlzU2NhbGFyKHByZXYudmFsdWUpICYmIFNjYWxhci5pc1NjYWxhclZhbHVlKF9wYWlyLnZhbHVlKSlcbiAgICAgICAgICAgICAgICBwcmV2LnZhbHVlLnZhbHVlID0gX3BhaXIudmFsdWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcHJldi52YWx1ZSA9IF9wYWlyLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNvcnRFbnRyaWVzKSB7XG4gICAgICAgICAgICBjb25zdCBpID0gdGhpcy5pdGVtcy5maW5kSW5kZXgoaXRlbSA9PiBzb3J0RW50cmllcyhfcGFpciwgaXRlbSkgPCAwKTtcbiAgICAgICAgICAgIGlmIChpID09PSAtMSlcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW1zLnB1c2goX3BhaXIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuaXRlbXMuc3BsaWNlKGksIDAsIF9wYWlyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXMucHVzaChfcGFpcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICBjb25zdCBpdCA9IGZpbmRQYWlyKHRoaXMuaXRlbXMsIGtleSk7XG4gICAgICAgIGlmICghaXQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGRlbCA9IHRoaXMuaXRlbXMuc3BsaWNlKHRoaXMuaXRlbXMuaW5kZXhPZihpdCksIDEpO1xuICAgICAgICByZXR1cm4gZGVsLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIGdldChrZXksIGtlZXBTY2FsYXIpIHtcbiAgICAgICAgY29uc3QgaXQgPSBmaW5kUGFpcih0aGlzLml0ZW1zLCBrZXkpO1xuICAgICAgICBjb25zdCBub2RlID0gaXQ/LnZhbHVlO1xuICAgICAgICByZXR1cm4gKCFrZWVwU2NhbGFyICYmIGlkZW50aXR5LmlzU2NhbGFyKG5vZGUpID8gbm9kZS52YWx1ZSA6IG5vZGUpID8/IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gISFmaW5kUGFpcih0aGlzLml0ZW1zLCBrZXkpO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmFkZChuZXcgUGFpci5QYWlyKGtleSwgdmFsdWUpLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGN0eCAtIENvbnZlcnNpb24gY29udGV4dCwgb3JpZ2luYWxseSBzZXQgaW4gRG9jdW1lbnQjdG9KUygpXG4gICAgICogQHBhcmFtIHtDbGFzc30gVHlwZSAtIElmIHNldCwgZm9yY2VzIHRoZSByZXR1cm5lZCBjb2xsZWN0aW9uIHR5cGVcbiAgICAgKiBAcmV0dXJucyBJbnN0YW5jZSBvZiBUeXBlLCBNYXAsIG9yIE9iamVjdFxuICAgICAqL1xuICAgIHRvSlNPTihfLCBjdHgsIFR5cGUpIHtcbiAgICAgICAgY29uc3QgbWFwID0gVHlwZSA/IG5ldyBUeXBlKCkgOiBjdHg/Lm1hcEFzTWFwID8gbmV3IE1hcCgpIDoge307XG4gICAgICAgIGlmIChjdHg/Lm9uQ3JlYXRlKVxuICAgICAgICAgICAgY3R4Lm9uQ3JlYXRlKG1hcCk7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLml0ZW1zKVxuICAgICAgICAgICAgYWRkUGFpclRvSlNNYXAuYWRkUGFpclRvSlNNYXAoY3R4LCBtYXAsIGl0ZW0pO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICB0b1N0cmluZyhjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICAgICAgaWYgKCFjdHgpXG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLml0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoIWlkZW50aXR5LmlzUGFpcihpdGVtKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1hcCBpdGVtcyBtdXN0IGFsbCBiZSBwYWlyczsgZm91bmQgJHtKU09OLnN0cmluZ2lmeShpdGVtKX0gaW5zdGVhZGApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY3R4LmFsbE51bGxWYWx1ZXMgJiYgdGhpcy5oYXNBbGxOdWxsVmFsdWVzKGZhbHNlKSlcbiAgICAgICAgICAgIGN0eCA9IE9iamVjdC5hc3NpZ24oe30sIGN0eCwgeyBhbGxOdWxsVmFsdWVzOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4gc3RyaW5naWZ5Q29sbGVjdGlvbi5zdHJpbmdpZnlDb2xsZWN0aW9uKHRoaXMsIGN0eCwge1xuICAgICAgICAgICAgYmxvY2tJdGVtUHJlZml4OiAnJyxcbiAgICAgICAgICAgIGZsb3dDaGFyczogeyBzdGFydDogJ3snLCBlbmQ6ICd9JyB9LFxuICAgICAgICAgICAgaXRlbUluZGVudDogY3R4LmluZGVudCB8fCAnJyxcbiAgICAgICAgICAgIG9uQ2hvbXBLZWVwLFxuICAgICAgICAgICAgb25Db21tZW50XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZXhwb3J0cy5ZQU1MTWFwID0gWUFNTE1hcDtcbmV4cG9ydHMuZmluZFBhaXIgPSBmaW5kUGFpcjtcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuLi8uLi9ub2Rlcy9pZGVudGl0eS5qcycpO1xudmFyIFlBTUxNYXAgPSByZXF1aXJlKCcuLi8uLi9ub2Rlcy9ZQU1MTWFwLmpzJyk7XG5cbmNvbnN0IG1hcCA9IHtcbiAgICBjb2xsZWN0aW9uOiAnbWFwJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIG5vZGVDbGFzczogWUFNTE1hcC5ZQU1MTWFwLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOm1hcCcsXG4gICAgcmVzb2x2ZShtYXAsIG9uRXJyb3IpIHtcbiAgICAgICAgaWYgKCFpZGVudGl0eS5pc01hcChtYXApKVxuICAgICAgICAgICAgb25FcnJvcignRXhwZWN0ZWQgYSBtYXBwaW5nIGZvciB0aGlzIHRhZycpO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH0sXG4gICAgY3JlYXRlTm9kZTogKHNjaGVtYSwgb2JqLCBjdHgpID0+IFlBTUxNYXAuWUFNTE1hcC5mcm9tKHNjaGVtYSwgb2JqLCBjdHgpXG59O1xuXG5leHBvcnRzLm1hcCA9IG1hcDtcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlTm9kZSA9IHJlcXVpcmUoJy4uL2RvYy9jcmVhdGVOb2RlLmpzJyk7XG52YXIgc3RyaW5naWZ5Q29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uL3N0cmluZ2lmeS9zdHJpbmdpZnlDb2xsZWN0aW9uLmpzJyk7XG52YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vQ29sbGVjdGlvbi5qcycpO1xudmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eS5qcycpO1xudmFyIFNjYWxhciA9IHJlcXVpcmUoJy4vU2NhbGFyLmpzJyk7XG52YXIgdG9KUyA9IHJlcXVpcmUoJy4vdG9KUy5qcycpO1xuXG5jbGFzcyBZQU1MU2VxIGV4dGVuZHMgQ29sbGVjdGlvbi5Db2xsZWN0aW9uIHtcbiAgICBzdGF0aWMgZ2V0IHRhZ05hbWUoKSB7XG4gICAgICAgIHJldHVybiAndGFnOnlhbWwub3JnLDIwMDI6c2VxJztcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc2NoZW1hKSB7XG4gICAgICAgIHN1cGVyKGlkZW50aXR5LlNFUSwgc2NoZW1hKTtcbiAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgIH1cbiAgICBhZGQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5pdGVtcy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHZhbHVlIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBga2V5YCBtdXN0IGNvbnRhaW4gYSByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnRlZ2VyIGZvciB0aGlzIHRvIHN1Y2NlZWQuXG4gICAgICogSXQgbWF5IGJlIHdyYXBwZWQgaW4gYSBgU2NhbGFyYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgaXRlbSB3YXMgZm91bmQgYW5kIHJlbW92ZWQuXG4gICAgICovXG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICBjb25zdCBpZHggPSBhc0l0ZW1JbmRleChrZXkpO1xuICAgICAgICBpZiAodHlwZW9mIGlkeCAhPT0gJ251bWJlcicpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGRlbCA9IHRoaXMuaXRlbXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIHJldHVybiBkZWwubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgZ2V0KGtleSwga2VlcFNjYWxhcikge1xuICAgICAgICBjb25zdCBpZHggPSBhc0l0ZW1JbmRleChrZXkpO1xuICAgICAgICBpZiAodHlwZW9mIGlkeCAhPT0gJ251bWJlcicpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBpdCA9IHRoaXMuaXRlbXNbaWR4XTtcbiAgICAgICAgcmV0dXJuICFrZWVwU2NhbGFyICYmIGlkZW50aXR5LmlzU2NhbGFyKGl0KSA/IGl0LnZhbHVlIDogaXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgY29sbGVjdGlvbiBpbmNsdWRlcyBhIHZhbHVlIHdpdGggdGhlIGtleSBga2V5YC5cbiAgICAgKlxuICAgICAqIGBrZXlgIG11c3QgY29udGFpbiBhIHJlcHJlc2VudGF0aW9uIG9mIGFuIGludGVnZXIgZm9yIHRoaXMgdG8gc3VjY2VlZC5cbiAgICAgKiBJdCBtYXkgYmUgd3JhcHBlZCBpbiBhIGBTY2FsYXJgLlxuICAgICAqL1xuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gYXNJdGVtSW5kZXgoa2V5KTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBpZHggPT09ICdudW1iZXInICYmIGlkeCA8IHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgdmFsdWUgaW4gdGhpcyBjb2xsZWN0aW9uLiBGb3IgYCEhc2V0YCwgYHZhbHVlYCBuZWVkcyB0byBiZSBhXG4gICAgICogYm9vbGVhbiB0byBhZGQvcmVtb3ZlIHRoZSBpdGVtIGZyb20gdGhlIHNldC5cbiAgICAgKlxuICAgICAqIElmIGBrZXlgIGRvZXMgbm90IGNvbnRhaW4gYSByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnRlZ2VyLCB0aGlzIHdpbGwgdGhyb3cuXG4gICAgICogSXQgbWF5IGJlIHdyYXBwZWQgaW4gYSBgU2NhbGFyYC5cbiAgICAgKi9cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBpZHggPSBhc0l0ZW1JbmRleChrZXkpO1xuICAgICAgICBpZiAodHlwZW9mIGlkeCAhPT0gJ251bWJlcicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgdmFsaWQgaW5kZXgsIG5vdCAke2tleX0uYCk7XG4gICAgICAgIGNvbnN0IHByZXYgPSB0aGlzLml0ZW1zW2lkeF07XG4gICAgICAgIGlmIChpZGVudGl0eS5pc1NjYWxhcihwcmV2KSAmJiBTY2FsYXIuaXNTY2FsYXJWYWx1ZSh2YWx1ZSkpXG4gICAgICAgICAgICBwcmV2LnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuaXRlbXNbaWR4XSA9IHZhbHVlO1xuICAgIH1cbiAgICB0b0pTT04oXywgY3R4KSB7XG4gICAgICAgIGNvbnN0IHNlcSA9IFtdO1xuICAgICAgICBpZiAoY3R4Py5vbkNyZWF0ZSlcbiAgICAgICAgICAgIGN0eC5vbkNyZWF0ZShzZXEpO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLml0ZW1zKVxuICAgICAgICAgICAgc2VxLnB1c2godG9KUy50b0pTKGl0ZW0sIFN0cmluZyhpKyspLCBjdHgpKTtcbiAgICAgICAgcmV0dXJuIHNlcTtcbiAgICB9XG4gICAgdG9TdHJpbmcoY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgICAgIGlmICghY3R4KVxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgICAgICByZXR1cm4gc3RyaW5naWZ5Q29sbGVjdGlvbi5zdHJpbmdpZnlDb2xsZWN0aW9uKHRoaXMsIGN0eCwge1xuICAgICAgICAgICAgYmxvY2tJdGVtUHJlZml4OiAnLSAnLFxuICAgICAgICAgICAgZmxvd0NoYXJzOiB7IHN0YXJ0OiAnWycsIGVuZDogJ10nIH0sXG4gICAgICAgICAgICBpdGVtSW5kZW50OiAoY3R4LmluZGVudCB8fCAnJykgKyAnICAnLFxuICAgICAgICAgICAgb25DaG9tcEtlZXAsXG4gICAgICAgICAgICBvbkNvbW1lbnRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHNjaGVtYSwgb2JqLCBjdHgpIHtcbiAgICAgICAgY29uc3QgeyByZXBsYWNlciB9ID0gY3R4O1xuICAgICAgICBjb25zdCBzZXEgPSBuZXcgdGhpcyhzY2hlbWEpO1xuICAgICAgICBpZiAob2JqICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3Qob2JqKSkge1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaXQgb2Ygb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBvYmogaW5zdGFuY2VvZiBTZXQgPyBpdCA6IFN0cmluZyhpKyspO1xuICAgICAgICAgICAgICAgICAgICBpdCA9IHJlcGxhY2VyLmNhbGwob2JqLCBrZXksIGl0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VxLml0ZW1zLnB1c2goY3JlYXRlTm9kZS5jcmVhdGVOb2RlKGl0LCB1bmRlZmluZWQsIGN0eCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXE7XG4gICAgfVxufVxuZnVuY3Rpb24gYXNJdGVtSW5kZXgoa2V5KSB7XG4gICAgbGV0IGlkeCA9IGlkZW50aXR5LmlzU2NhbGFyKGtleSkgPyBrZXkudmFsdWUgOiBrZXk7XG4gICAgaWYgKGlkeCAmJiB0eXBlb2YgaWR4ID09PSAnc3RyaW5nJylcbiAgICAgICAgaWR4ID0gTnVtYmVyKGlkeCk7XG4gICAgcmV0dXJuIHR5cGVvZiBpZHggPT09ICdudW1iZXInICYmIE51bWJlci5pc0ludGVnZXIoaWR4KSAmJiBpZHggPj0gMFxuICAgICAgICA/IGlkeFxuICAgICAgICA6IG51bGw7XG59XG5cbmV4cG9ydHMuWUFNTFNlcSA9IFlBTUxTZXE7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi4vLi4vbm9kZXMvaWRlbnRpdHkuanMnKTtcbnZhciBZQU1MU2VxID0gcmVxdWlyZSgnLi4vLi4vbm9kZXMvWUFNTFNlcS5qcycpO1xuXG5jb25zdCBzZXEgPSB7XG4gICAgY29sbGVjdGlvbjogJ3NlcScsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICBub2RlQ2xhc3M6IFlBTUxTZXEuWUFNTFNlcSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpzZXEnLFxuICAgIHJlc29sdmUoc2VxLCBvbkVycm9yKSB7XG4gICAgICAgIGlmICghaWRlbnRpdHkuaXNTZXEoc2VxKSlcbiAgICAgICAgICAgIG9uRXJyb3IoJ0V4cGVjdGVkIGEgc2VxdWVuY2UgZm9yIHRoaXMgdGFnJyk7XG4gICAgICAgIHJldHVybiBzZXE7XG4gICAgfSxcbiAgICBjcmVhdGVOb2RlOiAoc2NoZW1hLCBvYmosIGN0eCkgPT4gWUFNTFNlcS5ZQU1MU2VxLmZyb20oc2NoZW1hLCBvYmosIGN0eClcbn07XG5cbmV4cG9ydHMuc2VxID0gc2VxO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlTdHJpbmcgPSByZXF1aXJlKCcuLi8uLi9zdHJpbmdpZnkvc3RyaW5naWZ5U3RyaW5nLmpzJyk7XG5cbmNvbnN0IHN0cmluZyA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsXG4gICAgcmVzb2x2ZTogc3RyID0+IHN0cixcbiAgICBzdHJpbmdpZnkoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgICAgIGN0eCA9IE9iamVjdC5hc3NpZ24oeyBhY3R1YWxTdHJpbmc6IHRydWUgfSwgY3R4KTtcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeVN0cmluZy5zdHJpbmdpZnlTdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICB9XG59O1xuXG5leHBvcnRzLnN0cmluZyA9IHN0cmluZztcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgU2NhbGFyID0gcmVxdWlyZSgnLi4vLi4vbm9kZXMvU2NhbGFyLmpzJyk7XG5cbmNvbnN0IG51bGxUYWcgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlID09IG51bGwsXG4gICAgY3JlYXRlTm9kZTogKCkgPT4gbmV3IFNjYWxhci5TY2FsYXIobnVsbCksXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpudWxsJyxcbiAgICB0ZXN0OiAvXig/On58W05uXXVsbHxOVUxMKT8kLyxcbiAgICByZXNvbHZlOiAoKSA9PiBuZXcgU2NhbGFyLlNjYWxhcihudWxsKSxcbiAgICBzdHJpbmdpZnk6ICh7IHNvdXJjZSB9LCBjdHgpID0+IHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnICYmIG51bGxUYWcudGVzdC50ZXN0KHNvdXJjZSlcbiAgICAgICAgPyBzb3VyY2VcbiAgICAgICAgOiBjdHgub3B0aW9ucy5udWxsU3RyXG59O1xuXG5leHBvcnRzLm51bGxUYWcgPSBudWxsVGFnO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBTY2FsYXIgPSByZXF1aXJlKCcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnKTtcblxuY29uc3QgYm9vbFRhZyA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpib29sJyxcbiAgICB0ZXN0OiAvXig/OltUdF1ydWV8VFJVRXxbRmZdYWxzZXxGQUxTRSkkLyxcbiAgICByZXNvbHZlOiBzdHIgPT4gbmV3IFNjYWxhci5TY2FsYXIoc3RyWzBdID09PSAndCcgfHwgc3RyWzBdID09PSAnVCcpLFxuICAgIHN0cmluZ2lmeSh7IHNvdXJjZSwgdmFsdWUgfSwgY3R4KSB7XG4gICAgICAgIGlmIChzb3VyY2UgJiYgYm9vbFRhZy50ZXN0LnRlc3Qoc291cmNlKSkge1xuICAgICAgICAgICAgY29uc3Qgc3YgPSBzb3VyY2VbMF0gPT09ICd0JyB8fCBzb3VyY2VbMF0gPT09ICdUJztcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gc3YpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUgPyBjdHgub3B0aW9ucy50cnVlU3RyIDogY3R4Lm9wdGlvbnMuZmFsc2VTdHI7XG4gICAgfVxufTtcblxuZXhwb3J0cy5ib29sVGFnID0gYm9vbFRhZztcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBzdHJpbmdpZnlOdW1iZXIoeyBmb3JtYXQsIG1pbkZyYWN0aW9uRGlnaXRzLCB0YWcsIHZhbHVlIH0pIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JylcbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgY29uc3QgbnVtID0gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IHZhbHVlIDogTnVtYmVyKHZhbHVlKTtcbiAgICBpZiAoIWlzRmluaXRlKG51bSkpXG4gICAgICAgIHJldHVybiBpc05hTihudW0pID8gJy5uYW4nIDogbnVtIDwgMCA/ICctLmluZicgOiAnLmluZic7XG4gICAgbGV0IG4gPSBPYmplY3QuaXModmFsdWUsIC0wKSA/ICctMCcgOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgaWYgKCFmb3JtYXQgJiZcbiAgICAgICAgbWluRnJhY3Rpb25EaWdpdHMgJiZcbiAgICAgICAgKCF0YWcgfHwgdGFnID09PSAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnKSAmJlxuICAgICAgICAvXlxcZC8udGVzdChuKSkge1xuICAgICAgICBsZXQgaSA9IG4uaW5kZXhPZignLicpO1xuICAgICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgICAgIGkgPSBuLmxlbmd0aDtcbiAgICAgICAgICAgIG4gKz0gJy4nO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkID0gbWluRnJhY3Rpb25EaWdpdHMgLSAobi5sZW5ndGggLSBpIC0gMSk7XG4gICAgICAgIHdoaWxlIChkLS0gPiAwKVxuICAgICAgICAgICAgbiArPSAnMCc7XG4gICAgfVxuICAgIHJldHVybiBuO1xufVxuXG5leHBvcnRzLnN0cmluZ2lmeU51bWJlciA9IHN0cmluZ2lmeU51bWJlcjtcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgU2NhbGFyID0gcmVxdWlyZSgnLi4vLi4vbm9kZXMvU2NhbGFyLmpzJyk7XG52YXIgc3RyaW5naWZ5TnVtYmVyID0gcmVxdWlyZSgnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeU51bWJlci5qcycpO1xuXG5jb25zdCBmbG9hdE5hTiA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgICB0ZXN0OiAvXig/OlstK10/XFwuKD86aW5mfEluZnxJTkYpfFxcLm5hbnxcXC5OYU58XFwuTkFOKSQvLFxuICAgIHJlc29sdmU6IHN0ciA9PiBzdHIuc2xpY2UoLTMpLnRvTG93ZXJDYXNlKCkgPT09ICduYW4nXG4gICAgICAgID8gTmFOXG4gICAgICAgIDogc3RyWzBdID09PSAnLSdcbiAgICAgICAgICAgID8gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXG4gICAgICAgICAgICA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeU51bWJlci5zdHJpbmdpZnlOdW1iZXJcbn07XG5jb25zdCBmbG9hdEV4cCA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgICBmb3JtYXQ6ICdFWFAnLFxuICAgIHRlc3Q6IC9eWy0rXT8oPzpcXC5bMC05XSt8WzAtOV0rKD86XFwuWzAtOV0qKT8pW2VFXVstK10/WzAtOV0rJC8sXG4gICAgcmVzb2x2ZTogc3RyID0+IHBhcnNlRmxvYXQoc3RyKSxcbiAgICBzdHJpbmdpZnkobm9kZSkge1xuICAgICAgICBjb25zdCBudW0gPSBOdW1iZXIobm9kZS52YWx1ZSk7XG4gICAgICAgIHJldHVybiBpc0Zpbml0ZShudW0pID8gbnVtLnRvRXhwb25lbnRpYWwoKSA6IHN0cmluZ2lmeU51bWJlci5zdHJpbmdpZnlOdW1iZXIobm9kZSk7XG4gICAgfVxufTtcbmNvbnN0IGZsb2F0ID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICAgIHRlc3Q6IC9eWy0rXT8oPzpcXC5bMC05XSt8WzAtOV0rXFwuWzAtOV0qKSQvLFxuICAgIHJlc29sdmUoc3RyKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgU2NhbGFyLlNjYWxhcihwYXJzZUZsb2F0KHN0cikpO1xuICAgICAgICBjb25zdCBkb3QgPSBzdHIuaW5kZXhPZignLicpO1xuICAgICAgICBpZiAoZG90ICE9PSAtMSAmJiBzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnMCcpXG4gICAgICAgICAgICBub2RlLm1pbkZyYWN0aW9uRGlnaXRzID0gc3RyLmxlbmd0aCAtIGRvdCAtIDE7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG4gICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlOdW1iZXIuc3RyaW5naWZ5TnVtYmVyXG59O1xuXG5leHBvcnRzLmZsb2F0ID0gZmxvYXQ7XG5leHBvcnRzLmZsb2F0RXhwID0gZmxvYXRFeHA7XG5leHBvcnRzLmZsb2F0TmFOID0gZmxvYXROYU47XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeU51bWJlciA9IHJlcXVpcmUoJy4uLy4uL3N0cmluZ2lmeS9zdHJpbmdpZnlOdW1iZXIuanMnKTtcblxuY29uc3QgaW50SWRlbnRpZnkgPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcgfHwgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSk7XG5jb25zdCBpbnRSZXNvbHZlID0gKHN0ciwgb2Zmc2V0LCByYWRpeCwgeyBpbnRBc0JpZ0ludCB9KSA9PiAoaW50QXNCaWdJbnQgPyBCaWdJbnQoc3RyKSA6IHBhcnNlSW50KHN0ci5zdWJzdHJpbmcob2Zmc2V0KSwgcmFkaXgpKTtcbmZ1bmN0aW9uIGludFN0cmluZ2lmeShub2RlLCByYWRpeCwgcHJlZml4KSB7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gbm9kZTtcbiAgICBpZiAoaW50SWRlbnRpZnkodmFsdWUpICYmIHZhbHVlID49IDApXG4gICAgICAgIHJldHVybiBwcmVmaXggKyB2YWx1ZS50b1N0cmluZyhyYWRpeCk7XG4gICAgcmV0dXJuIHN0cmluZ2lmeU51bWJlci5zdHJpbmdpZnlOdW1iZXIobm9kZSk7XG59XG5jb25zdCBpbnRPY3QgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IGludElkZW50aWZ5KHZhbHVlKSAmJiB2YWx1ZSA+PSAwLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICBmb3JtYXQ6ICdPQ1QnLFxuICAgIHRlc3Q6IC9eMG9bMC03XSskLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgb3B0KSA9PiBpbnRSZXNvbHZlKHN0ciwgMiwgOCwgb3B0KSxcbiAgICBzdHJpbmdpZnk6IG5vZGUgPT4gaW50U3RyaW5naWZ5KG5vZGUsIDgsICcwbycpXG59O1xuY29uc3QgaW50ID0ge1xuICAgIGlkZW50aWZ5OiBpbnRJZGVudGlmeSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gICAgdGVzdDogL15bLStdP1swLTldKyQvLFxuICAgIHJlc29sdmU6IChzdHIsIF9vbkVycm9yLCBvcHQpID0+IGludFJlc29sdmUoc3RyLCAwLCAxMCwgb3B0KSxcbiAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeU51bWJlci5zdHJpbmdpZnlOdW1iZXJcbn07XG5jb25zdCBpbnRIZXggPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IGludElkZW50aWZ5KHZhbHVlKSAmJiB2YWx1ZSA+PSAwLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICBmb3JtYXQ6ICdIRVgnLFxuICAgIHRlc3Q6IC9eMHhbMC05YS1mQS1GXSskLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgb3B0KSA9PiBpbnRSZXNvbHZlKHN0ciwgMiwgMTYsIG9wdCksXG4gICAgc3RyaW5naWZ5OiBub2RlID0+IGludFN0cmluZ2lmeShub2RlLCAxNiwgJzB4Jylcbn07XG5cbmV4cG9ydHMuaW50ID0gaW50O1xuZXhwb3J0cy5pbnRIZXggPSBpbnRIZXg7XG5leHBvcnRzLmludE9jdCA9IGludE9jdDtcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWFwID0gcmVxdWlyZSgnLi4vY29tbW9uL21hcC5qcycpO1xudmFyIF9udWxsID0gcmVxdWlyZSgnLi4vY29tbW9uL251bGwuanMnKTtcbnZhciBzZXEgPSByZXF1aXJlKCcuLi9jb21tb24vc2VxLmpzJyk7XG52YXIgc3RyaW5nID0gcmVxdWlyZSgnLi4vY29tbW9uL3N0cmluZy5qcycpO1xudmFyIGJvb2wgPSByZXF1aXJlKCcuL2Jvb2wuanMnKTtcbnZhciBmbG9hdCA9IHJlcXVpcmUoJy4vZmxvYXQuanMnKTtcbnZhciBpbnQgPSByZXF1aXJlKCcuL2ludC5qcycpO1xuXG5jb25zdCBzY2hlbWEgPSBbXG4gICAgbWFwLm1hcCxcbiAgICBzZXEuc2VxLFxuICAgIHN0cmluZy5zdHJpbmcsXG4gICAgX251bGwubnVsbFRhZyxcbiAgICBib29sLmJvb2xUYWcsXG4gICAgaW50LmludE9jdCxcbiAgICBpbnQuaW50LFxuICAgIGludC5pbnRIZXgsXG4gICAgZmxvYXQuZmxvYXROYU4sXG4gICAgZmxvYXQuZmxvYXRFeHAsXG4gICAgZmxvYXQuZmxvYXRcbl07XG5cbmV4cG9ydHMuc2NoZW1hID0gc2NoZW1hO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBTY2FsYXIgPSByZXF1aXJlKCcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnKTtcbnZhciBtYXAgPSByZXF1aXJlKCcuLi9jb21tb24vbWFwLmpzJyk7XG52YXIgc2VxID0gcmVxdWlyZSgnLi4vY29tbW9uL3NlcS5qcycpO1xuXG5mdW5jdGlvbiBpbnRJZGVudGlmeSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnIHx8IE51bWJlci5pc0ludGVnZXIodmFsdWUpO1xufVxuY29uc3Qgc3RyaW5naWZ5SlNPTiA9ICh7IHZhbHVlIH0pID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbmNvbnN0IGpzb25TY2FsYXJzID0gW1xuICAgIHtcbiAgICAgICAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycsXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsXG4gICAgICAgIHJlc29sdmU6IHN0ciA9PiBzdHIsXG4gICAgICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5SlNPTlxuICAgIH0sXG4gICAge1xuICAgICAgICBpZGVudGlmeTogdmFsdWUgPT4gdmFsdWUgPT0gbnVsbCxcbiAgICAgICAgY3JlYXRlTm9kZTogKCkgPT4gbmV3IFNjYWxhci5TY2FsYXIobnVsbCksXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOm51bGwnLFxuICAgICAgICB0ZXN0OiAvXm51bGwkLyxcbiAgICAgICAgcmVzb2x2ZTogKCkgPT4gbnVsbCxcbiAgICAgICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlKU09OXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6Ym9vbCcsXG4gICAgICAgIHRlc3Q6IC9edHJ1ZSR8XmZhbHNlJC8sXG4gICAgICAgIHJlc29sdmU6IHN0ciA9PiBzdHIgPT09ICd0cnVlJyxcbiAgICAgICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlKU09OXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlkZW50aWZ5OiBpbnRJZGVudGlmeSxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICAgICAgdGVzdDogL14tPyg/OjB8WzEtOV1bMC05XSopJC8sXG4gICAgICAgIHJlc29sdmU6IChzdHIsIF9vbkVycm9yLCB7IGludEFzQmlnSW50IH0pID0+IGludEFzQmlnSW50ID8gQmlnSW50KHN0cikgOiBwYXJzZUludChzdHIsIDEwKSxcbiAgICAgICAgc3RyaW5naWZ5OiAoeyB2YWx1ZSB9KSA9PiBpbnRJZGVudGlmeSh2YWx1ZSkgPyB2YWx1ZS50b1N0cmluZygpIDogSlNPTi5zdHJpbmdpZnkodmFsdWUpXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsXG4gICAgICAgIHRlc3Q6IC9eLT8oPzowfFsxLTldWzAtOV0qKSg/OlxcLlswLTldKik/KD86W2VFXVstK10/WzAtOV0rKT8kLyxcbiAgICAgICAgcmVzb2x2ZTogc3RyID0+IHBhcnNlRmxvYXQoc3RyKSxcbiAgICAgICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlKU09OXG4gICAgfVxuXTtcbmNvbnN0IGpzb25FcnJvciA9IHtcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJycsXG4gICAgdGVzdDogL14vLFxuICAgIHJlc29sdmUoc3RyLCBvbkVycm9yKSB7XG4gICAgICAgIG9uRXJyb3IoYFVucmVzb2x2ZWQgcGxhaW4gc2NhbGFyICR7SlNPTi5zdHJpbmdpZnkoc3RyKX1gKTtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG59O1xuY29uc3Qgc2NoZW1hID0gW21hcC5tYXAsIHNlcS5zZXFdLmNvbmNhdChqc29uU2NhbGFycywganNvbkVycm9yKTtcblxuZXhwb3J0cy5zY2hlbWEgPSBzY2hlbWE7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIG5vZGVfYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJyk7XG52YXIgU2NhbGFyID0gcmVxdWlyZSgnLi4vLi4vbm9kZXMvU2NhbGFyLmpzJyk7XG52YXIgc3RyaW5naWZ5U3RyaW5nID0gcmVxdWlyZSgnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeVN0cmluZy5qcycpO1xuXG5jb25zdCBiaW5hcnkgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSwgLy8gQnVmZmVyIGluaGVyaXRzIGZyb20gVWludDhBcnJheVxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJpbmFyeScsXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEJ1ZmZlciBpbiBub2RlIGFuZCBhbiBVaW50OEFycmF5IGluIGJyb3dzZXJzXG4gICAgICpcbiAgICAgKiBUbyB1c2UgdGhlIHJlc3VsdGluZyBidWZmZXIgYXMgYW4gaW1hZ2UsIHlvdSdsbCB3YW50IHRvIGRvIHNvbWV0aGluZyBsaWtlOlxuICAgICAqXG4gICAgICogICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2J1ZmZlcl0sIHsgdHlwZTogJ2ltYWdlL2pwZWcnIH0pXG4gICAgICogICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcGhvdG8nKS5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpXG4gICAgICovXG4gICAgcmVzb2x2ZShzcmMsIG9uRXJyb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlX2J1ZmZlci5CdWZmZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlX2J1ZmZlci5CdWZmZXIuZnJvbShzcmMsICdiYXNlNjQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXRvYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gT24gSUUgMTEsIGF0b2IoKSBjYW4ndCBoYW5kbGUgbmV3bGluZXNcbiAgICAgICAgICAgIGNvbnN0IHN0ciA9IGF0b2Ioc3JjLnJlcGxhY2UoL1tcXG5cXHJdL2csICcnKSk7XG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIGJ1ZmZlcltpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9uRXJyb3IoJ1RoaXMgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCByZWFkaW5nIGJpbmFyeSB0YWdzOyBlaXRoZXIgQnVmZmVyIG9yIGF0b2IgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIHJldHVybiBzcmM7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHN0cmluZ2lmeSh7IGNvbW1lbnQsIHR5cGUsIHZhbHVlIH0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgICAgICBpZiAoIXZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICBjb25zdCBidWYgPSB2YWx1ZTsgLy8gY2hlY2tlZCBlYXJsaWVyIGJ5IGJpbmFyeS5pZGVudGlmeSgpXG4gICAgICAgIGxldCBzdHI7XG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZV9idWZmZXIuQnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzdHIgPVxuICAgICAgICAgICAgICAgIGJ1ZiBpbnN0YW5jZW9mIG5vZGVfYnVmZmVyLkJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICA/IGJ1Zi50b1N0cmluZygnYmFzZTY0JylcbiAgICAgICAgICAgICAgICAgICAgOiBub2RlX2J1ZmZlci5CdWZmZXIuZnJvbShidWYuYnVmZmVyKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGxldCBzID0gJyc7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgICAgICAgICAgIHN0ciA9IGJ0b2Eocyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCB3cml0aW5nIGJpbmFyeSB0YWdzOyBlaXRoZXIgQnVmZmVyIG9yIGJ0b2EgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0eXBlID8/ICh0eXBlID0gU2NhbGFyLlNjYWxhci5CTE9DS19MSVRFUkFMKTtcbiAgICAgICAgaWYgKHR5cGUgIT09IFNjYWxhci5TY2FsYXIuUVVPVEVfRE9VQkxFKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lV2lkdGggPSBNYXRoLm1heChjdHgub3B0aW9ucy5saW5lV2lkdGggLSBjdHguaW5kZW50Lmxlbmd0aCwgY3R4Lm9wdGlvbnMubWluQ29udGVudFdpZHRoKTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBNYXRoLmNlaWwoc3RyLmxlbmd0aCAvIGxpbmVXaWR0aCk7XG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IG5ldyBBcnJheShuKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBvID0gMDsgaSA8IG47ICsraSwgbyArPSBsaW5lV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBsaW5lc1tpXSA9IHN0ci5zdWJzdHIobywgbGluZVdpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0ciA9IGxpbmVzLmpvaW4odHlwZSA9PT0gU2NhbGFyLlNjYWxhci5CTE9DS19MSVRFUkFMID8gJ1xcbicgOiAnICcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlTdHJpbmcuc3RyaW5naWZ5U3RyaW5nKHsgY29tbWVudCwgdHlwZSwgdmFsdWU6IHN0ciB9LCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgIH1cbn07XG5cbmV4cG9ydHMuYmluYXJ5ID0gYmluYXJ5O1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4uLy4uL25vZGVzL2lkZW50aXR5LmpzJyk7XG52YXIgUGFpciA9IHJlcXVpcmUoJy4uLy4uL25vZGVzL1BhaXIuanMnKTtcbnZhciBTY2FsYXIgPSByZXF1aXJlKCcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnKTtcbnZhciBZQU1MU2VxID0gcmVxdWlyZSgnLi4vLi4vbm9kZXMvWUFNTFNlcS5qcycpO1xuXG5mdW5jdGlvbiByZXNvbHZlUGFpcnMoc2VxLCBvbkVycm9yKSB7XG4gICAgaWYgKGlkZW50aXR5LmlzU2VxKHNlcSkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXEuaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBpdGVtID0gc2VxLml0ZW1zW2ldO1xuICAgICAgICAgICAgaWYgKGlkZW50aXR5LmlzUGFpcihpdGVtKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlkZW50aXR5LmlzTWFwKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uaXRlbXMubGVuZ3RoID4gMSlcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcignRWFjaCBwYWlyIG11c3QgaGF2ZSBpdHMgb3duIHNlcXVlbmNlIGluZGljYXRvcicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhaXIgPSBpdGVtLml0ZW1zWzBdIHx8IG5ldyBQYWlyLlBhaXIobmV3IFNjYWxhci5TY2FsYXIobnVsbCkpO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmNvbW1lbnRCZWZvcmUpXG4gICAgICAgICAgICAgICAgICAgIHBhaXIua2V5LmNvbW1lbnRCZWZvcmUgPSBwYWlyLmtleS5jb21tZW50QmVmb3JlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGAke2l0ZW0uY29tbWVudEJlZm9yZX1cXG4ke3BhaXIua2V5LmNvbW1lbnRCZWZvcmV9YFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBpdGVtLmNvbW1lbnRCZWZvcmU7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uY29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbiA9IHBhaXIudmFsdWUgPz8gcGFpci5rZXk7XG4gICAgICAgICAgICAgICAgICAgIGNuLmNvbW1lbnQgPSBjbi5jb21tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICA/IGAke2l0ZW0uY29tbWVudH1cXG4ke2NuLmNvbW1lbnR9YFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBpdGVtLmNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGl0ZW0gPSBwYWlyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VxLml0ZW1zW2ldID0gaWRlbnRpdHkuaXNQYWlyKGl0ZW0pID8gaXRlbSA6IG5ldyBQYWlyLlBhaXIoaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZVxuICAgICAgICBvbkVycm9yKCdFeHBlY3RlZCBhIHNlcXVlbmNlIGZvciB0aGlzIHRhZycpO1xuICAgIHJldHVybiBzZXE7XG59XG5mdW5jdGlvbiBjcmVhdGVQYWlycyhzY2hlbWEsIGl0ZXJhYmxlLCBjdHgpIHtcbiAgICBjb25zdCB7IHJlcGxhY2VyIH0gPSBjdHg7XG4gICAgY29uc3QgcGFpcnMgPSBuZXcgWUFNTFNlcS5ZQU1MU2VxKHNjaGVtYSk7XG4gICAgcGFpcnMudGFnID0gJ3RhZzp5YW1sLm9yZywyMDAyOnBhaXJzJztcbiAgICBsZXQgaSA9IDA7XG4gICAgaWYgKGl0ZXJhYmxlICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcmFibGUpKVxuICAgICAgICBmb3IgKGxldCBpdCBvZiBpdGVyYWJsZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICBpdCA9IHJlcGxhY2VyLmNhbGwoaXRlcmFibGUsIFN0cmluZyhpKyspLCBpdCk7XG4gICAgICAgICAgICBsZXQga2V5LCB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0KSkge1xuICAgICAgICAgICAgICAgIGlmIChpdC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gaXRbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaXRbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgW2tleSwgdmFsdWVdIHR1cGxlOiAke2l0fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXQgJiYgaXQgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaXQpO1xuICAgICAgICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBrZXlzWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGl0W2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCB0dXBsZSB3aXRoIG9uZSBrZXksIG5vdCAke2tleXMubGVuZ3RofSBrZXlzYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAga2V5ID0gaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYWlycy5pdGVtcy5wdXNoKFBhaXIuY3JlYXRlUGFpcihrZXksIHZhbHVlLCBjdHgpKTtcbiAgICAgICAgfVxuICAgIHJldHVybiBwYWlycztcbn1cbmNvbnN0IHBhaXJzID0ge1xuICAgIGNvbGxlY3Rpb246ICdzZXEnLFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOnBhaXJzJyxcbiAgICByZXNvbHZlOiByZXNvbHZlUGFpcnMsXG4gICAgY3JlYXRlTm9kZTogY3JlYXRlUGFpcnNcbn07XG5cbmV4cG9ydHMuY3JlYXRlUGFpcnMgPSBjcmVhdGVQYWlycztcbmV4cG9ydHMucGFpcnMgPSBwYWlycztcbmV4cG9ydHMucmVzb2x2ZVBhaXJzID0gcmVzb2x2ZVBhaXJzO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4uLy4uL25vZGVzL2lkZW50aXR5LmpzJyk7XG52YXIgdG9KUyA9IHJlcXVpcmUoJy4uLy4uL25vZGVzL3RvSlMuanMnKTtcbnZhciBZQU1MTWFwID0gcmVxdWlyZSgnLi4vLi4vbm9kZXMvWUFNTE1hcC5qcycpO1xudmFyIFlBTUxTZXEgPSByZXF1aXJlKCcuLi8uLi9ub2Rlcy9ZQU1MU2VxLmpzJyk7XG52YXIgcGFpcnMgPSByZXF1aXJlKCcuL3BhaXJzLmpzJyk7XG5cbmNsYXNzIFlBTUxPTWFwIGV4dGVuZHMgWUFNTFNlcS5ZQU1MU2VxIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hZGQgPSBZQU1MTWFwLllBTUxNYXAucHJvdG90eXBlLmFkZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRlbGV0ZSA9IFlBTUxNYXAuWUFNTE1hcC5wcm90b3R5cGUuZGVsZXRlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0ID0gWUFNTE1hcC5ZQU1MTWFwLnByb3RvdHlwZS5nZXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYXMgPSBZQU1MTWFwLllBTUxNYXAucHJvdG90eXBlLmhhcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldCA9IFlBTUxNYXAuWUFNTE1hcC5wcm90b3R5cGUuc2V0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudGFnID0gWUFNTE9NYXAudGFnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiBgY3R4YCBpcyBnaXZlbiwgdGhlIHJldHVybiB0eXBlIGlzIGFjdHVhbGx5IGBNYXA8dW5rbm93biwgdW5rbm93bj5gLFxuICAgICAqIGJ1dCBUeXBlU2NyaXB0IHdvbid0IGFsbG93IHdpZGVuaW5nIHRoZSBzaWduYXR1cmUgb2YgYSBjaGlsZCBtZXRob2QuXG4gICAgICovXG4gICAgdG9KU09OKF8sIGN0eCkge1xuICAgICAgICBpZiAoIWN0eClcbiAgICAgICAgICAgIHJldHVybiBzdXBlci50b0pTT04oXyk7XG4gICAgICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKGN0eD8ub25DcmVhdGUpXG4gICAgICAgICAgICBjdHgub25DcmVhdGUobWFwKTtcbiAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHRoaXMuaXRlbXMpIHtcbiAgICAgICAgICAgIGxldCBrZXksIHZhbHVlO1xuICAgICAgICAgICAgaWYgKGlkZW50aXR5LmlzUGFpcihwYWlyKSkge1xuICAgICAgICAgICAgICAgIGtleSA9IHRvSlMudG9KUyhwYWlyLmtleSwgJycsIGN0eCk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b0pTLnRvSlMocGFpci52YWx1ZSwga2V5LCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAga2V5ID0gdG9KUy50b0pTKHBhaXIsICcnLCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hcC5oYXMoa2V5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09yZGVyZWQgbWFwcyBtdXN0IG5vdCBpbmNsdWRlIGR1cGxpY2F0ZSBrZXlzJyk7XG4gICAgICAgICAgICBtYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHNjaGVtYSwgaXRlcmFibGUsIGN0eCkge1xuICAgICAgICBjb25zdCBwYWlycyQxID0gcGFpcnMuY3JlYXRlUGFpcnMoc2NoZW1hLCBpdGVyYWJsZSwgY3R4KTtcbiAgICAgICAgY29uc3Qgb21hcCA9IG5ldyB0aGlzKCk7XG4gICAgICAgIG9tYXAuaXRlbXMgPSBwYWlycyQxLml0ZW1zO1xuICAgICAgICByZXR1cm4gb21hcDtcbiAgICB9XG59XG5ZQU1MT01hcC50YWcgPSAndGFnOnlhbWwub3JnLDIwMDI6b21hcCc7XG5jb25zdCBvbWFwID0ge1xuICAgIGNvbGxlY3Rpb246ICdzZXEnLFxuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB2YWx1ZSBpbnN0YW5jZW9mIE1hcCxcbiAgICBub2RlQ2xhc3M6IFlBTUxPTWFwLFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOm9tYXAnLFxuICAgIHJlc29sdmUoc2VxLCBvbkVycm9yKSB7XG4gICAgICAgIGNvbnN0IHBhaXJzJDEgPSBwYWlycy5yZXNvbHZlUGFpcnMoc2VxLCBvbkVycm9yKTtcbiAgICAgICAgY29uc3Qgc2VlbktleXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB7IGtleSB9IG9mIHBhaXJzJDEuaXRlbXMpIHtcbiAgICAgICAgICAgIGlmIChpZGVudGl0eS5pc1NjYWxhcihrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlZW5LZXlzLmluY2x1ZGVzKGtleS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihgT3JkZXJlZCBtYXBzIG11c3Qgbm90IGluY2x1ZGUgZHVwbGljYXRlIGtleXM6ICR7a2V5LnZhbHVlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VlbktleXMucHVzaChrZXkudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgWUFNTE9NYXAoKSwgcGFpcnMkMSk7XG4gICAgfSxcbiAgICBjcmVhdGVOb2RlOiAoc2NoZW1hLCBpdGVyYWJsZSwgY3R4KSA9PiBZQU1MT01hcC5mcm9tKHNjaGVtYSwgaXRlcmFibGUsIGN0eClcbn07XG5cbmV4cG9ydHMuWUFNTE9NYXAgPSBZQU1MT01hcDtcbmV4cG9ydHMub21hcCA9IG9tYXA7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIFNjYWxhciA9IHJlcXVpcmUoJy4uLy4uL25vZGVzL1NjYWxhci5qcycpO1xuXG5mdW5jdGlvbiBib29sU3RyaW5naWZ5KHsgdmFsdWUsIHNvdXJjZSB9LCBjdHgpIHtcbiAgICBjb25zdCBib29sT2JqID0gdmFsdWUgPyB0cnVlVGFnIDogZmFsc2VUYWc7XG4gICAgaWYgKHNvdXJjZSAmJiBib29sT2JqLnRlc3QudGVzdChzb3VyY2UpKVxuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIHJldHVybiB2YWx1ZSA/IGN0eC5vcHRpb25zLnRydWVTdHIgOiBjdHgub3B0aW9ucy5mYWxzZVN0cjtcbn1cbmNvbnN0IHRydWVUYWcgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlID09PSB0cnVlLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6Ym9vbCcsXG4gICAgdGVzdDogL14oPzpZfHl8W1l5XWVzfFlFU3xbVHRdcnVlfFRSVUV8W09vXW58T04pJC8sXG4gICAgcmVzb2x2ZTogKCkgPT4gbmV3IFNjYWxhci5TY2FsYXIodHJ1ZSksXG4gICAgc3RyaW5naWZ5OiBib29sU3RyaW5naWZ5XG59O1xuY29uc3QgZmFsc2VUYWcgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlID09PSBmYWxzZSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLFxuICAgIHRlc3Q6IC9eKD86TnxufFtObl1vfE5PfFtGZl1hbHNlfEZBTFNFfFtPb11mZnxPRkYpJC8sXG4gICAgcmVzb2x2ZTogKCkgPT4gbmV3IFNjYWxhci5TY2FsYXIoZmFsc2UpLFxuICAgIHN0cmluZ2lmeTogYm9vbFN0cmluZ2lmeVxufTtcblxuZXhwb3J0cy5mYWxzZVRhZyA9IGZhbHNlVGFnO1xuZXhwb3J0cy50cnVlVGFnID0gdHJ1ZVRhZztcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgU2NhbGFyID0gcmVxdWlyZSgnLi4vLi4vbm9kZXMvU2NhbGFyLmpzJyk7XG52YXIgc3RyaW5naWZ5TnVtYmVyID0gcmVxdWlyZSgnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeU51bWJlci5qcycpO1xuXG5jb25zdCBmbG9hdE5hTiA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgICB0ZXN0OiAvXig/OlstK10/XFwuKD86aW5mfEluZnxJTkYpfFxcLm5hbnxcXC5OYU58XFwuTkFOKSQvLFxuICAgIHJlc29sdmU6IChzdHIpID0+IHN0ci5zbGljZSgtMykudG9Mb3dlckNhc2UoKSA9PT0gJ25hbidcbiAgICAgICAgPyBOYU5cbiAgICAgICAgOiBzdHJbMF0gPT09ICctJ1xuICAgICAgICAgICAgPyBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFlcbiAgICAgICAgICAgIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5TnVtYmVyLnN0cmluZ2lmeU51bWJlclxufTtcbmNvbnN0IGZsb2F0RXhwID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICAgIGZvcm1hdDogJ0VYUCcsXG4gICAgdGVzdDogL15bLStdPyg/OlswLTldWzAtOV9dKik/KD86XFwuWzAtOV9dKik/W2VFXVstK10/WzAtOV0rJC8sXG4gICAgcmVzb2x2ZTogKHN0cikgPT4gcGFyc2VGbG9hdChzdHIucmVwbGFjZSgvXy9nLCAnJykpLFxuICAgIHN0cmluZ2lmeShub2RlKSB7XG4gICAgICAgIGNvbnN0IG51bSA9IE51bWJlcihub2RlLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGlzRmluaXRlKG51bSkgPyBudW0udG9FeHBvbmVudGlhbCgpIDogc3RyaW5naWZ5TnVtYmVyLnN0cmluZ2lmeU51bWJlcihub2RlKTtcbiAgICB9XG59O1xuY29uc3QgZmxvYXQgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsXG4gICAgdGVzdDogL15bLStdPyg/OlswLTldWzAtOV9dKik/XFwuWzAtOV9dKiQvLFxuICAgIHJlc29sdmUoc3RyKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgU2NhbGFyLlNjYWxhcihwYXJzZUZsb2F0KHN0ci5yZXBsYWNlKC9fL2csICcnKSkpO1xuICAgICAgICBjb25zdCBkb3QgPSBzdHIuaW5kZXhPZignLicpO1xuICAgICAgICBpZiAoZG90ICE9PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgZiA9IHN0ci5zdWJzdHJpbmcoZG90ICsgMSkucmVwbGFjZSgvXy9nLCAnJyk7XG4gICAgICAgICAgICBpZiAoZltmLmxlbmd0aCAtIDFdID09PSAnMCcpXG4gICAgICAgICAgICAgICAgbm9kZS5taW5GcmFjdGlvbkRpZ2l0cyA9IGYubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG4gICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlOdW1iZXIuc3RyaW5naWZ5TnVtYmVyXG59O1xuXG5leHBvcnRzLmZsb2F0ID0gZmxvYXQ7XG5leHBvcnRzLmZsb2F0RXhwID0gZmxvYXRFeHA7XG5leHBvcnRzLmZsb2F0TmFOID0gZmxvYXROYU47XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeU51bWJlciA9IHJlcXVpcmUoJy4uLy4uL3N0cmluZ2lmeS9zdHJpbmdpZnlOdW1iZXIuanMnKTtcblxuY29uc3QgaW50SWRlbnRpZnkgPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcgfHwgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSk7XG5mdW5jdGlvbiBpbnRSZXNvbHZlKHN0ciwgb2Zmc2V0LCByYWRpeCwgeyBpbnRBc0JpZ0ludCB9KSB7XG4gICAgY29uc3Qgc2lnbiA9IHN0clswXTtcbiAgICBpZiAoc2lnbiA9PT0gJy0nIHx8IHNpZ24gPT09ICcrJylcbiAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgc3RyID0gc3RyLnN1YnN0cmluZyhvZmZzZXQpLnJlcGxhY2UoL18vZywgJycpO1xuICAgIGlmIChpbnRBc0JpZ0ludCkge1xuICAgICAgICBzd2l0Y2ggKHJhZGl4KSB7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgc3RyID0gYDBiJHtzdHJ9YDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBzdHIgPSBgMG8ke3N0cn1gO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgICBzdHIgPSBgMHgke3N0cn1gO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG4gPSBCaWdJbnQoc3RyKTtcbiAgICAgICAgcmV0dXJuIHNpZ24gPT09ICctJyA/IEJpZ0ludCgtMSkgKiBuIDogbjtcbiAgICB9XG4gICAgY29uc3QgbiA9IHBhcnNlSW50KHN0ciwgcmFkaXgpO1xuICAgIHJldHVybiBzaWduID09PSAnLScgPyAtMSAqIG4gOiBuO1xufVxuZnVuY3Rpb24gaW50U3RyaW5naWZ5KG5vZGUsIHJhZGl4LCBwcmVmaXgpIHtcbiAgICBjb25zdCB7IHZhbHVlIH0gPSBub2RlO1xuICAgIGlmIChpbnRJZGVudGlmeSh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3Qgc3RyID0gdmFsdWUudG9TdHJpbmcocmFkaXgpO1xuICAgICAgICByZXR1cm4gdmFsdWUgPCAwID8gJy0nICsgcHJlZml4ICsgc3RyLnN1YnN0cigxKSA6IHByZWZpeCArIHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZ2lmeU51bWJlci5zdHJpbmdpZnlOdW1iZXIobm9kZSk7XG59XG5jb25zdCBpbnRCaW4gPSB7XG4gICAgaWRlbnRpZnk6IGludElkZW50aWZ5LFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICBmb3JtYXQ6ICdCSU4nLFxuICAgIHRlc3Q6IC9eWy0rXT8wYlswLTFfXSskLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgb3B0KSA9PiBpbnRSZXNvbHZlKHN0ciwgMiwgMiwgb3B0KSxcbiAgICBzdHJpbmdpZnk6IG5vZGUgPT4gaW50U3RyaW5naWZ5KG5vZGUsIDIsICcwYicpXG59O1xuY29uc3QgaW50T2N0ID0ge1xuICAgIGlkZW50aWZ5OiBpbnRJZGVudGlmeSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gICAgZm9ybWF0OiAnT0NUJyxcbiAgICB0ZXN0OiAvXlstK10/MFswLTdfXSskLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgb3B0KSA9PiBpbnRSZXNvbHZlKHN0ciwgMSwgOCwgb3B0KSxcbiAgICBzdHJpbmdpZnk6IG5vZGUgPT4gaW50U3RyaW5naWZ5KG5vZGUsIDgsICcwJylcbn07XG5jb25zdCBpbnQgPSB7XG4gICAgaWRlbnRpZnk6IGludElkZW50aWZ5LFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICB0ZXN0OiAvXlstK10/WzAtOV1bMC05X10qJC8sXG4gICAgcmVzb2x2ZTogKHN0ciwgX29uRXJyb3IsIG9wdCkgPT4gaW50UmVzb2x2ZShzdHIsIDAsIDEwLCBvcHQpLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5TnVtYmVyLnN0cmluZ2lmeU51bWJlclxufTtcbmNvbnN0IGludEhleCA9IHtcbiAgICBpZGVudGlmeTogaW50SWRlbnRpZnksXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICAgIGZvcm1hdDogJ0hFWCcsXG4gICAgdGVzdDogL15bLStdPzB4WzAtOWEtZkEtRl9dKyQvLFxuICAgIHJlc29sdmU6IChzdHIsIF9vbkVycm9yLCBvcHQpID0+IGludFJlc29sdmUoc3RyLCAyLCAxNiwgb3B0KSxcbiAgICBzdHJpbmdpZnk6IG5vZGUgPT4gaW50U3RyaW5naWZ5KG5vZGUsIDE2LCAnMHgnKVxufTtcblxuZXhwb3J0cy5pbnQgPSBpbnQ7XG5leHBvcnRzLmludEJpbiA9IGludEJpbjtcbmV4cG9ydHMuaW50SGV4ID0gaW50SGV4O1xuZXhwb3J0cy5pbnRPY3QgPSBpbnRPY3Q7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi4vLi4vbm9kZXMvaWRlbnRpdHkuanMnKTtcbnZhciBQYWlyID0gcmVxdWlyZSgnLi4vLi4vbm9kZXMvUGFpci5qcycpO1xudmFyIFlBTUxNYXAgPSByZXF1aXJlKCcuLi8uLi9ub2Rlcy9ZQU1MTWFwLmpzJyk7XG5cbmNsYXNzIFlBTUxTZXQgZXh0ZW5kcyBZQU1MTWFwLllBTUxNYXAge1xuICAgIGNvbnN0cnVjdG9yKHNjaGVtYSkge1xuICAgICAgICBzdXBlcihzY2hlbWEpO1xuICAgICAgICB0aGlzLnRhZyA9IFlBTUxTZXQudGFnO1xuICAgIH1cbiAgICBhZGQoa2V5KSB7XG4gICAgICAgIGxldCBwYWlyO1xuICAgICAgICBpZiAoaWRlbnRpdHkuaXNQYWlyKGtleSkpXG4gICAgICAgICAgICBwYWlyID0ga2V5O1xuICAgICAgICBlbHNlIGlmIChrZXkgJiZcbiAgICAgICAgICAgIHR5cGVvZiBrZXkgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAna2V5JyBpbiBrZXkgJiZcbiAgICAgICAgICAgICd2YWx1ZScgaW4ga2V5ICYmXG4gICAgICAgICAgICBrZXkudmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICBwYWlyID0gbmV3IFBhaXIuUGFpcihrZXkua2V5LCBudWxsKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcGFpciA9IG5ldyBQYWlyLlBhaXIoa2V5LCBudWxsKTtcbiAgICAgICAgY29uc3QgcHJldiA9IFlBTUxNYXAuZmluZFBhaXIodGhpcy5pdGVtcywgcGFpci5rZXkpO1xuICAgICAgICBpZiAoIXByZXYpXG4gICAgICAgICAgICB0aGlzLml0ZW1zLnB1c2gocGFpcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIGBrZWVwUGFpcmAgaXMgYHRydWVgLCByZXR1cm5zIHRoZSBQYWlyIG1hdGNoaW5nIGBrZXlgLlxuICAgICAqIE90aGVyd2lzZSwgcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhhdCBQYWlyJ3Mga2V5LlxuICAgICAqL1xuICAgIGdldChrZXksIGtlZXBQYWlyKSB7XG4gICAgICAgIGNvbnN0IHBhaXIgPSBZQU1MTWFwLmZpbmRQYWlyKHRoaXMuaXRlbXMsIGtleSk7XG4gICAgICAgIHJldHVybiAha2VlcFBhaXIgJiYgaWRlbnRpdHkuaXNQYWlyKHBhaXIpXG4gICAgICAgICAgICA/IGlkZW50aXR5LmlzU2NhbGFyKHBhaXIua2V5KVxuICAgICAgICAgICAgICAgID8gcGFpci5rZXkudmFsdWVcbiAgICAgICAgICAgICAgICA6IHBhaXIua2V5XG4gICAgICAgICAgICA6IHBhaXI7XG4gICAgfVxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiB2YWx1ZSBmb3Igc2V0KGtleSwgdmFsdWUpIGluIGEgWUFNTCBzZXQsIG5vdCAke3R5cGVvZiB2YWx1ZX1gKTtcbiAgICAgICAgY29uc3QgcHJldiA9IFlBTUxNYXAuZmluZFBhaXIodGhpcy5pdGVtcywga2V5KTtcbiAgICAgICAgaWYgKHByZXYgJiYgIXZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zLnNwbGljZSh0aGlzLml0ZW1zLmluZGV4T2YocHJldiksIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFwcmV2ICYmIHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zLnB1c2gobmV3IFBhaXIuUGFpcihrZXkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0pTT04oXywgY3R4KSB7XG4gICAgICAgIHJldHVybiBzdXBlci50b0pTT04oXywgY3R4LCBTZXQpO1xuICAgIH1cbiAgICB0b1N0cmluZyhjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICAgICAgaWYgKCFjdHgpXG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmhhc0FsbE51bGxWYWx1ZXModHJ1ZSkpXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIudG9TdHJpbmcoT2JqZWN0LmFzc2lnbih7fSwgY3R4LCB7IGFsbE51bGxWYWx1ZXM6IHRydWUgfSksIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NldCBpdGVtcyBtdXN0IGFsbCBoYXZlIG51bGwgdmFsdWVzJyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHNjaGVtYSwgaXRlcmFibGUsIGN0eCkge1xuICAgICAgICBjb25zdCB7IHJlcGxhY2VyIH0gPSBjdHg7XG4gICAgICAgIGNvbnN0IHNldCA9IG5ldyB0aGlzKHNjaGVtYSk7XG4gICAgICAgIGlmIChpdGVyYWJsZSAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXJhYmxlKSlcbiAgICAgICAgICAgIGZvciAobGV0IHZhbHVlIG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZXBsYWNlci5jYWxsKGl0ZXJhYmxlLCB2YWx1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHNldC5pdGVtcy5wdXNoKFBhaXIuY3JlYXRlUGFpcih2YWx1ZSwgbnVsbCwgY3R4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxufVxuWUFNTFNldC50YWcgPSAndGFnOnlhbWwub3JnLDIwMDI6c2V0JztcbmNvbnN0IHNldCA9IHtcbiAgICBjb2xsZWN0aW9uOiAnbWFwJyxcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdmFsdWUgaW5zdGFuY2VvZiBTZXQsXG4gICAgbm9kZUNsYXNzOiBZQU1MU2V0LFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOnNldCcsXG4gICAgY3JlYXRlTm9kZTogKHNjaGVtYSwgaXRlcmFibGUsIGN0eCkgPT4gWUFNTFNldC5mcm9tKHNjaGVtYSwgaXRlcmFibGUsIGN0eCksXG4gICAgcmVzb2x2ZShtYXAsIG9uRXJyb3IpIHtcbiAgICAgICAgaWYgKGlkZW50aXR5LmlzTWFwKG1hcCkpIHtcbiAgICAgICAgICAgIGlmIChtYXAuaGFzQWxsTnVsbFZhbHVlcyh0cnVlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgWUFNTFNldCgpLCBtYXApO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG9uRXJyb3IoJ1NldCBpdGVtcyBtdXN0IGFsbCBoYXZlIG51bGwgdmFsdWVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgb25FcnJvcignRXhwZWN0ZWQgYSBtYXBwaW5nIGZvciB0aGlzIHRhZycpO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH1cbn07XG5cbmV4cG9ydHMuWUFNTFNldCA9IFlBTUxTZXQ7XG5leHBvcnRzLnNldCA9IHNldDtcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5TnVtYmVyID0gcmVxdWlyZSgnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeU51bWJlci5qcycpO1xuXG4vKiogSW50ZXJuYWwgdHlwZXMgaGFuZGxlIGJpZ2ludCBhcyBudW1iZXIsIGJlY2F1c2UgVFMgY2FuJ3QgZmlndXJlIGl0IG91dC4gKi9cbmZ1bmN0aW9uIHBhcnNlU2V4YWdlc2ltYWwoc3RyLCBhc0JpZ0ludCkge1xuICAgIGNvbnN0IHNpZ24gPSBzdHJbMF07XG4gICAgY29uc3QgcGFydHMgPSBzaWduID09PSAnLScgfHwgc2lnbiA9PT0gJysnID8gc3RyLnN1YnN0cmluZygxKSA6IHN0cjtcbiAgICBjb25zdCBudW0gPSAobikgPT4gYXNCaWdJbnQgPyBCaWdJbnQobikgOiBOdW1iZXIobik7XG4gICAgY29uc3QgcmVzID0gcGFydHNcbiAgICAgICAgLnJlcGxhY2UoL18vZywgJycpXG4gICAgICAgIC5zcGxpdCgnOicpXG4gICAgICAgIC5yZWR1Y2UoKHJlcywgcCkgPT4gcmVzICogbnVtKDYwKSArIG51bShwKSwgbnVtKDApKTtcbiAgICByZXR1cm4gKHNpZ24gPT09ICctJyA/IG51bSgtMSkgKiByZXMgOiByZXMpO1xufVxuLyoqXG4gKiBoaGhoOm1tOnNzLnNzc1xuICpcbiAqIEludGVybmFsIHR5cGVzIGhhbmRsZSBiaWdpbnQgYXMgbnVtYmVyLCBiZWNhdXNlIFRTIGNhbid0IGZpZ3VyZSBpdCBvdXQuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeVNleGFnZXNpbWFsKG5vZGUpIHtcbiAgICBsZXQgeyB2YWx1ZSB9ID0gbm9kZTtcbiAgICBsZXQgbnVtID0gKG4pID0+IG47XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpXG4gICAgICAgIG51bSA9IG4gPT4gQmlnSW50KG4pO1xuICAgIGVsc2UgaWYgKGlzTmFOKHZhbHVlKSB8fCAhaXNGaW5pdGUodmFsdWUpKVxuICAgICAgICByZXR1cm4gc3RyaW5naWZ5TnVtYmVyLnN0cmluZ2lmeU51bWJlcihub2RlKTtcbiAgICBsZXQgc2lnbiA9ICcnO1xuICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgICAgc2lnbiA9ICctJztcbiAgICAgICAgdmFsdWUgKj0gbnVtKC0xKTtcbiAgICB9XG4gICAgY29uc3QgXzYwID0gbnVtKDYwKTtcbiAgICBjb25zdCBwYXJ0cyA9IFt2YWx1ZSAlIF82MF07IC8vIHNlY29uZHMsIGluY2x1ZGluZyBtc1xuICAgIGlmICh2YWx1ZSA8IDYwKSB7XG4gICAgICAgIHBhcnRzLnVuc2hpZnQoMCk7IC8vIGF0IGxlYXN0IG9uZSA6IGlzIHJlcXVpcmVkXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSAtIHBhcnRzWzBdKSAvIF82MDtcbiAgICAgICAgcGFydHMudW5zaGlmdCh2YWx1ZSAlIF82MCk7IC8vIG1pbnV0ZXNcbiAgICAgICAgaWYgKHZhbHVlID49IDYwKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICh2YWx1ZSAtIHBhcnRzWzBdKSAvIF82MDtcbiAgICAgICAgICAgIHBhcnRzLnVuc2hpZnQodmFsdWUpOyAvLyBob3Vyc1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoc2lnbiArXG4gICAgICAgIHBhcnRzXG4gICAgICAgICAgICAubWFwKG4gPT4gU3RyaW5nKG4pLnBhZFN0YXJ0KDIsICcwJykpXG4gICAgICAgICAgICAuam9pbignOicpXG4gICAgICAgICAgICAucmVwbGFjZSgvMDAwMDAwXFxkKiQvLCAnJykgLy8gJSA2MCBtYXkgaW50cm9kdWNlIGVycm9yXG4gICAgKTtcbn1cbmNvbnN0IGludFRpbWUgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcgfHwgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSksXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICAgIGZvcm1hdDogJ1RJTUUnLFxuICAgIHRlc3Q6IC9eWy0rXT9bMC05XVswLTlfXSooPzo6WzAtNV0/WzAtOV0pKyQvLFxuICAgIHJlc29sdmU6IChzdHIsIF9vbkVycm9yLCB7IGludEFzQmlnSW50IH0pID0+IHBhcnNlU2V4YWdlc2ltYWwoc3RyLCBpbnRBc0JpZ0ludCksXG4gICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlTZXhhZ2VzaW1hbFxufTtcbmNvbnN0IGZsb2F0VGltZSA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgICBmb3JtYXQ6ICdUSU1FJyxcbiAgICB0ZXN0OiAvXlstK10/WzAtOV1bMC05X10qKD86OlswLTVdP1swLTldKStcXC5bMC05X10qJC8sXG4gICAgcmVzb2x2ZTogc3RyID0+IHBhcnNlU2V4YWdlc2ltYWwoc3RyLCBmYWxzZSksXG4gICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlTZXhhZ2VzaW1hbFxufTtcbmNvbnN0IHRpbWVzdGFtcCA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6dGltZXN0YW1wJyxcbiAgICAvLyBJZiB0aGUgdGltZSB6b25lIGlzIG9taXR0ZWQsIHRoZSB0aW1lc3RhbXAgaXMgYXNzdW1lZCB0byBiZSBzcGVjaWZpZWQgaW4gVVRDLiBUaGUgdGltZSBwYXJ0XG4gICAgLy8gbWF5IGJlIG9taXR0ZWQgYWx0b2dldGhlciwgcmVzdWx0aW5nIGluIGEgZGF0ZSBmb3JtYXQuIEluIHN1Y2ggYSBjYXNlLCB0aGUgdGltZSBwYXJ0IGlzXG4gICAgLy8gYXNzdW1lZCB0byBiZSAwMDowMDowMFogKHN0YXJ0IG9mIGRheSwgVVRDKS5cbiAgICB0ZXN0OiBSZWdFeHAoJ14oWzAtOV17NH0pLShbMC05XXsxLDJ9KS0oWzAtOV17MSwyfSknICsgLy8gWVlZWS1NbS1EZFxuICAgICAgICAnKD86JyArIC8vIHRpbWUgaXMgb3B0aW9uYWxcbiAgICAgICAgJyg/OnR8VHxbIFxcXFx0XSspJyArIC8vIHQgfCBUIHwgd2hpdGVzcGFjZVxuICAgICAgICAnKFswLTldezEsMn0pOihbMC05XXsxLDJ9KTooWzAtOV17MSwyfShcXFxcLlswLTldKyk/KScgKyAvLyBIaDpNbTpTcyguc3MpP1xuICAgICAgICAnKD86WyBcXFxcdF0qKFp8Wy0rXVswMTJdP1swLTldKD86OlswLTldezJ9KT8pKT8nICsgLy8gWiB8ICs1IHwgLTAzOjMwXG4gICAgICAgICcpPyQnKSxcbiAgICByZXNvbHZlKHN0cikge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHN0ci5tYXRjaCh0aW1lc3RhbXAudGVzdCk7XG4gICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJyEhdGltZXN0YW1wIGV4cGVjdHMgYSBkYXRlLCBzdGFydGluZyB3aXRoIHl5eXktbW0tZGQnKTtcbiAgICAgICAgY29uc3QgWywgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmRdID0gbWF0Y2gubWFwKE51bWJlcik7XG4gICAgICAgIGNvbnN0IG1pbGxpc2VjID0gbWF0Y2hbN10gPyBOdW1iZXIoKG1hdGNoWzddICsgJzAwJykuc3Vic3RyKDEsIDMpKSA6IDA7XG4gICAgICAgIGxldCBkYXRlID0gRGF0ZS5VVEMoeWVhciwgbW9udGggLSAxLCBkYXksIGhvdXIgfHwgMCwgbWludXRlIHx8IDAsIHNlY29uZCB8fCAwLCBtaWxsaXNlYyk7XG4gICAgICAgIGNvbnN0IHR6ID0gbWF0Y2hbOF07XG4gICAgICAgIGlmICh0eiAmJiB0eiAhPT0gJ1onKSB7XG4gICAgICAgICAgICBsZXQgZCA9IHBhcnNlU2V4YWdlc2ltYWwodHosIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkKSA8IDMwKVxuICAgICAgICAgICAgICAgIGQgKj0gNjA7XG4gICAgICAgICAgICBkYXRlIC09IDYwMDAwICogZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZSk7XG4gICAgfSxcbiAgICBzdHJpbmdpZnk6ICh7IHZhbHVlIH0pID0+IHZhbHVlPy50b0lTT1N0cmluZygpLnJlcGxhY2UoLyhUMDA6MDA6MDApP1xcLjAwMFokLywgJycpID8/ICcnXG59O1xuXG5leHBvcnRzLmZsb2F0VGltZSA9IGZsb2F0VGltZTtcbmV4cG9ydHMuaW50VGltZSA9IGludFRpbWU7XG5leHBvcnRzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWFwID0gcmVxdWlyZSgnLi4vY29tbW9uL21hcC5qcycpO1xudmFyIF9udWxsID0gcmVxdWlyZSgnLi4vY29tbW9uL251bGwuanMnKTtcbnZhciBzZXEgPSByZXF1aXJlKCcuLi9jb21tb24vc2VxLmpzJyk7XG52YXIgc3RyaW5nID0gcmVxdWlyZSgnLi4vY29tbW9uL3N0cmluZy5qcycpO1xudmFyIGJpbmFyeSA9IHJlcXVpcmUoJy4vYmluYXJ5LmpzJyk7XG52YXIgYm9vbCA9IHJlcXVpcmUoJy4vYm9vbC5qcycpO1xudmFyIGZsb2F0ID0gcmVxdWlyZSgnLi9mbG9hdC5qcycpO1xudmFyIGludCA9IHJlcXVpcmUoJy4vaW50LmpzJyk7XG52YXIgbWVyZ2UgPSByZXF1aXJlKCcuL21lcmdlLmpzJyk7XG52YXIgb21hcCA9IHJlcXVpcmUoJy4vb21hcC5qcycpO1xudmFyIHBhaXJzID0gcmVxdWlyZSgnLi9wYWlycy5qcycpO1xudmFyIHNldCA9IHJlcXVpcmUoJy4vc2V0LmpzJyk7XG52YXIgdGltZXN0YW1wID0gcmVxdWlyZSgnLi90aW1lc3RhbXAuanMnKTtcblxuY29uc3Qgc2NoZW1hID0gW1xuICAgIG1hcC5tYXAsXG4gICAgc2VxLnNlcSxcbiAgICBzdHJpbmcuc3RyaW5nLFxuICAgIF9udWxsLm51bGxUYWcsXG4gICAgYm9vbC50cnVlVGFnLFxuICAgIGJvb2wuZmFsc2VUYWcsXG4gICAgaW50LmludEJpbixcbiAgICBpbnQuaW50T2N0LFxuICAgIGludC5pbnQsXG4gICAgaW50LmludEhleCxcbiAgICBmbG9hdC5mbG9hdE5hTixcbiAgICBmbG9hdC5mbG9hdEV4cCxcbiAgICBmbG9hdC5mbG9hdCxcbiAgICBiaW5hcnkuYmluYXJ5LFxuICAgIG1lcmdlLm1lcmdlLFxuICAgIG9tYXAub21hcCxcbiAgICBwYWlycy5wYWlycyxcbiAgICBzZXQuc2V0LFxuICAgIHRpbWVzdGFtcC5pbnRUaW1lLFxuICAgIHRpbWVzdGFtcC5mbG9hdFRpbWUsXG4gICAgdGltZXN0YW1wLnRpbWVzdGFtcFxuXTtcblxuZXhwb3J0cy5zY2hlbWEgPSBzY2hlbWE7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIG1hcCA9IHJlcXVpcmUoJy4vY29tbW9uL21hcC5qcycpO1xudmFyIF9udWxsID0gcmVxdWlyZSgnLi9jb21tb24vbnVsbC5qcycpO1xudmFyIHNlcSA9IHJlcXVpcmUoJy4vY29tbW9uL3NlcS5qcycpO1xudmFyIHN0cmluZyA9IHJlcXVpcmUoJy4vY29tbW9uL3N0cmluZy5qcycpO1xudmFyIGJvb2wgPSByZXF1aXJlKCcuL2NvcmUvYm9vbC5qcycpO1xudmFyIGZsb2F0ID0gcmVxdWlyZSgnLi9jb3JlL2Zsb2F0LmpzJyk7XG52YXIgaW50ID0gcmVxdWlyZSgnLi9jb3JlL2ludC5qcycpO1xudmFyIHNjaGVtYSA9IHJlcXVpcmUoJy4vY29yZS9zY2hlbWEuanMnKTtcbnZhciBzY2hlbWEkMSA9IHJlcXVpcmUoJy4vanNvbi9zY2hlbWEuanMnKTtcbnZhciBiaW5hcnkgPSByZXF1aXJlKCcuL3lhbWwtMS4xL2JpbmFyeS5qcycpO1xudmFyIG1lcmdlID0gcmVxdWlyZSgnLi95YW1sLTEuMS9tZXJnZS5qcycpO1xudmFyIG9tYXAgPSByZXF1aXJlKCcuL3lhbWwtMS4xL29tYXAuanMnKTtcbnZhciBwYWlycyA9IHJlcXVpcmUoJy4veWFtbC0xLjEvcGFpcnMuanMnKTtcbnZhciBzY2hlbWEkMiA9IHJlcXVpcmUoJy4veWFtbC0xLjEvc2NoZW1hLmpzJyk7XG52YXIgc2V0ID0gcmVxdWlyZSgnLi95YW1sLTEuMS9zZXQuanMnKTtcbnZhciB0aW1lc3RhbXAgPSByZXF1aXJlKCcuL3lhbWwtMS4xL3RpbWVzdGFtcC5qcycpO1xuXG5jb25zdCBzY2hlbWFzID0gbmV3IE1hcChbXG4gICAgWydjb3JlJywgc2NoZW1hLnNjaGVtYV0sXG4gICAgWydmYWlsc2FmZScsIFttYXAubWFwLCBzZXEuc2VxLCBzdHJpbmcuc3RyaW5nXV0sXG4gICAgWydqc29uJywgc2NoZW1hJDEuc2NoZW1hXSxcbiAgICBbJ3lhbWwxMScsIHNjaGVtYSQyLnNjaGVtYV0sXG4gICAgWyd5YW1sLTEuMScsIHNjaGVtYSQyLnNjaGVtYV1cbl0pO1xuY29uc3QgdGFnc0J5TmFtZSA9IHtcbiAgICBiaW5hcnk6IGJpbmFyeS5iaW5hcnksXG4gICAgYm9vbDogYm9vbC5ib29sVGFnLFxuICAgIGZsb2F0OiBmbG9hdC5mbG9hdCxcbiAgICBmbG9hdEV4cDogZmxvYXQuZmxvYXRFeHAsXG4gICAgZmxvYXROYU46IGZsb2F0LmZsb2F0TmFOLFxuICAgIGZsb2F0VGltZTogdGltZXN0YW1wLmZsb2F0VGltZSxcbiAgICBpbnQ6IGludC5pbnQsXG4gICAgaW50SGV4OiBpbnQuaW50SGV4LFxuICAgIGludE9jdDogaW50LmludE9jdCxcbiAgICBpbnRUaW1lOiB0aW1lc3RhbXAuaW50VGltZSxcbiAgICBtYXA6IG1hcC5tYXAsXG4gICAgbWVyZ2U6IG1lcmdlLm1lcmdlLFxuICAgIG51bGw6IF9udWxsLm51bGxUYWcsXG4gICAgb21hcDogb21hcC5vbWFwLFxuICAgIHBhaXJzOiBwYWlycy5wYWlycyxcbiAgICBzZXE6IHNlcS5zZXEsXG4gICAgc2V0OiBzZXQuc2V0LFxuICAgIHRpbWVzdGFtcDogdGltZXN0YW1wLnRpbWVzdGFtcFxufTtcbmNvbnN0IGNvcmVLbm93blRhZ3MgPSB7XG4gICAgJ3RhZzp5YW1sLm9yZywyMDAyOmJpbmFyeSc6IGJpbmFyeS5iaW5hcnksXG4gICAgJ3RhZzp5YW1sLm9yZywyMDAyOm1lcmdlJzogbWVyZ2UubWVyZ2UsXG4gICAgJ3RhZzp5YW1sLm9yZywyMDAyOm9tYXAnOiBvbWFwLm9tYXAsXG4gICAgJ3RhZzp5YW1sLm9yZywyMDAyOnBhaXJzJzogcGFpcnMucGFpcnMsXG4gICAgJ3RhZzp5YW1sLm9yZywyMDAyOnNldCc6IHNldC5zZXQsXG4gICAgJ3RhZzp5YW1sLm9yZywyMDAyOnRpbWVzdGFtcCc6IHRpbWVzdGFtcC50aW1lc3RhbXBcbn07XG5mdW5jdGlvbiBnZXRUYWdzKGN1c3RvbVRhZ3MsIHNjaGVtYU5hbWUsIGFkZE1lcmdlVGFnKSB7XG4gICAgY29uc3Qgc2NoZW1hVGFncyA9IHNjaGVtYXMuZ2V0KHNjaGVtYU5hbWUpO1xuICAgIGlmIChzY2hlbWFUYWdzICYmICFjdXN0b21UYWdzKSB7XG4gICAgICAgIHJldHVybiBhZGRNZXJnZVRhZyAmJiAhc2NoZW1hVGFncy5pbmNsdWRlcyhtZXJnZS5tZXJnZSlcbiAgICAgICAgICAgID8gc2NoZW1hVGFncy5jb25jYXQobWVyZ2UubWVyZ2UpXG4gICAgICAgICAgICA6IHNjaGVtYVRhZ3Muc2xpY2UoKTtcbiAgICB9XG4gICAgbGV0IHRhZ3MgPSBzY2hlbWFUYWdzO1xuICAgIGlmICghdGFncykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXN0b21UYWdzKSlcbiAgICAgICAgICAgIHRhZ3MgPSBbXTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gQXJyYXkuZnJvbShzY2hlbWFzLmtleXMoKSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGtleSA9PiBrZXkgIT09ICd5YW1sMTEnKVxuICAgICAgICAgICAgICAgIC5tYXAoa2V5ID0+IEpTT04uc3RyaW5naWZ5KGtleSkpXG4gICAgICAgICAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc2NoZW1hIFwiJHtzY2hlbWFOYW1lfVwiOyB1c2Ugb25lIG9mICR7a2V5c30gb3IgZGVmaW5lIGN1c3RvbVRhZ3MgYXJyYXlgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjdXN0b21UYWdzKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHRhZyBvZiBjdXN0b21UYWdzKVxuICAgICAgICAgICAgdGFncyA9IHRhZ3MuY29uY2F0KHRhZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBjdXN0b21UYWdzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRhZ3MgPSBjdXN0b21UYWdzKHRhZ3Muc2xpY2UoKSk7XG4gICAgfVxuICAgIGlmIChhZGRNZXJnZVRhZylcbiAgICAgICAgdGFncyA9IHRhZ3MuY29uY2F0KG1lcmdlLm1lcmdlKTtcbiAgICByZXR1cm4gdGFncy5yZWR1Y2UoKHRhZ3MsIHRhZykgPT4ge1xuICAgICAgICBjb25zdCB0YWdPYmogPSB0eXBlb2YgdGFnID09PSAnc3RyaW5nJyA/IHRhZ3NCeU5hbWVbdGFnXSA6IHRhZztcbiAgICAgICAgaWYgKCF0YWdPYmopIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZ05hbWUgPSBKU09OLnN0cmluZ2lmeSh0YWcpO1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRhZ3NCeU5hbWUpXG4gICAgICAgICAgICAgICAgLm1hcChrZXkgPT4gSlNPTi5zdHJpbmdpZnkoa2V5KSlcbiAgICAgICAgICAgICAgICAuam9pbignLCAnKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBjdXN0b20gdGFnICR7dGFnTmFtZX07IHVzZSBvbmUgb2YgJHtrZXlzfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGFncy5pbmNsdWRlcyh0YWdPYmopKVxuICAgICAgICAgICAgdGFncy5wdXNoKHRhZ09iaik7XG4gICAgICAgIHJldHVybiB0YWdzO1xuICAgIH0sIFtdKTtcbn1cblxuZXhwb3J0cy5jb3JlS25vd25UYWdzID0gY29yZUtub3duVGFncztcbmV4cG9ydHMuZ2V0VGFncyA9IGdldFRhZ3M7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi4vbm9kZXMvaWRlbnRpdHkuanMnKTtcbnZhciBtYXAgPSByZXF1aXJlKCcuL2NvbW1vbi9tYXAuanMnKTtcbnZhciBzZXEgPSByZXF1aXJlKCcuL2NvbW1vbi9zZXEuanMnKTtcbnZhciBzdHJpbmcgPSByZXF1aXJlKCcuL2NvbW1vbi9zdHJpbmcuanMnKTtcbnZhciB0YWdzID0gcmVxdWlyZSgnLi90YWdzLmpzJyk7XG5cbmNvbnN0IHNvcnRNYXBFbnRyaWVzQnlLZXkgPSAoYSwgYikgPT4gYS5rZXkgPCBiLmtleSA/IC0xIDogYS5rZXkgPiBiLmtleSA/IDEgOiAwO1xuY2xhc3MgU2NoZW1hIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGNvbXBhdCwgY3VzdG9tVGFncywgbWVyZ2UsIHJlc29sdmVLbm93blRhZ3MsIHNjaGVtYSwgc29ydE1hcEVudHJpZXMsIHRvU3RyaW5nRGVmYXVsdHMgfSkge1xuICAgICAgICB0aGlzLmNvbXBhdCA9IEFycmF5LmlzQXJyYXkoY29tcGF0KVxuICAgICAgICAgICAgPyB0YWdzLmdldFRhZ3MoY29tcGF0LCAnY29tcGF0JylcbiAgICAgICAgICAgIDogY29tcGF0XG4gICAgICAgICAgICAgICAgPyB0YWdzLmdldFRhZ3MobnVsbCwgY29tcGF0KVxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgdGhpcy5uYW1lID0gKHR5cGVvZiBzY2hlbWEgPT09ICdzdHJpbmcnICYmIHNjaGVtYSkgfHwgJ2NvcmUnO1xuICAgICAgICB0aGlzLmtub3duVGFncyA9IHJlc29sdmVLbm93blRhZ3MgPyB0YWdzLmNvcmVLbm93blRhZ3MgOiB7fTtcbiAgICAgICAgdGhpcy50YWdzID0gdGFncy5nZXRUYWdzKGN1c3RvbVRhZ3MsIHRoaXMubmFtZSwgbWVyZ2UpO1xuICAgICAgICB0aGlzLnRvU3RyaW5nT3B0aW9ucyA9IHRvU3RyaW5nRGVmYXVsdHMgPz8gbnVsbDtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGlkZW50aXR5Lk1BUCwgeyB2YWx1ZTogbWFwLm1hcCB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGlkZW50aXR5LlNDQUxBUiwgeyB2YWx1ZTogc3RyaW5nLnN0cmluZyB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGlkZW50aXR5LlNFUSwgeyB2YWx1ZTogc2VxLnNlcSB9KTtcbiAgICAgICAgLy8gVXNlZCBieSBjcmVhdGVNYXAoKVxuICAgICAgICB0aGlzLnNvcnRNYXBFbnRyaWVzID1cbiAgICAgICAgICAgIHR5cGVvZiBzb3J0TWFwRW50cmllcyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgID8gc29ydE1hcEVudHJpZXNcbiAgICAgICAgICAgICAgICA6IHNvcnRNYXBFbnRyaWVzID09PSB0cnVlXG4gICAgICAgICAgICAgICAgICAgID8gc29ydE1hcEVudHJpZXNCeUtleVxuICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmNyZWF0ZShTY2hlbWEucHJvdG90eXBlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0aGlzKSk7XG4gICAgICAgIGNvcHkudGFncyA9IHRoaXMudGFncy5zbGljZSgpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG59XG5cbmV4cG9ydHMuU2NoZW1hID0gU2NoZW1hO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4uL25vZGVzL2lkZW50aXR5LmpzJyk7XG52YXIgc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9zdHJpbmdpZnkuanMnKTtcbnZhciBzdHJpbmdpZnlDb21tZW50ID0gcmVxdWlyZSgnLi9zdHJpbmdpZnlDb21tZW50LmpzJyk7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeURvY3VtZW50KGRvYywgb3B0aW9ucykge1xuICAgIGNvbnN0IGxpbmVzID0gW107XG4gICAgbGV0IGhhc0RpcmVjdGl2ZXMgPSBvcHRpb25zLmRpcmVjdGl2ZXMgPT09IHRydWU7XG4gICAgaWYgKG9wdGlvbnMuZGlyZWN0aXZlcyAhPT0gZmFsc2UgJiYgZG9jLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgY29uc3QgZGlyID0gZG9jLmRpcmVjdGl2ZXMudG9TdHJpbmcoZG9jKTtcbiAgICAgICAgaWYgKGRpcikge1xuICAgICAgICAgICAgbGluZXMucHVzaChkaXIpO1xuICAgICAgICAgICAgaGFzRGlyZWN0aXZlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZG9jLmRpcmVjdGl2ZXMuZG9jU3RhcnQpXG4gICAgICAgICAgICBoYXNEaXJlY3RpdmVzID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGhhc0RpcmVjdGl2ZXMpXG4gICAgICAgIGxpbmVzLnB1c2goJy0tLScpO1xuICAgIGNvbnN0IGN0eCA9IHN0cmluZ2lmeS5jcmVhdGVTdHJpbmdpZnlDb250ZXh0KGRvYywgb3B0aW9ucyk7XG4gICAgY29uc3QgeyBjb21tZW50U3RyaW5nIH0gPSBjdHgub3B0aW9ucztcbiAgICBpZiAoZG9jLmNvbW1lbnRCZWZvcmUpIHtcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCAhPT0gMSlcbiAgICAgICAgICAgIGxpbmVzLnVuc2hpZnQoJycpO1xuICAgICAgICBjb25zdCBjcyA9IGNvbW1lbnRTdHJpbmcoZG9jLmNvbW1lbnRCZWZvcmUpO1xuICAgICAgICBsaW5lcy51bnNoaWZ0KHN0cmluZ2lmeUNvbW1lbnQuaW5kZW50Q29tbWVudChjcywgJycpKTtcbiAgICB9XG4gICAgbGV0IGNob21wS2VlcCA9IGZhbHNlO1xuICAgIGxldCBjb250ZW50Q29tbWVudCA9IG51bGw7XG4gICAgaWYgKGRvYy5jb250ZW50cykge1xuICAgICAgICBpZiAoaWRlbnRpdHkuaXNOb2RlKGRvYy5jb250ZW50cykpIHtcbiAgICAgICAgICAgIGlmIChkb2MuY29udGVudHMuc3BhY2VCZWZvcmUgJiYgaGFzRGlyZWN0aXZlcylcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICAgICAgICAgIGlmIChkb2MuY29udGVudHMuY29tbWVudEJlZm9yZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNzID0gY29tbWVudFN0cmluZyhkb2MuY29udGVudHMuY29tbWVudEJlZm9yZSk7XG4gICAgICAgICAgICAgICAgbGluZXMucHVzaChzdHJpbmdpZnlDb21tZW50LmluZGVudENvbW1lbnQoY3MsICcnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0b3AtbGV2ZWwgYmxvY2sgc2NhbGFycyBuZWVkIHRvIGJlIGluZGVudGVkIGlmIGZvbGxvd2VkIGJ5IGEgY29tbWVudFxuICAgICAgICAgICAgY3R4LmZvcmNlQmxvY2tJbmRlbnQgPSAhIWRvYy5jb21tZW50O1xuICAgICAgICAgICAgY29udGVudENvbW1lbnQgPSBkb2MuY29udGVudHMuY29tbWVudDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbkNob21wS2VlcCA9IGNvbnRlbnRDb21tZW50ID8gdW5kZWZpbmVkIDogKCkgPT4gKGNob21wS2VlcCA9IHRydWUpO1xuICAgICAgICBsZXQgYm9keSA9IHN0cmluZ2lmeS5zdHJpbmdpZnkoZG9jLmNvbnRlbnRzLCBjdHgsICgpID0+IChjb250ZW50Q29tbWVudCA9IG51bGwpLCBvbkNob21wS2VlcCk7XG4gICAgICAgIGlmIChjb250ZW50Q29tbWVudClcbiAgICAgICAgICAgIGJvZHkgKz0gc3RyaW5naWZ5Q29tbWVudC5saW5lQ29tbWVudChib2R5LCAnJywgY29tbWVudFN0cmluZyhjb250ZW50Q29tbWVudCkpO1xuICAgICAgICBpZiAoKGJvZHlbMF0gPT09ICd8JyB8fCBib2R5WzBdID09PSAnPicpICYmXG4gICAgICAgICAgICBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSA9PT0gJy0tLScpIHtcbiAgICAgICAgICAgIC8vIFRvcC1sZXZlbCBibG9jayBzY2FsYXJzIHdpdGggYSBwcmVjZWRpbmcgZG9jIG1hcmtlciBvdWdodCB0byB1c2UgdGhlXG4gICAgICAgICAgICAvLyBzYW1lIGxpbmUgZm9yIHRoZWlyIGhlYWRlci5cbiAgICAgICAgICAgIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdID0gYC0tLSAke2JvZHl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBsaW5lcy5wdXNoKGJvZHkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGluZXMucHVzaChzdHJpbmdpZnkuc3RyaW5naWZ5KGRvYy5jb250ZW50cywgY3R4KSk7XG4gICAgfVxuICAgIGlmIChkb2MuZGlyZWN0aXZlcz8uZG9jRW5kKSB7XG4gICAgICAgIGlmIChkb2MuY29tbWVudCkge1xuICAgICAgICAgICAgY29uc3QgY3MgPSBjb21tZW50U3RyaW5nKGRvYy5jb21tZW50KTtcbiAgICAgICAgICAgIGlmIChjcy5pbmNsdWRlcygnXFxuJykpIHtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKCcuLi4nKTtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKHN0cmluZ2lmeUNvbW1lbnQuaW5kZW50Q29tbWVudChjcywgJycpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goYC4uLiAke2NzfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGluZXMucHVzaCgnLi4uJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBkYyA9IGRvYy5jb21tZW50O1xuICAgICAgICBpZiAoZGMgJiYgY2hvbXBLZWVwKVxuICAgICAgICAgICAgZGMgPSBkYy5yZXBsYWNlKC9eXFxuKy8sICcnKTtcbiAgICAgICAgaWYgKGRjKSB7XG4gICAgICAgICAgICBpZiAoKCFjaG9tcEtlZXAgfHwgY29udGVudENvbW1lbnQpICYmIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdICE9PSAnJylcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICAgICAgICAgIGxpbmVzLnB1c2goc3RyaW5naWZ5Q29tbWVudC5pbmRlbnRDb21tZW50KGNvbW1lbnRTdHJpbmcoZGMpLCAnJykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsaW5lcy5qb2luKCdcXG4nKSArICdcXG4nO1xufVxuXG5leHBvcnRzLnN0cmluZ2lmeURvY3VtZW50ID0gc3RyaW5naWZ5RG9jdW1lbnQ7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIEFsaWFzID0gcmVxdWlyZSgnLi4vbm9kZXMvQWxpYXMuanMnKTtcbnZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vbm9kZXMvQ29sbGVjdGlvbi5qcycpO1xudmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi4vbm9kZXMvaWRlbnRpdHkuanMnKTtcbnZhciBQYWlyID0gcmVxdWlyZSgnLi4vbm9kZXMvUGFpci5qcycpO1xudmFyIHRvSlMgPSByZXF1aXJlKCcuLi9ub2Rlcy90b0pTLmpzJyk7XG52YXIgU2NoZW1hID0gcmVxdWlyZSgnLi4vc2NoZW1hL1NjaGVtYS5qcycpO1xudmFyIHN0cmluZ2lmeURvY3VtZW50ID0gcmVxdWlyZSgnLi4vc3RyaW5naWZ5L3N0cmluZ2lmeURvY3VtZW50LmpzJyk7XG52YXIgYW5jaG9ycyA9IHJlcXVpcmUoJy4vYW5jaG9ycy5qcycpO1xudmFyIGFwcGx5UmV2aXZlciA9IHJlcXVpcmUoJy4vYXBwbHlSZXZpdmVyLmpzJyk7XG52YXIgY3JlYXRlTm9kZSA9IHJlcXVpcmUoJy4vY3JlYXRlTm9kZS5qcycpO1xudmFyIGRpcmVjdGl2ZXMgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMuanMnKTtcblxuY2xhc3MgRG9jdW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCByZXBsYWNlciwgb3B0aW9ucykge1xuICAgICAgICAvKiogQSBjb21tZW50IGJlZm9yZSB0aGlzIERvY3VtZW50ICovXG4gICAgICAgIHRoaXMuY29tbWVudEJlZm9yZSA9IG51bGw7XG4gICAgICAgIC8qKiBBIGNvbW1lbnQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhpcyBEb2N1bWVudCAqL1xuICAgICAgICB0aGlzLmNvbW1lbnQgPSBudWxsO1xuICAgICAgICAvKiogRXJyb3JzIGVuY291bnRlcmVkIGR1cmluZyBwYXJzaW5nLiAqL1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICAvKiogV2FybmluZ3MgZW5jb3VudGVyZWQgZHVyaW5nIHBhcnNpbmcuICovXG4gICAgICAgIHRoaXMud2FybmluZ3MgPSBbXTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGlkZW50aXR5Lk5PREVfVFlQRSwgeyB2YWx1ZTogaWRlbnRpdHkuRE9DIH0pO1xuICAgICAgICBsZXQgX3JlcGxhY2VyID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJyB8fCBBcnJheS5pc0FycmF5KHJlcGxhY2VyKSkge1xuICAgICAgICAgICAgX3JlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkICYmIHJlcGxhY2VyKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gcmVwbGFjZXI7XG4gICAgICAgICAgICByZXBsYWNlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHQgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGludEFzQmlnSW50OiBmYWxzZSxcbiAgICAgICAgICAgIGtlZXBTb3VyY2VUb2tlbnM6IGZhbHNlLFxuICAgICAgICAgICAgbG9nTGV2ZWw6ICd3YXJuJyxcbiAgICAgICAgICAgIHByZXR0eUVycm9yczogdHJ1ZSxcbiAgICAgICAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgICAgICAgIHN0cmluZ0tleXM6IGZhbHNlLFxuICAgICAgICAgICAgdW5pcXVlS2V5czogdHJ1ZSxcbiAgICAgICAgICAgIHZlcnNpb246ICcxLjInXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHQ7XG4gICAgICAgIGxldCB7IHZlcnNpb24gfSA9IG9wdDtcbiAgICAgICAgaWYgKG9wdGlvbnM/Ll9kaXJlY3RpdmVzKSB7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBvcHRpb25zLl9kaXJlY3RpdmVzLmF0RG9jdW1lbnQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpcmVjdGl2ZXMueWFtbC5leHBsaWNpdClcbiAgICAgICAgICAgICAgICB2ZXJzaW9uID0gdGhpcy5kaXJlY3RpdmVzLnlhbWwudmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBuZXcgZGlyZWN0aXZlcy5EaXJlY3RpdmVzKHsgdmVyc2lvbiB9KTtcbiAgICAgICAgdGhpcy5zZXRTY2hlbWEodmVyc2lvbiwgb3B0aW9ucyk7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgV2UgY2FuJ3QgcmVhbGx5IGtub3cgdGhhdCB0aGlzIG1hdGNoZXMgQ29udGVudHMuXG4gICAgICAgIHRoaXMuY29udGVudHMgPVxuICAgICAgICAgICAgdmFsdWUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiB0aGlzLmNyZWF0ZU5vZGUodmFsdWUsIF9yZXBsYWNlciwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGRlZXAgY29weSBvZiB0aGlzIERvY3VtZW50IGFuZCBpdHMgY29udGVudHMuXG4gICAgICpcbiAgICAgKiBDdXN0b20gTm9kZSB2YWx1ZXMgdGhhdCBpbmhlcml0IGZyb20gYE9iamVjdGAgc3RpbGwgcmVmZXIgdG8gdGhlaXIgb3JpZ2luYWwgaW5zdGFuY2VzLlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmNyZWF0ZShEb2N1bWVudC5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgIFtpZGVudGl0eS5OT0RFX1RZUEVdOiB7IHZhbHVlOiBpZGVudGl0eS5ET0MgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29weS5jb21tZW50QmVmb3JlID0gdGhpcy5jb21tZW50QmVmb3JlO1xuICAgICAgICBjb3B5LmNvbW1lbnQgPSB0aGlzLmNvbW1lbnQ7XG4gICAgICAgIGNvcHkuZXJyb3JzID0gdGhpcy5lcnJvcnMuc2xpY2UoKTtcbiAgICAgICAgY29weS53YXJuaW5ncyA9IHRoaXMud2FybmluZ3Muc2xpY2UoKTtcbiAgICAgICAgY29weS5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMuZGlyZWN0aXZlcylcbiAgICAgICAgICAgIGNvcHkuZGlyZWN0aXZlcyA9IHRoaXMuZGlyZWN0aXZlcy5jbG9uZSgpO1xuICAgICAgICBjb3B5LnNjaGVtYSA9IHRoaXMuc2NoZW1hLmNsb25lKCk7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgV2UgY2FuJ3QgcmVhbGx5IGtub3cgdGhhdCB0aGlzIG1hdGNoZXMgQ29udGVudHMuXG4gICAgICAgIGNvcHkuY29udGVudHMgPSBpZGVudGl0eS5pc05vZGUodGhpcy5jb250ZW50cylcbiAgICAgICAgICAgID8gdGhpcy5jb250ZW50cy5jbG9uZShjb3B5LnNjaGVtYSlcbiAgICAgICAgICAgIDogdGhpcy5jb250ZW50cztcbiAgICAgICAgaWYgKHRoaXMucmFuZ2UpXG4gICAgICAgICAgICBjb3B5LnJhbmdlID0gdGhpcy5yYW5nZS5zbGljZSgpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLyoqIEFkZHMgYSB2YWx1ZSB0byB0aGUgZG9jdW1lbnQuICovXG4gICAgYWRkKHZhbHVlKSB7XG4gICAgICAgIGlmIChhc3NlcnRDb2xsZWN0aW9uKHRoaXMuY29udGVudHMpKVxuICAgICAgICAgICAgdGhpcy5jb250ZW50cy5hZGQodmFsdWUpO1xuICAgIH1cbiAgICAvKiogQWRkcyBhIHZhbHVlIHRvIHRoZSBkb2N1bWVudC4gKi9cbiAgICBhZGRJbihwYXRoLCB2YWx1ZSkge1xuICAgICAgICBpZiAoYXNzZXJ0Q29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKSlcbiAgICAgICAgICAgIHRoaXMuY29udGVudHMuYWRkSW4ocGF0aCwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgYEFsaWFzYCBub2RlLCBlbnN1cmluZyB0aGF0IHRoZSB0YXJnZXQgYG5vZGVgIGhhcyB0aGUgcmVxdWlyZWQgYW5jaG9yLlxuICAgICAqXG4gICAgICogSWYgYG5vZGVgIGFscmVhZHkgaGFzIGFuIGFuY2hvciwgYG5hbWVgIGlzIGlnbm9yZWQuXG4gICAgICogT3RoZXJ3aXNlLCB0aGUgYG5vZGUuYW5jaG9yYCB2YWx1ZSB3aWxsIGJlIHNldCB0byBgbmFtZWAsXG4gICAgICogb3IgaWYgYW4gYW5jaG9yIHdpdGggdGhhdCBuYW1lIGlzIGFscmVhZHkgcHJlc2VudCBpbiB0aGUgZG9jdW1lbnQsXG4gICAgICogYG5hbWVgIHdpbGwgYmUgdXNlZCBhcyBhIHByZWZpeCBmb3IgYSBuZXcgdW5pcXVlIGFuY2hvci5cbiAgICAgKiBJZiBgbmFtZWAgaXMgdW5kZWZpbmVkLCB0aGUgZ2VuZXJhdGVkIGFuY2hvciB3aWxsIHVzZSAnYScgYXMgYSBwcmVmaXguXG4gICAgICovXG4gICAgY3JlYXRlQWxpYXMobm9kZSwgbmFtZSkge1xuICAgICAgICBpZiAoIW5vZGUuYW5jaG9yKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gYW5jaG9ycy5hbmNob3JOYW1lcyh0aGlzKTtcbiAgICAgICAgICAgIG5vZGUuYW5jaG9yID1cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1udWxsaXNoLWNvYWxlc2NpbmdcbiAgICAgICAgICAgICAgICAhbmFtZSB8fCBwcmV2LmhhcyhuYW1lKSA/IGFuY2hvcnMuZmluZE5ld0FuY2hvcihuYW1lIHx8ICdhJywgcHJldikgOiBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQWxpYXMuQWxpYXMobm9kZS5hbmNob3IpO1xuICAgIH1cbiAgICBjcmVhdGVOb2RlKHZhbHVlLCByZXBsYWNlciwgb3B0aW9ucykge1xuICAgICAgICBsZXQgX3JlcGxhY2VyID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodHlwZW9mIHJlcGxhY2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHJlcGxhY2VyLmNhbGwoeyAnJzogdmFsdWUgfSwgJycsIHZhbHVlKTtcbiAgICAgICAgICAgIF9yZXBsYWNlciA9IHJlcGxhY2VyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVwbGFjZXIpKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlUb1N0ciA9ICh2KSA9PiB0eXBlb2YgdiA9PT0gJ251bWJlcicgfHwgdiBpbnN0YW5jZW9mIFN0cmluZyB8fCB2IGluc3RhbmNlb2YgTnVtYmVyO1xuICAgICAgICAgICAgY29uc3QgYXNTdHIgPSByZXBsYWNlci5maWx0ZXIoa2V5VG9TdHIpLm1hcChTdHJpbmcpO1xuICAgICAgICAgICAgaWYgKGFzU3RyLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgcmVwbGFjZXIgPSByZXBsYWNlci5jb25jYXQoYXNTdHIpO1xuICAgICAgICAgICAgX3JlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkICYmIHJlcGxhY2VyKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gcmVwbGFjZXI7XG4gICAgICAgICAgICByZXBsYWNlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGFsaWFzRHVwbGljYXRlT2JqZWN0cywgYW5jaG9yUHJlZml4LCBmbG93LCBrZWVwVW5kZWZpbmVkLCBvblRhZ09iaiwgdGFnIH0gPSBvcHRpb25zID8/IHt9O1xuICAgICAgICBjb25zdCB7IG9uQW5jaG9yLCBzZXRBbmNob3JzLCBzb3VyY2VPYmplY3RzIH0gPSBhbmNob3JzLmNyZWF0ZU5vZGVBbmNob3JzKHRoaXMsIFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1udWxsaXNoLWNvYWxlc2NpbmdcbiAgICAgICAgYW5jaG9yUHJlZml4IHx8ICdhJyk7XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIGFsaWFzRHVwbGljYXRlT2JqZWN0czogYWxpYXNEdXBsaWNhdGVPYmplY3RzID8/IHRydWUsXG4gICAgICAgICAgICBrZWVwVW5kZWZpbmVkOiBrZWVwVW5kZWZpbmVkID8/IGZhbHNlLFxuICAgICAgICAgICAgb25BbmNob3IsXG4gICAgICAgICAgICBvblRhZ09iaixcbiAgICAgICAgICAgIHJlcGxhY2VyOiBfcmVwbGFjZXIsXG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgICAgICAgc291cmNlT2JqZWN0c1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBub2RlID0gY3JlYXRlTm9kZS5jcmVhdGVOb2RlKHZhbHVlLCB0YWcsIGN0eCk7XG4gICAgICAgIGlmIChmbG93ICYmIGlkZW50aXR5LmlzQ29sbGVjdGlvbihub2RlKSlcbiAgICAgICAgICAgIG5vZGUuZmxvdyA9IHRydWU7XG4gICAgICAgIHNldEFuY2hvcnMoKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBrZXkgYW5kIGEgdmFsdWUgaW50byBhIGBQYWlyYCB1c2luZyB0aGUgY3VycmVudCBzY2hlbWEsXG4gICAgICogcmVjdXJzaXZlbHkgd3JhcHBpbmcgYWxsIHZhbHVlcyBhcyBgU2NhbGFyYCBvciBgQ29sbGVjdGlvbmAgbm9kZXMuXG4gICAgICovXG4gICAgY3JlYXRlUGFpcihrZXksIHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgayA9IHRoaXMuY3JlYXRlTm9kZShrZXksIG51bGwsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB2ID0gdGhpcy5jcmVhdGVOb2RlKHZhbHVlLCBudWxsLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQYWlyLlBhaXIoaywgdik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSB2YWx1ZSBmcm9tIHRoZSBkb2N1bWVudC5cbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGl0ZW0gd2FzIGZvdW5kIGFuZCByZW1vdmVkLlxuICAgICAqL1xuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgcmV0dXJuIGFzc2VydENvbGxlY3Rpb24odGhpcy5jb250ZW50cykgPyB0aGlzLmNvbnRlbnRzLmRlbGV0ZShrZXkpIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSB2YWx1ZSBmcm9tIHRoZSBkb2N1bWVudC5cbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGl0ZW0gd2FzIGZvdW5kIGFuZCByZW1vdmVkLlxuICAgICAqL1xuICAgIGRlbGV0ZUluKHBhdGgpIHtcbiAgICAgICAgaWYgKENvbGxlY3Rpb24uaXNFbXB0eVBhdGgocGF0aCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnRzID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBQcmVzdW1lZCBpbXBvc3NpYmxlIGlmIFN0cmljdCBleHRlbmRzIGZhbHNlXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRzID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3NlcnRDb2xsZWN0aW9uKHRoaXMuY29udGVudHMpXG4gICAgICAgICAgICA/IHRoaXMuY29udGVudHMuZGVsZXRlSW4ocGF0aClcbiAgICAgICAgICAgIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaXRlbSBhdCBga2V5YCwgb3IgYHVuZGVmaW5lZGAgaWYgbm90IGZvdW5kLiBCeSBkZWZhdWx0IHVud3JhcHNcbiAgICAgKiBzY2FsYXIgdmFsdWVzIGZyb20gdGhlaXIgc3Vycm91bmRpbmcgbm9kZTsgdG8gZGlzYWJsZSBzZXQgYGtlZXBTY2FsYXJgIHRvXG4gICAgICogYHRydWVgIChjb2xsZWN0aW9ucyBhcmUgYWx3YXlzIHJldHVybmVkIGludGFjdCkuXG4gICAgICovXG4gICAgZ2V0KGtleSwga2VlcFNjYWxhcikge1xuICAgICAgICByZXR1cm4gaWRlbnRpdHkuaXNDb2xsZWN0aW9uKHRoaXMuY29udGVudHMpXG4gICAgICAgICAgICA/IHRoaXMuY29udGVudHMuZ2V0KGtleSwga2VlcFNjYWxhcilcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGl0ZW0gYXQgYHBhdGhgLCBvciBgdW5kZWZpbmVkYCBpZiBub3QgZm91bmQuIEJ5IGRlZmF1bHQgdW53cmFwc1xuICAgICAqIHNjYWxhciB2YWx1ZXMgZnJvbSB0aGVpciBzdXJyb3VuZGluZyBub2RlOyB0byBkaXNhYmxlIHNldCBga2VlcFNjYWxhcmAgdG9cbiAgICAgKiBgdHJ1ZWAgKGNvbGxlY3Rpb25zIGFyZSBhbHdheXMgcmV0dXJuZWQgaW50YWN0KS5cbiAgICAgKi9cbiAgICBnZXRJbihwYXRoLCBrZWVwU2NhbGFyKSB7XG4gICAgICAgIGlmIChDb2xsZWN0aW9uLmlzRW1wdHlQYXRoKHBhdGgpKVxuICAgICAgICAgICAgcmV0dXJuICFrZWVwU2NhbGFyICYmIGlkZW50aXR5LmlzU2NhbGFyKHRoaXMuY29udGVudHMpXG4gICAgICAgICAgICAgICAgPyB0aGlzLmNvbnRlbnRzLnZhbHVlXG4gICAgICAgICAgICAgICAgOiB0aGlzLmNvbnRlbnRzO1xuICAgICAgICByZXR1cm4gaWRlbnRpdHkuaXNDb2xsZWN0aW9uKHRoaXMuY29udGVudHMpXG4gICAgICAgICAgICA/IHRoaXMuY29udGVudHMuZ2V0SW4ocGF0aCwga2VlcFNjYWxhcilcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGRvY3VtZW50IGluY2x1ZGVzIGEgdmFsdWUgd2l0aCB0aGUga2V5IGBrZXlgLlxuICAgICAqL1xuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5LmlzQ29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKSA/IHRoaXMuY29udGVudHMuaGFzKGtleSkgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBkb2N1bWVudCBpbmNsdWRlcyBhIHZhbHVlIGF0IGBwYXRoYC5cbiAgICAgKi9cbiAgICBoYXNJbihwYXRoKSB7XG4gICAgICAgIGlmIChDb2xsZWN0aW9uLmlzRW1wdHlQYXRoKHBhdGgpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudHMgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5LmlzQ29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKSA/IHRoaXMuY29udGVudHMuaGFzSW4ocGF0aCkgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIHZhbHVlIGluIHRoaXMgZG9jdW1lbnQuIEZvciBgISFzZXRgLCBgdmFsdWVgIG5lZWRzIHRvIGJlIGFcbiAgICAgKiBib29sZWFuIHRvIGFkZC9yZW1vdmUgdGhlIGl0ZW0gZnJvbSB0aGUgc2V0LlxuICAgICAqL1xuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRzID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgV2UgY2FuJ3QgcmVhbGx5IGtub3cgdGhhdCB0aGlzIG1hdGNoZXMgQ29udGVudHMuXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRzID0gQ29sbGVjdGlvbi5jb2xsZWN0aW9uRnJvbVBhdGgodGhpcy5zY2hlbWEsIFtrZXldLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXNzZXJ0Q29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKSkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50cy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIHZhbHVlIGluIHRoaXMgZG9jdW1lbnQuIEZvciBgISFzZXRgLCBgdmFsdWVgIG5lZWRzIHRvIGJlIGFcbiAgICAgKiBib29sZWFuIHRvIGFkZC9yZW1vdmUgdGhlIGl0ZW0gZnJvbSB0aGUgc2V0LlxuICAgICAqL1xuICAgIHNldEluKHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIGlmIChDb2xsZWN0aW9uLmlzRW1wdHlQYXRoKHBhdGgpKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFdlIGNhbid0IHJlYWxseSBrbm93IHRoYXQgdGhpcyBtYXRjaGVzIENvbnRlbnRzLlxuICAgICAgICAgICAgdGhpcy5jb250ZW50cyA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY29udGVudHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBXZSBjYW4ndCByZWFsbHkga25vdyB0aGF0IHRoaXMgbWF0Y2hlcyBDb250ZW50cy5cbiAgICAgICAgICAgIHRoaXMuY29udGVudHMgPSBDb2xsZWN0aW9uLmNvbGxlY3Rpb25Gcm9tUGF0aCh0aGlzLnNjaGVtYSwgQXJyYXkuZnJvbShwYXRoKSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFzc2VydENvbGxlY3Rpb24odGhpcy5jb250ZW50cykpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudHMuc2V0SW4ocGF0aCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZSB0aGUgWUFNTCB2ZXJzaW9uIGFuZCBzY2hlbWEgdXNlZCBieSB0aGUgZG9jdW1lbnQuXG4gICAgICogQSBgbnVsbGAgdmVyc2lvbiBkaXNhYmxlcyBzdXBwb3J0IGZvciBkaXJlY3RpdmVzLCBleHBsaWNpdCB0YWdzLCBhbmNob3JzLCBhbmQgYWxpYXNlcy5cbiAgICAgKiBJdCBhbHNvIHJlcXVpcmVzIHRoZSBgc2NoZW1hYCBvcHRpb24gdG8gYmUgZ2l2ZW4gYXMgYSBgU2NoZW1hYCBpbnN0YW5jZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIE92ZXJyaWRlcyBhbGwgcHJldmlvdXNseSBzZXQgc2NoZW1hIG9wdGlvbnMuXG4gICAgICovXG4gICAgc2V0U2NoZW1hKHZlcnNpb24sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdudW1iZXInKVxuICAgICAgICAgICAgdmVyc2lvbiA9IFN0cmluZyh2ZXJzaW9uKTtcbiAgICAgICAgbGV0IG9wdDtcbiAgICAgICAgc3dpdGNoICh2ZXJzaW9uKSB7XG4gICAgICAgICAgICBjYXNlICcxLjEnOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRpcmVjdGl2ZXMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcy55YW1sLnZlcnNpb24gPSAnMS4xJztcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IG5ldyBkaXJlY3RpdmVzLkRpcmVjdGl2ZXMoeyB2ZXJzaW9uOiAnMS4xJyB9KTtcbiAgICAgICAgICAgICAgICBvcHQgPSB7IHJlc29sdmVLbm93blRhZ3M6IGZhbHNlLCBzY2hlbWE6ICd5YW1sLTEuMScgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJzEuMic6XG4gICAgICAgICAgICBjYXNlICduZXh0JzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kaXJlY3RpdmVzKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMueWFtbC52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IG5ldyBkaXJlY3RpdmVzLkRpcmVjdGl2ZXMoeyB2ZXJzaW9uIH0pO1xuICAgICAgICAgICAgICAgIG9wdCA9IHsgcmVzb2x2ZUtub3duVGFnczogdHJ1ZSwgc2NoZW1hOiAnY29yZScgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgbnVsbDpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kaXJlY3RpdmVzKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5kaXJlY3RpdmVzO1xuICAgICAgICAgICAgICAgIG9wdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3YgPSBKU09OLnN0cmluZ2lmeSh2ZXJzaW9uKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkICcxLjEnLCAnMS4yJyBvciBudWxsIGFzIGZpcnN0IGFyZ3VtZW50LCBidXQgZm91bmQ6ICR7c3Z9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90IHVzaW5nIGBpbnN0YW5jZW9mIFNjaGVtYWAgdG8gYWxsb3cgZm9yIGR1Y2sgdHlwaW5nXG4gICAgICAgIGlmIChvcHRpb25zLnNjaGVtYSBpbnN0YW5jZW9mIE9iamVjdClcbiAgICAgICAgICAgIHRoaXMuc2NoZW1hID0gb3B0aW9ucy5zY2hlbWE7XG4gICAgICAgIGVsc2UgaWYgKG9wdClcbiAgICAgICAgICAgIHRoaXMuc2NoZW1hID0gbmV3IFNjaGVtYS5TY2hlbWEoT2JqZWN0LmFzc2lnbihvcHQsIG9wdGlvbnMpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXaXRoIGEgbnVsbCBZQU1MIHZlcnNpb24sIHRoZSB7IHNjaGVtYTogU2NoZW1hIH0gb3B0aW9uIGlzIHJlcXVpcmVkYCk7XG4gICAgfVxuICAgIC8vIGpzb24gJiBqc29uQXJnIGFyZSBvbmx5IHVzZWQgZnJvbSB0b0pTT04oKVxuICAgIHRvSlMoeyBqc29uLCBqc29uQXJnLCBtYXBBc01hcCwgbWF4QWxpYXNDb3VudCwgb25BbmNob3IsIHJldml2ZXIgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIGFuY2hvcnM6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIGRvYzogdGhpcyxcbiAgICAgICAgICAgIGtlZXA6ICFqc29uLFxuICAgICAgICAgICAgbWFwQXNNYXA6IG1hcEFzTWFwID09PSB0cnVlLFxuICAgICAgICAgICAgbWFwS2V5V2FybmVkOiBmYWxzZSxcbiAgICAgICAgICAgIG1heEFsaWFzQ291bnQ6IHR5cGVvZiBtYXhBbGlhc0NvdW50ID09PSAnbnVtYmVyJyA/IG1heEFsaWFzQ291bnQgOiAxMDBcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzID0gdG9KUy50b0pTKHRoaXMuY29udGVudHMsIGpzb25BcmcgPz8gJycsIGN0eCk7XG4gICAgICAgIGlmICh0eXBlb2Ygb25BbmNob3IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgY291bnQsIHJlcyB9IG9mIGN0eC5hbmNob3JzLnZhbHVlcygpKVxuICAgICAgICAgICAgICAgIG9uQW5jaG9yKHJlcywgY291bnQpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHJldml2ZXIgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gYXBwbHlSZXZpdmVyLmFwcGx5UmV2aXZlcihyZXZpdmVyLCB7ICcnOiByZXMgfSwgJycsIHJlcylcbiAgICAgICAgICAgIDogcmVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIGRvY3VtZW50IGBjb250ZW50c2AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ganNvbkFyZyBVc2VkIGJ5IGBKU09OLnN0cmluZ2lmeWAgdG8gaW5kaWNhdGUgdGhlIGFycmF5IGluZGV4IG9yXG4gICAgICogICBwcm9wZXJ0eSBuYW1lLlxuICAgICAqL1xuICAgIHRvSlNPTihqc29uQXJnLCBvbkFuY2hvcikge1xuICAgICAgICByZXR1cm4gdGhpcy50b0pTKHsganNvbjogdHJ1ZSwganNvbkFyZywgbWFwQXNNYXA6IGZhbHNlLCBvbkFuY2hvciB9KTtcbiAgICB9XG4gICAgLyoqIEEgWUFNTCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZG9jdW1lbnQuICovXG4gICAgdG9TdHJpbmcob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9ycy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEb2N1bWVudCB3aXRoIGVycm9ycyBjYW5ub3QgYmUgc3RyaW5naWZpZWQnKTtcbiAgICAgICAgaWYgKCdpbmRlbnQnIGluIG9wdGlvbnMgJiZcbiAgICAgICAgICAgICghTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLmluZGVudCkgfHwgTnVtYmVyKG9wdGlvbnMuaW5kZW50KSA8PSAwKSkge1xuICAgICAgICAgICAgY29uc3QgcyA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuaW5kZW50KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCJpbmRlbnRcIiBvcHRpb24gbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIG5vdCAke3N9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeURvY3VtZW50LnN0cmluZ2lmeURvY3VtZW50KHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2VydENvbGxlY3Rpb24oY29udGVudHMpIHtcbiAgICBpZiAoaWRlbnRpdHkuaXNDb2xsZWN0aW9uKGNvbnRlbnRzKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIFlBTUwgY29sbGVjdGlvbiBhcyBkb2N1bWVudCBjb250ZW50cycpO1xufVxuXG5leHBvcnRzLkRvY3VtZW50ID0gRG9jdW1lbnQ7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxuY2xhc3MgWUFNTEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHBvcywgY29kZSwgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICB9XG59XG5jbGFzcyBZQU1MUGFyc2VFcnJvciBleHRlbmRzIFlBTUxFcnJvciB7XG4gICAgY29uc3RydWN0b3IocG9zLCBjb2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKCdZQU1MUGFyc2VFcnJvcicsIHBvcywgY29kZSwgbWVzc2FnZSk7XG4gICAgfVxufVxuY2xhc3MgWUFNTFdhcm5pbmcgZXh0ZW5kcyBZQU1MRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHBvcywgY29kZSwgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcignWUFNTFdhcm5pbmcnLCBwb3MsIGNvZGUsIG1lc3NhZ2UpO1xuICAgIH1cbn1cbmNvbnN0IHByZXR0aWZ5RXJyb3IgPSAoc3JjLCBsYykgPT4gKGVycm9yKSA9PiB7XG4gICAgaWYgKGVycm9yLnBvc1swXSA9PT0gLTEpXG4gICAgICAgIHJldHVybjtcbiAgICBlcnJvci5saW5lUG9zID0gZXJyb3IucG9zLm1hcChwb3MgPT4gbGMubGluZVBvcyhwb3MpKTtcbiAgICBjb25zdCB7IGxpbmUsIGNvbCB9ID0gZXJyb3IubGluZVBvc1swXTtcbiAgICBlcnJvci5tZXNzYWdlICs9IGAgYXQgbGluZSAke2xpbmV9LCBjb2x1bW4gJHtjb2x9YDtcbiAgICBsZXQgY2kgPSBjb2wgLSAxO1xuICAgIGxldCBsaW5lU3RyID0gc3JjXG4gICAgICAgIC5zdWJzdHJpbmcobGMubGluZVN0YXJ0c1tsaW5lIC0gMV0sIGxjLmxpbmVTdGFydHNbbGluZV0pXG4gICAgICAgIC5yZXBsYWNlKC9bXFxuXFxyXSskLywgJycpO1xuICAgIC8vIFRyaW0gdG8gbWF4IDgwIGNoYXJzLCBrZWVwaW5nIGNvbCBwb3NpdGlvbiBuZWFyIHRoZSBtaWRkbGVcbiAgICBpZiAoY2kgPj0gNjAgJiYgbGluZVN0ci5sZW5ndGggPiA4MCkge1xuICAgICAgICBjb25zdCB0cmltU3RhcnQgPSBNYXRoLm1pbihjaSAtIDM5LCBsaW5lU3RyLmxlbmd0aCAtIDc5KTtcbiAgICAgICAgbGluZVN0ciA9ICfigKYnICsgbGluZVN0ci5zdWJzdHJpbmcodHJpbVN0YXJ0KTtcbiAgICAgICAgY2kgLT0gdHJpbVN0YXJ0IC0gMTtcbiAgICB9XG4gICAgaWYgKGxpbmVTdHIubGVuZ3RoID4gODApXG4gICAgICAgIGxpbmVTdHIgPSBsaW5lU3RyLnN1YnN0cmluZygwLCA3OSkgKyAn4oCmJztcbiAgICAvLyBJbmNsdWRlIHByZXZpb3VzIGxpbmUgaW4gY29udGV4dCBpZiBwb2ludGluZyBhdCBsaW5lIHN0YXJ0XG4gICAgaWYgKGxpbmUgPiAxICYmIC9eICokLy50ZXN0KGxpbmVTdHIuc3Vic3RyaW5nKDAsIGNpKSkpIHtcbiAgICAgICAgLy8gUmVnZXhwIHdvbid0IG1hdGNoIGlmIHN0YXJ0IGlzIHRyaW1tZWRcbiAgICAgICAgbGV0IHByZXYgPSBzcmMuc3Vic3RyaW5nKGxjLmxpbmVTdGFydHNbbGluZSAtIDJdLCBsYy5saW5lU3RhcnRzW2xpbmUgLSAxXSk7XG4gICAgICAgIGlmIChwcmV2Lmxlbmd0aCA+IDgwKVxuICAgICAgICAgICAgcHJldiA9IHByZXYuc3Vic3RyaW5nKDAsIDc5KSArICfigKZcXG4nO1xuICAgICAgICBsaW5lU3RyID0gcHJldiArIGxpbmVTdHI7XG4gICAgfVxuICAgIGlmICgvW14gXS8udGVzdChsaW5lU3RyKSkge1xuICAgICAgICBsZXQgY291bnQgPSAxO1xuICAgICAgICBjb25zdCBlbmQgPSBlcnJvci5saW5lUG9zWzFdO1xuICAgICAgICBpZiAoZW5kPy5saW5lID09PSBsaW5lICYmIGVuZC5jb2wgPiBjb2wpIHtcbiAgICAgICAgICAgIGNvdW50ID0gTWF0aC5tYXgoMSwgTWF0aC5taW4oZW5kLmNvbCAtIGNvbCwgODAgLSBjaSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvaW50ZXIgPSAnICcucmVwZWF0KGNpKSArICdeJy5yZXBlYXQoY291bnQpO1xuICAgICAgICBlcnJvci5tZXNzYWdlICs9IGA6XFxuXFxuJHtsaW5lU3RyfVxcbiR7cG9pbnRlcn1cXG5gO1xuICAgIH1cbn07XG5cbmV4cG9ydHMuWUFNTEVycm9yID0gWUFNTEVycm9yO1xuZXhwb3J0cy5ZQU1MUGFyc2VFcnJvciA9IFlBTUxQYXJzZUVycm9yO1xuZXhwb3J0cy5ZQU1MV2FybmluZyA9IFlBTUxXYXJuaW5nO1xuZXhwb3J0cy5wcmV0dGlmeUVycm9yID0gcHJldHRpZnlFcnJvcjtcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiByZXNvbHZlUHJvcHModG9rZW5zLCB7IGZsb3csIGluZGljYXRvciwgbmV4dCwgb2Zmc2V0LCBvbkVycm9yLCBwYXJlbnRJbmRlbnQsIHN0YXJ0T25OZXdsaW5lIH0pIHtcbiAgICBsZXQgc3BhY2VCZWZvcmUgPSBmYWxzZTtcbiAgICBsZXQgYXROZXdsaW5lID0gc3RhcnRPbk5ld2xpbmU7XG4gICAgbGV0IGhhc1NwYWNlID0gc3RhcnRPbk5ld2xpbmU7XG4gICAgbGV0IGNvbW1lbnQgPSAnJztcbiAgICBsZXQgY29tbWVudFNlcCA9ICcnO1xuICAgIGxldCBoYXNOZXdsaW5lID0gZmFsc2U7XG4gICAgbGV0IHJlcVNwYWNlID0gZmFsc2U7XG4gICAgbGV0IHRhYiA9IG51bGw7XG4gICAgbGV0IGFuY2hvciA9IG51bGw7XG4gICAgbGV0IHRhZyA9IG51bGw7XG4gICAgbGV0IG5ld2xpbmVBZnRlclByb3AgPSBudWxsO1xuICAgIGxldCBjb21tYSA9IG51bGw7XG4gICAgbGV0IGZvdW5kID0gbnVsbDtcbiAgICBsZXQgc3RhcnQgPSBudWxsO1xuICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zKSB7XG4gICAgICAgIGlmIChyZXFTcGFjZSkge1xuICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09ICdzcGFjZScgJiZcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlICE9PSAnbmV3bGluZScgJiZcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlICE9PSAnY29tbWEnKVxuICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4ub2Zmc2V0LCAnTUlTU0lOR19DSEFSJywgJ1RhZ3MgYW5kIGFuY2hvcnMgbXVzdCBiZSBzZXBhcmF0ZWQgZnJvbSB0aGUgbmV4dCB0b2tlbiBieSB3aGl0ZSBzcGFjZScpO1xuICAgICAgICAgICAgcmVxU3BhY2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFiKSB7XG4gICAgICAgICAgICBpZiAoYXROZXdsaW5lICYmIHRva2VuLnR5cGUgIT09ICdjb21tZW50JyAmJiB0b2tlbi50eXBlICE9PSAnbmV3bGluZScpIHtcbiAgICAgICAgICAgICAgICBvbkVycm9yKHRhYiwgJ1RBQl9BU19JTkRFTlQnLCAnVGFicyBhcmUgbm90IGFsbG93ZWQgYXMgaW5kZW50YXRpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhYiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgLy8gQXQgdGhlIGRvYyBsZXZlbCwgdGFicyBhdCBsaW5lIHN0YXJ0IG1heSBiZSBwYXJzZWRcbiAgICAgICAgICAgICAgICAvLyBhcyBsZWFkaW5nIHdoaXRlIHNwYWNlIHJhdGhlciB0aGFuIGluZGVudGF0aW9uLlxuICAgICAgICAgICAgICAgIC8vIEluIGEgZmxvdyBjb2xsZWN0aW9uLCBvbmx5IHRoZSBwYXJzZXIgaGFuZGxlcyBpbmRlbnQuXG4gICAgICAgICAgICAgICAgaWYgKCFmbG93ICYmXG4gICAgICAgICAgICAgICAgICAgIChpbmRpY2F0b3IgIT09ICdkb2Mtc3RhcnQnIHx8IG5leHQ/LnR5cGUgIT09ICdmbG93LWNvbGxlY3Rpb24nKSAmJlxuICAgICAgICAgICAgICAgICAgICB0b2tlbi5zb3VyY2UuaW5jbHVkZXMoJ1xcdCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhYiA9IHRva2VuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb21tZW50Jzoge1xuICAgICAgICAgICAgICAgIGlmICghaGFzU3BhY2UpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdNSVNTSU5HX0NIQVInLCAnQ29tbWVudHMgbXVzdCBiZSBzZXBhcmF0ZWQgZnJvbSBvdGhlciB0b2tlbnMgYnkgd2hpdGUgc3BhY2UgY2hhcmFjdGVycycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNiID0gdG9rZW4uc291cmNlLnN1YnN0cmluZygxKSB8fCAnICc7XG4gICAgICAgICAgICAgICAgaWYgKCFjb21tZW50KVxuICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gY2I7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjb21tZW50ICs9IGNvbW1lbnRTZXAgKyBjYjtcbiAgICAgICAgICAgICAgICBjb21tZW50U2VwID0gJyc7XG4gICAgICAgICAgICAgICAgYXROZXdsaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICBpZiAoYXROZXdsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudCArPSB0b2tlbi5zb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFmb3VuZCB8fCBpbmRpY2F0b3IgIT09ICdzZXEtaXRlbS1pbmQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3BhY2VCZWZvcmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnRTZXAgKz0gdG9rZW4uc291cmNlO1xuICAgICAgICAgICAgICAgIGF0TmV3bGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaGFzTmV3bGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGFuY2hvciB8fCB0YWcpXG4gICAgICAgICAgICAgICAgICAgIG5ld2xpbmVBZnRlclByb3AgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhbmNob3InOlxuICAgICAgICAgICAgICAgIGlmIChhbmNob3IpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdNVUxUSVBMRV9BTkNIT1JTJywgJ0Egbm9kZSBjYW4gaGF2ZSBhdCBtb3N0IG9uZSBhbmNob3InKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4uc291cmNlLmVuZHNXaXRoKCc6JykpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4ub2Zmc2V0ICsgdG9rZW4uc291cmNlLmxlbmd0aCAtIDEsICdCQURfQUxJQVMnLCAnQW5jaG9yIGVuZGluZyBpbiA6IGlzIGFtYmlndW91cycsIHRydWUpO1xuICAgICAgICAgICAgICAgIGFuY2hvciA9IHRva2VuO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID8/IChzdGFydCA9IHRva2VuLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgYXROZXdsaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaGFzU3BhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXFTcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0YWcnOiB7XG4gICAgICAgICAgICAgICAgaWYgKHRhZylcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ01VTFRJUExFX1RBR1MnLCAnQSBub2RlIGNhbiBoYXZlIGF0IG1vc3Qgb25lIHRhZycpO1xuICAgICAgICAgICAgICAgIHRhZyA9IHRva2VuO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID8/IChzdGFydCA9IHRva2VuLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgYXROZXdsaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaGFzU3BhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXFTcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIGluZGljYXRvcjpcbiAgICAgICAgICAgICAgICAvLyBDb3VsZCBoZXJlIGhhbmRsZSBwcmVjZWRpbmcgY29tbWVudHMgZGlmZmVyZW50bHlcbiAgICAgICAgICAgICAgICBpZiAoYW5jaG9yIHx8IHRhZylcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ0JBRF9QUk9QX09SREVSJywgYEFuY2hvcnMgYW5kIHRhZ3MgbXVzdCBiZSBhZnRlciB0aGUgJHt0b2tlbi5zb3VyY2V9IGluZGljYXRvcmApO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ1VORVhQRUNURURfVE9LRU4nLCBgVW5leHBlY3RlZCAke3Rva2VuLnNvdXJjZX0gaW4gJHtmbG93ID8/ICdjb2xsZWN0aW9uJ31gKTtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgIGF0TmV3bGluZSA9XG4gICAgICAgICAgICAgICAgICAgIGluZGljYXRvciA9PT0gJ3NlcS1pdGVtLWluZCcgfHwgaW5kaWNhdG9yID09PSAnZXhwbGljaXQta2V5LWluZCc7XG4gICAgICAgICAgICAgICAgaGFzU3BhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1hJzpcbiAgICAgICAgICAgICAgICBpZiAoZmxvdykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWEpXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnVU5FWFBFQ1RFRF9UT0tFTicsIGBVbmV4cGVjdGVkICwgaW4gJHtmbG93fWApO1xuICAgICAgICAgICAgICAgICAgICBjb21tYSA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBhdE5ld2xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaGFzU3BhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZWxzZSBmYWxsdGhyb3VnaFxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnVU5FWFBFQ1RFRF9UT0tFTicsIGBVbmV4cGVjdGVkICR7dG9rZW4udHlwZX0gdG9rZW5gKTtcbiAgICAgICAgICAgICAgICBhdE5ld2xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxhc3QgPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGVuZCA9IGxhc3QgPyBsYXN0Lm9mZnNldCArIGxhc3Quc291cmNlLmxlbmd0aCA6IG9mZnNldDtcbiAgICBpZiAocmVxU3BhY2UgJiZcbiAgICAgICAgbmV4dCAmJlxuICAgICAgICBuZXh0LnR5cGUgIT09ICdzcGFjZScgJiZcbiAgICAgICAgbmV4dC50eXBlICE9PSAnbmV3bGluZScgJiZcbiAgICAgICAgbmV4dC50eXBlICE9PSAnY29tbWEnICYmXG4gICAgICAgIChuZXh0LnR5cGUgIT09ICdzY2FsYXInIHx8IG5leHQuc291cmNlICE9PSAnJykpIHtcbiAgICAgICAgb25FcnJvcihuZXh0Lm9mZnNldCwgJ01JU1NJTkdfQ0hBUicsICdUYWdzIGFuZCBhbmNob3JzIG11c3QgYmUgc2VwYXJhdGVkIGZyb20gdGhlIG5leHQgdG9rZW4gYnkgd2hpdGUgc3BhY2UnKTtcbiAgICB9XG4gICAgaWYgKHRhYiAmJlxuICAgICAgICAoKGF0TmV3bGluZSAmJiB0YWIuaW5kZW50IDw9IHBhcmVudEluZGVudCkgfHxcbiAgICAgICAgICAgIG5leHQ/LnR5cGUgPT09ICdibG9jay1tYXAnIHx8XG4gICAgICAgICAgICBuZXh0Py50eXBlID09PSAnYmxvY2stc2VxJykpXG4gICAgICAgIG9uRXJyb3IodGFiLCAnVEFCX0FTX0lOREVOVCcsICdUYWJzIGFyZSBub3QgYWxsb3dlZCBhcyBpbmRlbnRhdGlvbicpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbW1hLFxuICAgICAgICBmb3VuZCxcbiAgICAgICAgc3BhY2VCZWZvcmUsXG4gICAgICAgIGNvbW1lbnQsXG4gICAgICAgIGhhc05ld2xpbmUsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgdGFnLFxuICAgICAgICBuZXdsaW5lQWZ0ZXJQcm9wLFxuICAgICAgICBlbmQsXG4gICAgICAgIHN0YXJ0OiBzdGFydCA/PyBlbmRcbiAgICB9O1xufVxuXG5leHBvcnRzLnJlc29sdmVQcm9wcyA9IHJlc29sdmVQcm9wcztcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjb250YWluc05ld2xpbmUoa2V5KSB7XG4gICAgaWYgKCFrZXkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHN3aXRjaCAoa2V5LnR5cGUpIHtcbiAgICAgICAgY2FzZSAnYWxpYXMnOlxuICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICBjYXNlICdkb3VibGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgIGlmIChrZXkuc291cmNlLmluY2x1ZGVzKCdcXG4nKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChrZXkuZW5kKVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3Qgb2Yga2V5LmVuZClcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0LnR5cGUgPT09ICduZXdsaW5lJylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjYXNlICdmbG93LWNvbGxlY3Rpb24nOlxuICAgICAgICAgICAgZm9yIChjb25zdCBpdCBvZiBrZXkuaXRlbXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN0IG9mIGl0LnN0YXJ0KVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3QudHlwZSA9PT0gJ25ld2xpbmUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGl0LnNlcClcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdCBvZiBpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3QudHlwZSA9PT0gJ25ld2xpbmUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChjb250YWluc05ld2xpbmUoaXQua2V5KSB8fCBjb250YWluc05ld2xpbmUoaXQudmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxuZXhwb3J0cy5jb250YWluc05ld2xpbmUgPSBjb250YWluc05ld2xpbmU7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxDb250YWluc05ld2xpbmUgPSByZXF1aXJlKCcuL3V0aWwtY29udGFpbnMtbmV3bGluZS5qcycpO1xuXG5mdW5jdGlvbiBmbG93SW5kZW50Q2hlY2soaW5kZW50LCBmYywgb25FcnJvcikge1xuICAgIGlmIChmYz8udHlwZSA9PT0gJ2Zsb3ctY29sbGVjdGlvbicpIHtcbiAgICAgICAgY29uc3QgZW5kID0gZmMuZW5kWzBdO1xuICAgICAgICBpZiAoZW5kLmluZGVudCA9PT0gaW5kZW50ICYmXG4gICAgICAgICAgICAoZW5kLnNvdXJjZSA9PT0gJ10nIHx8IGVuZC5zb3VyY2UgPT09ICd9JykgJiZcbiAgICAgICAgICAgIHV0aWxDb250YWluc05ld2xpbmUuY29udGFpbnNOZXdsaW5lKGZjKSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gJ0Zsb3cgZW5kIGluZGljYXRvciBzaG91bGQgYmUgbW9yZSBpbmRlbnRlZCB0aGFuIHBhcmVudCc7XG4gICAgICAgICAgICBvbkVycm9yKGVuZCwgJ0JBRF9JTkRFTlQnLCBtc2csIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnRzLmZsb3dJbmRlbnRDaGVjayA9IGZsb3dJbmRlbnRDaGVjaztcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuLi9ub2Rlcy9pZGVudGl0eS5qcycpO1xuXG5mdW5jdGlvbiBtYXBJbmNsdWRlcyhjdHgsIGl0ZW1zLCBzZWFyY2gpIHtcbiAgICBjb25zdCB7IHVuaXF1ZUtleXMgfSA9IGN0eC5vcHRpb25zO1xuICAgIGlmICh1bmlxdWVLZXlzID09PSBmYWxzZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGlzRXF1YWwgPSB0eXBlb2YgdW5pcXVlS2V5cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHVuaXF1ZUtleXNcbiAgICAgICAgOiAoYSwgYikgPT4gYSA9PT0gYiB8fCAoaWRlbnRpdHkuaXNTY2FsYXIoYSkgJiYgaWRlbnRpdHkuaXNTY2FsYXIoYikgJiYgYS52YWx1ZSA9PT0gYi52YWx1ZSk7XG4gICAgcmV0dXJuIGl0ZW1zLnNvbWUocGFpciA9PiBpc0VxdWFsKHBhaXIua2V5LCBzZWFyY2gpKTtcbn1cblxuZXhwb3J0cy5tYXBJbmNsdWRlcyA9IG1hcEluY2x1ZGVzO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBQYWlyID0gcmVxdWlyZSgnLi4vbm9kZXMvUGFpci5qcycpO1xudmFyIFlBTUxNYXAgPSByZXF1aXJlKCcuLi9ub2Rlcy9ZQU1MTWFwLmpzJyk7XG52YXIgcmVzb2x2ZVByb3BzID0gcmVxdWlyZSgnLi9yZXNvbHZlLXByb3BzLmpzJyk7XG52YXIgdXRpbENvbnRhaW5zTmV3bGluZSA9IHJlcXVpcmUoJy4vdXRpbC1jb250YWlucy1uZXdsaW5lLmpzJyk7XG52YXIgdXRpbEZsb3dJbmRlbnRDaGVjayA9IHJlcXVpcmUoJy4vdXRpbC1mbG93LWluZGVudC1jaGVjay5qcycpO1xudmFyIHV0aWxNYXBJbmNsdWRlcyA9IHJlcXVpcmUoJy4vdXRpbC1tYXAtaW5jbHVkZXMuanMnKTtcblxuY29uc3Qgc3RhcnRDb2xNc2cgPSAnQWxsIG1hcHBpbmcgaXRlbXMgbXVzdCBzdGFydCBhdCB0aGUgc2FtZSBjb2x1bW4nO1xuZnVuY3Rpb24gcmVzb2x2ZUJsb2NrTWFwKHsgY29tcG9zZU5vZGUsIGNvbXBvc2VFbXB0eU5vZGUgfSwgY3R4LCBibSwgb25FcnJvciwgdGFnKSB7XG4gICAgY29uc3QgTm9kZUNsYXNzID0gdGFnPy5ub2RlQ2xhc3MgPz8gWUFNTE1hcC5ZQU1MTWFwO1xuICAgIGNvbnN0IG1hcCA9IG5ldyBOb2RlQ2xhc3MoY3R4LnNjaGVtYSk7XG4gICAgaWYgKGN0eC5hdFJvb3QpXG4gICAgICAgIGN0eC5hdFJvb3QgPSBmYWxzZTtcbiAgICBsZXQgb2Zmc2V0ID0gYm0ub2Zmc2V0O1xuICAgIGxldCBjb21tZW50RW5kID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IGNvbGxJdGVtIG9mIGJtLml0ZW1zKSB7XG4gICAgICAgIGNvbnN0IHsgc3RhcnQsIGtleSwgc2VwLCB2YWx1ZSB9ID0gY29sbEl0ZW07XG4gICAgICAgIC8vIGtleSBwcm9wZXJ0aWVzXG4gICAgICAgIGNvbnN0IGtleVByb3BzID0gcmVzb2x2ZVByb3BzLnJlc29sdmVQcm9wcyhzdGFydCwge1xuICAgICAgICAgICAgaW5kaWNhdG9yOiAnZXhwbGljaXQta2V5LWluZCcsXG4gICAgICAgICAgICBuZXh0OiBrZXkgPz8gc2VwPy5bMF0sXG4gICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgcGFyZW50SW5kZW50OiBibS5pbmRlbnQsXG4gICAgICAgICAgICBzdGFydE9uTmV3bGluZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaW1wbGljaXRLZXkgPSAha2V5UHJvcHMuZm91bmQ7XG4gICAgICAgIGlmIChpbXBsaWNpdEtleSkge1xuICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkudHlwZSA9PT0gJ2Jsb2NrLXNlcScpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3Iob2Zmc2V0LCAnQkxPQ0tfQVNfSU1QTElDSVRfS0VZJywgJ0EgYmxvY2sgc2VxdWVuY2UgbWF5IG5vdCBiZSB1c2VkIGFzIGFuIGltcGxpY2l0IG1hcCBrZXknKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgnaW5kZW50JyBpbiBrZXkgJiYga2V5LmluZGVudCAhPT0gYm0uaW5kZW50KVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKG9mZnNldCwgJ0JBRF9JTkRFTlQnLCBzdGFydENvbE1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWtleVByb3BzLmFuY2hvciAmJiAha2V5UHJvcHMudGFnICYmICFzZXApIHtcbiAgICAgICAgICAgICAgICBjb21tZW50RW5kID0ga2V5UHJvcHMuZW5kO1xuICAgICAgICAgICAgICAgIGlmIChrZXlQcm9wcy5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXAuY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5jb21tZW50ICs9ICdcXG4nICsga2V5UHJvcHMuY29tbWVudDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLmNvbW1lbnQgPSBrZXlQcm9wcy5jb21tZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXlQcm9wcy5uZXdsaW5lQWZ0ZXJQcm9wIHx8IHV0aWxDb250YWluc05ld2xpbmUuY29udGFpbnNOZXdsaW5lKGtleSkpIHtcbiAgICAgICAgICAgICAgICBvbkVycm9yKGtleSA/PyBzdGFydFtzdGFydC5sZW5ndGggLSAxXSwgJ01VTFRJTElORV9JTVBMSUNJVF9LRVknLCAnSW1wbGljaXQga2V5cyBuZWVkIHRvIGJlIG9uIGEgc2luZ2xlIGxpbmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXlQcm9wcy5mb3VuZD8uaW5kZW50ICE9PSBibS5pbmRlbnQpIHtcbiAgICAgICAgICAgIG9uRXJyb3Iob2Zmc2V0LCAnQkFEX0lOREVOVCcsIHN0YXJ0Q29sTXNnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBrZXkgdmFsdWVcbiAgICAgICAgY3R4LmF0S2V5ID0gdHJ1ZTtcbiAgICAgICAgY29uc3Qga2V5U3RhcnQgPSBrZXlQcm9wcy5lbmQ7XG4gICAgICAgIGNvbnN0IGtleU5vZGUgPSBrZXlcbiAgICAgICAgICAgID8gY29tcG9zZU5vZGUoY3R4LCBrZXksIGtleVByb3BzLCBvbkVycm9yKVxuICAgICAgICAgICAgOiBjb21wb3NlRW1wdHlOb2RlKGN0eCwga2V5U3RhcnQsIHN0YXJ0LCBudWxsLCBrZXlQcm9wcywgb25FcnJvcik7XG4gICAgICAgIGlmIChjdHguc2NoZW1hLmNvbXBhdClcbiAgICAgICAgICAgIHV0aWxGbG93SW5kZW50Q2hlY2suZmxvd0luZGVudENoZWNrKGJtLmluZGVudCwga2V5LCBvbkVycm9yKTtcbiAgICAgICAgY3R4LmF0S2V5ID0gZmFsc2U7XG4gICAgICAgIGlmICh1dGlsTWFwSW5jbHVkZXMubWFwSW5jbHVkZXMoY3R4LCBtYXAuaXRlbXMsIGtleU5vZGUpKVxuICAgICAgICAgICAgb25FcnJvcihrZXlTdGFydCwgJ0RVUExJQ0FURV9LRVknLCAnTWFwIGtleXMgbXVzdCBiZSB1bmlxdWUnKTtcbiAgICAgICAgLy8gdmFsdWUgcHJvcGVydGllc1xuICAgICAgICBjb25zdCB2YWx1ZVByb3BzID0gcmVzb2x2ZVByb3BzLnJlc29sdmVQcm9wcyhzZXAgPz8gW10sIHtcbiAgICAgICAgICAgIGluZGljYXRvcjogJ21hcC12YWx1ZS1pbmQnLFxuICAgICAgICAgICAgbmV4dDogdmFsdWUsXG4gICAgICAgICAgICBvZmZzZXQ6IGtleU5vZGUucmFuZ2VbMl0sXG4gICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgcGFyZW50SW5kZW50OiBibS5pbmRlbnQsXG4gICAgICAgICAgICBzdGFydE9uTmV3bGluZTogIWtleSB8fCBrZXkudHlwZSA9PT0gJ2Jsb2NrLXNjYWxhcidcbiAgICAgICAgfSk7XG4gICAgICAgIG9mZnNldCA9IHZhbHVlUHJvcHMuZW5kO1xuICAgICAgICBpZiAodmFsdWVQcm9wcy5mb3VuZCkge1xuICAgICAgICAgICAgaWYgKGltcGxpY2l0S2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlPy50eXBlID09PSAnYmxvY2stbWFwJyAmJiAhdmFsdWVQcm9wcy5oYXNOZXdsaW5lKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKG9mZnNldCwgJ0JMT0NLX0FTX0lNUExJQ0lUX0tFWScsICdOZXN0ZWQgbWFwcGluZ3MgYXJlIG5vdCBhbGxvd2VkIGluIGNvbXBhY3QgbWFwcGluZ3MnKTtcbiAgICAgICAgICAgICAgICBpZiAoY3R4Lm9wdGlvbnMuc3RyaWN0ICYmXG4gICAgICAgICAgICAgICAgICAgIGtleVByb3BzLnN0YXJ0IDwgdmFsdWVQcm9wcy5mb3VuZC5vZmZzZXQgLSAxMDI0KVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGtleU5vZGUucmFuZ2UsICdLRVlfT1ZFUl8xMDI0X0NIQVJTJywgJ1RoZSA6IGluZGljYXRvciBtdXN0IGJlIGF0IG1vc3QgMTAyNCBjaGFycyBhZnRlciB0aGUgc3RhcnQgb2YgYW4gaW1wbGljaXQgYmxvY2sgbWFwcGluZyBrZXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHZhbHVlIHZhbHVlXG4gICAgICAgICAgICBjb25zdCB2YWx1ZU5vZGUgPSB2YWx1ZVxuICAgICAgICAgICAgICAgID8gY29tcG9zZU5vZGUoY3R4LCB2YWx1ZSwgdmFsdWVQcm9wcywgb25FcnJvcilcbiAgICAgICAgICAgICAgICA6IGNvbXBvc2VFbXB0eU5vZGUoY3R4LCBvZmZzZXQsIHNlcCwgbnVsbCwgdmFsdWVQcm9wcywgb25FcnJvcik7XG4gICAgICAgICAgICBpZiAoY3R4LnNjaGVtYS5jb21wYXQpXG4gICAgICAgICAgICAgICAgdXRpbEZsb3dJbmRlbnRDaGVjay5mbG93SW5kZW50Q2hlY2soYm0uaW5kZW50LCB2YWx1ZSwgb25FcnJvcik7XG4gICAgICAgICAgICBvZmZzZXQgPSB2YWx1ZU5vZGUucmFuZ2VbMl07XG4gICAgICAgICAgICBjb25zdCBwYWlyID0gbmV3IFBhaXIuUGFpcihrZXlOb2RlLCB2YWx1ZU5vZGUpO1xuICAgICAgICAgICAgaWYgKGN0eC5vcHRpb25zLmtlZXBTb3VyY2VUb2tlbnMpXG4gICAgICAgICAgICAgICAgcGFpci5zcmNUb2tlbiA9IGNvbGxJdGVtO1xuICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2gocGFpcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBrZXkgd2l0aCBubyB2YWx1ZVxuICAgICAgICAgICAgaWYgKGltcGxpY2l0S2V5KVxuICAgICAgICAgICAgICAgIG9uRXJyb3Ioa2V5Tm9kZS5yYW5nZSwgJ01JU1NJTkdfQ0hBUicsICdJbXBsaWNpdCBtYXAga2V5cyBuZWVkIHRvIGJlIGZvbGxvd2VkIGJ5IG1hcCB2YWx1ZXMnKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZVByb3BzLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5Tm9kZS5jb21tZW50KVxuICAgICAgICAgICAgICAgICAgICBrZXlOb2RlLmNvbW1lbnQgKz0gJ1xcbicgKyB2YWx1ZVByb3BzLmNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBrZXlOb2RlLmNvbW1lbnQgPSB2YWx1ZVByb3BzLmNvbW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYWlyID0gbmV3IFBhaXIuUGFpcihrZXlOb2RlKTtcbiAgICAgICAgICAgIGlmIChjdHgub3B0aW9ucy5rZWVwU291cmNlVG9rZW5zKVxuICAgICAgICAgICAgICAgIHBhaXIuc3JjVG9rZW4gPSBjb2xsSXRlbTtcbiAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHBhaXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjb21tZW50RW5kICYmIGNvbW1lbnRFbmQgPCBvZmZzZXQpXG4gICAgICAgIG9uRXJyb3IoY29tbWVudEVuZCwgJ0lNUE9TU0lCTEUnLCAnTWFwIGNvbW1lbnQgd2l0aCB0cmFpbGluZyBjb250ZW50Jyk7XG4gICAgbWFwLnJhbmdlID0gW2JtLm9mZnNldCwgb2Zmc2V0LCBjb21tZW50RW5kID8/IG9mZnNldF07XG4gICAgcmV0dXJuIG1hcDtcbn1cblxuZXhwb3J0cy5yZXNvbHZlQmxvY2tNYXAgPSByZXNvbHZlQmxvY2tNYXA7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIFlBTUxTZXEgPSByZXF1aXJlKCcuLi9ub2Rlcy9ZQU1MU2VxLmpzJyk7XG52YXIgcmVzb2x2ZVByb3BzID0gcmVxdWlyZSgnLi9yZXNvbHZlLXByb3BzLmpzJyk7XG52YXIgdXRpbEZsb3dJbmRlbnRDaGVjayA9IHJlcXVpcmUoJy4vdXRpbC1mbG93LWluZGVudC1jaGVjay5qcycpO1xuXG5mdW5jdGlvbiByZXNvbHZlQmxvY2tTZXEoeyBjb21wb3NlTm9kZSwgY29tcG9zZUVtcHR5Tm9kZSB9LCBjdHgsIGJzLCBvbkVycm9yLCB0YWcpIHtcbiAgICBjb25zdCBOb2RlQ2xhc3MgPSB0YWc/Lm5vZGVDbGFzcyA/PyBZQU1MU2VxLllBTUxTZXE7XG4gICAgY29uc3Qgc2VxID0gbmV3IE5vZGVDbGFzcyhjdHguc2NoZW1hKTtcbiAgICBpZiAoY3R4LmF0Um9vdClcbiAgICAgICAgY3R4LmF0Um9vdCA9IGZhbHNlO1xuICAgIGlmIChjdHguYXRLZXkpXG4gICAgICAgIGN0eC5hdEtleSA9IGZhbHNlO1xuICAgIGxldCBvZmZzZXQgPSBicy5vZmZzZXQ7XG4gICAgbGV0IGNvbW1lbnRFbmQgPSBudWxsO1xuICAgIGZvciAoY29uc3QgeyBzdGFydCwgdmFsdWUgfSBvZiBicy5pdGVtcykge1xuICAgICAgICBjb25zdCBwcm9wcyA9IHJlc29sdmVQcm9wcy5yZXNvbHZlUHJvcHMoc3RhcnQsIHtcbiAgICAgICAgICAgIGluZGljYXRvcjogJ3NlcS1pdGVtLWluZCcsXG4gICAgICAgICAgICBuZXh0OiB2YWx1ZSxcbiAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICAgIG9uRXJyb3IsXG4gICAgICAgICAgICBwYXJlbnRJbmRlbnQ6IGJzLmluZGVudCxcbiAgICAgICAgICAgIHN0YXJ0T25OZXdsaW5lOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXByb3BzLmZvdW5kKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMuYW5jaG9yIHx8IHByb3BzLnRhZyB8fCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZT8udHlwZSA9PT0gJ2Jsb2NrLXNlcScpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IocHJvcHMuZW5kLCAnQkFEX0lOREVOVCcsICdBbGwgc2VxdWVuY2UgaXRlbXMgbXVzdCBzdGFydCBhdCB0aGUgc2FtZSBjb2x1bW4nKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3Iob2Zmc2V0LCAnTUlTU0lOR19DSEFSJywgJ1NlcXVlbmNlIGl0ZW0gd2l0aG91dCAtIGluZGljYXRvcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tbWVudEVuZCA9IHByb3BzLmVuZDtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMuY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgc2VxLmNvbW1lbnQgPSBwcm9wcy5jb21tZW50O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGUgPSB2YWx1ZVxuICAgICAgICAgICAgPyBjb21wb3NlTm9kZShjdHgsIHZhbHVlLCBwcm9wcywgb25FcnJvcilcbiAgICAgICAgICAgIDogY29tcG9zZUVtcHR5Tm9kZShjdHgsIHByb3BzLmVuZCwgc3RhcnQsIG51bGwsIHByb3BzLCBvbkVycm9yKTtcbiAgICAgICAgaWYgKGN0eC5zY2hlbWEuY29tcGF0KVxuICAgICAgICAgICAgdXRpbEZsb3dJbmRlbnRDaGVjay5mbG93SW5kZW50Q2hlY2soYnMuaW5kZW50LCB2YWx1ZSwgb25FcnJvcik7XG4gICAgICAgIG9mZnNldCA9IG5vZGUucmFuZ2VbMl07XG4gICAgICAgIHNlcS5pdGVtcy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgICBzZXEucmFuZ2UgPSBbYnMub2Zmc2V0LCBvZmZzZXQsIGNvbW1lbnRFbmQgPz8gb2Zmc2V0XTtcbiAgICByZXR1cm4gc2VxO1xufVxuXG5leHBvcnRzLnJlc29sdmVCbG9ja1NlcSA9IHJlc29sdmVCbG9ja1NlcTtcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiByZXNvbHZlRW5kKGVuZCwgb2Zmc2V0LCByZXFTcGFjZSwgb25FcnJvcikge1xuICAgIGxldCBjb21tZW50ID0gJyc7XG4gICAgaWYgKGVuZCkge1xuICAgICAgICBsZXQgaGFzU3BhY2UgPSBmYWxzZTtcbiAgICAgICAgbGV0IHNlcCA9ICcnO1xuICAgICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIGVuZCkge1xuICAgICAgICAgICAgY29uc3QgeyBzb3VyY2UsIHR5cGUgfSA9IHRva2VuO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXFTcGFjZSAmJiAhaGFzU3BhY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnTUlTU0lOR19DSEFSJywgJ0NvbW1lbnRzIG11c3QgYmUgc2VwYXJhdGVkIGZyb20gb3RoZXIgdG9rZW5zIGJ5IHdoaXRlIHNwYWNlIGNoYXJhY3RlcnMnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2IgPSBzb3VyY2Uuc3Vic3RyaW5nKDEpIHx8ICcgJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21tZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IGNiO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50ICs9IHNlcCArIGNiO1xuICAgICAgICAgICAgICAgICAgICBzZXAgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcCArPSBzb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgIGhhc1NwYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ1VORVhQRUNURURfVE9LRU4nLCBgVW5leHBlY3RlZCAke3R5cGV9IGF0IG5vZGUgZW5kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgKz0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBjb21tZW50LCBvZmZzZXQgfTtcbn1cblxuZXhwb3J0cy5yZXNvbHZlRW5kID0gcmVzb2x2ZUVuZDtcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuLi9ub2Rlcy9pZGVudGl0eS5qcycpO1xudmFyIFBhaXIgPSByZXF1aXJlKCcuLi9ub2Rlcy9QYWlyLmpzJyk7XG52YXIgWUFNTE1hcCA9IHJlcXVpcmUoJy4uL25vZGVzL1lBTUxNYXAuanMnKTtcbnZhciBZQU1MU2VxID0gcmVxdWlyZSgnLi4vbm9kZXMvWUFNTFNlcS5qcycpO1xudmFyIHJlc29sdmVFbmQgPSByZXF1aXJlKCcuL3Jlc29sdmUtZW5kLmpzJyk7XG52YXIgcmVzb2x2ZVByb3BzID0gcmVxdWlyZSgnLi9yZXNvbHZlLXByb3BzLmpzJyk7XG52YXIgdXRpbENvbnRhaW5zTmV3bGluZSA9IHJlcXVpcmUoJy4vdXRpbC1jb250YWlucy1uZXdsaW5lLmpzJyk7XG52YXIgdXRpbE1hcEluY2x1ZGVzID0gcmVxdWlyZSgnLi91dGlsLW1hcC1pbmNsdWRlcy5qcycpO1xuXG5jb25zdCBibG9ja01zZyA9ICdCbG9jayBjb2xsZWN0aW9ucyBhcmUgbm90IGFsbG93ZWQgd2l0aGluIGZsb3cgY29sbGVjdGlvbnMnO1xuY29uc3QgaXNCbG9jayA9ICh0b2tlbikgPT4gdG9rZW4gJiYgKHRva2VuLnR5cGUgPT09ICdibG9jay1tYXAnIHx8IHRva2VuLnR5cGUgPT09ICdibG9jay1zZXEnKTtcbmZ1bmN0aW9uIHJlc29sdmVGbG93Q29sbGVjdGlvbih7IGNvbXBvc2VOb2RlLCBjb21wb3NlRW1wdHlOb2RlIH0sIGN0eCwgZmMsIG9uRXJyb3IsIHRhZykge1xuICAgIGNvbnN0IGlzTWFwID0gZmMuc3RhcnQuc291cmNlID09PSAneyc7XG4gICAgY29uc3QgZmNOYW1lID0gaXNNYXAgPyAnZmxvdyBtYXAnIDogJ2Zsb3cgc2VxdWVuY2UnO1xuICAgIGNvbnN0IE5vZGVDbGFzcyA9ICh0YWc/Lm5vZGVDbGFzcyA/PyAoaXNNYXAgPyBZQU1MTWFwLllBTUxNYXAgOiBZQU1MU2VxLllBTUxTZXEpKTtcbiAgICBjb25zdCBjb2xsID0gbmV3IE5vZGVDbGFzcyhjdHguc2NoZW1hKTtcbiAgICBjb2xsLmZsb3cgPSB0cnVlO1xuICAgIGNvbnN0IGF0Um9vdCA9IGN0eC5hdFJvb3Q7XG4gICAgaWYgKGF0Um9vdClcbiAgICAgICAgY3R4LmF0Um9vdCA9IGZhbHNlO1xuICAgIGlmIChjdHguYXRLZXkpXG4gICAgICAgIGN0eC5hdEtleSA9IGZhbHNlO1xuICAgIGxldCBvZmZzZXQgPSBmYy5vZmZzZXQgKyBmYy5zdGFydC5zb3VyY2UubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmMuaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgY29sbEl0ZW0gPSBmYy5pdGVtc1tpXTtcbiAgICAgICAgY29uc3QgeyBzdGFydCwga2V5LCBzZXAsIHZhbHVlIH0gPSBjb2xsSXRlbTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSByZXNvbHZlUHJvcHMucmVzb2x2ZVByb3BzKHN0YXJ0LCB7XG4gICAgICAgICAgICBmbG93OiBmY05hbWUsXG4gICAgICAgICAgICBpbmRpY2F0b3I6ICdleHBsaWNpdC1rZXktaW5kJyxcbiAgICAgICAgICAgIG5leHQ6IGtleSA/PyBzZXA/LlswXSxcbiAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICAgIG9uRXJyb3IsXG4gICAgICAgICAgICBwYXJlbnRJbmRlbnQ6IGZjLmluZGVudCxcbiAgICAgICAgICAgIHN0YXJ0T25OZXdsaW5lOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFwcm9wcy5mb3VuZCkge1xuICAgICAgICAgICAgaWYgKCFwcm9wcy5hbmNob3IgJiYgIXByb3BzLnRhZyAmJiAhc2VwICYmICF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAwICYmIHByb3BzLmNvbW1hKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHByb3BzLmNvbW1hLCAnVU5FWFBFQ1RFRF9UT0tFTicsIGBVbmV4cGVjdGVkICwgaW4gJHtmY05hbWV9YCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaSA8IGZjLml0ZW1zLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IocHJvcHMuc3RhcnQsICdVTkVYUEVDVEVEX1RPS0VOJywgYFVuZXhwZWN0ZWQgZW1wdHkgaXRlbSBpbiAke2ZjTmFtZX1gKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMuY29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sbC5jb21tZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbC5jb21tZW50ICs9ICdcXG4nICsgcHJvcHMuY29tbWVudDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbC5jb21tZW50ID0gcHJvcHMuY29tbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gcHJvcHMuZW5kO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc01hcCAmJiBjdHgub3B0aW9ucy5zdHJpY3QgJiYgdXRpbENvbnRhaW5zTmV3bGluZS5jb250YWluc05ld2xpbmUoa2V5KSlcbiAgICAgICAgICAgICAgICBvbkVycm9yKGtleSwgLy8gY2hlY2tlZCBieSBjb250YWluc05ld2xpbmUoKVxuICAgICAgICAgICAgICAgICdNVUxUSUxJTkVfSU1QTElDSVRfS0VZJywgJ0ltcGxpY2l0IGtleXMgb2YgZmxvdyBzZXF1ZW5jZSBwYWlycyBuZWVkIHRvIGJlIG9uIGEgc2luZ2xlIGxpbmUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHByb3BzLmNvbW1hKVxuICAgICAgICAgICAgICAgIG9uRXJyb3IocHJvcHMuY29tbWEsICdVTkVYUEVDVEVEX1RPS0VOJywgYFVuZXhwZWN0ZWQgLCBpbiAke2ZjTmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghcHJvcHMuY29tbWEpXG4gICAgICAgICAgICAgICAgb25FcnJvcihwcm9wcy5zdGFydCwgJ01JU1NJTkdfQ0hBUicsIGBNaXNzaW5nICwgYmV0d2VlbiAke2ZjTmFtZX0gaXRlbXNgKTtcbiAgICAgICAgICAgIGlmIChwcm9wcy5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IHByZXZJdGVtQ29tbWVudCA9ICcnO1xuICAgICAgICAgICAgICAgIGxvb3A6IGZvciAoY29uc3Qgc3Qgb2Ygc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb21tYSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2SXRlbUNvbW1lbnQgPSBzdC5zb3VyY2Uuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByZXZJdGVtQ29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHJldiA9IGNvbGwuaXRlbXNbY29sbC5pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkZW50aXR5LmlzUGFpcihwcmV2KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYgPSBwcmV2LnZhbHVlID8/IHByZXYua2V5O1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldi5jb21tZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldi5jb21tZW50ICs9ICdcXG4nICsgcHJldkl0ZW1Db21tZW50O1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2LmNvbW1lbnQgPSBwcmV2SXRlbUNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmNvbW1lbnQgPSBwcm9wcy5jb21tZW50LnN1YnN0cmluZyhwcmV2SXRlbUNvbW1lbnQubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNNYXAgJiYgIXNlcCAmJiAhcHJvcHMuZm91bmQpIHtcbiAgICAgICAgICAgIC8vIGl0ZW0gaXMgYSB2YWx1ZSBpbiBhIHNlcVxuICAgICAgICAgICAgLy8g4oaSIGtleSAmIHNlcCBhcmUgZW1wdHksIHN0YXJ0IGRvZXMgbm90IGluY2x1ZGUgPyBvciA6XG4gICAgICAgICAgICBjb25zdCB2YWx1ZU5vZGUgPSB2YWx1ZVxuICAgICAgICAgICAgICAgID8gY29tcG9zZU5vZGUoY3R4LCB2YWx1ZSwgcHJvcHMsIG9uRXJyb3IpXG4gICAgICAgICAgICAgICAgOiBjb21wb3NlRW1wdHlOb2RlKGN0eCwgcHJvcHMuZW5kLCBzZXAsIG51bGwsIHByb3BzLCBvbkVycm9yKTtcbiAgICAgICAgICAgIGNvbGwuaXRlbXMucHVzaCh2YWx1ZU5vZGUpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gdmFsdWVOb2RlLnJhbmdlWzJdO1xuICAgICAgICAgICAgaWYgKGlzQmxvY2sodmFsdWUpKVxuICAgICAgICAgICAgICAgIG9uRXJyb3IodmFsdWVOb2RlLnJhbmdlLCAnQkxPQ0tfSU5fRkxPVycsIGJsb2NrTXNnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGl0ZW0gaXMgYSBrZXkrdmFsdWUgcGFpclxuICAgICAgICAgICAgLy8ga2V5IHZhbHVlXG4gICAgICAgICAgICBjdHguYXRLZXkgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3Qga2V5U3RhcnQgPSBwcm9wcy5lbmQ7XG4gICAgICAgICAgICBjb25zdCBrZXlOb2RlID0ga2V5XG4gICAgICAgICAgICAgICAgPyBjb21wb3NlTm9kZShjdHgsIGtleSwgcHJvcHMsIG9uRXJyb3IpXG4gICAgICAgICAgICAgICAgOiBjb21wb3NlRW1wdHlOb2RlKGN0eCwga2V5U3RhcnQsIHN0YXJ0LCBudWxsLCBwcm9wcywgb25FcnJvcik7XG4gICAgICAgICAgICBpZiAoaXNCbG9jayhrZXkpKVxuICAgICAgICAgICAgICAgIG9uRXJyb3Ioa2V5Tm9kZS5yYW5nZSwgJ0JMT0NLX0lOX0ZMT1cnLCBibG9ja01zZyk7XG4gICAgICAgICAgICBjdHguYXRLZXkgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIHZhbHVlIHByb3BlcnRpZXNcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlUHJvcHMgPSByZXNvbHZlUHJvcHMucmVzb2x2ZVByb3BzKHNlcCA/PyBbXSwge1xuICAgICAgICAgICAgICAgIGZsb3c6IGZjTmFtZSxcbiAgICAgICAgICAgICAgICBpbmRpY2F0b3I6ICdtYXAtdmFsdWUtaW5kJyxcbiAgICAgICAgICAgICAgICBuZXh0OiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IGtleU5vZGUucmFuZ2VbMl0sXG4gICAgICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgICAgICBwYXJlbnRJbmRlbnQ6IGZjLmluZGVudCxcbiAgICAgICAgICAgICAgICBzdGFydE9uTmV3bGluZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHZhbHVlUHJvcHMuZm91bmQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTWFwICYmICFwcm9wcy5mb3VuZCAmJiBjdHgub3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcClcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3Qgb2Ygc2VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0ID09PSB2YWx1ZVByb3BzLmZvdW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3QudHlwZSA9PT0gJ25ld2xpbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3Ioc3QsICdNVUxUSUxJTkVfSU1QTElDSVRfS0VZJywgJ0ltcGxpY2l0IGtleXMgb2YgZmxvdyBzZXF1ZW5jZSBwYWlycyBuZWVkIHRvIGJlIG9uIGEgc2luZ2xlIGxpbmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcHMuc3RhcnQgPCB2YWx1ZVByb3BzLmZvdW5kLm9mZnNldCAtIDEwMjQpXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHZhbHVlUHJvcHMuZm91bmQsICdLRVlfT1ZFUl8xMDI0X0NIQVJTJywgJ1RoZSA6IGluZGljYXRvciBtdXN0IGJlIGF0IG1vc3QgMTAyNCBjaGFycyBhZnRlciB0aGUgc3RhcnQgb2YgYW4gaW1wbGljaXQgZmxvdyBzZXF1ZW5jZSBrZXknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICgnc291cmNlJyBpbiB2YWx1ZSAmJiB2YWx1ZS5zb3VyY2U/LlswXSA9PT0gJzonKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHZhbHVlLCAnTUlTU0lOR19DSEFSJywgYE1pc3Npbmcgc3BhY2UgYWZ0ZXIgOiBpbiAke2ZjTmFtZX1gKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodmFsdWVQcm9wcy5zdGFydCwgJ01JU1NJTkdfQ0hBUicsIGBNaXNzaW5nICwgb3IgOiBiZXR3ZWVuICR7ZmNOYW1lfSBpdGVtc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdmFsdWUgdmFsdWVcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlTm9kZSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgPyBjb21wb3NlTm9kZShjdHgsIHZhbHVlLCB2YWx1ZVByb3BzLCBvbkVycm9yKVxuICAgICAgICAgICAgICAgIDogdmFsdWVQcm9wcy5mb3VuZFxuICAgICAgICAgICAgICAgICAgICA/IGNvbXBvc2VFbXB0eU5vZGUoY3R4LCB2YWx1ZVByb3BzLmVuZCwgc2VwLCBudWxsLCB2YWx1ZVByb3BzLCBvbkVycm9yKVxuICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICBpZiAodmFsdWVOb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQmxvY2sodmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHZhbHVlTm9kZS5yYW5nZSwgJ0JMT0NLX0lOX0ZMT1cnLCBibG9ja01zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZVByb3BzLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5Tm9kZS5jb21tZW50KVxuICAgICAgICAgICAgICAgICAgICBrZXlOb2RlLmNvbW1lbnQgKz0gJ1xcbicgKyB2YWx1ZVByb3BzLmNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBrZXlOb2RlLmNvbW1lbnQgPSB2YWx1ZVByb3BzLmNvbW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYWlyID0gbmV3IFBhaXIuUGFpcihrZXlOb2RlLCB2YWx1ZU5vZGUpO1xuICAgICAgICAgICAgaWYgKGN0eC5vcHRpb25zLmtlZXBTb3VyY2VUb2tlbnMpXG4gICAgICAgICAgICAgICAgcGFpci5zcmNUb2tlbiA9IGNvbGxJdGVtO1xuICAgICAgICAgICAgaWYgKGlzTWFwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFwID0gY29sbDtcbiAgICAgICAgICAgICAgICBpZiAodXRpbE1hcEluY2x1ZGVzLm1hcEluY2x1ZGVzKGN0eCwgbWFwLml0ZW1zLCBrZXlOb2RlKSlcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihrZXlTdGFydCwgJ0RVUExJQ0FURV9LRVknLCAnTWFwIGtleXMgbXVzdCBiZSB1bmlxdWUnKTtcbiAgICAgICAgICAgICAgICBtYXAuaXRlbXMucHVzaChwYWlyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcCA9IG5ldyBZQU1MTWFwLllBTUxNYXAoY3R4LnNjaGVtYSk7XG4gICAgICAgICAgICAgICAgbWFwLmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHBhaXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZFJhbmdlID0gKHZhbHVlTm9kZSA/PyBrZXlOb2RlKS5yYW5nZTtcbiAgICAgICAgICAgICAgICBtYXAucmFuZ2UgPSBba2V5Tm9kZS5yYW5nZVswXSwgZW5kUmFuZ2VbMV0sIGVuZFJhbmdlWzJdXTtcbiAgICAgICAgICAgICAgICBjb2xsLml0ZW1zLnB1c2gobWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCA9IHZhbHVlTm9kZSA/IHZhbHVlTm9kZS5yYW5nZVsyXSA6IHZhbHVlUHJvcHMuZW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGV4cGVjdGVkRW5kID0gaXNNYXAgPyAnfScgOiAnXSc7XG4gICAgY29uc3QgW2NlLCAuLi5lZV0gPSBmYy5lbmQ7XG4gICAgbGV0IGNlUG9zID0gb2Zmc2V0O1xuICAgIGlmIChjZT8uc291cmNlID09PSBleHBlY3RlZEVuZClcbiAgICAgICAgY2VQb3MgPSBjZS5vZmZzZXQgKyBjZS5zb3VyY2UubGVuZ3RoO1xuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBuYW1lID0gZmNOYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBmY05hbWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICBjb25zdCBtc2cgPSBhdFJvb3RcbiAgICAgICAgICAgID8gYCR7bmFtZX0gbXVzdCBlbmQgd2l0aCBhICR7ZXhwZWN0ZWRFbmR9YFxuICAgICAgICAgICAgOiBgJHtuYW1lfSBpbiBibG9jayBjb2xsZWN0aW9uIG11c3QgYmUgc3VmZmljaWVudGx5IGluZGVudGVkIGFuZCBlbmQgd2l0aCBhICR7ZXhwZWN0ZWRFbmR9YDtcbiAgICAgICAgb25FcnJvcihvZmZzZXQsIGF0Um9vdCA/ICdNSVNTSU5HX0NIQVInIDogJ0JBRF9JTkRFTlQnLCBtc2cpO1xuICAgICAgICBpZiAoY2UgJiYgY2Uuc291cmNlLmxlbmd0aCAhPT0gMSlcbiAgICAgICAgICAgIGVlLnVuc2hpZnQoY2UpO1xuICAgIH1cbiAgICBpZiAoZWUubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBlbmQgPSByZXNvbHZlRW5kLnJlc29sdmVFbmQoZWUsIGNlUG9zLCBjdHgub3B0aW9ucy5zdHJpY3QsIG9uRXJyb3IpO1xuICAgICAgICBpZiAoZW5kLmNvbW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChjb2xsLmNvbW1lbnQpXG4gICAgICAgICAgICAgICAgY29sbC5jb21tZW50ICs9ICdcXG4nICsgZW5kLmNvbW1lbnQ7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY29sbC5jb21tZW50ID0gZW5kLmNvbW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29sbC5yYW5nZSA9IFtmYy5vZmZzZXQsIGNlUG9zLCBlbmQub2Zmc2V0XTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbGwucmFuZ2UgPSBbZmMub2Zmc2V0LCBjZVBvcywgY2VQb3NdO1xuICAgIH1cbiAgICByZXR1cm4gY29sbDtcbn1cblxuZXhwb3J0cy5yZXNvbHZlRmxvd0NvbGxlY3Rpb24gPSByZXNvbHZlRmxvd0NvbGxlY3Rpb247XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi4vbm9kZXMvaWRlbnRpdHkuanMnKTtcbnZhciBTY2FsYXIgPSByZXF1aXJlKCcuLi9ub2Rlcy9TY2FsYXIuanMnKTtcbnZhciBZQU1MTWFwID0gcmVxdWlyZSgnLi4vbm9kZXMvWUFNTE1hcC5qcycpO1xudmFyIFlBTUxTZXEgPSByZXF1aXJlKCcuLi9ub2Rlcy9ZQU1MU2VxLmpzJyk7XG52YXIgcmVzb2x2ZUJsb2NrTWFwID0gcmVxdWlyZSgnLi9yZXNvbHZlLWJsb2NrLW1hcC5qcycpO1xudmFyIHJlc29sdmVCbG9ja1NlcSA9IHJlcXVpcmUoJy4vcmVzb2x2ZS1ibG9jay1zZXEuanMnKTtcbnZhciByZXNvbHZlRmxvd0NvbGxlY3Rpb24gPSByZXF1aXJlKCcuL3Jlc29sdmUtZmxvdy1jb2xsZWN0aW9uLmpzJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVDb2xsZWN0aW9uKENOLCBjdHgsIHRva2VuLCBvbkVycm9yLCB0YWdOYW1lLCB0YWcpIHtcbiAgICBjb25zdCBjb2xsID0gdG9rZW4udHlwZSA9PT0gJ2Jsb2NrLW1hcCdcbiAgICAgICAgPyByZXNvbHZlQmxvY2tNYXAucmVzb2x2ZUJsb2NrTWFwKENOLCBjdHgsIHRva2VuLCBvbkVycm9yLCB0YWcpXG4gICAgICAgIDogdG9rZW4udHlwZSA9PT0gJ2Jsb2NrLXNlcSdcbiAgICAgICAgICAgID8gcmVzb2x2ZUJsb2NrU2VxLnJlc29sdmVCbG9ja1NlcShDTiwgY3R4LCB0b2tlbiwgb25FcnJvciwgdGFnKVxuICAgICAgICAgICAgOiByZXNvbHZlRmxvd0NvbGxlY3Rpb24ucmVzb2x2ZUZsb3dDb2xsZWN0aW9uKENOLCBjdHgsIHRva2VuLCBvbkVycm9yLCB0YWcpO1xuICAgIGNvbnN0IENvbGwgPSBjb2xsLmNvbnN0cnVjdG9yO1xuICAgIC8vIElmIHdlIGdvdCBhIHRhZ05hbWUgbWF0Y2hpbmcgdGhlIGNsYXNzLCBvciB0aGUgdGFnIG5hbWUgaXMgJyEnLFxuICAgIC8vIHRoZW4gdXNlIHRoZSB0YWdOYW1lIGZyb20gdGhlIG5vZGUgY2xhc3MgdXNlZCB0byBjcmVhdGUgaXQuXG4gICAgaWYgKHRhZ05hbWUgPT09ICchJyB8fCB0YWdOYW1lID09PSBDb2xsLnRhZ05hbWUpIHtcbiAgICAgICAgY29sbC50YWcgPSBDb2xsLnRhZ05hbWU7XG4gICAgICAgIHJldHVybiBjb2xsO1xuICAgIH1cbiAgICBpZiAodGFnTmFtZSlcbiAgICAgICAgY29sbC50YWcgPSB0YWdOYW1lO1xuICAgIHJldHVybiBjb2xsO1xufVxuZnVuY3Rpb24gY29tcG9zZUNvbGxlY3Rpb24oQ04sIGN0eCwgdG9rZW4sIHByb3BzLCBvbkVycm9yKSB7XG4gICAgY29uc3QgdGFnVG9rZW4gPSBwcm9wcy50YWc7XG4gICAgY29uc3QgdGFnTmFtZSA9ICF0YWdUb2tlblxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiBjdHguZGlyZWN0aXZlcy50YWdOYW1lKHRhZ1Rva2VuLnNvdXJjZSwgbXNnID0+IG9uRXJyb3IodGFnVG9rZW4sICdUQUdfUkVTT0xWRV9GQUlMRUQnLCBtc2cpKTtcbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2Jsb2NrLXNlcScpIHtcbiAgICAgICAgY29uc3QgeyBhbmNob3IsIG5ld2xpbmVBZnRlclByb3A6IG5sIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgbGFzdFByb3AgPSBhbmNob3IgJiYgdGFnVG9rZW5cbiAgICAgICAgICAgID8gYW5jaG9yLm9mZnNldCA+IHRhZ1Rva2VuLm9mZnNldFxuICAgICAgICAgICAgICAgID8gYW5jaG9yXG4gICAgICAgICAgICAgICAgOiB0YWdUb2tlblxuICAgICAgICAgICAgOiAoYW5jaG9yID8/IHRhZ1Rva2VuKTtcbiAgICAgICAgaWYgKGxhc3RQcm9wICYmICghbmwgfHwgbmwub2Zmc2V0IDwgbGFzdFByb3Aub2Zmc2V0KSkge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdNaXNzaW5nIG5ld2xpbmUgYWZ0ZXIgYmxvY2sgc2VxdWVuY2UgcHJvcHMnO1xuICAgICAgICAgICAgb25FcnJvcihsYXN0UHJvcCwgJ01JU1NJTkdfQ0hBUicsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGV4cFR5cGUgPSB0b2tlbi50eXBlID09PSAnYmxvY2stbWFwJ1xuICAgICAgICA/ICdtYXAnXG4gICAgICAgIDogdG9rZW4udHlwZSA9PT0gJ2Jsb2NrLXNlcSdcbiAgICAgICAgICAgID8gJ3NlcSdcbiAgICAgICAgICAgIDogdG9rZW4uc3RhcnQuc291cmNlID09PSAneydcbiAgICAgICAgICAgICAgICA/ICdtYXAnXG4gICAgICAgICAgICAgICAgOiAnc2VxJztcbiAgICAvLyBzaG9ydGN1dDogY2hlY2sgaWYgaXQncyBhIGdlbmVyaWMgWUFNTE1hcCBvciBZQU1MU2VxXG4gICAgLy8gYmVmb3JlIGp1bXBpbmcgaW50byB0aGUgY3VzdG9tIHRhZyBsb2dpYy5cbiAgICBpZiAoIXRhZ1Rva2VuIHx8XG4gICAgICAgICF0YWdOYW1lIHx8XG4gICAgICAgIHRhZ05hbWUgPT09ICchJyB8fFxuICAgICAgICAodGFnTmFtZSA9PT0gWUFNTE1hcC5ZQU1MTWFwLnRhZ05hbWUgJiYgZXhwVHlwZSA9PT0gJ21hcCcpIHx8XG4gICAgICAgICh0YWdOYW1lID09PSBZQU1MU2VxLllBTUxTZXEudGFnTmFtZSAmJiBleHBUeXBlID09PSAnc2VxJykpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVDb2xsZWN0aW9uKENOLCBjdHgsIHRva2VuLCBvbkVycm9yLCB0YWdOYW1lKTtcbiAgICB9XG4gICAgbGV0IHRhZyA9IGN0eC5zY2hlbWEudGFncy5maW5kKHQgPT4gdC50YWcgPT09IHRhZ05hbWUgJiYgdC5jb2xsZWN0aW9uID09PSBleHBUeXBlKTtcbiAgICBpZiAoIXRhZykge1xuICAgICAgICBjb25zdCBrdCA9IGN0eC5zY2hlbWEua25vd25UYWdzW3RhZ05hbWVdO1xuICAgICAgICBpZiAoa3Q/LmNvbGxlY3Rpb24gPT09IGV4cFR5cGUpIHtcbiAgICAgICAgICAgIGN0eC5zY2hlbWEudGFncy5wdXNoKE9iamVjdC5hc3NpZ24oe30sIGt0LCB7IGRlZmF1bHQ6IGZhbHNlIH0pKTtcbiAgICAgICAgICAgIHRhZyA9IGt0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGt0KSB7XG4gICAgICAgICAgICAgICAgb25FcnJvcih0YWdUb2tlbiwgJ0JBRF9DT0xMRUNUSU9OX1RZUEUnLCBgJHtrdC50YWd9IHVzZWQgZm9yICR7ZXhwVHlwZX0gY29sbGVjdGlvbiwgYnV0IGV4cGVjdHMgJHtrdC5jb2xsZWN0aW9uID8/ICdzY2FsYXInfWAsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb25FcnJvcih0YWdUb2tlbiwgJ1RBR19SRVNPTFZFX0ZBSUxFRCcsIGBVbnJlc29sdmVkIHRhZzogJHt0YWdOYW1lfWAsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVDb2xsZWN0aW9uKENOLCBjdHgsIHRva2VuLCBvbkVycm9yLCB0YWdOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjb2xsID0gcmVzb2x2ZUNvbGxlY3Rpb24oQ04sIGN0eCwgdG9rZW4sIG9uRXJyb3IsIHRhZ05hbWUsIHRhZyk7XG4gICAgY29uc3QgcmVzID0gdGFnLnJlc29sdmU/Lihjb2xsLCBtc2cgPT4gb25FcnJvcih0YWdUb2tlbiwgJ1RBR19SRVNPTFZFX0ZBSUxFRCcsIG1zZyksIGN0eC5vcHRpb25zKSA/PyBjb2xsO1xuICAgIGNvbnN0IG5vZGUgPSBpZGVudGl0eS5pc05vZGUocmVzKVxuICAgICAgICA/IHJlc1xuICAgICAgICA6IG5ldyBTY2FsYXIuU2NhbGFyKHJlcyk7XG4gICAgbm9kZS5yYW5nZSA9IGNvbGwucmFuZ2U7XG4gICAgbm9kZS50YWcgPSB0YWdOYW1lO1xuICAgIGlmICh0YWc/LmZvcm1hdClcbiAgICAgICAgbm9kZS5mb3JtYXQgPSB0YWcuZm9ybWF0O1xuICAgIHJldHVybiBub2RlO1xufVxuXG5leHBvcnRzLmNvbXBvc2VDb2xsZWN0aW9uID0gY29tcG9zZUNvbGxlY3Rpb247XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIFNjYWxhciA9IHJlcXVpcmUoJy4uL25vZGVzL1NjYWxhci5qcycpO1xuXG5mdW5jdGlvbiByZXNvbHZlQmxvY2tTY2FsYXIoY3R4LCBzY2FsYXIsIG9uRXJyb3IpIHtcbiAgICBjb25zdCBzdGFydCA9IHNjYWxhci5vZmZzZXQ7XG4gICAgY29uc3QgaGVhZGVyID0gcGFyc2VCbG9ja1NjYWxhckhlYWRlcihzY2FsYXIsIGN0eC5vcHRpb25zLnN0cmljdCwgb25FcnJvcik7XG4gICAgaWYgKCFoZWFkZXIpXG4gICAgICAgIHJldHVybiB7IHZhbHVlOiAnJywgdHlwZTogbnVsbCwgY29tbWVudDogJycsIHJhbmdlOiBbc3RhcnQsIHN0YXJ0LCBzdGFydF0gfTtcbiAgICBjb25zdCB0eXBlID0gaGVhZGVyLm1vZGUgPT09ICc+JyA/IFNjYWxhci5TY2FsYXIuQkxPQ0tfRk9MREVEIDogU2NhbGFyLlNjYWxhci5CTE9DS19MSVRFUkFMO1xuICAgIGNvbnN0IGxpbmVzID0gc2NhbGFyLnNvdXJjZSA/IHNwbGl0TGluZXMoc2NhbGFyLnNvdXJjZSkgOiBbXTtcbiAgICAvLyBkZXRlcm1pbmUgdGhlIGVuZCBvZiBjb250ZW50ICYgc3RhcnQgb2YgY2hvbXBpbmdcbiAgICBsZXQgY2hvbXBTdGFydCA9IGxpbmVzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gbGluZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGxpbmVzW2ldWzFdO1xuICAgICAgICBpZiAoY29udGVudCA9PT0gJycgfHwgY29udGVudCA9PT0gJ1xccicpXG4gICAgICAgICAgICBjaG9tcFN0YXJ0ID0gaTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIHNob3J0Y3V0IGZvciBlbXB0eSBjb250ZW50c1xuICAgIGlmIChjaG9tcFN0YXJ0ID09PSAwKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaGVhZGVyLmNob21wID09PSAnKycgJiYgbGluZXMubGVuZ3RoID4gMFxuICAgICAgICAgICAgPyAnXFxuJy5yZXBlYXQoTWF0aC5tYXgoMSwgbGluZXMubGVuZ3RoIC0gMSkpXG4gICAgICAgICAgICA6ICcnO1xuICAgICAgICBsZXQgZW5kID0gc3RhcnQgKyBoZWFkZXIubGVuZ3RoO1xuICAgICAgICBpZiAoc2NhbGFyLnNvdXJjZSlcbiAgICAgICAgICAgIGVuZCArPSBzY2FsYXIuc291cmNlLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWUsIHR5cGUsIGNvbW1lbnQ6IGhlYWRlci5jb21tZW50LCByYW5nZTogW3N0YXJ0LCBlbmQsIGVuZF0gfTtcbiAgICB9XG4gICAgLy8gZmluZCB0aGUgaW5kZW50YXRpb24gbGV2ZWwgdG8gdHJpbSBmcm9tIHN0YXJ0XG4gICAgbGV0IHRyaW1JbmRlbnQgPSBzY2FsYXIuaW5kZW50ICsgaGVhZGVyLmluZGVudDtcbiAgICBsZXQgb2Zmc2V0ID0gc2NhbGFyLm9mZnNldCArIGhlYWRlci5sZW5ndGg7XG4gICAgbGV0IGNvbnRlbnRTdGFydCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaG9tcFN0YXJ0OyArK2kpIHtcbiAgICAgICAgY29uc3QgW2luZGVudCwgY29udGVudF0gPSBsaW5lc1tpXTtcbiAgICAgICAgaWYgKGNvbnRlbnQgPT09ICcnIHx8IGNvbnRlbnQgPT09ICdcXHInKSB7XG4gICAgICAgICAgICBpZiAoaGVhZGVyLmluZGVudCA9PT0gMCAmJiBpbmRlbnQubGVuZ3RoID4gdHJpbUluZGVudClcbiAgICAgICAgICAgICAgICB0cmltSW5kZW50ID0gaW5kZW50Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpbmRlbnQubGVuZ3RoIDwgdHJpbUluZGVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnQmxvY2sgc2NhbGFycyB3aXRoIG1vcmUtaW5kZW50ZWQgbGVhZGluZyBlbXB0eSBsaW5lcyBtdXN0IHVzZSBhbiBleHBsaWNpdCBpbmRlbnRhdGlvbiBpbmRpY2F0b3InO1xuICAgICAgICAgICAgICAgIG9uRXJyb3Iob2Zmc2V0ICsgaW5kZW50Lmxlbmd0aCwgJ01JU1NJTkdfQ0hBUicsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhlYWRlci5pbmRlbnQgPT09IDApXG4gICAgICAgICAgICAgICAgdHJpbUluZGVudCA9IGluZGVudC5sZW5ndGg7XG4gICAgICAgICAgICBjb250ZW50U3RhcnQgPSBpO1xuICAgICAgICAgICAgaWYgKHRyaW1JbmRlbnQgPT09IDAgJiYgIWN0eC5hdFJvb3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0Jsb2NrIHNjYWxhciB2YWx1ZXMgaW4gY29sbGVjdGlvbnMgbXVzdCBiZSBpbmRlbnRlZCc7XG4gICAgICAgICAgICAgICAgb25FcnJvcihvZmZzZXQsICdCQURfSU5ERU5UJywgbWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gaW5kZW50Lmxlbmd0aCArIGNvbnRlbnQubGVuZ3RoICsgMTtcbiAgICB9XG4gICAgLy8gaW5jbHVkZSB0cmFpbGluZyBtb3JlLWluZGVudGVkIGVtcHR5IGxpbmVzIGluIGNvbnRlbnRcbiAgICBmb3IgKGxldCBpID0gbGluZXMubGVuZ3RoIC0gMTsgaSA+PSBjaG9tcFN0YXJ0OyAtLWkpIHtcbiAgICAgICAgaWYgKGxpbmVzW2ldWzBdLmxlbmd0aCA+IHRyaW1JbmRlbnQpXG4gICAgICAgICAgICBjaG9tcFN0YXJ0ID0gaSArIDE7XG4gICAgfVxuICAgIGxldCB2YWx1ZSA9ICcnO1xuICAgIGxldCBzZXAgPSAnJztcbiAgICBsZXQgcHJldk1vcmVJbmRlbnRlZCA9IGZhbHNlO1xuICAgIC8vIGxlYWRpbmcgd2hpdGVzcGFjZSBpcyBrZXB0IGludGFjdFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGVudFN0YXJ0OyArK2kpXG4gICAgICAgIHZhbHVlICs9IGxpbmVzW2ldWzBdLnNsaWNlKHRyaW1JbmRlbnQpICsgJ1xcbic7XG4gICAgZm9yIChsZXQgaSA9IGNvbnRlbnRTdGFydDsgaSA8IGNob21wU3RhcnQ7ICsraSkge1xuICAgICAgICBsZXQgW2luZGVudCwgY29udGVudF0gPSBsaW5lc1tpXTtcbiAgICAgICAgb2Zmc2V0ICs9IGluZGVudC5sZW5ndGggKyBjb250ZW50Lmxlbmd0aCArIDE7XG4gICAgICAgIGNvbnN0IGNybGYgPSBjb250ZW50W2NvbnRlbnQubGVuZ3RoIC0gMV0gPT09ICdcXHInO1xuICAgICAgICBpZiAoY3JsZilcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDAsIC0xKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmIGFscmVhZHkgY2F1Z2h0IGluIGxleGVyICovXG4gICAgICAgIGlmIChjb250ZW50ICYmIGluZGVudC5sZW5ndGggPCB0cmltSW5kZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzcmMgPSBoZWFkZXIuaW5kZW50XG4gICAgICAgICAgICAgICAgPyAnZXhwbGljaXQgaW5kZW50YXRpb24gaW5kaWNhdG9yJ1xuICAgICAgICAgICAgICAgIDogJ2ZpcnN0IGxpbmUnO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBCbG9jayBzY2FsYXIgbGluZXMgbXVzdCBub3QgYmUgbGVzcyBpbmRlbnRlZCB0aGFuIHRoZWlyICR7c3JjfWA7XG4gICAgICAgICAgICBvbkVycm9yKG9mZnNldCAtIGNvbnRlbnQubGVuZ3RoIC0gKGNybGYgPyAyIDogMSksICdCQURfSU5ERU5UJywgbWVzc2FnZSk7XG4gICAgICAgICAgICBpbmRlbnQgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gU2NhbGFyLlNjYWxhci5CTE9DS19MSVRFUkFMKSB7XG4gICAgICAgICAgICB2YWx1ZSArPSBzZXAgKyBpbmRlbnQuc2xpY2UodHJpbUluZGVudCkgKyBjb250ZW50O1xuICAgICAgICAgICAgc2VwID0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5kZW50Lmxlbmd0aCA+IHRyaW1JbmRlbnQgfHwgY29udGVudFswXSA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICAgIC8vIG1vcmUtaW5kZW50ZWQgY29udGVudCB3aXRoaW4gYSBmb2xkZWQgYmxvY2tcbiAgICAgICAgICAgIGlmIChzZXAgPT09ICcgJylcbiAgICAgICAgICAgICAgICBzZXAgPSAnXFxuJztcbiAgICAgICAgICAgIGVsc2UgaWYgKCFwcmV2TW9yZUluZGVudGVkICYmIHNlcCA9PT0gJ1xcbicpXG4gICAgICAgICAgICAgICAgc2VwID0gJ1xcblxcbic7XG4gICAgICAgICAgICB2YWx1ZSArPSBzZXAgKyBpbmRlbnQuc2xpY2UodHJpbUluZGVudCkgKyBjb250ZW50O1xuICAgICAgICAgICAgc2VwID0gJ1xcbic7XG4gICAgICAgICAgICBwcmV2TW9yZUluZGVudGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250ZW50ID09PSAnJykge1xuICAgICAgICAgICAgLy8gZW1wdHkgbGluZVxuICAgICAgICAgICAgaWYgKHNlcCA9PT0gJ1xcbicpXG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gJ1xcbic7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc2VwID0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSArPSBzZXAgKyBjb250ZW50O1xuICAgICAgICAgICAgc2VwID0gJyAnO1xuICAgICAgICAgICAgcHJldk1vcmVJbmRlbnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAoaGVhZGVyLmNob21wKSB7XG4gICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGNob21wU3RhcnQ7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSAnXFxuJyArIGxpbmVzW2ldWzBdLnNsaWNlKHRyaW1JbmRlbnQpO1xuICAgICAgICAgICAgaWYgKHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdICE9PSAnXFxuJylcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSAnXFxuJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFsdWUgKz0gJ1xcbic7XG4gICAgfVxuICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgaGVhZGVyLmxlbmd0aCArIHNjYWxhci5zb3VyY2UubGVuZ3RoO1xuICAgIHJldHVybiB7IHZhbHVlLCB0eXBlLCBjb21tZW50OiBoZWFkZXIuY29tbWVudCwgcmFuZ2U6IFtzdGFydCwgZW5kLCBlbmRdIH07XG59XG5mdW5jdGlvbiBwYXJzZUJsb2NrU2NhbGFySGVhZGVyKHsgb2Zmc2V0LCBwcm9wcyB9LCBzdHJpY3QsIG9uRXJyb3IpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICBpZiAocHJvcHNbMF0udHlwZSAhPT0gJ2Jsb2NrLXNjYWxhci1oZWFkZXInKSB7XG4gICAgICAgIG9uRXJyb3IocHJvcHNbMF0sICdJTVBPU1NJQkxFJywgJ0Jsb2NrIHNjYWxhciBoZWFkZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7IHNvdXJjZSB9ID0gcHJvcHNbMF07XG4gICAgY29uc3QgbW9kZSA9IHNvdXJjZVswXTtcbiAgICBsZXQgaW5kZW50ID0gMDtcbiAgICBsZXQgY2hvbXAgPSAnJztcbiAgICBsZXQgZXJyb3IgPSAtMTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNvdXJjZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBjaCA9IHNvdXJjZVtpXTtcbiAgICAgICAgaWYgKCFjaG9tcCAmJiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJysnKSlcbiAgICAgICAgICAgIGNob21wID0gY2g7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbiA9IE51bWJlcihjaCk7XG4gICAgICAgICAgICBpZiAoIWluZGVudCAmJiBuKVxuICAgICAgICAgICAgICAgIGluZGVudCA9IG47XG4gICAgICAgICAgICBlbHNlIGlmIChlcnJvciA9PT0gLTEpXG4gICAgICAgICAgICAgICAgZXJyb3IgPSBvZmZzZXQgKyBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlcnJvciAhPT0gLTEpXG4gICAgICAgIG9uRXJyb3IoZXJyb3IsICdVTkVYUEVDVEVEX1RPS0VOJywgYEJsb2NrIHNjYWxhciBoZWFkZXIgaW5jbHVkZXMgZXh0cmEgY2hhcmFjdGVyczogJHtzb3VyY2V9YCk7XG4gICAgbGV0IGhhc1NwYWNlID0gZmFsc2U7XG4gICAgbGV0IGNvbW1lbnQgPSAnJztcbiAgICBsZXQgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHByb3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gcHJvcHNbaV07XG4gICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgICAgIGhhc1NwYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICBsZW5ndGggKz0gdG9rZW4uc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIWhhc1NwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnQ29tbWVudHMgbXVzdCBiZSBzZXBhcmF0ZWQgZnJvbSBvdGhlciB0b2tlbnMgYnkgd2hpdGUgc3BhY2UgY2hhcmFjdGVycyc7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdNSVNTSU5HX0NIQVInLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGVuZ3RoICs9IHRva2VuLnNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29tbWVudCA9IHRva2VuLnNvdXJjZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ1VORVhQRUNURURfVE9LRU4nLCB0b2tlbi5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBsZW5ndGggKz0gdG9rZW4uc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IHNob3VsZCBub3QgaGFwcGVuICovXG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBVbmV4cGVjdGVkIHRva2VuIGluIGJsb2NrIHNjYWxhciBoZWFkZXI6ICR7dG9rZW4udHlwZX1gO1xuICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdVTkVYUEVDVEVEX1RPS0VOJywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHMgPSB0b2tlbi5zb3VyY2U7XG4gICAgICAgICAgICAgICAgaWYgKHRzICYmIHR5cGVvZiB0cyA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCArPSB0cy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbW9kZSwgaW5kZW50LCBjaG9tcCwgY29tbWVudCwgbGVuZ3RoIH07XG59XG4vKiogQHJldHVybnMgQXJyYXkgb2YgbGluZXMgc3BsaXQgdXAgYXMgYFtpbmRlbnQsIGNvbnRlbnRdYCAqL1xuZnVuY3Rpb24gc3BsaXRMaW5lcyhzb3VyY2UpIHtcbiAgICBjb25zdCBzcGxpdCA9IHNvdXJjZS5zcGxpdCgvXFxuKCAqKS8pO1xuICAgIGNvbnN0IGZpcnN0ID0gc3BsaXRbMF07XG4gICAgY29uc3QgbSA9IGZpcnN0Lm1hdGNoKC9eKCAqKS8pO1xuICAgIGNvbnN0IGxpbmUwID0gbT8uWzFdXG4gICAgICAgID8gW21bMV0sIGZpcnN0LnNsaWNlKG1bMV0ubGVuZ3RoKV1cbiAgICAgICAgOiBbJycsIGZpcnN0XTtcbiAgICBjb25zdCBsaW5lcyA9IFtsaW5lMF07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzcGxpdC5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgbGluZXMucHVzaChbc3BsaXRbaV0sIHNwbGl0W2kgKyAxXV0pO1xuICAgIHJldHVybiBsaW5lcztcbn1cblxuZXhwb3J0cy5yZXNvbHZlQmxvY2tTY2FsYXIgPSByZXNvbHZlQmxvY2tTY2FsYXI7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIFNjYWxhciA9IHJlcXVpcmUoJy4uL25vZGVzL1NjYWxhci5qcycpO1xudmFyIHJlc29sdmVFbmQgPSByZXF1aXJlKCcuL3Jlc29sdmUtZW5kLmpzJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVGbG93U2NhbGFyKHNjYWxhciwgc3RyaWN0LCBvbkVycm9yKSB7XG4gICAgY29uc3QgeyBvZmZzZXQsIHR5cGUsIHNvdXJjZSwgZW5kIH0gPSBzY2FsYXI7XG4gICAgbGV0IF90eXBlO1xuICAgIGxldCB2YWx1ZTtcbiAgICBjb25zdCBfb25FcnJvciA9IChyZWwsIGNvZGUsIG1zZykgPT4gb25FcnJvcihvZmZzZXQgKyByZWwsIGNvZGUsIG1zZyk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgICAgICAgICBfdHlwZSA9IFNjYWxhci5TY2FsYXIuUExBSU47XG4gICAgICAgICAgICB2YWx1ZSA9IHBsYWluVmFsdWUoc291cmNlLCBfb25FcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2luZ2xlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgX3R5cGUgPSBTY2FsYXIuU2NhbGFyLlFVT1RFX1NJTkdMRTtcbiAgICAgICAgICAgIHZhbHVlID0gc2luZ2xlUXVvdGVkVmFsdWUoc291cmNlLCBfb25FcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZG91YmxlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgX3R5cGUgPSBTY2FsYXIuU2NhbGFyLlFVT1RFX0RPVUJMRTtcbiAgICAgICAgICAgIHZhbHVlID0gZG91YmxlUXVvdGVkVmFsdWUoc291cmNlLCBfb25FcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIG9uRXJyb3Ioc2NhbGFyLCAnVU5FWFBFQ1RFRF9UT0tFTicsIGBFeHBlY3RlZCBhIGZsb3cgc2NhbGFyIHZhbHVlLCBidXQgZm91bmQ6ICR7dHlwZX1gKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6ICcnLFxuICAgICAgICAgICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgICAgICAgICAgY29tbWVudDogJycsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFtvZmZzZXQsIG9mZnNldCArIHNvdXJjZS5sZW5ndGgsIG9mZnNldCArIHNvdXJjZS5sZW5ndGhdXG4gICAgICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZUVuZCA9IG9mZnNldCArIHNvdXJjZS5sZW5ndGg7XG4gICAgY29uc3QgcmUgPSByZXNvbHZlRW5kLnJlc29sdmVFbmQoZW5kLCB2YWx1ZUVuZCwgc3RyaWN0LCBvbkVycm9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgdHlwZTogX3R5cGUsXG4gICAgICAgIGNvbW1lbnQ6IHJlLmNvbW1lbnQsXG4gICAgICAgIHJhbmdlOiBbb2Zmc2V0LCB2YWx1ZUVuZCwgcmUub2Zmc2V0XVxuICAgIH07XG59XG5mdW5jdGlvbiBwbGFpblZhbHVlKHNvdXJjZSwgb25FcnJvcikge1xuICAgIGxldCBiYWRDaGFyID0gJyc7XG4gICAgc3dpdGNoIChzb3VyY2VbMF0pIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICAgY2FzZSAnXFx0JzpcbiAgICAgICAgICAgIGJhZENoYXIgPSAnYSB0YWIgY2hhcmFjdGVyJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcsJzpcbiAgICAgICAgICAgIGJhZENoYXIgPSAnZmxvdyBpbmRpY2F0b3IgY2hhcmFjdGVyICwnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgYmFkQ2hhciA9ICdkaXJlY3RpdmUgaW5kaWNhdG9yIGNoYXJhY3RlciAlJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd8JzpcbiAgICAgICAgY2FzZSAnPic6IHtcbiAgICAgICAgICAgIGJhZENoYXIgPSBgYmxvY2sgc2NhbGFyIGluZGljYXRvciAke3NvdXJjZVswXX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnQCc6XG4gICAgICAgIGNhc2UgJ2AnOiB7XG4gICAgICAgICAgICBiYWRDaGFyID0gYHJlc2VydmVkIGNoYXJhY3RlciAke3NvdXJjZVswXX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJhZENoYXIpXG4gICAgICAgIG9uRXJyb3IoMCwgJ0JBRF9TQ0FMQVJfU1RBUlQnLCBgUGxhaW4gdmFsdWUgY2Fubm90IHN0YXJ0IHdpdGggJHtiYWRDaGFyfWApO1xuICAgIHJldHVybiBmb2xkTGluZXMoc291cmNlKTtcbn1cbmZ1bmN0aW9uIHNpbmdsZVF1b3RlZFZhbHVlKHNvdXJjZSwgb25FcnJvcikge1xuICAgIGlmIChzb3VyY2Vbc291cmNlLmxlbmd0aCAtIDFdICE9PSBcIidcIiB8fCBzb3VyY2UubGVuZ3RoID09PSAxKVxuICAgICAgICBvbkVycm9yKHNvdXJjZS5sZW5ndGgsICdNSVNTSU5HX0NIQVInLCBcIk1pc3NpbmcgY2xvc2luZyAncXVvdGVcIik7XG4gICAgcmV0dXJuIGZvbGRMaW5lcyhzb3VyY2Uuc2xpY2UoMSwgLTEpKS5yZXBsYWNlKC8nJy9nLCBcIidcIik7XG59XG5mdW5jdGlvbiBmb2xkTGluZXMoc291cmNlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIG5lZ2F0aXZlIGxvb2tiZWhpbmQgaGVyZSBhbmQgaW4gdGhlIGByZWAgUmVnRXhwIGlzIHRvXG4gICAgICogcHJldmVudCBjYXVzaW5nIGEgcG9seW5vbWlhbCBzZWFyY2ggdGltZSBpbiBjZXJ0YWluIGNhc2VzLlxuICAgICAqXG4gICAgICogVGhlIHRyeS1jYXRjaCBpcyBmb3IgU2FmYXJpLCB3aGljaCBkb2Vzbid0IHN1cHBvcnQgdGhpcyB5ZXQ6XG4gICAgICogaHR0cHM6Ly9jYW5pdXNlLmNvbS9qcy1yZWdleHAtbG9va2JlaGluZFxuICAgICAqL1xuICAgIGxldCBmaXJzdCwgbGluZTtcbiAgICB0cnkge1xuICAgICAgICBmaXJzdCA9IG5ldyBSZWdFeHAoJyguKj8pKD88IVsgXFx0XSlbIFxcdF0qXFxyP1xcbicsICdzeScpO1xuICAgICAgICBsaW5lID0gbmV3IFJlZ0V4cCgnWyBcXHRdKiguKj8pKD86KD88IVsgXFx0XSlbIFxcdF0qKT9cXHI/XFxuJywgJ3N5Jyk7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgZmlyc3QgPSAvKC4qPylbIFxcdF0qXFxyP1xcbi9zeTtcbiAgICAgICAgbGluZSA9IC9bIFxcdF0qKC4qPylbIFxcdF0qXFxyP1xcbi9zeTtcbiAgICB9XG4gICAgbGV0IG1hdGNoID0gZmlyc3QuZXhlYyhzb3VyY2UpO1xuICAgIGlmICghbWF0Y2gpXG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgbGV0IHJlcyA9IG1hdGNoWzFdO1xuICAgIGxldCBzZXAgPSAnICc7XG4gICAgbGV0IHBvcyA9IGZpcnN0Lmxhc3RJbmRleDtcbiAgICBsaW5lLmxhc3RJbmRleCA9IHBvcztcbiAgICB3aGlsZSAoKG1hdGNoID0gbGluZS5leGVjKHNvdXJjZSkpKSB7XG4gICAgICAgIGlmIChtYXRjaFsxXSA9PT0gJycpIHtcbiAgICAgICAgICAgIGlmIChzZXAgPT09ICdcXG4nKVxuICAgICAgICAgICAgICAgIHJlcyArPSBzZXA7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc2VwID0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXMgKz0gc2VwICsgbWF0Y2hbMV07XG4gICAgICAgICAgICBzZXAgPSAnICc7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gbGluZS5sYXN0SW5kZXg7XG4gICAgfVxuICAgIGNvbnN0IGxhc3QgPSAvWyBcXHRdKiguKikvc3k7XG4gICAgbGFzdC5sYXN0SW5kZXggPSBwb3M7XG4gICAgbWF0Y2ggPSBsYXN0LmV4ZWMoc291cmNlKTtcbiAgICByZXR1cm4gcmVzICsgc2VwICsgKG1hdGNoPy5bMV0gPz8gJycpO1xufVxuZnVuY3Rpb24gZG91YmxlUXVvdGVkVmFsdWUoc291cmNlLCBvbkVycm9yKSB7XG4gICAgbGV0IHJlcyA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc291cmNlLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICBjb25zdCBjaCA9IHNvdXJjZVtpXTtcbiAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiBzb3VyY2VbaSArIDFdID09PSAnXFxuJylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoY2ggPT09ICdcXG4nKSB7XG4gICAgICAgICAgICBjb25zdCB7IGZvbGQsIG9mZnNldCB9ID0gZm9sZE5ld2xpbmUoc291cmNlLCBpKTtcbiAgICAgICAgICAgIHJlcyArPSBmb2xkO1xuICAgICAgICAgICAgaSA9IG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHNvdXJjZVsrK2ldO1xuICAgICAgICAgICAgY29uc3QgY2MgPSBlc2NhcGVDb2Rlc1tuZXh0XTtcbiAgICAgICAgICAgIGlmIChjYylcbiAgICAgICAgICAgICAgICByZXMgKz0gY2M7XG4gICAgICAgICAgICBlbHNlIGlmIChuZXh0ID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgIC8vIHNraXAgZXNjYXBlZCBuZXdsaW5lcywgYnV0IHN0aWxsIHRyaW0gdGhlIGZvbGxvd2luZyBsaW5lXG4gICAgICAgICAgICAgICAgbmV4dCA9IHNvdXJjZVtpICsgMV07XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHQgPT09ICcgJyB8fCBuZXh0ID09PSAnXFx0JylcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHNvdXJjZVsrK2kgKyAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPT09ICdcXHInICYmIHNvdXJjZVtpICsgMV0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgLy8gc2tpcCBlc2NhcGVkIENSTEYgbmV3bGluZXMsIGJ1dCBzdGlsbCB0cmltIHRoZSBmb2xsb3dpbmcgbGluZVxuICAgICAgICAgICAgICAgIG5leHQgPSBzb3VyY2VbKytpICsgMV07XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHQgPT09ICcgJyB8fCBuZXh0ID09PSAnXFx0JylcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHNvdXJjZVsrK2kgKyAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPT09ICd4JyB8fCBuZXh0ID09PSAndScgfHwgbmV4dCA9PT0gJ1UnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0geyB4OiAyLCB1OiA0LCBVOiA4IH1bbmV4dF07XG4gICAgICAgICAgICAgICAgcmVzICs9IHBhcnNlQ2hhckNvZGUoc291cmNlLCBpICsgMSwgbGVuZ3RoLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICBpICs9IGxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhdyA9IHNvdXJjZS5zdWJzdHIoaSAtIDEsIDIpO1xuICAgICAgICAgICAgICAgIG9uRXJyb3IoaSAtIDEsICdCQURfRFFfRVNDQVBFJywgYEludmFsaWQgZXNjYXBlIHNlcXVlbmNlICR7cmF3fWApO1xuICAgICAgICAgICAgICAgIHJlcyArPSByYXc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICAgIC8vIHRyaW0gdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgICAgICAgY29uc3Qgd3NTdGFydCA9IGk7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHNvdXJjZVtpICsgMV07XG4gICAgICAgICAgICB3aGlsZSAobmV4dCA9PT0gJyAnIHx8IG5leHQgPT09ICdcXHQnKVxuICAgICAgICAgICAgICAgIG5leHQgPSBzb3VyY2VbKytpICsgMV07XG4gICAgICAgICAgICBpZiAobmV4dCAhPT0gJ1xcbicgJiYgIShuZXh0ID09PSAnXFxyJyAmJiBzb3VyY2VbaSArIDJdID09PSAnXFxuJykpXG4gICAgICAgICAgICAgICAgcmVzICs9IGkgPiB3c1N0YXJ0ID8gc291cmNlLnNsaWNlKHdzU3RhcnQsIGkgKyAxKSA6IGNoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzICs9IGNoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzb3VyY2Vbc291cmNlLmxlbmd0aCAtIDFdICE9PSAnXCInIHx8IHNvdXJjZS5sZW5ndGggPT09IDEpXG4gICAgICAgIG9uRXJyb3Ioc291cmNlLmxlbmd0aCwgJ01JU1NJTkdfQ0hBUicsICdNaXNzaW5nIGNsb3NpbmcgXCJxdW90ZScpO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIEZvbGQgYSBzaW5nbGUgbmV3bGluZSBpbnRvIGEgc3BhY2UsIG11bHRpcGxlIG5ld2xpbmVzIHRvIE4gLSAxIG5ld2xpbmVzLlxuICogUHJlc3VtZXMgYHNvdXJjZVtvZmZzZXRdID09PSAnXFxuJ2BcbiAqL1xuZnVuY3Rpb24gZm9sZE5ld2xpbmUoc291cmNlLCBvZmZzZXQpIHtcbiAgICBsZXQgZm9sZCA9ICcnO1xuICAgIGxldCBjaCA9IHNvdXJjZVtvZmZzZXQgKyAxXTtcbiAgICB3aGlsZSAoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcgfHwgY2ggPT09ICdcXG4nIHx8IGNoID09PSAnXFxyJykge1xuICAgICAgICBpZiAoY2ggPT09ICdcXHInICYmIHNvdXJjZVtvZmZzZXQgKyAyXSAhPT0gJ1xcbicpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKGNoID09PSAnXFxuJylcbiAgICAgICAgICAgIGZvbGQgKz0gJ1xcbic7XG4gICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICBjaCA9IHNvdXJjZVtvZmZzZXQgKyAxXTtcbiAgICB9XG4gICAgaWYgKCFmb2xkKVxuICAgICAgICBmb2xkID0gJyAnO1xuICAgIHJldHVybiB7IGZvbGQsIG9mZnNldCB9O1xufVxuY29uc3QgZXNjYXBlQ29kZXMgPSB7XG4gICAgJzAnOiAnXFwwJywgLy8gbnVsbCBjaGFyYWN0ZXJcbiAgICBhOiAnXFx4MDcnLCAvLyBiZWxsIGNoYXJhY3RlclxuICAgIGI6ICdcXGInLCAvLyBiYWNrc3BhY2VcbiAgICBlOiAnXFx4MWInLCAvLyBlc2NhcGUgY2hhcmFjdGVyXG4gICAgZjogJ1xcZicsIC8vIGZvcm0gZmVlZFxuICAgIG46ICdcXG4nLCAvLyBsaW5lIGZlZWRcbiAgICByOiAnXFxyJywgLy8gY2FycmlhZ2UgcmV0dXJuXG4gICAgdDogJ1xcdCcsIC8vIGhvcml6b250YWwgdGFiXG4gICAgdjogJ1xcdicsIC8vIHZlcnRpY2FsIHRhYlxuICAgIE46ICdcXHUwMDg1JywgLy8gVW5pY29kZSBuZXh0IGxpbmVcbiAgICBfOiAnXFx1MDBhMCcsIC8vIFVuaWNvZGUgbm9uLWJyZWFraW5nIHNwYWNlXG4gICAgTDogJ1xcdTIwMjgnLCAvLyBVbmljb2RlIGxpbmUgc2VwYXJhdG9yXG4gICAgUDogJ1xcdTIwMjknLCAvLyBVbmljb2RlIHBhcmFncmFwaCBzZXBhcmF0b3JcbiAgICAnICc6ICcgJyxcbiAgICAnXCInOiAnXCInLFxuICAgICcvJzogJy8nLFxuICAgICdcXFxcJzogJ1xcXFwnLFxuICAgICdcXHQnOiAnXFx0J1xufTtcbmZ1bmN0aW9uIHBhcnNlQ2hhckNvZGUoc291cmNlLCBvZmZzZXQsIGxlbmd0aCwgb25FcnJvcikge1xuICAgIGNvbnN0IGNjID0gc291cmNlLnN1YnN0cihvZmZzZXQsIGxlbmd0aCk7XG4gICAgY29uc3Qgb2sgPSBjYy5sZW5ndGggPT09IGxlbmd0aCAmJiAvXlswLTlhLWZBLUZdKyQvLnRlc3QoY2MpO1xuICAgIGNvbnN0IGNvZGUgPSBvayA/IHBhcnNlSW50KGNjLCAxNikgOiBOYU47XG4gICAgaWYgKGlzTmFOKGNvZGUpKSB7XG4gICAgICAgIGNvbnN0IHJhdyA9IHNvdXJjZS5zdWJzdHIob2Zmc2V0IC0gMiwgbGVuZ3RoICsgMik7XG4gICAgICAgIG9uRXJyb3Iob2Zmc2V0IC0gMiwgJ0JBRF9EUV9FU0NBUEUnLCBgSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UgJHtyYXd9YCk7XG4gICAgICAgIHJldHVybiByYXc7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlKTtcbn1cblxuZXhwb3J0cy5yZXNvbHZlRmxvd1NjYWxhciA9IHJlc29sdmVGbG93U2NhbGFyO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4uL25vZGVzL2lkZW50aXR5LmpzJyk7XG52YXIgU2NhbGFyID0gcmVxdWlyZSgnLi4vbm9kZXMvU2NhbGFyLmpzJyk7XG52YXIgcmVzb2x2ZUJsb2NrU2NhbGFyID0gcmVxdWlyZSgnLi9yZXNvbHZlLWJsb2NrLXNjYWxhci5qcycpO1xudmFyIHJlc29sdmVGbG93U2NhbGFyID0gcmVxdWlyZSgnLi9yZXNvbHZlLWZsb3ctc2NhbGFyLmpzJyk7XG5cbmZ1bmN0aW9uIGNvbXBvc2VTY2FsYXIoY3R4LCB0b2tlbiwgdGFnVG9rZW4sIG9uRXJyb3IpIHtcbiAgICBjb25zdCB7IHZhbHVlLCB0eXBlLCBjb21tZW50LCByYW5nZSB9ID0gdG9rZW4udHlwZSA9PT0gJ2Jsb2NrLXNjYWxhcidcbiAgICAgICAgPyByZXNvbHZlQmxvY2tTY2FsYXIucmVzb2x2ZUJsb2NrU2NhbGFyKGN0eCwgdG9rZW4sIG9uRXJyb3IpXG4gICAgICAgIDogcmVzb2x2ZUZsb3dTY2FsYXIucmVzb2x2ZUZsb3dTY2FsYXIodG9rZW4sIGN0eC5vcHRpb25zLnN0cmljdCwgb25FcnJvcik7XG4gICAgY29uc3QgdGFnTmFtZSA9IHRhZ1Rva2VuXG4gICAgICAgID8gY3R4LmRpcmVjdGl2ZXMudGFnTmFtZSh0YWdUb2tlbi5zb3VyY2UsIG1zZyA9PiBvbkVycm9yKHRhZ1Rva2VuLCAnVEFHX1JFU09MVkVfRkFJTEVEJywgbXNnKSlcbiAgICAgICAgOiBudWxsO1xuICAgIGxldCB0YWc7XG4gICAgaWYgKGN0eC5vcHRpb25zLnN0cmluZ0tleXMgJiYgY3R4LmF0S2V5KSB7XG4gICAgICAgIHRhZyA9IGN0eC5zY2hlbWFbaWRlbnRpdHkuU0NBTEFSXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGFnTmFtZSlcbiAgICAgICAgdGFnID0gZmluZFNjYWxhclRhZ0J5TmFtZShjdHguc2NoZW1hLCB2YWx1ZSwgdGFnTmFtZSwgdGFnVG9rZW4sIG9uRXJyb3IpO1xuICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09ICdzY2FsYXInKVxuICAgICAgICB0YWcgPSBmaW5kU2NhbGFyVGFnQnlUZXN0KGN0eCwgdmFsdWUsIHRva2VuLCBvbkVycm9yKTtcbiAgICBlbHNlXG4gICAgICAgIHRhZyA9IGN0eC5zY2hlbWFbaWRlbnRpdHkuU0NBTEFSXTtcbiAgICBsZXQgc2NhbGFyO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHRhZy5yZXNvbHZlKHZhbHVlLCBtc2cgPT4gb25FcnJvcih0YWdUb2tlbiA/PyB0b2tlbiwgJ1RBR19SRVNPTFZFX0ZBSUxFRCcsIG1zZyksIGN0eC5vcHRpb25zKTtcbiAgICAgICAgc2NhbGFyID0gaWRlbnRpdHkuaXNTY2FsYXIocmVzKSA/IHJlcyA6IG5ldyBTY2FsYXIuU2NhbGFyKHJlcyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBtc2cgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICAgIG9uRXJyb3IodGFnVG9rZW4gPz8gdG9rZW4sICdUQUdfUkVTT0xWRV9GQUlMRUQnLCBtc2cpO1xuICAgICAgICBzY2FsYXIgPSBuZXcgU2NhbGFyLlNjYWxhcih2YWx1ZSk7XG4gICAgfVxuICAgIHNjYWxhci5yYW5nZSA9IHJhbmdlO1xuICAgIHNjYWxhci5zb3VyY2UgPSB2YWx1ZTtcbiAgICBpZiAodHlwZSlcbiAgICAgICAgc2NhbGFyLnR5cGUgPSB0eXBlO1xuICAgIGlmICh0YWdOYW1lKVxuICAgICAgICBzY2FsYXIudGFnID0gdGFnTmFtZTtcbiAgICBpZiAodGFnLmZvcm1hdClcbiAgICAgICAgc2NhbGFyLmZvcm1hdCA9IHRhZy5mb3JtYXQ7XG4gICAgaWYgKGNvbW1lbnQpXG4gICAgICAgIHNjYWxhci5jb21tZW50ID0gY29tbWVudDtcbiAgICByZXR1cm4gc2NhbGFyO1xufVxuZnVuY3Rpb24gZmluZFNjYWxhclRhZ0J5TmFtZShzY2hlbWEsIHZhbHVlLCB0YWdOYW1lLCB0YWdUb2tlbiwgb25FcnJvcikge1xuICAgIGlmICh0YWdOYW1lID09PSAnIScpXG4gICAgICAgIHJldHVybiBzY2hlbWFbaWRlbnRpdHkuU0NBTEFSXTsgLy8gbm9uLXNwZWNpZmljIHRhZ1xuICAgIGNvbnN0IG1hdGNoV2l0aFRlc3QgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHRhZyBvZiBzY2hlbWEudGFncykge1xuICAgICAgICBpZiAoIXRhZy5jb2xsZWN0aW9uICYmIHRhZy50YWcgPT09IHRhZ05hbWUpIHtcbiAgICAgICAgICAgIGlmICh0YWcuZGVmYXVsdCAmJiB0YWcudGVzdClcbiAgICAgICAgICAgICAgICBtYXRjaFdpdGhUZXN0LnB1c2godGFnKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgdGFnIG9mIG1hdGNoV2l0aFRlc3QpXG4gICAgICAgIGlmICh0YWcudGVzdD8udGVzdCh2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gdGFnO1xuICAgIGNvbnN0IGt0ID0gc2NoZW1hLmtub3duVGFnc1t0YWdOYW1lXTtcbiAgICBpZiAoa3QgJiYgIWt0LmNvbGxlY3Rpb24pIHtcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGtub3duIHRhZyBpcyBhdmFpbGFibGUgZm9yIHN0cmluZ2lmeWluZyxcbiAgICAgICAgLy8gYnV0IGRvZXMgbm90IGdldCB1c2VkIGJ5IGRlZmF1bHQuXG4gICAgICAgIHNjaGVtYS50YWdzLnB1c2goT2JqZWN0LmFzc2lnbih7fSwga3QsIHsgZGVmYXVsdDogZmFsc2UsIHRlc3Q6IHVuZGVmaW5lZCB9KSk7XG4gICAgICAgIHJldHVybiBrdDtcbiAgICB9XG4gICAgb25FcnJvcih0YWdUb2tlbiwgJ1RBR19SRVNPTFZFX0ZBSUxFRCcsIGBVbnJlc29sdmVkIHRhZzogJHt0YWdOYW1lfWAsIHRhZ05hbWUgIT09ICd0YWc6eWFtbC5vcmcsMjAwMjpzdHInKTtcbiAgICByZXR1cm4gc2NoZW1hW2lkZW50aXR5LlNDQUxBUl07XG59XG5mdW5jdGlvbiBmaW5kU2NhbGFyVGFnQnlUZXN0KHsgYXRLZXksIGRpcmVjdGl2ZXMsIHNjaGVtYSB9LCB2YWx1ZSwgdG9rZW4sIG9uRXJyb3IpIHtcbiAgICBjb25zdCB0YWcgPSBzY2hlbWEudGFncy5maW5kKHRhZyA9PiAodGFnLmRlZmF1bHQgPT09IHRydWUgfHwgKGF0S2V5ICYmIHRhZy5kZWZhdWx0ID09PSAna2V5JykpICYmXG4gICAgICAgIHRhZy50ZXN0Py50ZXN0KHZhbHVlKSkgfHwgc2NoZW1hW2lkZW50aXR5LlNDQUxBUl07XG4gICAgaWYgKHNjaGVtYS5jb21wYXQpIHtcbiAgICAgICAgY29uc3QgY29tcGF0ID0gc2NoZW1hLmNvbXBhdC5maW5kKHRhZyA9PiB0YWcuZGVmYXVsdCAmJiB0YWcudGVzdD8udGVzdCh2YWx1ZSkpID8/XG4gICAgICAgICAgICBzY2hlbWFbaWRlbnRpdHkuU0NBTEFSXTtcbiAgICAgICAgaWYgKHRhZy50YWcgIT09IGNvbXBhdC50YWcpIHtcbiAgICAgICAgICAgIGNvbnN0IHRzID0gZGlyZWN0aXZlcy50YWdTdHJpbmcodGFnLnRhZyk7XG4gICAgICAgICAgICBjb25zdCBjcyA9IGRpcmVjdGl2ZXMudGFnU3RyaW5nKGNvbXBhdC50YWcpO1xuICAgICAgICAgICAgY29uc3QgbXNnID0gYFZhbHVlIG1heSBiZSBwYXJzZWQgYXMgZWl0aGVyICR7dHN9IG9yICR7Y3N9YDtcbiAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdUQUdfUkVTT0xWRV9GQUlMRUQnLCBtc2csIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YWc7XG59XG5cbmV4cG9ydHMuY29tcG9zZVNjYWxhciA9IGNvbXBvc2VTY2FsYXI7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZW1wdHlTY2FsYXJQb3NpdGlvbihvZmZzZXQsIGJlZm9yZSwgcG9zKSB7XG4gICAgaWYgKGJlZm9yZSkge1xuICAgICAgICBwb3MgPz8gKHBvcyA9IGJlZm9yZS5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIGxldCBzdCA9IGJlZm9yZVtpXTtcbiAgICAgICAgICAgIHN3aXRjaCAoc3QudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0IC09IHN0LnNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGVjaG5pY2FsbHksIGFuIGVtcHR5IHNjYWxhciBpcyBpbW1lZGlhdGVseSBhZnRlciB0aGUgbGFzdCBub24tZW1wdHlcbiAgICAgICAgICAgIC8vIG5vZGUsIGJ1dCBpdCdzIG1vcmUgdXNlZnVsIHRvIHBsYWNlIGl0IGFmdGVyIGFueSB3aGl0ZXNwYWNlLlxuICAgICAgICAgICAgc3QgPSBiZWZvcmVbKytpXTtcbiAgICAgICAgICAgIHdoaWxlIChzdD8udHlwZSA9PT0gJ3NwYWNlJykge1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBzdC5zb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHN0ID0gYmVmb3JlWysraV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0O1xufVxuXG5leHBvcnRzLmVtcHR5U2NhbGFyUG9zaXRpb24gPSBlbXB0eVNjYWxhclBvc2l0aW9uO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBBbGlhcyA9IHJlcXVpcmUoJy4uL25vZGVzL0FsaWFzLmpzJyk7XG52YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuLi9ub2Rlcy9pZGVudGl0eS5qcycpO1xudmFyIGNvbXBvc2VDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi9jb21wb3NlLWNvbGxlY3Rpb24uanMnKTtcbnZhciBjb21wb3NlU2NhbGFyID0gcmVxdWlyZSgnLi9jb21wb3NlLXNjYWxhci5qcycpO1xudmFyIHJlc29sdmVFbmQgPSByZXF1aXJlKCcuL3Jlc29sdmUtZW5kLmpzJyk7XG52YXIgdXRpbEVtcHR5U2NhbGFyUG9zaXRpb24gPSByZXF1aXJlKCcuL3V0aWwtZW1wdHktc2NhbGFyLXBvc2l0aW9uLmpzJyk7XG5cbmNvbnN0IENOID0geyBjb21wb3NlTm9kZSwgY29tcG9zZUVtcHR5Tm9kZSB9O1xuZnVuY3Rpb24gY29tcG9zZU5vZGUoY3R4LCB0b2tlbiwgcHJvcHMsIG9uRXJyb3IpIHtcbiAgICBjb25zdCBhdEtleSA9IGN0eC5hdEtleTtcbiAgICBjb25zdCB7IHNwYWNlQmVmb3JlLCBjb21tZW50LCBhbmNob3IsIHRhZyB9ID0gcHJvcHM7XG4gICAgbGV0IG5vZGU7XG4gICAgbGV0IGlzU3JjVG9rZW4gPSB0cnVlO1xuICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICBjYXNlICdhbGlhcyc6XG4gICAgICAgICAgICBub2RlID0gY29tcG9zZUFsaWFzKGN0eCwgdG9rZW4sIG9uRXJyb3IpO1xuICAgICAgICAgICAgaWYgKGFuY2hvciB8fCB0YWcpXG4gICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ0FMSUFTX1BST1BTJywgJ0FuIGFsaWFzIG5vZGUgbXVzdCBub3Qgc3BlY2lmeSBhbnkgcHJvcGVydGllcycpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgY2FzZSAnZG91YmxlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICBjYXNlICdibG9jay1zY2FsYXInOlxuICAgICAgICAgICAgbm9kZSA9IGNvbXBvc2VTY2FsYXIuY29tcG9zZVNjYWxhcihjdHgsIHRva2VuLCB0YWcsIG9uRXJyb3IpO1xuICAgICAgICAgICAgaWYgKGFuY2hvcilcbiAgICAgICAgICAgICAgICBub2RlLmFuY2hvciA9IGFuY2hvci5zb3VyY2Uuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Jsb2NrLW1hcCc6XG4gICAgICAgIGNhc2UgJ2Jsb2NrLXNlcSc6XG4gICAgICAgIGNhc2UgJ2Zsb3ctY29sbGVjdGlvbic6XG4gICAgICAgICAgICBub2RlID0gY29tcG9zZUNvbGxlY3Rpb24uY29tcG9zZUNvbGxlY3Rpb24oQ04sIGN0eCwgdG9rZW4sIHByb3BzLCBvbkVycm9yKTtcbiAgICAgICAgICAgIGlmIChhbmNob3IpXG4gICAgICAgICAgICAgICAgbm9kZS5hbmNob3IgPSBhbmNob3Iuc291cmNlLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gdG9rZW4udHlwZSA9PT0gJ2Vycm9yJ1xuICAgICAgICAgICAgICAgID8gdG9rZW4ubWVzc2FnZVxuICAgICAgICAgICAgICAgIDogYFVuc3VwcG9ydGVkIHRva2VuICh0eXBlOiAke3Rva2VuLnR5cGV9KWA7XG4gICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnVU5FWFBFQ1RFRF9UT0tFTicsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgbm9kZSA9IGNvbXBvc2VFbXB0eU5vZGUoY3R4LCB0b2tlbi5vZmZzZXQsIHVuZGVmaW5lZCwgbnVsbCwgcHJvcHMsIG9uRXJyb3IpO1xuICAgICAgICAgICAgaXNTcmNUb2tlbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhbmNob3IgJiYgbm9kZS5hbmNob3IgPT09ICcnKVxuICAgICAgICBvbkVycm9yKGFuY2hvciwgJ0JBRF9BTElBUycsICdBbmNob3IgY2Fubm90IGJlIGFuIGVtcHR5IHN0cmluZycpO1xuICAgIGlmIChhdEtleSAmJlxuICAgICAgICBjdHgub3B0aW9ucy5zdHJpbmdLZXlzICYmXG4gICAgICAgICghaWRlbnRpdHkuaXNTY2FsYXIobm9kZSkgfHxcbiAgICAgICAgICAgIHR5cGVvZiBub2RlLnZhbHVlICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgKG5vZGUudGFnICYmIG5vZGUudGFnICE9PSAndGFnOnlhbWwub3JnLDIwMDI6c3RyJykpKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9ICdXaXRoIHN0cmluZ0tleXMsIGFsbCBrZXlzIG11c3QgYmUgc3RyaW5ncyc7XG4gICAgICAgIG9uRXJyb3IodGFnID8/IHRva2VuLCAnTk9OX1NUUklOR19LRVknLCBtc2cpO1xuICAgIH1cbiAgICBpZiAoc3BhY2VCZWZvcmUpXG4gICAgICAgIG5vZGUuc3BhY2VCZWZvcmUgPSB0cnVlO1xuICAgIGlmIChjb21tZW50KSB7XG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnc2NhbGFyJyAmJiB0b2tlbi5zb3VyY2UgPT09ICcnKVxuICAgICAgICAgICAgbm9kZS5jb21tZW50ID0gY29tbWVudDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbm9kZS5jb21tZW50QmVmb3JlID0gY29tbWVudDtcbiAgICB9XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUeXBlIGNoZWNraW5nIG1pc3NlcyBtZWFuaW5nIG9mIGlzU3JjVG9rZW5cbiAgICBpZiAoY3R4Lm9wdGlvbnMua2VlcFNvdXJjZVRva2VucyAmJiBpc1NyY1Rva2VuKVxuICAgICAgICBub2RlLnNyY1Rva2VuID0gdG9rZW47XG4gICAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBjb21wb3NlRW1wdHlOb2RlKGN0eCwgb2Zmc2V0LCBiZWZvcmUsIHBvcywgeyBzcGFjZUJlZm9yZSwgY29tbWVudCwgYW5jaG9yLCB0YWcsIGVuZCB9LCBvbkVycm9yKSB7XG4gICAgY29uc3QgdG9rZW4gPSB7XG4gICAgICAgIHR5cGU6ICdzY2FsYXInLFxuICAgICAgICBvZmZzZXQ6IHV0aWxFbXB0eVNjYWxhclBvc2l0aW9uLmVtcHR5U2NhbGFyUG9zaXRpb24ob2Zmc2V0LCBiZWZvcmUsIHBvcyksXG4gICAgICAgIGluZGVudDogLTEsXG4gICAgICAgIHNvdXJjZTogJydcbiAgICB9O1xuICAgIGNvbnN0IG5vZGUgPSBjb21wb3NlU2NhbGFyLmNvbXBvc2VTY2FsYXIoY3R4LCB0b2tlbiwgdGFnLCBvbkVycm9yKTtcbiAgICBpZiAoYW5jaG9yKSB7XG4gICAgICAgIG5vZGUuYW5jaG9yID0gYW5jaG9yLnNvdXJjZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIGlmIChub2RlLmFuY2hvciA9PT0gJycpXG4gICAgICAgICAgICBvbkVycm9yKGFuY2hvciwgJ0JBRF9BTElBUycsICdBbmNob3IgY2Fubm90IGJlIGFuIGVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAoc3BhY2VCZWZvcmUpXG4gICAgICAgIG5vZGUuc3BhY2VCZWZvcmUgPSB0cnVlO1xuICAgIGlmIChjb21tZW50KSB7XG4gICAgICAgIG5vZGUuY29tbWVudCA9IGNvbW1lbnQ7XG4gICAgICAgIG5vZGUucmFuZ2VbMl0gPSBlbmQ7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gY29tcG9zZUFsaWFzKHsgb3B0aW9ucyB9LCB7IG9mZnNldCwgc291cmNlLCBlbmQgfSwgb25FcnJvcikge1xuICAgIGNvbnN0IGFsaWFzID0gbmV3IEFsaWFzLkFsaWFzKHNvdXJjZS5zdWJzdHJpbmcoMSkpO1xuICAgIGlmIChhbGlhcy5zb3VyY2UgPT09ICcnKVxuICAgICAgICBvbkVycm9yKG9mZnNldCwgJ0JBRF9BTElBUycsICdBbGlhcyBjYW5ub3QgYmUgYW4gZW1wdHkgc3RyaW5nJyk7XG4gICAgaWYgKGFsaWFzLnNvdXJjZS5lbmRzV2l0aCgnOicpKVxuICAgICAgICBvbkVycm9yKG9mZnNldCArIHNvdXJjZS5sZW5ndGggLSAxLCAnQkFEX0FMSUFTJywgJ0FsaWFzIGVuZGluZyBpbiA6IGlzIGFtYmlndW91cycsIHRydWUpO1xuICAgIGNvbnN0IHZhbHVlRW5kID0gb2Zmc2V0ICsgc291cmNlLmxlbmd0aDtcbiAgICBjb25zdCByZSA9IHJlc29sdmVFbmQucmVzb2x2ZUVuZChlbmQsIHZhbHVlRW5kLCBvcHRpb25zLnN0cmljdCwgb25FcnJvcik7XG4gICAgYWxpYXMucmFuZ2UgPSBbb2Zmc2V0LCB2YWx1ZUVuZCwgcmUub2Zmc2V0XTtcbiAgICBpZiAocmUuY29tbWVudClcbiAgICAgICAgYWxpYXMuY29tbWVudCA9IHJlLmNvbW1lbnQ7XG4gICAgcmV0dXJuIGFsaWFzO1xufVxuXG5leHBvcnRzLmNvbXBvc2VFbXB0eU5vZGUgPSBjb21wb3NlRW1wdHlOb2RlO1xuZXhwb3J0cy5jb21wb3NlTm9kZSA9IGNvbXBvc2VOb2RlO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBEb2N1bWVudCA9IHJlcXVpcmUoJy4uL2RvYy9Eb2N1bWVudC5qcycpO1xudmFyIGNvbXBvc2VOb2RlID0gcmVxdWlyZSgnLi9jb21wb3NlLW5vZGUuanMnKTtcbnZhciByZXNvbHZlRW5kID0gcmVxdWlyZSgnLi9yZXNvbHZlLWVuZC5qcycpO1xudmFyIHJlc29sdmVQcm9wcyA9IHJlcXVpcmUoJy4vcmVzb2x2ZS1wcm9wcy5qcycpO1xuXG5mdW5jdGlvbiBjb21wb3NlRG9jKG9wdGlvbnMsIGRpcmVjdGl2ZXMsIHsgb2Zmc2V0LCBzdGFydCwgdmFsdWUsIGVuZCB9LCBvbkVycm9yKSB7XG4gICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyBfZGlyZWN0aXZlczogZGlyZWN0aXZlcyB9LCBvcHRpb25zKTtcbiAgICBjb25zdCBkb2MgPSBuZXcgRG9jdW1lbnQuRG9jdW1lbnQodW5kZWZpbmVkLCBvcHRzKTtcbiAgICBjb25zdCBjdHggPSB7XG4gICAgICAgIGF0S2V5OiBmYWxzZSxcbiAgICAgICAgYXRSb290OiB0cnVlLFxuICAgICAgICBkaXJlY3RpdmVzOiBkb2MuZGlyZWN0aXZlcyxcbiAgICAgICAgb3B0aW9uczogZG9jLm9wdGlvbnMsXG4gICAgICAgIHNjaGVtYTogZG9jLnNjaGVtYVxuICAgIH07XG4gICAgY29uc3QgcHJvcHMgPSByZXNvbHZlUHJvcHMucmVzb2x2ZVByb3BzKHN0YXJ0LCB7XG4gICAgICAgIGluZGljYXRvcjogJ2RvYy1zdGFydCcsXG4gICAgICAgIG5leHQ6IHZhbHVlID8/IGVuZD8uWzBdLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIG9uRXJyb3IsXG4gICAgICAgIHBhcmVudEluZGVudDogMCxcbiAgICAgICAgc3RhcnRPbk5ld2xpbmU6IHRydWVcbiAgICB9KTtcbiAgICBpZiAocHJvcHMuZm91bmQpIHtcbiAgICAgICAgZG9jLmRpcmVjdGl2ZXMuZG9jU3RhcnQgPSB0cnVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgICh2YWx1ZS50eXBlID09PSAnYmxvY2stbWFwJyB8fCB2YWx1ZS50eXBlID09PSAnYmxvY2stc2VxJykgJiZcbiAgICAgICAgICAgICFwcm9wcy5oYXNOZXdsaW5lKVxuICAgICAgICAgICAgb25FcnJvcihwcm9wcy5lbmQsICdNSVNTSU5HX0NIQVInLCAnQmxvY2sgY29sbGVjdGlvbiBjYW5ub3Qgc3RhcnQgb24gc2FtZSBsaW5lIHdpdGggZGlyZWN0aXZlcy1lbmQgbWFya2VyJyk7XG4gICAgfVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgSWYgQ29udGVudHMgaXMgc2V0LCBsZXQncyB0cnVzdCB0aGUgdXNlclxuICAgIGRvYy5jb250ZW50cyA9IHZhbHVlXG4gICAgICAgID8gY29tcG9zZU5vZGUuY29tcG9zZU5vZGUoY3R4LCB2YWx1ZSwgcHJvcHMsIG9uRXJyb3IpXG4gICAgICAgIDogY29tcG9zZU5vZGUuY29tcG9zZUVtcHR5Tm9kZShjdHgsIHByb3BzLmVuZCwgc3RhcnQsIG51bGwsIHByb3BzLCBvbkVycm9yKTtcbiAgICBjb25zdCBjb250ZW50RW5kID0gZG9jLmNvbnRlbnRzLnJhbmdlWzJdO1xuICAgIGNvbnN0IHJlID0gcmVzb2x2ZUVuZC5yZXNvbHZlRW5kKGVuZCwgY29udGVudEVuZCwgZmFsc2UsIG9uRXJyb3IpO1xuICAgIGlmIChyZS5jb21tZW50KVxuICAgICAgICBkb2MuY29tbWVudCA9IHJlLmNvbW1lbnQ7XG4gICAgZG9jLnJhbmdlID0gW29mZnNldCwgY29udGVudEVuZCwgcmUub2Zmc2V0XTtcbiAgICByZXR1cm4gZG9jO1xufVxuXG5leHBvcnRzLmNvbXBvc2VEb2MgPSBjb21wb3NlRG9jO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBub2RlX3Byb2Nlc3MgPSByZXF1aXJlKCdwcm9jZXNzJyk7XG52YXIgZGlyZWN0aXZlcyA9IHJlcXVpcmUoJy4uL2RvYy9kaXJlY3RpdmVzLmpzJyk7XG52YXIgRG9jdW1lbnQgPSByZXF1aXJlKCcuLi9kb2MvRG9jdW1lbnQuanMnKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMuanMnKTtcbnZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4uL25vZGVzL2lkZW50aXR5LmpzJyk7XG52YXIgY29tcG9zZURvYyA9IHJlcXVpcmUoJy4vY29tcG9zZS1kb2MuanMnKTtcbnZhciByZXNvbHZlRW5kID0gcmVxdWlyZSgnLi9yZXNvbHZlLWVuZC5qcycpO1xuXG5mdW5jdGlvbiBnZXRFcnJvclBvcyhzcmMpIHtcbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ251bWJlcicpXG4gICAgICAgIHJldHVybiBbc3JjLCBzcmMgKyAxXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzcmMpKVxuICAgICAgICByZXR1cm4gc3JjLmxlbmd0aCA9PT0gMiA/IHNyYyA6IFtzcmNbMF0sIHNyY1sxXV07XG4gICAgY29uc3QgeyBvZmZzZXQsIHNvdXJjZSB9ID0gc3JjO1xuICAgIHJldHVybiBbb2Zmc2V0LCBvZmZzZXQgKyAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgPyBzb3VyY2UubGVuZ3RoIDogMSldO1xufVxuZnVuY3Rpb24gcGFyc2VQcmVsdWRlKHByZWx1ZGUpIHtcbiAgICBsZXQgY29tbWVudCA9ICcnO1xuICAgIGxldCBhdENvbW1lbnQgPSBmYWxzZTtcbiAgICBsZXQgYWZ0ZXJFbXB0eUxpbmUgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZWx1ZGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3Qgc291cmNlID0gcHJlbHVkZVtpXTtcbiAgICAgICAgc3dpdGNoIChzb3VyY2VbMF0pIHtcbiAgICAgICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgICAgICAgIGNvbW1lbnQgKz1cbiAgICAgICAgICAgICAgICAgICAgKGNvbW1lbnQgPT09ICcnID8gJycgOiBhZnRlckVtcHR5TGluZSA/ICdcXG5cXG4nIDogJ1xcbicpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzb3VyY2Uuc3Vic3RyaW5nKDEpIHx8ICcgJyk7XG4gICAgICAgICAgICAgICAgYXRDb21tZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhZnRlckVtcHR5TGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICAgICAgaWYgKHByZWx1ZGVbaSArIDFdPy5bMF0gIT09ICcjJylcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgIGF0Q29tbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG1heSBiZSB3cm9uZyBhZnRlciBkb2MtZW5kLCBidXQgaW4gdGhhdCBjYXNlIGl0IGRvZXNuJ3QgbWF0dGVyXG4gICAgICAgICAgICAgICAgaWYgKCFhdENvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyRW1wdHlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhdENvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBjb21tZW50LCBhZnRlckVtcHR5TGluZSB9O1xufVxuLyoqXG4gKiBDb21wb3NlIGEgc3RyZWFtIG9mIENTVCBub2RlcyBpbnRvIGEgc3RyZWFtIG9mIFlBTUwgRG9jdW1lbnRzLlxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBDb21wb3NlciwgUGFyc2VyIH0gZnJvbSAneWFtbCdcbiAqXG4gKiBjb25zdCBzcmM6IHN0cmluZyA9IC4uLlxuICogY29uc3QgdG9rZW5zID0gbmV3IFBhcnNlcigpLnBhcnNlKHNyYylcbiAqIGNvbnN0IGRvY3MgPSBuZXcgQ29tcG9zZXIoKS5jb21wb3NlKHRva2VucylcbiAqIGBgYFxuICovXG5jbGFzcyBDb21wb3NlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuZG9jID0gbnVsbDtcbiAgICAgICAgdGhpcy5hdERpcmVjdGl2ZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcmVsdWRlID0gW107XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICAgIHRoaXMud2FybmluZ3MgPSBbXTtcbiAgICAgICAgdGhpcy5vbkVycm9yID0gKHNvdXJjZSwgY29kZSwgbWVzc2FnZSwgd2FybmluZykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcG9zID0gZ2V0RXJyb3JQb3Moc291cmNlKTtcbiAgICAgICAgICAgIGlmICh3YXJuaW5nKVxuICAgICAgICAgICAgICAgIHRoaXMud2FybmluZ3MucHVzaChuZXcgZXJyb3JzLllBTUxXYXJuaW5nKHBvcywgY29kZSwgbWVzc2FnZSkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IGVycm9ycy5ZQU1MUGFyc2VFcnJvcihwb3MsIGNvZGUsIG1lc3NhZ2UpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItbnVsbGlzaC1jb2FsZXNjaW5nXG4gICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IG5ldyBkaXJlY3RpdmVzLkRpcmVjdGl2ZXMoeyB2ZXJzaW9uOiBvcHRpb25zLnZlcnNpb24gfHwgJzEuMicgfSk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIGRlY29yYXRlKGRvYywgYWZ0ZXJEb2MpIHtcbiAgICAgICAgY29uc3QgeyBjb21tZW50LCBhZnRlckVtcHR5TGluZSB9ID0gcGFyc2VQcmVsdWRlKHRoaXMucHJlbHVkZSk7XG4gICAgICAgIC8vY29uc29sZS5sb2coeyBkYzogZG9jLmNvbW1lbnQsIHByZWx1ZGUsIGNvbW1lbnQgfSlcbiAgICAgICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRjID0gZG9jLmNvbnRlbnRzO1xuICAgICAgICAgICAgaWYgKGFmdGVyRG9jKSB7XG4gICAgICAgICAgICAgICAgZG9jLmNvbW1lbnQgPSBkb2MuY29tbWVudCA/IGAke2RvYy5jb21tZW50fVxcbiR7Y29tbWVudH1gIDogY29tbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFmdGVyRW1wdHlMaW5lIHx8IGRvYy5kaXJlY3RpdmVzLmRvY1N0YXJ0IHx8ICFkYykge1xuICAgICAgICAgICAgICAgIGRvYy5jb21tZW50QmVmb3JlID0gY29tbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlkZW50aXR5LmlzQ29sbGVjdGlvbihkYykgJiYgIWRjLmZsb3cgJiYgZGMuaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBpdCA9IGRjLml0ZW1zWzBdO1xuICAgICAgICAgICAgICAgIGlmIChpZGVudGl0eS5pc1BhaXIoaXQpKVxuICAgICAgICAgICAgICAgICAgICBpdCA9IGl0LmtleTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYiA9IGl0LmNvbW1lbnRCZWZvcmU7XG4gICAgICAgICAgICAgICAgaXQuY29tbWVudEJlZm9yZSA9IGNiID8gYCR7Y29tbWVudH1cXG4ke2NifWAgOiBjb21tZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2IgPSBkYy5jb21tZW50QmVmb3JlO1xuICAgICAgICAgICAgICAgIGRjLmNvbW1lbnRCZWZvcmUgPSBjYiA/IGAke2NvbW1lbnR9XFxuJHtjYn1gIDogY29tbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWZ0ZXJEb2MpIHtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGRvYy5lcnJvcnMsIHRoaXMuZXJyb3JzKTtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGRvYy53YXJuaW5ncywgdGhpcy53YXJuaW5ncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkb2MuZXJyb3JzID0gdGhpcy5lcnJvcnM7XG4gICAgICAgICAgICBkb2Mud2FybmluZ3MgPSB0aGlzLndhcm5pbmdzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlbHVkZSA9IFtdO1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLndhcm5pbmdzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgc3RyZWFtIHN0YXR1cyBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIE1vc3RseSB1c2VmdWwgYXQgdGhlIGVuZCBvZiBpbnB1dCBmb3IgYW4gZW1wdHkgc3RyZWFtLlxuICAgICAqL1xuICAgIHN0cmVhbUluZm8oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb21tZW50OiBwYXJzZVByZWx1ZGUodGhpcy5wcmVsdWRlKS5jb21tZW50LFxuICAgICAgICAgICAgZGlyZWN0aXZlczogdGhpcy5kaXJlY3RpdmVzLFxuICAgICAgICAgICAgZXJyb3JzOiB0aGlzLmVycm9ycyxcbiAgICAgICAgICAgIHdhcm5pbmdzOiB0aGlzLndhcm5pbmdzXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXBvc2UgdG9rZW5zIGludG8gZG9jdW1lbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZvcmNlRG9jIC0gSWYgdGhlIHN0cmVhbSBjb250YWlucyBubyBkb2N1bWVudCwgc3RpbGwgZW1pdCBhIGZpbmFsIGRvY3VtZW50IGluY2x1ZGluZyBhbnkgY29tbWVudHMgYW5kIGRpcmVjdGl2ZXMgdGhhdCB3b3VsZCBiZSBhcHBsaWVkIHRvIGEgc3Vic2VxdWVudCBkb2N1bWVudC5cbiAgICAgKiBAcGFyYW0gZW5kT2Zmc2V0IC0gU2hvdWxkIGJlIHNldCBpZiBgZm9yY2VEb2NgIGlzIGFsc28gc2V0LCB0byBzZXQgdGhlIGRvY3VtZW50IHJhbmdlIGVuZCBhbmQgdG8gaW5kaWNhdGUgZXJyb3JzIGNvcnJlY3RseS5cbiAgICAgKi9cbiAgICAqY29tcG9zZSh0b2tlbnMsIGZvcmNlRG9jID0gZmFsc2UsIGVuZE9mZnNldCA9IC0xKSB7XG4gICAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zKVxuICAgICAgICAgICAgeWllbGQqIHRoaXMubmV4dCh0b2tlbik7XG4gICAgICAgIHlpZWxkKiB0aGlzLmVuZChmb3JjZURvYywgZW5kT2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqIEFkdmFuY2UgdGhlIGNvbXBvc2VyIGJ5IG9uZSBDU1QgdG9rZW4uICovXG4gICAgKm5leHQodG9rZW4pIHtcbiAgICAgICAgaWYgKG5vZGVfcHJvY2Vzcy5lbnYuTE9HX1NUUkVBTSlcbiAgICAgICAgICAgIGNvbnNvbGUuZGlyKHRva2VuLCB7IGRlcHRoOiBudWxsIH0pO1xuICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RpcmVjdGl2ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzLmFkZCh0b2tlbi5zb3VyY2UsIChvZmZzZXQsIG1lc3NhZ2UsIHdhcm5pbmcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zID0gZ2V0RXJyb3JQb3ModG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBwb3NbMF0gKz0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IocG9zLCAnQkFEX0RJUkVDVElWRScsIG1lc3NhZ2UsIHdhcm5pbmcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucHJlbHVkZS5wdXNoKHRva2VuLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hdERpcmVjdGl2ZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZG9jdW1lbnQnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZG9jID0gY29tcG9zZURvYy5jb21wb3NlRG9jKHRoaXMub3B0aW9ucywgdGhpcy5kaXJlY3RpdmVzLCB0b2tlbiwgdGhpcy5vbkVycm9yKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdERpcmVjdGl2ZXMgJiYgIWRvYy5kaXJlY3RpdmVzLmRvY1N0YXJ0KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IodG9rZW4sICdNSVNTSU5HX0NIQVInLCAnTWlzc2luZyBkaXJlY3RpdmVzLWVuZC9kb2Mtc3RhcnQgaW5kaWNhdG9yIGxpbmUnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29yYXRlKGRvYywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRvYylcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5kb2M7XG4gICAgICAgICAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgICAgICAgICAgICAgdGhpcy5hdERpcmVjdGl2ZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2J5dGUtb3JkZXItbWFyayc6XG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIHRoaXMucHJlbHVkZS5wdXNoKHRva2VuLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdlcnJvcic6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSB0b2tlbi5zb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgPyBgJHt0b2tlbi5tZXNzYWdlfTogJHtKU09OLnN0cmluZ2lmeSh0b2tlbi5zb3VyY2UpfWBcbiAgICAgICAgICAgICAgICAgICAgOiB0b2tlbi5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IGVycm9ycy5ZQU1MUGFyc2VFcnJvcihnZXRFcnJvclBvcyh0b2tlbiksICdVTkVYUEVDVEVEX1RPS0VOJywgbXNnKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdERpcmVjdGl2ZXMgfHwgIXRoaXMuZG9jKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jLmVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2RvYy1lbmQnOiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRvYykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSAnVW5leHBlY3RlZCBkb2MtZW5kIHdpdGhvdXQgcHJlY2VkaW5nIGRvY3VtZW50JztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgZXJyb3JzLllBTUxQYXJzZUVycm9yKGdldEVycm9yUG9zKHRva2VuKSwgJ1VORVhQRUNURURfVE9LRU4nLCBtc2cpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZG9jLmRpcmVjdGl2ZXMuZG9jRW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSByZXNvbHZlRW5kLnJlc29sdmVFbmQodG9rZW4uZW5kLCB0b2tlbi5vZmZzZXQgKyB0b2tlbi5zb3VyY2UubGVuZ3RoLCB0aGlzLmRvYy5vcHRpb25zLnN0cmljdCwgdGhpcy5vbkVycm9yKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29yYXRlKHRoaXMuZG9jLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGMgPSB0aGlzLmRvYy5jb21tZW50O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvYy5jb21tZW50ID0gZGMgPyBgJHtkY31cXG4ke2VuZC5jb21tZW50fWAgOiBlbmQuY29tbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5kb2MucmFuZ2VbMl0gPSBlbmQub2Zmc2V0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBlcnJvcnMuWUFNTFBhcnNlRXJyb3IoZ2V0RXJyb3JQb3ModG9rZW4pLCAnVU5FWFBFQ1RFRF9UT0tFTicsIGBVbnN1cHBvcnRlZCB0b2tlbiAke3Rva2VuLnR5cGV9YCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgYXQgZW5kIG9mIGlucHV0IHRvIHlpZWxkIGFueSByZW1haW5pbmcgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm9yY2VEb2MgLSBJZiB0aGUgc3RyZWFtIGNvbnRhaW5zIG5vIGRvY3VtZW50LCBzdGlsbCBlbWl0IGEgZmluYWwgZG9jdW1lbnQgaW5jbHVkaW5nIGFueSBjb21tZW50cyBhbmQgZGlyZWN0aXZlcyB0aGF0IHdvdWxkIGJlIGFwcGxpZWQgdG8gYSBzdWJzZXF1ZW50IGRvY3VtZW50LlxuICAgICAqIEBwYXJhbSBlbmRPZmZzZXQgLSBTaG91bGQgYmUgc2V0IGlmIGBmb3JjZURvY2AgaXMgYWxzbyBzZXQsIHRvIHNldCB0aGUgZG9jdW1lbnQgcmFuZ2UgZW5kIGFuZCB0byBpbmRpY2F0ZSBlcnJvcnMgY29ycmVjdGx5LlxuICAgICAqL1xuICAgICplbmQoZm9yY2VEb2MgPSBmYWxzZSwgZW5kT2Zmc2V0ID0gLTEpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9jKSB7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRlKHRoaXMuZG9jLCB0cnVlKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZG9jO1xuICAgICAgICAgICAgdGhpcy5kb2MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZvcmNlRG9jKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7IF9kaXJlY3RpdmVzOiB0aGlzLmRpcmVjdGl2ZXMgfSwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGRvYyA9IG5ldyBEb2N1bWVudC5Eb2N1bWVudCh1bmRlZmluZWQsIG9wdHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXREaXJlY3RpdmVzKVxuICAgICAgICAgICAgICAgIHRoaXMub25FcnJvcihlbmRPZmZzZXQsICdNSVNTSU5HX0NIQVInLCAnTWlzc2luZyBkaXJlY3RpdmVzLWVuZCBpbmRpY2F0b3IgbGluZScpO1xuICAgICAgICAgICAgZG9jLnJhbmdlID0gWzAsIGVuZE9mZnNldCwgZW5kT2Zmc2V0XTtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGUoZG9jLCBmYWxzZSk7XG4gICAgICAgICAgICB5aWVsZCBkb2M7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydHMuQ29tcG9zZXIgPSBDb21wb3NlcjtcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVzb2x2ZUJsb2NrU2NhbGFyID0gcmVxdWlyZSgnLi4vY29tcG9zZS9yZXNvbHZlLWJsb2NrLXNjYWxhci5qcycpO1xudmFyIHJlc29sdmVGbG93U2NhbGFyID0gcmVxdWlyZSgnLi4vY29tcG9zZS9yZXNvbHZlLWZsb3ctc2NhbGFyLmpzJyk7XG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzLmpzJyk7XG52YXIgc3RyaW5naWZ5U3RyaW5nID0gcmVxdWlyZSgnLi4vc3RyaW5naWZ5L3N0cmluZ2lmeVN0cmluZy5qcycpO1xuXG5mdW5jdGlvbiByZXNvbHZlQXNTY2FsYXIodG9rZW4sIHN0cmljdCA9IHRydWUsIG9uRXJyb3IpIHtcbiAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgY29uc3QgX29uRXJyb3IgPSAocG9zLCBjb2RlLCBtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0eXBlb2YgcG9zID09PSAnbnVtYmVyJyA/IHBvcyA6IEFycmF5LmlzQXJyYXkocG9zKSA/IHBvc1swXSA6IHBvcy5vZmZzZXQ7XG4gICAgICAgICAgICBpZiAob25FcnJvcilcbiAgICAgICAgICAgICAgICBvbkVycm9yKG9mZnNldCwgY29kZSwgbWVzc2FnZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5ZQU1MUGFyc2VFcnJvcihbb2Zmc2V0LCBvZmZzZXQgKyAxXSwgY29kZSwgbWVzc2FnZSk7XG4gICAgICAgIH07XG4gICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgIGNhc2UgJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZUZsb3dTY2FsYXIucmVzb2x2ZUZsb3dTY2FsYXIodG9rZW4sIHN0cmljdCwgX29uRXJyb3IpO1xuICAgICAgICAgICAgY2FzZSAnYmxvY2stc2NhbGFyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZUJsb2NrU2NhbGFyLnJlc29sdmVCbG9ja1NjYWxhcih7IG9wdGlvbnM6IHsgc3RyaWN0IH0gfSwgdG9rZW4sIF9vbkVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHNjYWxhciB0b2tlbiB3aXRoIGB2YWx1ZWBcbiAqXG4gKiBWYWx1ZXMgdGhhdCByZXByZXNlbnQgYW4gYWN0dWFsIHN0cmluZyBidXQgbWF5IGJlIHBhcnNlZCBhcyBhIGRpZmZlcmVudCB0eXBlIHNob3VsZCB1c2UgYSBgdHlwZWAgb3RoZXIgdGhhbiBgJ1BMQUlOJ2AsXG4gKiBhcyB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IHN1cHBvcnQgYW55IHNjaGVtYSBvcGVyYXRpb25zIGFuZCB3b24ndCBjaGVjayBmb3Igc3VjaCBjb25mbGljdHMuXG4gKlxuICogQHBhcmFtIHZhbHVlIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZhbHVlLCB3aGljaCB3aWxsIGhhdmUgaXRzIGNvbnRlbnQgcHJvcGVybHkgaW5kZW50ZWQuXG4gKiBAcGFyYW0gY29udGV4dC5lbmQgQ29tbWVudHMgYW5kIHdoaXRlc3BhY2UgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgdmFsdWUsIG9yIGFmdGVyIHRoZSBibG9jayBzY2FsYXIgaGVhZGVyLiBJZiB1bmRlZmluZWQsIGEgbmV3bGluZSB3aWxsIGJlIGFkZGVkLlxuICogQHBhcmFtIGNvbnRleHQuaW1wbGljaXRLZXkgQmVpbmcgd2l0aGluIGFuIGltcGxpY2l0IGtleSBtYXkgYWZmZWN0IHRoZSByZXNvbHZlZCB0eXBlIG9mIHRoZSB0b2tlbidzIHZhbHVlLlxuICogQHBhcmFtIGNvbnRleHQuaW5kZW50IFRoZSBpbmRlbnQgbGV2ZWwgb2YgdGhlIHRva2VuLlxuICogQHBhcmFtIGNvbnRleHQuaW5GbG93IElzIHRoaXMgc2NhbGFyIHdpdGhpbiBhIGZsb3cgY29sbGVjdGlvbj8gVGhpcyBtYXkgYWZmZWN0IHRoZSByZXNvbHZlZCB0eXBlIG9mIHRoZSB0b2tlbidzIHZhbHVlLlxuICogQHBhcmFtIGNvbnRleHQub2Zmc2V0IFRoZSBvZmZzZXQgcG9zaXRpb24gb2YgdGhlIHRva2VuLlxuICogQHBhcmFtIGNvbnRleHQudHlwZSBUaGUgcHJlZmVycmVkIHR5cGUgb2YgdGhlIHNjYWxhciB0b2tlbi4gSWYgdW5kZWZpbmVkLCB0aGUgcHJldmlvdXMgdHlwZSBvZiB0aGUgYHRva2VuYCB3aWxsIGJlIHVzZWQsIGRlZmF1bHRpbmcgdG8gYCdQTEFJTidgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVTY2FsYXJUb2tlbih2YWx1ZSwgY29udGV4dCkge1xuICAgIGNvbnN0IHsgaW1wbGljaXRLZXkgPSBmYWxzZSwgaW5kZW50LCBpbkZsb3cgPSBmYWxzZSwgb2Zmc2V0ID0gLTEsIHR5cGUgPSAnUExBSU4nIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmluZ2lmeVN0cmluZy5zdHJpbmdpZnlTdHJpbmcoeyB0eXBlLCB2YWx1ZSB9LCB7XG4gICAgICAgIGltcGxpY2l0S2V5LFxuICAgICAgICBpbmRlbnQ6IGluZGVudCA+IDAgPyAnICcucmVwZWF0KGluZGVudCkgOiAnJyxcbiAgICAgICAgaW5GbG93LFxuICAgICAgICBvcHRpb25zOiB7IGJsb2NrUXVvdGU6IHRydWUsIGxpbmVXaWR0aDogLTEgfVxuICAgIH0pO1xuICAgIGNvbnN0IGVuZCA9IGNvbnRleHQuZW5kID8/IFtcbiAgICAgICAgeyB0eXBlOiAnbmV3bGluZScsIG9mZnNldDogLTEsIGluZGVudCwgc291cmNlOiAnXFxuJyB9XG4gICAgXTtcbiAgICBzd2l0Y2ggKHNvdXJjZVswXSkge1xuICAgICAgICBjYXNlICd8JzpcbiAgICAgICAgY2FzZSAnPic6IHtcbiAgICAgICAgICAgIGNvbnN0IGhlID0gc291cmNlLmluZGV4T2YoJ1xcbicpO1xuICAgICAgICAgICAgY29uc3QgaGVhZCA9IHNvdXJjZS5zdWJzdHJpbmcoMCwgaGUpO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHNvdXJjZS5zdWJzdHJpbmcoaGUgKyAxKSArICdcXG4nO1xuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBbXG4gICAgICAgICAgICAgICAgeyB0eXBlOiAnYmxvY2stc2NhbGFyLWhlYWRlcicsIG9mZnNldCwgaW5kZW50LCBzb3VyY2U6IGhlYWQgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGlmICghYWRkRW5kdG9CbG9ja1Byb3BzKHByb3BzLCBlbmQpKVxuICAgICAgICAgICAgICAgIHByb3BzLnB1c2goeyB0eXBlOiAnbmV3bGluZScsIG9mZnNldDogLTEsIGluZGVudCwgc291cmNlOiAnXFxuJyB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICdibG9jay1zY2FsYXInLCBvZmZzZXQsIGluZGVudCwgcHJvcHMsIHNvdXJjZTogYm9keSB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICdkb3VibGUtcXVvdGVkLXNjYWxhcicsIG9mZnNldCwgaW5kZW50LCBzb3VyY2UsIGVuZCB9O1xuICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJywgb2Zmc2V0LCBpbmRlbnQsIHNvdXJjZSwgZW5kIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnc2NhbGFyJywgb2Zmc2V0LCBpbmRlbnQsIHNvdXJjZSwgZW5kIH07XG4gICAgfVxufVxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGB0b2tlbmAgdG8gdGhlIGdpdmVuIHN0cmluZyBgdmFsdWVgLCBvdmVyd3JpdGluZyBhbnkgcHJldmlvdXMgY29udGVudHMgYW5kIHR5cGUgdGhhdCBpdCBtYXkgaGF2ZS5cbiAqXG4gKiBCZXN0IGVmZm9ydHMgYXJlIG1hZGUgdG8gcmV0YWluIGFueSBjb21tZW50cyBwcmV2aW91c2x5IGFzc29jaWF0ZWQgd2l0aCB0aGUgYHRva2VuYCxcbiAqIHRob3VnaCBhbGwgY29udGVudHMgd2l0aGluIGEgY29sbGVjdGlvbidzIGBpdGVtc2Agd2lsbCBiZSBvdmVyd3JpdHRlbi5cbiAqXG4gKiBWYWx1ZXMgdGhhdCByZXByZXNlbnQgYW4gYWN0dWFsIHN0cmluZyBidXQgbWF5IGJlIHBhcnNlZCBhcyBhIGRpZmZlcmVudCB0eXBlIHNob3VsZCB1c2UgYSBgdHlwZWAgb3RoZXIgdGhhbiBgJ1BMQUlOJ2AsXG4gKiBhcyB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IHN1cHBvcnQgYW55IHNjaGVtYSBvcGVyYXRpb25zIGFuZCB3b24ndCBjaGVjayBmb3Igc3VjaCBjb25mbGljdHMuXG4gKlxuICogQHBhcmFtIHRva2VuIEFueSB0b2tlbi4gSWYgaXQgZG9lcyBub3QgaW5jbHVkZSBhbiBgaW5kZW50YCB2YWx1ZSwgdGhlIHZhbHVlIHdpbGwgYmUgc3RyaW5naWZpZWQgYXMgaWYgaXQgd2VyZSBhbiBpbXBsaWNpdCBrZXkuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmFsdWUsIHdoaWNoIHdpbGwgaGF2ZSBpdHMgY29udGVudCBwcm9wZXJseSBpbmRlbnRlZC5cbiAqIEBwYXJhbSBjb250ZXh0LmFmdGVyS2V5IEluIG1vc3QgY2FzZXMsIHZhbHVlcyBhZnRlciBhIGtleSBzaG91bGQgaGF2ZSBhbiBhZGRpdGlvbmFsIGxldmVsIG9mIGluZGVudGF0aW9uLlxuICogQHBhcmFtIGNvbnRleHQuaW1wbGljaXRLZXkgQmVpbmcgd2l0aGluIGFuIGltcGxpY2l0IGtleSBtYXkgYWZmZWN0IHRoZSByZXNvbHZlZCB0eXBlIG9mIHRoZSB0b2tlbidzIHZhbHVlLlxuICogQHBhcmFtIGNvbnRleHQuaW5GbG93IEJlaW5nIHdpdGhpbiBhIGZsb3cgY29sbGVjdGlvbiBtYXkgYWZmZWN0IHRoZSByZXNvbHZlZCB0eXBlIG9mIHRoZSB0b2tlbidzIHZhbHVlLlxuICogQHBhcmFtIGNvbnRleHQudHlwZSBUaGUgcHJlZmVycmVkIHR5cGUgb2YgdGhlIHNjYWxhciB0b2tlbi4gSWYgdW5kZWZpbmVkLCB0aGUgcHJldmlvdXMgdHlwZSBvZiB0aGUgYHRva2VuYCB3aWxsIGJlIHVzZWQsIGRlZmF1bHRpbmcgdG8gYCdQTEFJTidgLlxuICovXG5mdW5jdGlvbiBzZXRTY2FsYXJWYWx1ZSh0b2tlbiwgdmFsdWUsIGNvbnRleHQgPSB7fSkge1xuICAgIGxldCB7IGFmdGVyS2V5ID0gZmFsc2UsIGltcGxpY2l0S2V5ID0gZmFsc2UsIGluRmxvdyA9IGZhbHNlLCB0eXBlIH0gPSBjb250ZXh0O1xuICAgIGxldCBpbmRlbnQgPSAnaW5kZW50JyBpbiB0b2tlbiA/IHRva2VuLmluZGVudCA6IG51bGw7XG4gICAgaWYgKGFmdGVyS2V5ICYmIHR5cGVvZiBpbmRlbnQgPT09ICdudW1iZXInKVxuICAgICAgICBpbmRlbnQgKz0gMjtcbiAgICBpZiAoIXR5cGUpXG4gICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc2luZ2xlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgICAgIHR5cGUgPSAnUVVPVEVfU0lOR0xFJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgICAgICB0eXBlID0gJ1FVT1RFX0RPVUJMRSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdibG9jay1zY2FsYXInOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVyID0gdG9rZW4ucHJvcHNbMF07XG4gICAgICAgICAgICAgICAgaWYgKGhlYWRlci50eXBlICE9PSAnYmxvY2stc2NhbGFyLWhlYWRlcicpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBibG9jayBzY2FsYXIgaGVhZGVyJyk7XG4gICAgICAgICAgICAgICAgdHlwZSA9IGhlYWRlci5zb3VyY2VbMF0gPT09ICc+JyA/ICdCTE9DS19GT0xERUQnIDogJ0JMT0NLX0xJVEVSQUwnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0eXBlID0gJ1BMQUlOJztcbiAgICAgICAgfVxuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmluZ2lmeVN0cmluZy5zdHJpbmdpZnlTdHJpbmcoeyB0eXBlLCB2YWx1ZSB9LCB7XG4gICAgICAgIGltcGxpY2l0S2V5OiBpbXBsaWNpdEtleSB8fCBpbmRlbnQgPT09IG51bGwsXG4gICAgICAgIGluZGVudDogaW5kZW50ICE9PSBudWxsICYmIGluZGVudCA+IDAgPyAnICcucmVwZWF0KGluZGVudCkgOiAnJyxcbiAgICAgICAgaW5GbG93LFxuICAgICAgICBvcHRpb25zOiB7IGJsb2NrUXVvdGU6IHRydWUsIGxpbmVXaWR0aDogLTEgfVxuICAgIH0pO1xuICAgIHN3aXRjaCAoc291cmNlWzBdKSB7XG4gICAgICAgIGNhc2UgJ3wnOlxuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgIHNldEJsb2NrU2NhbGFyVmFsdWUodG9rZW4sIHNvdXJjZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgICAgc2V0Rmxvd1NjYWxhclZhbHVlKHRva2VuLCBzb3VyY2UsICdkb3VibGUtcXVvdGVkLXNjYWxhcicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCInXCI6XG4gICAgICAgICAgICBzZXRGbG93U2NhbGFyVmFsdWUodG9rZW4sIHNvdXJjZSwgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHNldEZsb3dTY2FsYXJWYWx1ZSh0b2tlbiwgc291cmNlLCAnc2NhbGFyJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0QmxvY2tTY2FsYXJWYWx1ZSh0b2tlbiwgc291cmNlKSB7XG4gICAgY29uc3QgaGUgPSBzb3VyY2UuaW5kZXhPZignXFxuJyk7XG4gICAgY29uc3QgaGVhZCA9IHNvdXJjZS5zdWJzdHJpbmcoMCwgaGUpO1xuICAgIGNvbnN0IGJvZHkgPSBzb3VyY2Uuc3Vic3RyaW5nKGhlICsgMSkgKyAnXFxuJztcbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2Jsb2NrLXNjYWxhcicpIHtcbiAgICAgICAgY29uc3QgaGVhZGVyID0gdG9rZW4ucHJvcHNbMF07XG4gICAgICAgIGlmIChoZWFkZXIudHlwZSAhPT0gJ2Jsb2NrLXNjYWxhci1oZWFkZXInKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJsb2NrIHNjYWxhciBoZWFkZXInKTtcbiAgICAgICAgaGVhZGVyLnNvdXJjZSA9IGhlYWQ7XG4gICAgICAgIHRva2VuLnNvdXJjZSA9IGJvZHk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB7IG9mZnNldCB9ID0gdG9rZW47XG4gICAgICAgIGNvbnN0IGluZGVudCA9ICdpbmRlbnQnIGluIHRva2VuID8gdG9rZW4uaW5kZW50IDogLTE7XG4gICAgICAgIGNvbnN0IHByb3BzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiAnYmxvY2stc2NhbGFyLWhlYWRlcicsIG9mZnNldCwgaW5kZW50LCBzb3VyY2U6IGhlYWQgfVxuICAgICAgICBdO1xuICAgICAgICBpZiAoIWFkZEVuZHRvQmxvY2tQcm9wcyhwcm9wcywgJ2VuZCcgaW4gdG9rZW4gPyB0b2tlbi5lbmQgOiB1bmRlZmluZWQpKVxuICAgICAgICAgICAgcHJvcHMucHVzaCh7IHR5cGU6ICduZXdsaW5lJywgb2Zmc2V0OiAtMSwgaW5kZW50LCBzb3VyY2U6ICdcXG4nIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0b2tlbikpXG4gICAgICAgICAgICBpZiAoa2V5ICE9PSAndHlwZScgJiYga2V5ICE9PSAnb2Zmc2V0JylcbiAgICAgICAgICAgICAgICBkZWxldGUgdG9rZW5ba2V5XTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0b2tlbiwgeyB0eXBlOiAnYmxvY2stc2NhbGFyJywgaW5kZW50LCBwcm9wcywgc291cmNlOiBib2R5IH0pO1xuICAgIH1cbn1cbi8qKiBAcmV0dXJucyBgdHJ1ZWAgaWYgbGFzdCB0b2tlbiBpcyBhIG5ld2xpbmUgKi9cbmZ1bmN0aW9uIGFkZEVuZHRvQmxvY2tQcm9wcyhwcm9wcywgZW5kKSB7XG4gICAgaWYgKGVuZClcbiAgICAgICAgZm9yIChjb25zdCBzdCBvZiBlbmQpXG4gICAgICAgICAgICBzd2l0Y2ggKHN0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnB1c2goc3QpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMucHVzaChzdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNldEZsb3dTY2FsYXJWYWx1ZSh0b2tlbiwgc291cmNlLCB0eXBlKSB7XG4gICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgICAgIGNhc2UgJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgY2FzZSAnc2luZ2xlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgdG9rZW4udHlwZSA9IHR5cGU7XG4gICAgICAgICAgICB0b2tlbi5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYmxvY2stc2NhbGFyJzoge1xuICAgICAgICAgICAgY29uc3QgZW5kID0gdG9rZW4ucHJvcHMuc2xpY2UoMSk7XG4gICAgICAgICAgICBsZXQgb2EgPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRva2VuLnByb3BzWzBdLnR5cGUgPT09ICdibG9jay1zY2FsYXItaGVhZGVyJylcbiAgICAgICAgICAgICAgICBvYSAtPSB0b2tlbi5wcm9wc1swXS5zb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0b2sgb2YgZW5kKVxuICAgICAgICAgICAgICAgIHRvay5vZmZzZXQgKz0gb2E7XG4gICAgICAgICAgICBkZWxldGUgdG9rZW4ucHJvcHM7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRva2VuLCB7IHR5cGUsIHNvdXJjZSwgZW5kIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnYmxvY2stbWFwJzpcbiAgICAgICAgY2FzZSAnYmxvY2stc2VxJzoge1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdG9rZW4ub2Zmc2V0ICsgc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IG5sID0geyB0eXBlOiAnbmV3bGluZScsIG9mZnNldCwgaW5kZW50OiB0b2tlbi5pbmRlbnQsIHNvdXJjZTogJ1xcbicgfTtcbiAgICAgICAgICAgIGRlbGV0ZSB0b2tlbi5pdGVtcztcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odG9rZW4sIHsgdHlwZSwgc291cmNlLCBlbmQ6IFtubF0gfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBjb25zdCBpbmRlbnQgPSAnaW5kZW50JyBpbiB0b2tlbiA/IHRva2VuLmluZGVudCA6IC0xO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gJ2VuZCcgaW4gdG9rZW4gJiYgQXJyYXkuaXNBcnJheSh0b2tlbi5lbmQpXG4gICAgICAgICAgICAgICAgPyB0b2tlbi5lbmQuZmlsdGVyKHN0ID0+IHN0LnR5cGUgPT09ICdzcGFjZScgfHxcbiAgICAgICAgICAgICAgICAgICAgc3QudHlwZSA9PT0gJ2NvbW1lbnQnIHx8XG4gICAgICAgICAgICAgICAgICAgIHN0LnR5cGUgPT09ICduZXdsaW5lJylcbiAgICAgICAgICAgICAgICA6IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModG9rZW4pKVxuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICd0eXBlJyAmJiBrZXkgIT09ICdvZmZzZXQnKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdG9rZW5ba2V5XTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odG9rZW4sIHsgdHlwZSwgaW5kZW50LCBzb3VyY2UsIGVuZCB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0cy5jcmVhdGVTY2FsYXJUb2tlbiA9IGNyZWF0ZVNjYWxhclRva2VuO1xuZXhwb3J0cy5yZXNvbHZlQXNTY2FsYXIgPSByZXNvbHZlQXNTY2FsYXI7XG5leHBvcnRzLnNldFNjYWxhclZhbHVlID0gc2V0U2NhbGFyVmFsdWU7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTdHJpbmdpZnkgYSBDU1QgZG9jdW1lbnQsIHRva2VuLCBvciBjb2xsZWN0aW9uIGl0ZW1cbiAqXG4gKiBGYWlyIHdhcm5pbmc6IFRoaXMgYXBwbGllcyBubyB2YWxpZGF0aW9uIHdoYXRzb2V2ZXIsIGFuZFxuICogc2ltcGx5IGNvbmNhdGVuYXRlcyB0aGUgc291cmNlcyBpbiB0aGVpciBsb2dpY2FsIG9yZGVyLlxuICovXG5jb25zdCBzdHJpbmdpZnkgPSAoY3N0KSA9PiAndHlwZScgaW4gY3N0ID8gc3RyaW5naWZ5VG9rZW4oY3N0KSA6IHN0cmluZ2lmeUl0ZW0oY3N0KTtcbmZ1bmN0aW9uIHN0cmluZ2lmeVRva2VuKHRva2VuKSB7XG4gICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2Jsb2NrLXNjYWxhcic6IHtcbiAgICAgICAgICAgIGxldCByZXMgPSAnJztcbiAgICAgICAgICAgIGZvciAoY29uc3QgdG9rIG9mIHRva2VuLnByb3BzKVxuICAgICAgICAgICAgICAgIHJlcyArPSBzdHJpbmdpZnlUb2tlbih0b2spO1xuICAgICAgICAgICAgcmV0dXJuIHJlcyArIHRva2VuLnNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdibG9jay1tYXAnOlxuICAgICAgICBjYXNlICdibG9jay1zZXEnOiB7XG4gICAgICAgICAgICBsZXQgcmVzID0gJyc7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdG9rZW4uaXRlbXMpXG4gICAgICAgICAgICAgICAgcmVzICs9IHN0cmluZ2lmeUl0ZW0oaXRlbSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2Zsb3ctY29sbGVjdGlvbic6IHtcbiAgICAgICAgICAgIGxldCByZXMgPSB0b2tlbi5zdGFydC5zb3VyY2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdG9rZW4uaXRlbXMpXG4gICAgICAgICAgICAgICAgcmVzICs9IHN0cmluZ2lmeUl0ZW0oaXRlbSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHN0IG9mIHRva2VuLmVuZClcbiAgICAgICAgICAgICAgICByZXMgKz0gc3Quc291cmNlO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdkb2N1bWVudCc6IHtcbiAgICAgICAgICAgIGxldCByZXMgPSBzdHJpbmdpZnlJdGVtKHRva2VuKTtcbiAgICAgICAgICAgIGlmICh0b2tlbi5lbmQpXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdCBvZiB0b2tlbi5lbmQpXG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSBzdC5zb3VyY2U7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGxldCByZXMgPSB0b2tlbi5zb3VyY2U7XG4gICAgICAgICAgICBpZiAoJ2VuZCcgaW4gdG9rZW4gJiYgdG9rZW4uZW5kKVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3Qgb2YgdG9rZW4uZW5kKVxuICAgICAgICAgICAgICAgICAgICByZXMgKz0gc3Quc291cmNlO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeUl0ZW0oeyBzdGFydCwga2V5LCBzZXAsIHZhbHVlIH0pIHtcbiAgICBsZXQgcmVzID0gJyc7XG4gICAgZm9yIChjb25zdCBzdCBvZiBzdGFydClcbiAgICAgICAgcmVzICs9IHN0LnNvdXJjZTtcbiAgICBpZiAoa2V5KVxuICAgICAgICByZXMgKz0gc3RyaW5naWZ5VG9rZW4oa2V5KTtcbiAgICBpZiAoc2VwKVxuICAgICAgICBmb3IgKGNvbnN0IHN0IG9mIHNlcClcbiAgICAgICAgICAgIHJlcyArPSBzdC5zb3VyY2U7XG4gICAgaWYgKHZhbHVlKVxuICAgICAgICByZXMgKz0gc3RyaW5naWZ5VG9rZW4odmFsdWUpO1xuICAgIHJldHVybiByZXM7XG59XG5cbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJSRUFLID0gU3ltYm9sKCdicmVhayB2aXNpdCcpO1xuY29uc3QgU0tJUCA9IFN5bWJvbCgnc2tpcCBjaGlsZHJlbicpO1xuY29uc3QgUkVNT1ZFID0gU3ltYm9sKCdyZW1vdmUgaXRlbScpO1xuLyoqXG4gKiBBcHBseSBhIHZpc2l0b3IgdG8gYSBDU1QgZG9jdW1lbnQgb3IgaXRlbS5cbiAqXG4gKiBXYWxrcyB0aHJvdWdoIHRoZSB0cmVlIChkZXB0aC1maXJzdCkgc3RhcnRpbmcgZnJvbSB0aGUgcm9vdCwgY2FsbGluZyBhXG4gKiBgdmlzaXRvcmAgZnVuY3Rpb24gd2l0aCB0d28gYXJndW1lbnRzIHdoZW4gZW50ZXJpbmcgZWFjaCBpdGVtOlxuICogICAtIGBpdGVtYDogVGhlIGN1cnJlbnQgaXRlbSwgd2hpY2ggaW5jbHVkZWQgdGhlIGZvbGxvd2luZyBtZW1iZXJzOlxuICogICAgIC0gYHN0YXJ0OiBTb3VyY2VUb2tlbltdYCDigJMgU291cmNlIHRva2VucyBiZWZvcmUgdGhlIGtleSBvciB2YWx1ZSxcbiAqICAgICAgIHBvc3NpYmx5IGluY2x1ZGluZyBpdHMgYW5jaG9yIG9yIHRhZy5cbiAqICAgICAtIGBrZXk/OiBUb2tlbiB8IG51bGxgIOKAkyBTZXQgZm9yIHBhaXIgdmFsdWVzLiBNYXkgdGhlbiBiZSBgbnVsbGAsIGlmXG4gKiAgICAgICB0aGUga2V5IGJlZm9yZSB0aGUgYDpgIHNlcGFyYXRvciBpcyBlbXB0eS5cbiAqICAgICAtIGBzZXA/OiBTb3VyY2VUb2tlbltdYCDigJMgU291cmNlIHRva2VucyBiZXR3ZWVuIHRoZSBrZXkgYW5kIHRoZSB2YWx1ZSxcbiAqICAgICAgIHdoaWNoIHNob3VsZCBpbmNsdWRlIHRoZSBgOmAgbWFwIHZhbHVlIGluZGljYXRvciBpZiBgdmFsdWVgIGlzIHNldC5cbiAqICAgICAtIGB2YWx1ZT86IFRva2VuYCDigJMgVGhlIHZhbHVlIG9mIGEgc2VxdWVuY2UgaXRlbSwgb3Igb2YgYSBtYXAgcGFpci5cbiAqICAgLSBgcGF0aGA6IFRoZSBzdGVwcyBmcm9tIHRoZSByb290IHRvIHRoZSBjdXJyZW50IG5vZGUsIGFzIGFuIGFycmF5IG9mXG4gKiAgICAgYFsna2V5JyB8ICd2YWx1ZScsIG51bWJlcl1gIHR1cGxlcy5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSB2aXNpdG9yIG1heSBiZSB1c2VkIHRvIGNvbnRyb2wgdGhlIHRyYXZlcnNhbDpcbiAqICAgLSBgdW5kZWZpbmVkYCAoZGVmYXVsdCk6IERvIG5vdGhpbmcgYW5kIGNvbnRpbnVlXG4gKiAgIC0gYHZpc2l0LlNLSVBgOiBEbyBub3QgdmlzaXQgdGhlIGNoaWxkcmVuIG9mIHRoaXMgdG9rZW4sIGNvbnRpbnVlIHdpdGhcbiAqICAgICAgbmV4dCBzaWJsaW5nXG4gKiAgIC0gYHZpc2l0LkJSRUFLYDogVGVybWluYXRlIHRyYXZlcnNhbCBjb21wbGV0ZWx5XG4gKiAgIC0gYHZpc2l0LlJFTU9WRWA6IFJlbW92ZSB0aGUgY3VycmVudCBpdGVtLCB0aGVuIGNvbnRpbnVlIHdpdGggdGhlIG5leHQgb25lXG4gKiAgIC0gYG51bWJlcmA6IFNldCB0aGUgaW5kZXggb2YgdGhlIG5leHQgc3RlcC4gVGhpcyBpcyB1c2VmdWwgZXNwZWNpYWxseSBpZlxuICogICAgIHRoZSBpbmRleCBvZiB0aGUgY3VycmVudCB0b2tlbiBoYXMgY2hhbmdlZC5cbiAqICAgLSBgZnVuY3Rpb25gOiBEZWZpbmUgdGhlIG5leHQgdmlzaXRvciBmb3IgdGhpcyBpdGVtLiBBZnRlciB0aGUgb3JpZ2luYWxcbiAqICAgICB2aXNpdG9yIGlzIGNhbGxlZCBvbiBpdGVtIGVudHJ5LCBuZXh0IHZpc2l0b3JzIGFyZSBjYWxsZWQgYWZ0ZXIgaGFuZGxpbmdcbiAqICAgICBhIG5vbi1lbXB0eSBga2V5YCBhbmQgd2hlbiBleGl0aW5nIHRoZSBpdGVtLlxuICovXG5mdW5jdGlvbiB2aXNpdChjc3QsIHZpc2l0b3IpIHtcbiAgICBpZiAoJ3R5cGUnIGluIGNzdCAmJiBjc3QudHlwZSA9PT0gJ2RvY3VtZW50JylcbiAgICAgICAgY3N0ID0geyBzdGFydDogY3N0LnN0YXJ0LCB2YWx1ZTogY3N0LnZhbHVlIH07XG4gICAgX3Zpc2l0KE9iamVjdC5mcmVlemUoW10pLCBjc3QsIHZpc2l0b3IpO1xufVxuLy8gV2l0aG91dCB0aGUgYGFzIHN5bWJvbGAgY2FzdHMsIFRTIGRlY2xhcmVzIHRoZXNlIGluIHRoZSBgdmlzaXRgXG4vLyBuYW1lc3BhY2UgdXNpbmcgYHZhcmAsIGJ1dCB0aGVuIGNvbXBsYWlucyBhYm91dCB0aGF0IGJlY2F1c2Vcbi8vIGB1bmlxdWUgc3ltYm9sYCBtdXN0IGJlIGBjb25zdGAuXG4vKiogVGVybWluYXRlIHZpc2l0IHRyYXZlcnNhbCBjb21wbGV0ZWx5ICovXG52aXNpdC5CUkVBSyA9IEJSRUFLO1xuLyoqIERvIG5vdCB2aXNpdCB0aGUgY2hpbGRyZW4gb2YgdGhlIGN1cnJlbnQgaXRlbSAqL1xudmlzaXQuU0tJUCA9IFNLSVA7XG4vKiogUmVtb3ZlIHRoZSBjdXJyZW50IGl0ZW0gKi9cbnZpc2l0LlJFTU9WRSA9IFJFTU9WRTtcbi8qKiBGaW5kIHRoZSBpdGVtIGF0IGBwYXRoYCBmcm9tIGBjc3RgIGFzIHRoZSByb290ICovXG52aXNpdC5pdGVtQXRQYXRoID0gKGNzdCwgcGF0aCkgPT4ge1xuICAgIGxldCBpdGVtID0gY3N0O1xuICAgIGZvciAoY29uc3QgW2ZpZWxkLCBpbmRleF0gb2YgcGF0aCkge1xuICAgICAgICBjb25zdCB0b2sgPSBpdGVtPy5bZmllbGRdO1xuICAgICAgICBpZiAodG9rICYmICdpdGVtcycgaW4gdG9rKSB7XG4gICAgICAgICAgICBpdGVtID0gdG9rLml0ZW1zW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbn07XG4vKipcbiAqIEdldCB0aGUgaW1tZWRpYXRlIHBhcmVudCBjb2xsZWN0aW9uIG9mIHRoZSBpdGVtIGF0IGBwYXRoYCBmcm9tIGBjc3RgIGFzIHRoZSByb290LlxuICpcbiAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgY29sbGVjdGlvbiBpcyBub3QgZm91bmQsIHdoaWNoIHNob3VsZCBuZXZlciBoYXBwZW4gaWYgdGhlIGl0ZW0gaXRzZWxmIGV4aXN0cy5cbiAqL1xudmlzaXQucGFyZW50Q29sbGVjdGlvbiA9IChjc3QsIHBhdGgpID0+IHtcbiAgICBjb25zdCBwYXJlbnQgPSB2aXNpdC5pdGVtQXRQYXRoKGNzdCwgcGF0aC5zbGljZSgwLCAtMSkpO1xuICAgIGNvbnN0IGZpZWxkID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdWzBdO1xuICAgIGNvbnN0IGNvbGwgPSBwYXJlbnQ/LltmaWVsZF07XG4gICAgaWYgKGNvbGwgJiYgJ2l0ZW1zJyBpbiBjb2xsKVxuICAgICAgICByZXR1cm4gY29sbDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmVudCBjb2xsZWN0aW9uIG5vdCBmb3VuZCcpO1xufTtcbmZ1bmN0aW9uIF92aXNpdChwYXRoLCBpdGVtLCB2aXNpdG9yKSB7XG4gICAgbGV0IGN0cmwgPSB2aXNpdG9yKGl0ZW0sIHBhdGgpO1xuICAgIGlmICh0eXBlb2YgY3RybCA9PT0gJ3N5bWJvbCcpXG4gICAgICAgIHJldHVybiBjdHJsO1xuICAgIGZvciAoY29uc3QgZmllbGQgb2YgWydrZXknLCAndmFsdWUnXSkge1xuICAgICAgICBjb25zdCB0b2tlbiA9IGl0ZW1bZmllbGRdO1xuICAgICAgICBpZiAodG9rZW4gJiYgJ2l0ZW1zJyBpbiB0b2tlbikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbi5pdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNpID0gX3Zpc2l0KE9iamVjdC5mcmVlemUocGF0aC5jb25jYXQoW1tmaWVsZCwgaV1dKSksIHRva2VuLml0ZW1zW2ldLCB2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNpID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICAgICAgaSA9IGNpIC0gMTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaSA9PT0gQlJFQUspXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCUkVBSztcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaSA9PT0gUkVNT1ZFKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuLml0ZW1zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3RybCA9PT0gJ2Z1bmN0aW9uJyAmJiBmaWVsZCA9PT0gJ2tleScpXG4gICAgICAgICAgICAgICAgY3RybCA9IGN0cmwoaXRlbSwgcGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiBjdHJsID09PSAnZnVuY3Rpb24nID8gY3RybChpdGVtLCBwYXRoKSA6IGN0cmw7XG59XG5cbmV4cG9ydHMudmlzaXQgPSB2aXNpdDtcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3N0U2NhbGFyID0gcmVxdWlyZSgnLi9jc3Qtc2NhbGFyLmpzJyk7XG52YXIgY3N0U3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9jc3Qtc3RyaW5naWZ5LmpzJyk7XG52YXIgY3N0VmlzaXQgPSByZXF1aXJlKCcuL2NzdC12aXNpdC5qcycpO1xuXG4vKiogVGhlIGJ5dGUgb3JkZXIgbWFyayAqL1xuY29uc3QgQk9NID0gJ1xcdXtGRUZGfSc7XG4vKiogU3RhcnQgb2YgZG9jLW1vZGUgKi9cbmNvbnN0IERPQ1VNRU5UID0gJ1xceDAyJzsgLy8gQzA6IFN0YXJ0IG9mIFRleHRcbi8qKiBVbmV4cGVjdGVkIGVuZCBvZiBmbG93LW1vZGUgKi9cbmNvbnN0IEZMT1dfRU5EID0gJ1xceDE4JzsgLy8gQzA6IENhbmNlbFxuLyoqIE5leHQgdG9rZW4gaXMgYSBzY2FsYXIgdmFsdWUgKi9cbmNvbnN0IFNDQUxBUiA9ICdcXHgxZic7IC8vIEMwOiBVbml0IFNlcGFyYXRvclxuLyoqIEByZXR1cm5zIGB0cnVlYCBpZiBgdG9rZW5gIGlzIGEgZmxvdyBvciBibG9jayBjb2xsZWN0aW9uICovXG5jb25zdCBpc0NvbGxlY3Rpb24gPSAodG9rZW4pID0+ICEhdG9rZW4gJiYgJ2l0ZW1zJyBpbiB0b2tlbjtcbi8qKiBAcmV0dXJucyBgdHJ1ZWAgaWYgYHRva2VuYCBpcyBhIGZsb3cgb3IgYmxvY2sgc2NhbGFyOyBub3QgYW4gYWxpYXMgKi9cbmNvbnN0IGlzU2NhbGFyID0gKHRva2VuKSA9PiAhIXRva2VuICYmXG4gICAgKHRva2VuLnR5cGUgPT09ICdzY2FsYXInIHx8XG4gICAgICAgIHRva2VuLnR5cGUgPT09ICdzaW5nbGUtcXVvdGVkLXNjYWxhcicgfHxcbiAgICAgICAgdG9rZW4udHlwZSA9PT0gJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJyB8fFxuICAgICAgICB0b2tlbi50eXBlID09PSAnYmxvY2stc2NhbGFyJyk7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuLyoqIEdldCBhIHByaW50YWJsZSByZXByZXNlbnRhdGlvbiBvZiBhIGxleGVyIHRva2VuICovXG5mdW5jdGlvbiBwcmV0dHlUb2tlbih0b2tlbikge1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgY2FzZSBCT006XG4gICAgICAgICAgICByZXR1cm4gJzxCT00+JztcbiAgICAgICAgY2FzZSBET0NVTUVOVDpcbiAgICAgICAgICAgIHJldHVybiAnPERPQz4nO1xuICAgICAgICBjYXNlIEZMT1dfRU5EOlxuICAgICAgICAgICAgcmV0dXJuICc8RkxPV19FTkQ+JztcbiAgICAgICAgY2FzZSBTQ0FMQVI6XG4gICAgICAgICAgICByZXR1cm4gJzxTQ0FMQVI+JztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0b2tlbik7XG4gICAgfVxufVxuLyoqIElkZW50aWZ5IHRoZSB0eXBlIG9mIGEgbGV4ZXIgdG9rZW4uIE1heSByZXR1cm4gYG51bGxgIGZvciB1bmtub3duIHRva2Vucy4gKi9cbmZ1bmN0aW9uIHRva2VuVHlwZShzb3VyY2UpIHtcbiAgICBzd2l0Y2ggKHNvdXJjZSkge1xuICAgICAgICBjYXNlIEJPTTpcbiAgICAgICAgICAgIHJldHVybiAnYnl0ZS1vcmRlci1tYXJrJztcbiAgICAgICAgY2FzZSBET0NVTUVOVDpcbiAgICAgICAgICAgIHJldHVybiAnZG9jLW1vZGUnO1xuICAgICAgICBjYXNlIEZMT1dfRU5EOlxuICAgICAgICAgICAgcmV0dXJuICdmbG93LWVycm9yLWVuZCc7XG4gICAgICAgIGNhc2UgU0NBTEFSOlxuICAgICAgICAgICAgcmV0dXJuICdzY2FsYXInO1xuICAgICAgICBjYXNlICctLS0nOlxuICAgICAgICAgICAgcmV0dXJuICdkb2Mtc3RhcnQnO1xuICAgICAgICBjYXNlICcuLi4nOlxuICAgICAgICAgICAgcmV0dXJuICdkb2MtZW5kJztcbiAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgY2FzZSAnXFxuJzpcbiAgICAgICAgY2FzZSAnXFxyXFxuJzpcbiAgICAgICAgICAgIHJldHVybiAnbmV3bGluZSc7XG4gICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgcmV0dXJuICdzZXEtaXRlbS1pbmQnO1xuICAgICAgICBjYXNlICc/JzpcbiAgICAgICAgICAgIHJldHVybiAnZXhwbGljaXQta2V5LWluZCc7XG4gICAgICAgIGNhc2UgJzonOlxuICAgICAgICAgICAgcmV0dXJuICdtYXAtdmFsdWUtaW5kJztcbiAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICByZXR1cm4gJ2Zsb3ctbWFwLXN0YXJ0JztcbiAgICAgICAgY2FzZSAnfSc6XG4gICAgICAgICAgICByZXR1cm4gJ2Zsb3ctbWFwLWVuZCc7XG4gICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgcmV0dXJuICdmbG93LXNlcS1zdGFydCc7XG4gICAgICAgIGNhc2UgJ10nOlxuICAgICAgICAgICAgcmV0dXJuICdmbG93LXNlcS1lbmQnO1xuICAgICAgICBjYXNlICcsJzpcbiAgICAgICAgICAgIHJldHVybiAnY29tbWEnO1xuICAgIH1cbiAgICBzd2l0Y2ggKHNvdXJjZVswXSkge1xuICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgY2FzZSAnXFx0JzpcbiAgICAgICAgICAgIHJldHVybiAnc3BhY2UnO1xuICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgIHJldHVybiAnY29tbWVudCc7XG4gICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgcmV0dXJuICdkaXJlY3RpdmUtbGluZSc7XG4gICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgcmV0dXJuICdhbGlhcyc7XG4gICAgICAgIGNhc2UgJyYnOlxuICAgICAgICAgICAgcmV0dXJuICdhbmNob3InO1xuICAgICAgICBjYXNlICchJzpcbiAgICAgICAgICAgIHJldHVybiAndGFnJztcbiAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICAgIHJldHVybiAnc2luZ2xlLXF1b3RlZC1zY2FsYXInO1xuICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICByZXR1cm4gJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJztcbiAgICAgICAgY2FzZSAnfCc6XG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgcmV0dXJuICdibG9jay1zY2FsYXItaGVhZGVyJztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydHMuY3JlYXRlU2NhbGFyVG9rZW4gPSBjc3RTY2FsYXIuY3JlYXRlU2NhbGFyVG9rZW47XG5leHBvcnRzLnJlc29sdmVBc1NjYWxhciA9IGNzdFNjYWxhci5yZXNvbHZlQXNTY2FsYXI7XG5leHBvcnRzLnNldFNjYWxhclZhbHVlID0gY3N0U2NhbGFyLnNldFNjYWxhclZhbHVlO1xuZXhwb3J0cy5zdHJpbmdpZnkgPSBjc3RTdHJpbmdpZnkuc3RyaW5naWZ5O1xuZXhwb3J0cy52aXNpdCA9IGNzdFZpc2l0LnZpc2l0O1xuZXhwb3J0cy5CT00gPSBCT007XG5leHBvcnRzLkRPQ1VNRU5UID0gRE9DVU1FTlQ7XG5leHBvcnRzLkZMT1dfRU5EID0gRkxPV19FTkQ7XG5leHBvcnRzLlNDQUxBUiA9IFNDQUxBUjtcbmV4cG9ydHMuaXNDb2xsZWN0aW9uID0gaXNDb2xsZWN0aW9uO1xuZXhwb3J0cy5pc1NjYWxhciA9IGlzU2NhbGFyO1xuZXhwb3J0cy5wcmV0dHlUb2tlbiA9IHByZXR0eVRva2VuO1xuZXhwb3J0cy50b2tlblR5cGUgPSB0b2tlblR5cGU7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIGNzdCA9IHJlcXVpcmUoJy4vY3N0LmpzJyk7XG5cbi8qXG5TVEFSVCAtPiBzdHJlYW1cblxuc3RyZWFtXG4gIGRpcmVjdGl2ZSAtPiBsaW5lLWVuZCAtPiBzdHJlYW1cbiAgaW5kZW50ICsgbGluZS1lbmQgLT4gc3RyZWFtXG4gIFtlbHNlXSAtPiBsaW5lLXN0YXJ0XG5cbmxpbmUtZW5kXG4gIGNvbW1lbnQgLT4gbGluZS1lbmRcbiAgbmV3bGluZSAtPiAuXG4gIGlucHV0LWVuZCAtPiBFTkRcblxubGluZS1zdGFydFxuICBkb2Mtc3RhcnQgLT4gZG9jXG4gIGRvYy1lbmQgLT4gc3RyZWFtXG4gIFtlbHNlXSAtPiBpbmRlbnQgLT4gYmxvY2stc3RhcnRcblxuYmxvY2stc3RhcnRcbiAgc2VxLWl0ZW0tc3RhcnQgLT4gYmxvY2stc3RhcnRcbiAgZXhwbGljaXQta2V5LXN0YXJ0IC0+IGJsb2NrLXN0YXJ0XG4gIG1hcC12YWx1ZS1zdGFydCAtPiBibG9jay1zdGFydFxuICBbZWxzZV0gLT4gZG9jXG5cbmRvY1xuICBsaW5lLWVuZCAtPiBsaW5lLXN0YXJ0XG4gIHNwYWNlcyAtPiBkb2NcbiAgYW5jaG9yIC0+IGRvY1xuICB0YWcgLT4gZG9jXG4gIGZsb3ctc3RhcnQgLT4gZmxvdyAtPiBkb2NcbiAgZmxvdy1lbmQgLT4gZXJyb3IgLT4gZG9jXG4gIHNlcS1pdGVtLXN0YXJ0IC0+IGVycm9yIC0+IGRvY1xuICBleHBsaWNpdC1rZXktc3RhcnQgLT4gZXJyb3IgLT4gZG9jXG4gIG1hcC12YWx1ZS1zdGFydCAtPiBkb2NcbiAgYWxpYXMgLT4gZG9jXG4gIHF1b3RlLXN0YXJ0IC0+IHF1b3RlZC1zY2FsYXIgLT4gZG9jXG4gIGJsb2NrLXNjYWxhci1oZWFkZXIgLT4gbGluZS1lbmQgLT4gYmxvY2stc2NhbGFyKG1pbikgLT4gbGluZS1zdGFydFxuICBbZWxzZV0gLT4gcGxhaW4tc2NhbGFyKGZhbHNlLCBtaW4pIC0+IGRvY1xuXG5mbG93XG4gIGxpbmUtZW5kIC0+IGZsb3dcbiAgc3BhY2VzIC0+IGZsb3dcbiAgYW5jaG9yIC0+IGZsb3dcbiAgdGFnIC0+IGZsb3dcbiAgZmxvdy1zdGFydCAtPiBmbG93IC0+IGZsb3dcbiAgZmxvdy1lbmQgLT4gLlxuICBzZXEtaXRlbS1zdGFydCAtPiBlcnJvciAtPiBmbG93XG4gIGV4cGxpY2l0LWtleS1zdGFydCAtPiBmbG93XG4gIG1hcC12YWx1ZS1zdGFydCAtPiBmbG93XG4gIGFsaWFzIC0+IGZsb3dcbiAgcXVvdGUtc3RhcnQgLT4gcXVvdGVkLXNjYWxhciAtPiBmbG93XG4gIGNvbW1hIC0+IGZsb3dcbiAgW2Vsc2VdIC0+IHBsYWluLXNjYWxhcih0cnVlLCAwKSAtPiBmbG93XG5cbnF1b3RlZC1zY2FsYXJcbiAgcXVvdGUtZW5kIC0+IC5cbiAgW2Vsc2VdIC0+IHF1b3RlZC1zY2FsYXJcblxuYmxvY2stc2NhbGFyKG1pbilcbiAgbmV3bGluZSArIHBlZWsoaW5kZW50IDwgbWluKSAtPiAuXG4gIFtlbHNlXSAtPiBibG9jay1zY2FsYXIobWluKVxuXG5wbGFpbi1zY2FsYXIoaXMtZmxvdywgbWluKVxuICBzY2FsYXItZW5kKGlzLWZsb3cpIC0+IC5cbiAgcGVlayhuZXdsaW5lICsgKGluZGVudCA8IG1pbikpIC0+IC5cbiAgW2Vsc2VdIC0+IHBsYWluLXNjYWxhcihtaW4pXG4qL1xuZnVuY3Rpb24gaXNFbXB0eShjaCkge1xuICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIGNhc2UgJyAnOlxuICAgICAgICBjYXNlICdcXG4nOlxuICAgICAgICBjYXNlICdcXHInOlxuICAgICAgICBjYXNlICdcXHQnOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuY29uc3QgaGV4RGlnaXRzID0gbmV3IFNldCgnMDEyMzQ1Njc4OUFCQ0RFRmFiY2RlZicpO1xuY29uc3QgdGFnQ2hhcnMgPSBuZXcgU2V0KFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXotIzsvPzpAJj0rJF8uIX4qJygpXCIpO1xuY29uc3QgZmxvd0luZGljYXRvckNoYXJzID0gbmV3IFNldCgnLFtde30nKTtcbmNvbnN0IGludmFsaWRBbmNob3JDaGFycyA9IG5ldyBTZXQoJyAsW117fVxcblxcclxcdCcpO1xuY29uc3QgaXNOb3RBbmNob3JDaGFyID0gKGNoKSA9PiAhY2ggfHwgaW52YWxpZEFuY2hvckNoYXJzLmhhcyhjaCk7XG4vKipcbiAqIFNwbGl0cyBhbiBpbnB1dCBzdHJpbmcgaW50byBsZXhpY2FsIHRva2VucywgaS5lLiBzbWFsbGVyIHN0cmluZ3MgdGhhdCBhcmVcbiAqIGVhc2lseSBpZGVudGlmaWFibGUgYnkgYHRva2Vucy50b2tlblR5cGUoKWAuXG4gKlxuICogTGV4aW5nIHN0YXJ0cyBhbHdheXMgaW4gYSBcInN0cmVhbVwiIGNvbnRleHQuIEluY29tcGxldGUgaW5wdXQgbWF5IGJlIGJ1ZmZlcmVkXG4gKiB1bnRpbCBhIGNvbXBsZXRlIHRva2VuIGNhbiBiZSBlbWl0dGVkLlxuICpcbiAqIEluIGFkZGl0aW9uIHRvIHNsaWNlcyBvZiB0aGUgb3JpZ2luYWwgaW5wdXQsIHRoZSBmb2xsb3dpbmcgY29udHJvbCBjaGFyYWN0ZXJzXG4gKiBtYXkgYWxzbyBiZSBlbWl0dGVkOlxuICpcbiAqIC0gYFxceDAyYCAoU3RhcnQgb2YgVGV4dCk6IEEgZG9jdW1lbnQgc3RhcnRzIHdpdGggdGhlIG5leHQgdG9rZW5cbiAqIC0gYFxceDE4YCAoQ2FuY2VsKTogVW5leHBlY3RlZCBlbmQgb2YgZmxvdy1tb2RlIChpbmRpY2F0ZXMgYW4gZXJyb3IpXG4gKiAtIGBcXHgxZmAgKFVuaXQgU2VwYXJhdG9yKTogTmV4dCB0b2tlbiBpcyBhIHNjYWxhciB2YWx1ZVxuICogLSBgXFx1e0ZFRkZ9YCAoQnl0ZSBvcmRlciBtYXJrKTogRW1pdHRlZCBzZXBhcmF0ZWx5IG91dHNpZGUgZG9jdW1lbnRzXG4gKi9cbmNsYXNzIExleGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgYnVmZmVyIG1hcmtzIHRoZSBlbmQgb2ZcbiAgICAgICAgICogYWxsIGlucHV0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmF0RW5kID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHBsaWNpdCBpbmRlbnQgc2V0IGluIGJsb2NrIHNjYWxhciBoZWFkZXIsIGFzIGFuIG9mZnNldCBmcm9tIHRoZSBjdXJyZW50XG4gICAgICAgICAqIG1pbmltdW0gaW5kZW50LCBzbyBlLmcuIHNldCB0byAxIGZyb20gYSBoZWFkZXIgYHwyK2AuIFNldCB0byAtMSBpZiBub3RcbiAgICAgICAgICogZXhwbGljaXRseSBzZXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJsb2NrU2NhbGFySW5kZW50ID0gLTE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCbG9jayBzY2FsYXJzIHRoYXQgaW5jbHVkZSBhICsgKGtlZXApIGNob21waW5nIGluZGljYXRvciBpbiB0aGVpciBoZWFkZXJcbiAgICAgICAgICogaW5jbHVkZSB0cmFpbGluZyBlbXB0eSBsaW5lcywgd2hpY2ggYXJlIG90aGVyd2lzZSBleGNsdWRlZCBmcm9tIHRoZVxuICAgICAgICAgKiBzY2FsYXIncyBjb250ZW50cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmxvY2tTY2FsYXJLZWVwID0gZmFsc2U7XG4gICAgICAgIC8qKiBDdXJyZW50IGlucHV0ICovXG4gICAgICAgIHRoaXMuYnVmZmVyID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGbGFnIG5vdGluZyB3aGV0aGVyIHRoZSBtYXAgdmFsdWUgaW5kaWNhdG9yIDogY2FuIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGlzXG4gICAgICAgICAqIG5vZGUgd2l0aGluIGEgZmxvdyBjb250ZXh0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mbG93S2V5ID0gZmFsc2U7XG4gICAgICAgIC8qKiBDb3VudCBvZiBzdXJyb3VuZGluZyBmbG93IGNvbGxlY3Rpb24gbGV2ZWxzLiAqL1xuICAgICAgICB0aGlzLmZsb3dMZXZlbCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNaW5pbXVtIGxldmVsIG9mIGluZGVudGF0aW9uIHJlcXVpcmVkIGZvciBuZXh0IGxpbmVzIHRvIGJlIHBhcnNlZCBhcyBhXG4gICAgICAgICAqIHBhcnQgb2YgdGhlIGN1cnJlbnQgc2NhbGFyIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmRlbnROZXh0ID0gMDtcbiAgICAgICAgLyoqIEluZGVudGF0aW9uIGxldmVsIG9mIHRoZSBjdXJyZW50IGxpbmUuICovXG4gICAgICAgIHRoaXMuaW5kZW50VmFsdWUgPSAwO1xuICAgICAgICAvKiogUG9zaXRpb24gb2YgdGhlIG5leHQgXFxuIGNoYXJhY3Rlci4gKi9cbiAgICAgICAgdGhpcy5saW5lRW5kUG9zID0gbnVsbDtcbiAgICAgICAgLyoqIFN0b3JlcyB0aGUgc3RhdGUgb2YgdGhlIGxleGVyIGlmIHJlYWNoaW5nIHRoZSBlbmQgb2YgaW5jcG9tcGxldGUgaW5wdXQgKi9cbiAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICAgICAgLyoqIEEgcG9pbnRlciB0byBgYnVmZmVyYDsgdGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIGxleGVyLiAqL1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIFlBTUwgdG9rZW5zIGZyb20gdGhlIGBzb3VyY2VgIHN0cmluZy4gSWYgYGluY29tcGxldGVgLFxuICAgICAqIGEgcGFydCBvZiB0aGUgbGFzdCBsaW5lIG1heSBiZSBsZWZ0IGFzIGEgYnVmZmVyIGZvciB0aGUgbmV4dCBjYWxsLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBnZW5lcmF0b3Igb2YgbGV4aWNhbCB0b2tlbnNcbiAgICAgKi9cbiAgICAqbGV4KHNvdXJjZSwgaW5jb21wbGV0ZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ3NvdXJjZSBpcyBub3QgYSBzdHJpbmcnKTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIgPyB0aGlzLmJ1ZmZlciArIHNvdXJjZSA6IHNvdXJjZTtcbiAgICAgICAgICAgIHRoaXMubGluZUVuZFBvcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hdEVuZCA9ICFpbmNvbXBsZXRlO1xuICAgICAgICBsZXQgbmV4dCA9IHRoaXMubmV4dCA/PyAnc3RyZWFtJztcbiAgICAgICAgd2hpbGUgKG5leHQgJiYgKGluY29tcGxldGUgfHwgdGhpcy5oYXNDaGFycygxKSkpXG4gICAgICAgICAgICBuZXh0ID0geWllbGQqIHRoaXMucGFyc2VOZXh0KG5leHQpO1xuICAgIH1cbiAgICBhdExpbmVFbmQoKSB7XG4gICAgICAgIGxldCBpID0gdGhpcy5wb3M7XG4gICAgICAgIGxldCBjaCA9IHRoaXMuYnVmZmVyW2ldO1xuICAgICAgICB3aGlsZSAoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcpXG4gICAgICAgICAgICBjaCA9IHRoaXMuYnVmZmVyWysraV07XG4gICAgICAgIGlmICghY2ggfHwgY2ggPT09ICcjJyB8fCBjaCA9PT0gJ1xcbicpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGNoID09PSAnXFxyJylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcltpICsgMV0gPT09ICdcXG4nO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNoYXJBdChuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLnBvcyArIG5dO1xuICAgIH1cbiAgICBjb250aW51ZVNjYWxhcihvZmZzZXQpIHtcbiAgICAgICAgbGV0IGNoID0gdGhpcy5idWZmZXJbb2Zmc2V0XTtcbiAgICAgICAgaWYgKHRoaXMuaW5kZW50TmV4dCA+IDApIHtcbiAgICAgICAgICAgIGxldCBpbmRlbnQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGNoID09PSAnICcpXG4gICAgICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclsrK2luZGVudCArIG9mZnNldF07XG4gICAgICAgICAgICBpZiAoY2ggPT09ICdcXHInKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuYnVmZmVyW2luZGVudCArIG9mZnNldCArIDFdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0ID09PSAnXFxuJyB8fCAoIW5leHQgJiYgIXRoaXMuYXRFbmQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0ICsgaW5kZW50ICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaCA9PT0gJ1xcbicgfHwgaW5kZW50ID49IHRoaXMuaW5kZW50TmV4dCB8fCAoIWNoICYmICF0aGlzLmF0RW5kKVxuICAgICAgICAgICAgICAgID8gb2Zmc2V0ICsgaW5kZW50XG4gICAgICAgICAgICAgICAgOiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJy4nKSB7XG4gICAgICAgICAgICBjb25zdCBkdCA9IHRoaXMuYnVmZmVyLnN1YnN0cihvZmZzZXQsIDMpO1xuICAgICAgICAgICAgaWYgKChkdCA9PT0gJy0tLScgfHwgZHQgPT09ICcuLi4nKSAmJiBpc0VtcHR5KHRoaXMuYnVmZmVyW29mZnNldCArIDNdKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gICAgZ2V0TGluZSgpIHtcbiAgICAgICAgbGV0IGVuZCA9IHRoaXMubGluZUVuZFBvcztcbiAgICAgICAgaWYgKHR5cGVvZiBlbmQgIT09ICdudW1iZXInIHx8IChlbmQgIT09IC0xICYmIGVuZCA8IHRoaXMucG9zKSkge1xuICAgICAgICAgICAgZW5kID0gdGhpcy5idWZmZXIuaW5kZXhPZignXFxuJywgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5saW5lRW5kUG9zID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPT09IC0xKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXRFbmQgPyB0aGlzLmJ1ZmZlci5zdWJzdHJpbmcodGhpcy5wb3MpIDogbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyW2VuZCAtIDFdID09PSAnXFxyJylcbiAgICAgICAgICAgIGVuZCAtPSAxO1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIuc3Vic3RyaW5nKHRoaXMucG9zLCBlbmQpO1xuICAgIH1cbiAgICBoYXNDaGFycyhuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyArIG4gPD0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgIH1cbiAgICBzZXROZXh0KHN0YXRlKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIuc3Vic3RyaW5nKHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmxpbmVFbmRQb3MgPSBudWxsO1xuICAgICAgICB0aGlzLm5leHQgPSBzdGF0ZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHBlZWsobikge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIuc3Vic3RyKHRoaXMucG9zLCBuKTtcbiAgICB9XG4gICAgKnBhcnNlTmV4dChuZXh0KSB7XG4gICAgICAgIHN3aXRjaCAobmV4dCkge1xuICAgICAgICAgICAgY2FzZSAnc3RyZWFtJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VTdHJlYW0oKTtcbiAgICAgICAgICAgIGNhc2UgJ2xpbmUtc3RhcnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUxpbmVTdGFydCgpO1xuICAgICAgICAgICAgY2FzZSAnYmxvY2stc3RhcnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUJsb2NrU3RhcnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ2RvYyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlRG9jdW1lbnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ2Zsb3cnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUZsb3dDb2xsZWN0aW9uKCk7XG4gICAgICAgICAgICBjYXNlICdxdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VRdW90ZWRTY2FsYXIoKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlQmxvY2tTY2FsYXIoKTtcbiAgICAgICAgICAgIGNhc2UgJ3BsYWluLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlUGxhaW5TY2FsYXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqcGFyc2VTdHJlYW0oKSB7XG4gICAgICAgIGxldCBsaW5lID0gdGhpcy5nZXRMaW5lKCk7XG4gICAgICAgIGlmIChsaW5lID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgnc3RyZWFtJyk7XG4gICAgICAgIGlmIChsaW5lWzBdID09PSBjc3QuQk9NKSB7XG4gICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQoMSk7XG4gICAgICAgICAgICBsaW5lID0gbGluZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmVbMF0gPT09ICclJykge1xuICAgICAgICAgICAgbGV0IGRpckVuZCA9IGxpbmUubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGNzID0gbGluZS5pbmRleE9mKCcjJyk7XG4gICAgICAgICAgICB3aGlsZSAoY3MgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2ggPSBsaW5lW2NzIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnICcgfHwgY2ggPT09ICdcXHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpckVuZCA9IGNzIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjcyA9IGxpbmUuaW5kZXhPZignIycsIGNzICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaCA9IGxpbmVbZGlyRW5kIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnICcgfHwgY2ggPT09ICdcXHQnKVxuICAgICAgICAgICAgICAgICAgICBkaXJFbmQgLT0gMTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbiA9ICh5aWVsZCogdGhpcy5wdXNoQ291bnQoZGlyRW5kKSkgKyAoeWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKSk7XG4gICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQobGluZS5sZW5ndGggLSBuKTsgLy8gcG9zc2libGUgY29tbWVudFxuICAgICAgICAgICAgdGhpcy5wdXNoTmV3bGluZSgpO1xuICAgICAgICAgICAgcmV0dXJuICdzdHJlYW0nO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF0TGluZUVuZCgpKSB7XG4gICAgICAgICAgICBjb25zdCBzcCA9IHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSk7XG4gICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQobGluZS5sZW5ndGggLSBzcCk7XG4gICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoTmV3bGluZSgpO1xuICAgICAgICAgICAgcmV0dXJuICdzdHJlYW0nO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIGNzdC5ET0NVTUVOVDtcbiAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlTGluZVN0YXJ0KCk7XG4gICAgfVxuICAgICpwYXJzZUxpbmVTdGFydCgpIHtcbiAgICAgICAgY29uc3QgY2ggPSB0aGlzLmNoYXJBdCgwKTtcbiAgICAgICAgaWYgKCFjaCAmJiAhdGhpcy5hdEVuZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE5leHQoJ2xpbmUtc3RhcnQnKTtcbiAgICAgICAgaWYgKGNoID09PSAnLScgfHwgY2ggPT09ICcuJykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmF0RW5kICYmICF0aGlzLmhhc0NoYXJzKDQpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE5leHQoJ2xpbmUtc3RhcnQnKTtcbiAgICAgICAgICAgIGNvbnN0IHMgPSB0aGlzLnBlZWsoMyk7XG4gICAgICAgICAgICBpZiAoKHMgPT09ICctLS0nIHx8IHMgPT09ICcuLi4nKSAmJiBpc0VtcHR5KHRoaXMuY2hhckF0KDMpKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudFZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudE5leHQgPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiBzID09PSAnLS0tJyA/ICdkb2MnIDogJ3N0cmVhbSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmRlbnRWYWx1ZSA9IHlpZWxkKiB0aGlzLnB1c2hTcGFjZXMoZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5pbmRlbnROZXh0ID4gdGhpcy5pbmRlbnRWYWx1ZSAmJiAhaXNFbXB0eSh0aGlzLmNoYXJBdCgxKSkpXG4gICAgICAgICAgICB0aGlzLmluZGVudE5leHQgPSB0aGlzLmluZGVudFZhbHVlO1xuICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VCbG9ja1N0YXJ0KCk7XG4gICAgfVxuICAgICpwYXJzZUJsb2NrU3RhcnQoKSB7XG4gICAgICAgIGNvbnN0IFtjaDAsIGNoMV0gPSB0aGlzLnBlZWsoMik7XG4gICAgICAgIGlmICghY2gxICYmICF0aGlzLmF0RW5kKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgnYmxvY2stc3RhcnQnKTtcbiAgICAgICAgaWYgKChjaDAgPT09ICctJyB8fCBjaDAgPT09ICc/JyB8fCBjaDAgPT09ICc6JykgJiYgaXNFbXB0eShjaDEpKSB7XG4gICAgICAgICAgICBjb25zdCBuID0gKHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKSkgKyAoeWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKSk7XG4gICAgICAgICAgICB0aGlzLmluZGVudE5leHQgPSB0aGlzLmluZGVudFZhbHVlICsgMTtcbiAgICAgICAgICAgIHRoaXMuaW5kZW50VmFsdWUgKz0gbjtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUJsb2NrU3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ2RvYyc7XG4gICAgfVxuICAgICpwYXJzZURvY3VtZW50KCkge1xuICAgICAgICB5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpO1xuICAgICAgICBjb25zdCBsaW5lID0gdGhpcy5nZXRMaW5lKCk7XG4gICAgICAgIGlmIChsaW5lID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgnZG9jJyk7XG4gICAgICAgIGxldCBuID0geWllbGQqIHRoaXMucHVzaEluZGljYXRvcnMoKTtcbiAgICAgICAgc3dpdGNoIChsaW5lW25dKSB7XG4gICAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQobGluZS5sZW5ndGggLSBuKTtcbiAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoTmV3bGluZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUxpbmVTdGFydCgpO1xuICAgICAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQoMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5mbG93S2V5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5mbG93TGV2ZWwgPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiAnZmxvdyc7XG4gICAgICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICAgIGNhc2UgJ10nOlxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQoMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdkb2MnO1xuICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaFVudGlsKGlzTm90QW5jaG9yQ2hhcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdkb2MnO1xuICAgICAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VRdW90ZWRTY2FsYXIoKTtcbiAgICAgICAgICAgIGNhc2UgJ3wnOlxuICAgICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICAgICAgbiArPSB5aWVsZCogdGhpcy5wYXJzZUJsb2NrU2NhbGFySGVhZGVyKCk7XG4gICAgICAgICAgICAgICAgbiArPSB5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpO1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudChsaW5lLmxlbmd0aCAtIG4pO1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hOZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlQmxvY2tTY2FsYXIoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlUGxhaW5TY2FsYXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqcGFyc2VGbG93Q29sbGVjdGlvbigpIHtcbiAgICAgICAgbGV0IG5sLCBzcDtcbiAgICAgICAgbGV0IGluZGVudCA9IC0xO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBubCA9IHlpZWxkKiB0aGlzLnB1c2hOZXdsaW5lKCk7XG4gICAgICAgICAgICBpZiAobmwgPiAwKSB7XG4gICAgICAgICAgICAgICAgc3AgPSB5aWVsZCogdGhpcy5wdXNoU3BhY2VzKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudFZhbHVlID0gaW5kZW50ID0gc3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzcCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzcCArPSB5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpO1xuICAgICAgICB9IHdoaWxlIChubCArIHNwID4gMCk7XG4gICAgICAgIGNvbnN0IGxpbmUgPSB0aGlzLmdldExpbmUoKTtcbiAgICAgICAgaWYgKGxpbmUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdmbG93Jyk7XG4gICAgICAgIGlmICgoaW5kZW50ICE9PSAtMSAmJiBpbmRlbnQgPCB0aGlzLmluZGVudE5leHQgJiYgbGluZVswXSAhPT0gJyMnKSB8fFxuICAgICAgICAgICAgKGluZGVudCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIChsaW5lLnN0YXJ0c1dpdGgoJy0tLScpIHx8IGxpbmUuc3RhcnRzV2l0aCgnLi4uJykpICYmXG4gICAgICAgICAgICAgICAgaXNFbXB0eShsaW5lWzNdKSkpIHtcbiAgICAgICAgICAgIC8vIEFsbG93aW5nIGZvciB0aGUgdGVybWluYWwgXSBvciB9IGF0IHRoZSBzYW1lIChyYXRoZXIgdGhhbiBncmVhdGVyKVxuICAgICAgICAgICAgLy8gaW5kZW50IGxldmVsIGFzIHRoZSBpbml0aWFsIFsgb3IgeyBpcyB0ZWNobmljYWxseSBpbnZhbGlkLCBidXRcbiAgICAgICAgICAgIC8vIGZhaWxpbmcgaGVyZSB3b3VsZCBiZSBzdXJwcmlzaW5nIHRvIHVzZXJzLlxuICAgICAgICAgICAgY29uc3QgYXRGbG93RW5kTWFya2VyID0gaW5kZW50ID09PSB0aGlzLmluZGVudE5leHQgLSAxICYmXG4gICAgICAgICAgICAgICAgdGhpcy5mbG93TGV2ZWwgPT09IDEgJiZcbiAgICAgICAgICAgICAgICAobGluZVswXSA9PT0gJ10nIHx8IGxpbmVbMF0gPT09ICd9Jyk7XG4gICAgICAgICAgICBpZiAoIWF0Rmxvd0VuZE1hcmtlcikge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dMZXZlbCA9IDA7XG4gICAgICAgICAgICAgICAgeWllbGQgY3N0LkZMT1dfRU5EO1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUxpbmVTdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBuID0gMDtcbiAgICAgICAgd2hpbGUgKGxpbmVbbl0gPT09ICcsJykge1xuICAgICAgICAgICAgbiArPSB5aWVsZCogdGhpcy5wdXNoQ291bnQoMSk7XG4gICAgICAgICAgICBuICs9IHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmZsb3dLZXkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBuICs9IHlpZWxkKiB0aGlzLnB1c2hJbmRpY2F0b3JzKCk7XG4gICAgICAgIHN3aXRjaCAobGluZVtuXSkge1xuICAgICAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdmbG93JztcbiAgICAgICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudChsaW5lLmxlbmd0aCAtIG4pO1xuICAgICAgICAgICAgICAgIHJldHVybiAnZmxvdyc7XG4gICAgICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dLZXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dMZXZlbCArPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiAnZmxvdyc7XG4gICAgICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICAgIGNhc2UgJ10nOlxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dLZXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0xldmVsIC09IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmxvd0xldmVsID8gJ2Zsb3cnIDogJ2RvYyc7XG4gICAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoVW50aWwoaXNOb3RBbmNob3JDaGFyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2Zsb3cnO1xuICAgICAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dLZXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZVF1b3RlZFNjYWxhcigpO1xuICAgICAgICAgICAgY2FzZSAnOic6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5jaGFyQXQoMSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmxvd0tleSB8fCBpc0VtcHR5KG5leHQpIHx8IG5leHQgPT09ICcsJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZsb3dLZXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KDEpO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2Zsb3cnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0tleSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZVBsYWluU2NhbGFyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKnBhcnNlUXVvdGVkU2NhbGFyKCkge1xuICAgICAgICBjb25zdCBxdW90ZSA9IHRoaXMuY2hhckF0KDApO1xuICAgICAgICBsZXQgZW5kID0gdGhpcy5idWZmZXIuaW5kZXhPZihxdW90ZSwgdGhpcy5wb3MgKyAxKTtcbiAgICAgICAgaWYgKHF1b3RlID09PSBcIidcIikge1xuICAgICAgICAgICAgd2hpbGUgKGVuZCAhPT0gLTEgJiYgdGhpcy5idWZmZXJbZW5kICsgMV0gPT09IFwiJ1wiKVxuICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMuYnVmZmVyLmluZGV4T2YoXCInXCIsIGVuZCArIDIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZG91YmxlLXF1b3RlXG4gICAgICAgICAgICB3aGlsZSAoZW5kICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGxldCBuID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5idWZmZXJbZW5kIC0gMSAtIG5dID09PSAnXFxcXCcpXG4gICAgICAgICAgICAgICAgICAgIG4gKz0gMTtcbiAgICAgICAgICAgICAgICBpZiAobiAlIDIgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMuYnVmZmVyLmluZGV4T2YoJ1wiJywgZW5kICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSBsb29raW5nIGZvciBuZXdsaW5lcyB3aXRoaW4gdGhlIHF1b3Rlc1xuICAgICAgICBjb25zdCBxYiA9IHRoaXMuYnVmZmVyLnN1YnN0cmluZygwLCBlbmQpO1xuICAgICAgICBsZXQgbmwgPSBxYi5pbmRleE9mKCdcXG4nLCB0aGlzLnBvcyk7XG4gICAgICAgIGlmIChubCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHdoaWxlIChubCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjcyA9IHRoaXMuY29udGludWVTY2FsYXIobmwgKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAoY3MgPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBubCA9IHFiLmluZGV4T2YoJ1xcbicsIGNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChubCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGFuIGVycm9yIGNhdXNlZCBieSBhbiB1bmV4cGVjdGVkIHVuaW5kZW50XG4gICAgICAgICAgICAgICAgZW5kID0gbmwgLSAocWJbbmwgLSAxXSA9PT0gJ1xccicgPyAyIDogMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hdEVuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdxdW90ZWQtc2NhbGFyJyk7XG4gICAgICAgICAgICBlbmQgPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQqIHRoaXMucHVzaFRvSW5kZXgoZW5kICsgMSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5mbG93TGV2ZWwgPyAnZmxvdycgOiAnZG9jJztcbiAgICB9XG4gICAgKnBhcnNlQmxvY2tTY2FsYXJIZWFkZXIoKSB7XG4gICAgICAgIHRoaXMuYmxvY2tTY2FsYXJJbmRlbnQgPSAtMTtcbiAgICAgICAgdGhpcy5ibG9ja1NjYWxhcktlZXAgPSBmYWxzZTtcbiAgICAgICAgbGV0IGkgPSB0aGlzLnBvcztcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoID0gdGhpcy5idWZmZXJbKytpXTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJysnKVxuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tTY2FsYXJLZWVwID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoID4gJzAnICYmIGNoIDw9ICc5JylcbiAgICAgICAgICAgICAgICB0aGlzLmJsb2NrU2NhbGFySW5kZW50ID0gTnVtYmVyKGNoKSAtIDE7XG4gICAgICAgICAgICBlbHNlIGlmIChjaCAhPT0gJy0nKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wdXNoVW50aWwoY2ggPT4gaXNFbXB0eShjaCkgfHwgY2ggPT09ICcjJyk7XG4gICAgfVxuICAgICpwYXJzZUJsb2NrU2NhbGFyKCkge1xuICAgICAgICBsZXQgbmwgPSB0aGlzLnBvcyAtIDE7IC8vIG1heSBiZSAtMSBpZiB0aGlzLnBvcyA9PT0gMFxuICAgICAgICBsZXQgaW5kZW50ID0gMDtcbiAgICAgICAgbGV0IGNoO1xuICAgICAgICBsb29wOiBmb3IgKGxldCBpID0gdGhpcy5wb3M7IChjaCA9IHRoaXMuYnVmZmVyW2ldKTsgKytpKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnICc6XG4gICAgICAgICAgICAgICAgICAgIGluZGVudCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdcXG4nOlxuICAgICAgICAgICAgICAgICAgICBubCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGluZGVudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1xccic6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuYnVmZmVyW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXh0ICYmICF0aGlzLmF0RW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgnYmxvY2stc2NhbGFyJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID09PSAnXFxuJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghY2ggJiYgIXRoaXMuYXRFbmQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdibG9jay1zY2FsYXInKTtcbiAgICAgICAgaWYgKGluZGVudCA+PSB0aGlzLmluZGVudE5leHQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJsb2NrU2NhbGFySW5kZW50ID09PSAtMSlcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudE5leHQgPSBpbmRlbnQ7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudE5leHQgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJsb2NrU2NhbGFySW5kZW50ICsgKHRoaXMuaW5kZW50TmV4dCA9PT0gMCA/IDEgOiB0aGlzLmluZGVudE5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNzID0gdGhpcy5jb250aW51ZVNjYWxhcihubCArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChjcyA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIG5sID0gdGhpcy5idWZmZXIuaW5kZXhPZignXFxuJywgY3MpO1xuICAgICAgICAgICAgfSB3aGlsZSAobmwgIT09IC0xKTtcbiAgICAgICAgICAgIGlmIChubCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYXRFbmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE5leHQoJ2Jsb2NrLXNjYWxhcicpO1xuICAgICAgICAgICAgICAgIG5sID0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRyYWlsaW5nIGluc3VmZmljaWVudGx5IGluZGVudGVkIHRhYnMgYXJlIGludmFsaWQuXG4gICAgICAgIC8vIFRvIGNhdGNoIHRoYXQgZHVyaW5nIHBhcnNpbmcsIHdlIGluY2x1ZGUgdGhlbSBpbiB0aGUgYmxvY2sgc2NhbGFyIHZhbHVlLlxuICAgICAgICBsZXQgaSA9IG5sICsgMTtcbiAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlcltpXTtcbiAgICAgICAgd2hpbGUgKGNoID09PSAnICcpXG4gICAgICAgICAgICBjaCA9IHRoaXMuYnVmZmVyWysraV07XG4gICAgICAgIGlmIChjaCA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICAgIHdoaWxlIChjaCA9PT0gJ1xcdCcgfHwgY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xccicgfHwgY2ggPT09ICdcXG4nKVxuICAgICAgICAgICAgICAgIGNoID0gdGhpcy5idWZmZXJbKytpXTtcbiAgICAgICAgICAgIG5sID0gaSAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuYmxvY2tTY2FsYXJLZWVwKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSBubCAtIDE7XG4gICAgICAgICAgICAgICAgbGV0IGNoID0gdGhpcy5idWZmZXJbaV07XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJylcbiAgICAgICAgICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclstLWldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RDaGFyID0gaTsgLy8gRHJvcCB0aGUgbGluZSBpZiBsYXN0IGNoYXIgbm90IG1vcmUgaW5kZW50ZWRcbiAgICAgICAgICAgICAgICB3aGlsZSAoY2ggPT09ICcgJylcbiAgICAgICAgICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclstLWldO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcbicgJiYgaSA+PSB0aGlzLnBvcyAmJiBpICsgMSArIGluZGVudCA+IGxhc3RDaGFyKVxuICAgICAgICAgICAgICAgICAgICBubCA9IGk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIGNzdC5TQ0FMQVI7XG4gICAgICAgIHlpZWxkKiB0aGlzLnB1c2hUb0luZGV4KG5sICsgMSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUxpbmVTdGFydCgpO1xuICAgIH1cbiAgICAqcGFyc2VQbGFpblNjYWxhcigpIHtcbiAgICAgICAgY29uc3QgaW5GbG93ID0gdGhpcy5mbG93TGV2ZWwgPiAwO1xuICAgICAgICBsZXQgZW5kID0gdGhpcy5wb3MgLSAxO1xuICAgICAgICBsZXQgaSA9IHRoaXMucG9zIC0gMTtcbiAgICAgICAgbGV0IGNoO1xuICAgICAgICB3aGlsZSAoKGNoID0gdGhpcy5idWZmZXJbKytpXSkpIHtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJzonKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuYnVmZmVyW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShuZXh0KSB8fCAoaW5GbG93ICYmIGZsb3dJbmRpY2F0b3JDaGFycy5oYXMobmV4dCkpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNFbXB0eShjaCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMuYnVmZmVyW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXHInKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSB0aGlzLmJ1ZmZlcltpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgPT09ICcjJyB8fCAoaW5GbG93ICYmIGZsb3dJbmRpY2F0b3JDaGFycy5oYXMobmV4dCkpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNzID0gdGhpcy5jb250aW51ZVNjYWxhcihpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjcyA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgaSA9IE1hdGgubWF4KGksIGNzIC0gMik7IC8vIHRvIGFkdmFuY2UsIGJ1dCBzdGlsbCBhY2NvdW50IGZvciAnICMnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGluRmxvdyAmJiBmbG93SW5kaWNhdG9yQ2hhcnMuaGFzKGNoKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNoICYmICF0aGlzLmF0RW5kKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgncGxhaW4tc2NhbGFyJyk7XG4gICAgICAgIHlpZWxkIGNzdC5TQ0FMQVI7XG4gICAgICAgIHlpZWxkKiB0aGlzLnB1c2hUb0luZGV4KGVuZCArIDEsIHRydWUpO1xuICAgICAgICByZXR1cm4gaW5GbG93ID8gJ2Zsb3cnIDogJ2RvYyc7XG4gICAgfVxuICAgICpwdXNoQ291bnQobikge1xuICAgICAgICBpZiAobiA+IDApIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuYnVmZmVyLnN1YnN0cih0aGlzLnBvcywgbik7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSBuO1xuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgICpwdXNoVG9JbmRleChpLCBhbGxvd0VtcHR5KSB7XG4gICAgICAgIGNvbnN0IHMgPSB0aGlzLmJ1ZmZlci5zbGljZSh0aGlzLnBvcywgaSk7XG4gICAgICAgIGlmIChzKSB7XG4gICAgICAgICAgICB5aWVsZCBzO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gcy5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWxsb3dFbXB0eSlcbiAgICAgICAgICAgIHlpZWxkICcnO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgKnB1c2hJbmRpY2F0b3JzKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuY2hhckF0KDApKSB7XG4gICAgICAgICAgICBjYXNlICchJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKCh5aWVsZCogdGhpcy5wdXNoVGFnKCkpICtcbiAgICAgICAgICAgICAgICAgICAgKHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSkpICtcbiAgICAgICAgICAgICAgICAgICAgKHlpZWxkKiB0aGlzLnB1c2hJbmRpY2F0b3JzKCkpKTtcbiAgICAgICAgICAgIGNhc2UgJyYnOlxuICAgICAgICAgICAgICAgIHJldHVybiAoKHlpZWxkKiB0aGlzLnB1c2hVbnRpbChpc05vdEFuY2hvckNoYXIpKSArXG4gICAgICAgICAgICAgICAgICAgICh5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpKSArXG4gICAgICAgICAgICAgICAgICAgICh5aWVsZCogdGhpcy5wdXNoSW5kaWNhdG9ycygpKSk7XG4gICAgICAgICAgICBjYXNlICctJzogLy8gdGhpcyBpcyBhbiBlcnJvclxuICAgICAgICAgICAgY2FzZSAnPyc6IC8vIHRoaXMgaXMgYW4gZXJyb3Igb3V0c2lkZSBmbG93IGNvbGxlY3Rpb25zXG4gICAgICAgICAgICBjYXNlICc6Jzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluRmxvdyA9IHRoaXMuZmxvd0xldmVsID4gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBjaDEgPSB0aGlzLmNoYXJBdCgxKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShjaDEpIHx8IChpbkZsb3cgJiYgZmxvd0luZGljYXRvckNoYXJzLmhhcyhjaDEpKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWluRmxvdylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50TmV4dCA9IHRoaXMuaW5kZW50VmFsdWUgKyAxO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmZsb3dLZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZsb3dLZXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgoeWllbGQqIHRoaXMucHVzaENvdW50KDEpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoeWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHlpZWxkKiB0aGlzLnB1c2hJbmRpY2F0b3JzKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgICpwdXNoVGFnKCkge1xuICAgICAgICBpZiAodGhpcy5jaGFyQXQoMSkgPT09ICc8Jykge1xuICAgICAgICAgICAgbGV0IGkgPSB0aGlzLnBvcyArIDI7XG4gICAgICAgICAgICBsZXQgY2ggPSB0aGlzLmJ1ZmZlcltpXTtcbiAgICAgICAgICAgIHdoaWxlICghaXNFbXB0eShjaCkgJiYgY2ggIT09ICc+JylcbiAgICAgICAgICAgICAgICBjaCA9IHRoaXMuYnVmZmVyWysraV07XG4gICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucHVzaFRvSW5kZXgoY2ggPT09ICc+JyA/IGkgKyAxIDogaSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGkgPSB0aGlzLnBvcyArIDE7XG4gICAgICAgICAgICBsZXQgY2ggPSB0aGlzLmJ1ZmZlcltpXTtcbiAgICAgICAgICAgIHdoaWxlIChjaCkge1xuICAgICAgICAgICAgICAgIGlmICh0YWdDaGFycy5oYXMoY2gpKVxuICAgICAgICAgICAgICAgICAgICBjaCA9IHRoaXMuYnVmZmVyWysraV07XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09ICclJyAmJlxuICAgICAgICAgICAgICAgICAgICBoZXhEaWdpdHMuaGFzKHRoaXMuYnVmZmVyW2kgKyAxXSkgJiZcbiAgICAgICAgICAgICAgICAgICAgaGV4RGlnaXRzLmhhcyh0aGlzLmJ1ZmZlcltpICsgMl0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoID0gdGhpcy5idWZmZXJbKGkgKz0gMyldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnB1c2hUb0luZGV4KGksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqcHVzaE5ld2xpbmUoKSB7XG4gICAgICAgIGNvbnN0IGNoID0gdGhpcy5idWZmZXJbdGhpcy5wb3NdO1xuICAgICAgICBpZiAoY2ggPT09ICdcXG4nKVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKTtcbiAgICAgICAgZWxzZSBpZiAoY2ggPT09ICdcXHInICYmIHRoaXMuY2hhckF0KDEpID09PSAnXFxuJylcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wdXNoQ291bnQoMik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAqcHVzaFNwYWNlcyhhbGxvd1RhYnMpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzLnBvcyAtIDE7XG4gICAgICAgIGxldCBjaDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclsrK2ldO1xuICAgICAgICB9IHdoaWxlIChjaCA9PT0gJyAnIHx8IChhbGxvd1RhYnMgJiYgY2ggPT09ICdcXHQnKSk7XG4gICAgICAgIGNvbnN0IG4gPSBpIC0gdGhpcy5wb3M7XG4gICAgICAgIGlmIChuID4gMCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5idWZmZXIuc3Vic3RyKHRoaXMucG9zLCBuKTtcbiAgICAgICAgICAgIHRoaXMucG9zID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG4gICAgKnB1c2hVbnRpbCh0ZXN0KSB7XG4gICAgICAgIGxldCBpID0gdGhpcy5wb3M7XG4gICAgICAgIGxldCBjaCA9IHRoaXMuYnVmZmVyW2ldO1xuICAgICAgICB3aGlsZSAoIXRlc3QoY2gpKVxuICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclsrK2ldO1xuICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucHVzaFRvSW5kZXgoaSwgZmFsc2UpO1xuICAgIH1cbn1cblxuZXhwb3J0cy5MZXhlciA9IExleGVyO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVHJhY2tzIG5ld2xpbmVzIGR1cmluZyBwYXJzaW5nIGluIG9yZGVyIHRvIHByb3ZpZGUgYW4gZWZmaWNpZW50IEFQSSBmb3JcbiAqIGRldGVybWluaW5nIHRoZSBvbmUtaW5kZXhlZCBgeyBsaW5lLCBjb2wgfWAgcG9zaXRpb24gZm9yIGFueSBvZmZzZXRcbiAqIHdpdGhpbiB0aGUgaW5wdXQuXG4gKi9cbmNsYXNzIExpbmVDb3VudGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5saW5lU3RhcnRzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG91bGQgYmUgY2FsbGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLCBjYWxsXG4gICAgICAgICAqIGBsaW5lQ291bnRlci5saW5lU3RhcnRzLnNvcnQoKWAgYmVmb3JlIGNhbGxpbmcgYGxpbmVQb3MoKWAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFkZE5ld0xpbmUgPSAob2Zmc2V0KSA9PiB0aGlzLmxpbmVTdGFydHMucHVzaChvZmZzZXQpO1xuICAgICAgICAvKipcbiAgICAgICAgICogUGVyZm9ybXMgYSBiaW5hcnkgc2VhcmNoIGFuZCByZXR1cm5zIHRoZSAxLWluZGV4ZWQgeyBsaW5lLCBjb2wgfVxuICAgICAgICAgKiBwb3NpdGlvbiBvZiBgb2Zmc2V0YC4gSWYgYGxpbmUgPT09IDBgLCBgYWRkTmV3TGluZWAgaGFzIG5ldmVyIGJlZW5cbiAgICAgICAgICogY2FsbGVkIG9yIGBvZmZzZXRgIGlzIGJlZm9yZSB0aGUgZmlyc3Qga25vd24gbmV3bGluZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGluZVBvcyA9IChvZmZzZXQpID0+IHtcbiAgICAgICAgICAgIGxldCBsb3cgPSAwO1xuICAgICAgICAgICAgbGV0IGhpZ2ggPSB0aGlzLmxpbmVTdGFydHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtaWQgPSAobG93ICsgaGlnaCkgPj4gMTsgLy8gTWF0aC5mbG9vcigobG93ICsgaGlnaCkgLyAyKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxpbmVTdGFydHNbbWlkXSA8IG9mZnNldClcbiAgICAgICAgICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5saW5lU3RhcnRzW2xvd10gPT09IG9mZnNldClcbiAgICAgICAgICAgICAgICByZXR1cm4geyBsaW5lOiBsb3cgKyAxLCBjb2w6IDEgfTtcbiAgICAgICAgICAgIGlmIChsb3cgPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbGluZTogMCwgY29sOiBvZmZzZXQgfTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5saW5lU3RhcnRzW2xvdyAtIDFdO1xuICAgICAgICAgICAgcmV0dXJuIHsgbGluZTogbG93LCBjb2w6IG9mZnNldCAtIHN0YXJ0ICsgMSB9O1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuZXhwb3J0cy5MaW5lQ291bnRlciA9IExpbmVDb3VudGVyO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBub2RlX3Byb2Nlc3MgPSByZXF1aXJlKCdwcm9jZXNzJyk7XG52YXIgY3N0ID0gcmVxdWlyZSgnLi9jc3QuanMnKTtcbnZhciBsZXhlciA9IHJlcXVpcmUoJy4vbGV4ZXIuanMnKTtcblxuZnVuY3Rpb24gaW5jbHVkZXNUb2tlbihsaXN0LCB0eXBlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAobGlzdFtpXS50eXBlID09PSB0eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZmluZE5vbkVtcHR5SW5kZXgobGlzdCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgICBzd2l0Y2ggKGxpc3RbaV0udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gaXNGbG93VG9rZW4odG9rZW4pIHtcbiAgICBzd2l0Y2ggKHRva2VuPy50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2FsaWFzJzpcbiAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgY2FzZSAnc2luZ2xlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICBjYXNlICdkb3VibGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgIGNhc2UgJ2Zsb3ctY29sbGVjdGlvbic6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRQcmV2UHJvcHMocGFyZW50KSB7XG4gICAgc3dpdGNoIChwYXJlbnQudHlwZSkge1xuICAgICAgICBjYXNlICdkb2N1bWVudCc6XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50LnN0YXJ0O1xuICAgICAgICBjYXNlICdibG9jay1tYXAnOiB7XG4gICAgICAgICAgICBjb25zdCBpdCA9IHBhcmVudC5pdGVtc1twYXJlbnQuaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICByZXR1cm4gaXQuc2VwID8/IGl0LnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2Jsb2NrLXNlcSc6XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50Lml0ZW1zW3BhcmVudC5pdGVtcy5sZW5ndGggLSAxXS5zdGFydDtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG4vKiogTm90ZTogTWF5IG1vZGlmeSBpbnB1dCBhcnJheSAqL1xuZnVuY3Rpb24gZ2V0Rmlyc3RLZXlTdGFydFByb3BzKHByZXYpIHtcbiAgICBpZiAocHJldi5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBsZXQgaSA9IHByZXYubGVuZ3RoO1xuICAgIGxvb3A6IHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICBzd2l0Y2ggKHByZXZbaV0udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnZG9jLXN0YXJ0JzpcbiAgICAgICAgICAgIGNhc2UgJ2V4cGxpY2l0LWtleS1pbmQnOlxuICAgICAgICAgICAgY2FzZSAnbWFwLXZhbHVlLWluZCc6XG4gICAgICAgICAgICBjYXNlICdzZXEtaXRlbS1pbmQnOlxuICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAocHJldlsrK2ldPy50eXBlID09PSAnc3BhY2UnKSB7XG4gICAgICAgIC8qIGxvb3AgKi9cbiAgICB9XG4gICAgcmV0dXJuIHByZXYuc3BsaWNlKGksIHByZXYubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGZpeEZsb3dTZXFJdGVtcyhmYykge1xuICAgIGlmIChmYy5zdGFydC50eXBlID09PSAnZmxvdy1zZXEtc3RhcnQnKSB7XG4gICAgICAgIGZvciAoY29uc3QgaXQgb2YgZmMuaXRlbXMpIHtcbiAgICAgICAgICAgIGlmIChpdC5zZXAgJiZcbiAgICAgICAgICAgICAgICAhaXQudmFsdWUgJiZcbiAgICAgICAgICAgICAgICAhaW5jbHVkZXNUb2tlbihpdC5zdGFydCwgJ2V4cGxpY2l0LWtleS1pbmQnKSAmJlxuICAgICAgICAgICAgICAgICFpbmNsdWRlc1Rva2VuKGl0LnNlcCwgJ21hcC12YWx1ZS1pbmQnKSkge1xuICAgICAgICAgICAgICAgIGlmIChpdC5rZXkpXG4gICAgICAgICAgICAgICAgICAgIGl0LnZhbHVlID0gaXQua2V5O1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpdC5rZXk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRmxvd1Rva2VuKGl0LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXQudmFsdWUuZW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoaXQudmFsdWUuZW5kLCBpdC5zZXApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpdC52YWx1ZS5lbmQgPSBpdC5zZXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoaXQuc3RhcnQsIGl0LnNlcCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGl0LnNlcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQSBZQU1MIGNvbmNyZXRlIHN5bnRheCB0cmVlIChDU1QpIHBhcnNlclxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBzcmM6IHN0cmluZyA9IC4uLlxuICogZm9yIChjb25zdCB0b2tlbiBvZiBuZXcgUGFyc2VyKCkucGFyc2Uoc3JjKSkge1xuICogICAvLyB0b2tlbjogVG9rZW5cbiAqIH1cbiAqIGBgYFxuICpcbiAqIFRvIHVzZSB0aGUgcGFyc2VyIHdpdGggYSB1c2VyLXByb3ZpZGVkIGxleGVyOlxuICpcbiAqIGBgYHRzXG4gKiBmdW5jdGlvbiogcGFyc2Uoc291cmNlOiBzdHJpbmcsIGxleGVyOiBMZXhlcikge1xuICogICBjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2VyKClcbiAqICAgZm9yIChjb25zdCBsZXhlbWUgb2YgbGV4ZXIubGV4KHNvdXJjZSkpXG4gKiAgICAgeWllbGQqIHBhcnNlci5uZXh0KGxleGVtZSlcbiAqICAgeWllbGQqIHBhcnNlci5lbmQoKVxuICogfVxuICpcbiAqIGNvbnN0IHNyYzogc3RyaW5nID0gLi4uXG4gKiBjb25zdCBsZXhlciA9IG5ldyBMZXhlcigpXG4gKiBmb3IgKGNvbnN0IHRva2VuIG9mIHBhcnNlKHNyYywgbGV4ZXIpKSB7XG4gKiAgIC8vIHRva2VuOiBUb2tlblxuICogfVxuICogYGBgXG4gKi9cbmNsYXNzIFBhcnNlciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9uTmV3TGluZSAtIElmIGRlZmluZWQsIGNhbGxlZCBzZXBhcmF0ZWx5IHdpdGggdGhlIHN0YXJ0IHBvc2l0aW9uIG9mXG4gICAgICogICBlYWNoIG5ldyBsaW5lIChpbiBgcGFyc2UoKWAsIGluY2x1ZGluZyB0aGUgc3RhcnQgb2YgaW5wdXQpLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9uTmV3TGluZSkge1xuICAgICAgICAvKiogSWYgdHJ1ZSwgc3BhY2UgYW5kIHNlcXVlbmNlIGluZGljYXRvcnMgY291bnQgYXMgaW5kZW50YXRpb24gKi9cbiAgICAgICAgdGhpcy5hdE5ld0xpbmUgPSB0cnVlO1xuICAgICAgICAvKiogSWYgdHJ1ZSwgbmV4dCB0b2tlbiBpcyBhIHNjYWxhciB2YWx1ZSAqL1xuICAgICAgICB0aGlzLmF0U2NhbGFyID0gZmFsc2U7XG4gICAgICAgIC8qKiBDdXJyZW50IGluZGVudGF0aW9uIGxldmVsICovXG4gICAgICAgIHRoaXMuaW5kZW50ID0gMDtcbiAgICAgICAgLyoqIEN1cnJlbnQgb2Zmc2V0IHNpbmNlIHRoZSBzdGFydCBvZiBwYXJzaW5nICovXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgICAgLyoqIE9uIHRoZSBzYW1lIGxpbmUgd2l0aCBhIGJsb2NrIG1hcCBrZXkgKi9cbiAgICAgICAgdGhpcy5vbktleUxpbmUgPSBmYWxzZTtcbiAgICAgICAgLyoqIFRvcCBpbmRpY2F0ZXMgdGhlIG5vZGUgdGhhdCdzIGN1cnJlbnRseSBiZWluZyBidWlsdCAqL1xuICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICAgIC8qKiBUaGUgc291cmNlIG9mIHRoZSBjdXJyZW50IHRva2VuLCBzZXQgaW4gcGFyc2UoKSAqL1xuICAgICAgICB0aGlzLnNvdXJjZSA9ICcnO1xuICAgICAgICAvKiogVGhlIHR5cGUgb2YgdGhlIGN1cnJlbnQgdG9rZW4sIHNldCBpbiBwYXJzZSgpICovXG4gICAgICAgIHRoaXMudHlwZSA9ICcnO1xuICAgICAgICAvLyBNdXN0IGJlIGRlZmluZWQgYWZ0ZXIgYG5leHQoKWBcbiAgICAgICAgdGhpcy5sZXhlciA9IG5ldyBsZXhlci5MZXhlcigpO1xuICAgICAgICB0aGlzLm9uTmV3TGluZSA9IG9uTmV3TGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgYHNvdXJjZWAgYXMgYSBZQU1MIHN0cmVhbS5cbiAgICAgKiBJZiBgaW5jb21wbGV0ZWAsIGEgcGFydCBvZiB0aGUgbGFzdCBsaW5lIG1heSBiZSBsZWZ0IGFzIGEgYnVmZmVyIGZvciB0aGUgbmV4dCBjYWxsLlxuICAgICAqXG4gICAgICogRXJyb3JzIGFyZSBub3QgdGhyb3duLCBidXQgeWllbGRlZCBhcyBgeyB0eXBlOiAnZXJyb3InLCBtZXNzYWdlIH1gIHRva2Vucy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgZ2VuZXJhdG9yIG9mIHRva2VucyByZXByZXNlbnRpbmcgZWFjaCBkaXJlY3RpdmUsIGRvY3VtZW50LCBhbmQgb3RoZXIgc3RydWN0dXJlLlxuICAgICAqL1xuICAgICpwYXJzZShzb3VyY2UsIGluY29tcGxldGUgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5vbk5ld0xpbmUgJiYgdGhpcy5vZmZzZXQgPT09IDApXG4gICAgICAgICAgICB0aGlzLm9uTmV3TGluZSgwKTtcbiAgICAgICAgZm9yIChjb25zdCBsZXhlbWUgb2YgdGhpcy5sZXhlci5sZXgoc291cmNlLCBpbmNvbXBsZXRlKSlcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLm5leHQobGV4ZW1lKTtcbiAgICAgICAgaWYgKCFpbmNvbXBsZXRlKVxuICAgICAgICAgICAgeWllbGQqIHRoaXMuZW5kKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkdmFuY2UgdGhlIHBhcnNlciBieSB0aGUgYHNvdXJjZWAgb2Ygb25lIGxleGljYWwgdG9rZW4uXG4gICAgICovXG4gICAgKm5leHQoc291cmNlKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICBpZiAobm9kZV9wcm9jZXNzLmVudi5MT0dfVE9LRU5TKVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ3wnLCBjc3QucHJldHR5VG9rZW4oc291cmNlKSk7XG4gICAgICAgIGlmICh0aGlzLmF0U2NhbGFyKSB7XG4gICAgICAgICAgICB0aGlzLmF0U2NhbGFyID0gZmFsc2U7XG4gICAgICAgICAgICB5aWVsZCogdGhpcy5zdGVwKCk7XG4gICAgICAgICAgICB0aGlzLm9mZnNldCArPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGUgPSBjc3QudG9rZW5UeXBlKHNvdXJjZSk7XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBOb3QgYSBZQU1MIHRva2VuOiAke3NvdXJjZX1gO1xuICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKHsgdHlwZTogJ2Vycm9yJywgb2Zmc2V0OiB0aGlzLm9mZnNldCwgbWVzc2FnZSwgc291cmNlIH0pO1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnc2NhbGFyJykge1xuICAgICAgICAgICAgdGhpcy5hdE5ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuYXRTY2FsYXIgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy50eXBlID0gJ3NjYWxhcic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgeWllbGQqIHRoaXMuc3RlcCgpO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXROZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRlbnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vbk5ld0xpbmUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTmV3TGluZSh0aGlzLm9mZnNldCArIHNvdXJjZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0TmV3TGluZSAmJiBzb3VyY2VbMF0gPT09ICcgJylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50ICs9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2V4cGxpY2l0LWtleS1pbmQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ21hcC12YWx1ZS1pbmQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3NlcS1pdGVtLWluZCc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0TmV3TGluZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50ICs9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RvYy1tb2RlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdmbG93LWVycm9yLWVuZCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0TmV3TGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQ2FsbCBhdCBlbmQgb2YgaW5wdXQgdG8gcHVzaCBvdXQgYW55IHJlbWFpbmluZyBjb25zdHJ1Y3Rpb25zICovXG4gICAgKmVuZCgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuc3RhY2subGVuZ3RoID4gMClcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgIH1cbiAgICBnZXQgc291cmNlVG9rZW4oKSB7XG4gICAgICAgIGNvbnN0IHN0ID0ge1xuICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzdDtcbiAgICB9XG4gICAgKnN0ZXAoKSB7XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygxKTtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2RvYy1lbmQnICYmIHRvcD8udHlwZSAhPT0gJ2RvYy1lbmQnKSB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5zdGFjay5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZG9jLWVuZCcsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRvcClcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5zdHJlYW0oKTtcbiAgICAgICAgc3dpdGNoICh0b3AudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnZG9jdW1lbnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5kb2N1bWVudCh0b3ApO1xuICAgICAgICAgICAgY2FzZSAnYWxpYXMnOlxuICAgICAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgIGNhc2UgJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMuc2NhbGFyKHRvcCk7XG4gICAgICAgICAgICBjYXNlICdibG9jay1zY2FsYXInOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5ibG9ja1NjYWxhcih0b3ApO1xuICAgICAgICAgICAgY2FzZSAnYmxvY2stbWFwJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMuYmxvY2tNYXAodG9wKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLXNlcSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLmJsb2NrU2VxdWVuY2UodG9wKTtcbiAgICAgICAgICAgIGNhc2UgJ2Zsb3ctY29sbGVjdGlvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLmZsb3dDb2xsZWN0aW9uKHRvcCk7XG4gICAgICAgICAgICBjYXNlICdkb2MtZW5kJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMuZG9jdW1lbnRFbmQodG9wKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICB9XG4gICAgcGVlayhuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gbl07XG4gICAgfVxuICAgICpwb3AoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBlcnJvciA/PyB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdUcmllZCB0byBwb3AgYW4gZW1wdHkgc3RhY2snO1xuICAgICAgICAgICAgeWllbGQgeyB0eXBlOiAnZXJyb3InLCBvZmZzZXQ6IHRoaXMub2Zmc2V0LCBzb3VyY2U6ICcnLCBtZXNzYWdlIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHlpZWxkIHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrKDEpO1xuICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdibG9jay1zY2FsYXInKSB7XG4gICAgICAgICAgICAgICAgLy8gQmxvY2sgc2NhbGFycyB1c2UgdGhlaXIgcGFyZW50IHJhdGhlciB0aGFuIGhlYWRlciBpbmRlbnRcbiAgICAgICAgICAgICAgICB0b2tlbi5pbmRlbnQgPSAnaW5kZW50JyBpbiB0b3AgPyB0b3AuaW5kZW50IDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09ICdmbG93LWNvbGxlY3Rpb24nICYmIHRvcC50eXBlID09PSAnZG9jdW1lbnQnKSB7XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIGFsbCBpbmRlbnQgZm9yIHRvcC1sZXZlbCBmbG93IGNvbGxlY3Rpb25zXG4gICAgICAgICAgICAgICAgdG9rZW4uaW5kZW50ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnZmxvdy1jb2xsZWN0aW9uJylcbiAgICAgICAgICAgICAgICBmaXhGbG93U2VxSXRlbXModG9rZW4pO1xuICAgICAgICAgICAgc3dpdGNoICh0b3AudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RvY3VtZW50JzpcbiAgICAgICAgICAgICAgICAgICAgdG9wLnZhbHVlID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgICAgIHRvcC5wcm9wcy5wdXNoKHRva2VuKTsgLy8gZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYmxvY2stbWFwJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdCA9IHRvcC5pdGVtc1t0b3AuaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wLml0ZW1zLnB1c2goeyBzdGFydDogW10sIGtleTogdG9rZW4sIHNlcDogW10gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXQuc2VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdC52YWx1ZSA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpdCwgeyBrZXk6IHRva2VuLCBzZXA6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSAhaXQuZXhwbGljaXRLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLXNlcSc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXQgPSB0b3AuaXRlbXNbdG9wLml0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AuaXRlbXMucHVzaCh7IHN0YXJ0OiBbXSwgdmFsdWU6IHRva2VuIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpdC52YWx1ZSA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnZmxvdy1jb2xsZWN0aW9uJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdCA9IHRvcC5pdGVtc1t0b3AuaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXQgfHwgaXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AuaXRlbXMucHVzaCh7IHN0YXJ0OiBbXSwga2V5OiB0b2tlbiwgc2VwOiBbXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXQuc2VwKVxuICAgICAgICAgICAgICAgICAgICAgICAgaXQudmFsdWUgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpdCwgeyBrZXk6IHRva2VuLCBzZXA6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IHNob3VsZCBub3QgaGFwcGVuICovXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRvcC50eXBlID09PSAnZG9jdW1lbnQnIHx8XG4gICAgICAgICAgICAgICAgdG9wLnR5cGUgPT09ICdibG9jay1tYXAnIHx8XG4gICAgICAgICAgICAgICAgdG9wLnR5cGUgPT09ICdibG9jay1zZXEnKSAmJlxuICAgICAgICAgICAgICAgICh0b2tlbi50eXBlID09PSAnYmxvY2stbWFwJyB8fCB0b2tlbi50eXBlID09PSAnYmxvY2stc2VxJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0ID0gdG9rZW4uaXRlbXNbdG9rZW4uaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QgJiZcbiAgICAgICAgICAgICAgICAgICAgIWxhc3Quc2VwICYmXG4gICAgICAgICAgICAgICAgICAgICFsYXN0LnZhbHVlICYmXG4gICAgICAgICAgICAgICAgICAgIGxhc3Quc3RhcnQubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmaW5kTm9uRW1wdHlJbmRleChsYXN0LnN0YXJ0KSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgKHRva2VuLmluZGVudCA9PT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdC5zdGFydC5ldmVyeShzdCA9PiBzdC50eXBlICE9PSAnY29tbWVudCcgfHwgc3QuaW5kZW50IDwgdG9rZW4uaW5kZW50KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvcC50eXBlID09PSAnZG9jdW1lbnQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wLmVuZCA9IGxhc3Quc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcC5pdGVtcy5wdXNoKHsgc3RhcnQ6IGxhc3Quc3RhcnQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuLml0ZW1zLnNwbGljZSgtMSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgICpzdHJlYW0oKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdkaXJlY3RpdmUtbGluZSc6XG4gICAgICAgICAgICAgICAgeWllbGQgeyB0eXBlOiAnZGlyZWN0aXZlJywgb2Zmc2V0OiB0aGlzLm9mZnNldCwgc291cmNlOiB0aGlzLnNvdXJjZSB9O1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ2J5dGUtb3JkZXItbWFyayc6XG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuc291cmNlVG9rZW47XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAnZG9jLW1vZGUnOlxuICAgICAgICAgICAgY2FzZSAnZG9jLXN0YXJ0Jzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvYyA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RvY3VtZW50JyxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnZG9jLXN0YXJ0JylcbiAgICAgICAgICAgICAgICAgICAgZG9jLnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGRvYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHlpZWxkIHtcbiAgICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgbWVzc2FnZTogYFVuZXhwZWN0ZWQgJHt0aGlzLnR5cGV9IHRva2VuIGluIFlBTUwgc3RyZWFtYCxcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2VcbiAgICAgICAgfTtcbiAgICB9XG4gICAgKmRvY3VtZW50KGRvYykge1xuICAgICAgICBpZiAoZG9jLnZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLmxpbmVFbmQoZG9jKTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RvYy1zdGFydCc6IHtcbiAgICAgICAgICAgICAgICBpZiAoZmluZE5vbkVtcHR5SW5kZXgoZG9jLnN0YXJ0KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnN0ZXAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBkb2Muc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdhbmNob3InOlxuICAgICAgICAgICAgY2FzZSAndGFnJzpcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgZG9jLnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ2ID0gdGhpcy5zdGFydEJsb2NrVmFsdWUoZG9jKTtcbiAgICAgICAgaWYgKGJ2KVxuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGJ2KTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBVbmV4cGVjdGVkICR7dGhpcy50eXBlfSB0b2tlbiBpbiBZQU1MIGRvY3VtZW50YCxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgICpzY2FsYXIoc2NhbGFyKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdtYXAtdmFsdWUtaW5kJykge1xuICAgICAgICAgICAgY29uc3QgcHJldiA9IGdldFByZXZQcm9wcyh0aGlzLnBlZWsoMikpO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBnZXRGaXJzdEtleVN0YXJ0UHJvcHMocHJldik7XG4gICAgICAgICAgICBsZXQgc2VwO1xuICAgICAgICAgICAgaWYgKHNjYWxhci5lbmQpIHtcbiAgICAgICAgICAgICAgICBzZXAgPSBzY2FsYXIuZW5kO1xuICAgICAgICAgICAgICAgIHNlcC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2FsYXIuZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNlcCA9IFt0aGlzLnNvdXJjZVRva2VuXTtcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2stbWFwJyxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHNjYWxhci5vZmZzZXQsXG4gICAgICAgICAgICAgICAgaW5kZW50OiBzY2FsYXIuaW5kZW50LFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbeyBzdGFydCwga2V5OiBzY2FsYXIsIHNlcCB9XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXSA9IG1hcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB5aWVsZCogdGhpcy5saW5lRW5kKHNjYWxhcik7XG4gICAgfVxuICAgICpibG9ja1NjYWxhcihzY2FsYXIpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgc2NhbGFyLnByb3BzLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgICAgICAgICBzY2FsYXIuc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgICAgICAgICAgICAgLy8gYmxvY2stc2NhbGFyIHNvdXJjZSBpbmNsdWRlcyB0cmFpbGluZyBuZXdsaW5lXG4gICAgICAgICAgICAgICAgdGhpcy5hdE5ld0xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbk5ld0xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5sID0gdGhpcy5zb3VyY2UuaW5kZXhPZignXFxuJykgKyAxO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobmwgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25OZXdMaW5lKHRoaXMub2Zmc2V0ICsgbmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmwgPSB0aGlzLnNvdXJjZS5pbmRleE9mKCdcXG4nLCBubCkgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMuc3RlcCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgICpibG9ja01hcChtYXApIHtcbiAgICAgICAgY29uc3QgaXQgPSBtYXAuaXRlbXNbbWFwLml0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICAvLyBpdC5zZXAgaXMgdHJ1ZS1pc2ggaWYgcGFpciBhbHJlYWR5IGhhcyBrZXkgb3IgOiBzZXBhcmF0b3JcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKGl0LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9ICdlbmQnIGluIGl0LnZhbHVlID8gaXQudmFsdWUuZW5kIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0ID0gQXJyYXkuaXNBcnJheShlbmQpID8gZW5kW2VuZC5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3Q/LnR5cGUgPT09ICdjb21tZW50JylcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZD8ucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2goeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApIHtcbiAgICAgICAgICAgICAgICAgICAgaXQuc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICBpZiAoaXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2goeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApIHtcbiAgICAgICAgICAgICAgICAgICAgaXQuc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdEluZGVudGVkQ29tbWVudChpdC5zdGFydCwgbWFwLmluZGVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBtYXAuaXRlbXNbbWFwLml0ZW1zLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kID0gcHJldj8udmFsdWU/LmVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShlbmQsIGl0LnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXAuaXRlbXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGl0LnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmRlbnQgPj0gbWFwLmluZGVudCkge1xuICAgICAgICAgICAgY29uc3QgYXRNYXBJbmRlbnQgPSAhdGhpcy5vbktleUxpbmUgJiYgdGhpcy5pbmRlbnQgPT09IG1hcC5pbmRlbnQ7XG4gICAgICAgICAgICBjb25zdCBhdE5leHRJdGVtID0gYXRNYXBJbmRlbnQgJiZcbiAgICAgICAgICAgICAgICAoaXQuc2VwIHx8IGl0LmV4cGxpY2l0S2V5KSAmJlxuICAgICAgICAgICAgICAgIHRoaXMudHlwZSAhPT0gJ3NlcS1pdGVtLWluZCc7XG4gICAgICAgICAgICAvLyBGb3IgZW1wdHkgbm9kZXMsIGFzc2lnbiBuZXdsaW5lLXNlcGFyYXRlZCBub3QgaW5kZW50ZWQgZW1wdHkgdG9rZW5zIHRvIGZvbGxvd2luZyBub2RlXG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBbXTtcbiAgICAgICAgICAgIGlmIChhdE5leHRJdGVtICYmIGl0LnNlcCAmJiAhaXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBubCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXQuc2VwLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0ID0gaXQuc2VwW2ldO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5sLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3QuaW5kZW50ID4gbWFwLmluZGVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmwubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmwubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmwubGVuZ3RoID49IDIpXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gaXQuc2VwLnNwbGljZShubFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FuY2hvcic6XG4gICAgICAgICAgICAgICAgY2FzZSAndGFnJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0TmV4dEl0ZW0gfHwgaXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAuaXRlbXMucHVzaCh7IHN0YXJ0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0LnNlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXQuc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlICdleHBsaWNpdC1rZXktaW5kJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdC5zZXAgJiYgIWl0LmV4cGxpY2l0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXQuZXhwbGljaXRLZXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGF0TmV4dEl0ZW0gfHwgaXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAuaXRlbXMucHVzaCh7IHN0YXJ0LCBleHBsaWNpdEtleTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jsb2NrLW1hcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dLCBleHBsaWNpdEtleTogdHJ1ZSB9XVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSAnbWFwLXZhbHVlLWluZCc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdC5leHBsaWNpdEtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpdC5zZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZXNUb2tlbihpdC5zdGFydCwgJ25ld2xpbmUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGl0LCB7IGtleTogbnVsbCwgc2VwOiBbdGhpcy5zb3VyY2VUb2tlbl0gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IGdldEZpcnN0S2V5U3RhcnRQcm9wcyhpdC5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2stbWFwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFt7IHN0YXJ0LCBrZXk6IG51bGwsIHNlcDogW3RoaXMuc291cmNlVG9rZW5dIH1dXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2goeyBzdGFydDogW10sIGtleTogbnVsbCwgc2VwOiBbdGhpcy5zb3VyY2VUb2tlbl0gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpbmNsdWRlc1Rva2VuKGl0LnNlcCwgJ21hcC12YWx1ZS1pbmQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1tYXAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogW3sgc3RhcnQsIGtleTogbnVsbCwgc2VwOiBbdGhpcy5zb3VyY2VUb2tlbl0gfV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRmxvd1Rva2VuKGl0LmtleSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaW5jbHVkZXNUb2tlbihpdC5zZXAsICduZXdsaW5lJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IGdldEZpcnN0S2V5U3RhcnRQcm9wcyhpdC5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gaXQua2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcCA9IGl0LnNlcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXAucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHR5cGUgZ3VhcmQgaXMgd3JvbmcgaGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBpdC5rZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciB0eXBlIGd1YXJkIGlzIHdyb25nIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgaXQuc2VwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1tYXAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogW3sgc3RhcnQsIGtleSwgc2VwIH1dXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGFydC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGFjdHVhbGx5IGF0IG5leHQgaXRlbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0LnNlcCA9IGl0LnNlcC5jb25jYXQoc3RhcnQsIHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXQuc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWl0LnNlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaXQsIHsga2V5OiBudWxsLCBzZXA6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0LnZhbHVlIHx8IGF0TmV4dEl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXAuaXRlbXMucHVzaCh7IHN0YXJ0LCBrZXk6IG51bGwsIHNlcDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5jbHVkZXNUb2tlbihpdC5zZXAsICdtYXAtdmFsdWUtaW5kJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2stbWFwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZW50OiB0aGlzLmluZGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFt7IHN0YXJ0OiBbXSwga2V5OiBudWxsLCBzZXA6IFt0aGlzLnNvdXJjZVRva2VuXSB9XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXQuc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSAnYWxpYXMnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnc2luZ2xlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmcyA9IHRoaXMuZmxvd1NjYWxhcih0aGlzLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXROZXh0SXRlbSB8fCBpdC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2goeyBzdGFydCwga2V5OiBmcywgc2VwOiBbXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChmcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGl0LCB7IGtleTogZnMsIHNlcDogW10gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ2ID0gdGhpcy5zdGFydEJsb2NrVmFsdWUobWFwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnYudHlwZSA9PT0gJ2Jsb2NrLXNlcScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWl0LmV4cGxpY2l0S2V5ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0LnNlcCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaW5jbHVkZXNUb2tlbihpdC5zZXAsICduZXdsaW5lJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ1VuZXhwZWN0ZWQgYmxvY2stc2VxLWluZCBvbiBzYW1lIGxpbmUgd2l0aCBrZXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGF0TWFwSW5kZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2goeyBzdGFydCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChidik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgICAgIHlpZWxkKiB0aGlzLnN0ZXAoKTtcbiAgICB9XG4gICAgKmJsb2NrU2VxdWVuY2Uoc2VxKSB7XG4gICAgICAgIGNvbnN0IGl0ID0gc2VxLml0ZW1zW3NlcS5pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIGlmIChpdC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSAnZW5kJyBpbiBpdC52YWx1ZSA/IGl0LnZhbHVlLmVuZCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IEFycmF5LmlzQXJyYXkoZW5kKSA/IGVuZFtlbmQubGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0Py50eXBlID09PSAnY29tbWVudCcpXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ/LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcS5pdGVtcy5wdXNoKHsgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgICAgIGlmIChpdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgc2VxLml0ZW1zLnB1c2goeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdEluZGVudGVkQ29tbWVudChpdC5zdGFydCwgc2VxLmluZGVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBzZXEuaXRlbXNbc2VxLml0ZW1zLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kID0gcHJldj8udmFsdWU/LmVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShlbmQsIGl0LnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXEuaXRlbXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGl0LnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ2FuY2hvcic6XG4gICAgICAgICAgICBjYXNlICd0YWcnOlxuICAgICAgICAgICAgICAgIGlmIChpdC52YWx1ZSB8fCB0aGlzLmluZGVudCA8PSBzZXEuaW5kZW50KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ3NlcS1pdGVtLWluZCc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5kZW50ICE9PSBzZXEuaW5kZW50KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoaXQudmFsdWUgfHwgaW5jbHVkZXNUb2tlbihpdC5zdGFydCwgJ3NlcS1pdGVtLWluZCcpKVxuICAgICAgICAgICAgICAgICAgICBzZXEuaXRlbXMucHVzaCh7IHN0YXJ0OiBbdGhpcy5zb3VyY2VUb2tlbl0gfSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmRlbnQgPiBzZXEuaW5kZW50KSB7XG4gICAgICAgICAgICBjb25zdCBidiA9IHRoaXMuc3RhcnRCbG9ja1ZhbHVlKHNlcSk7XG4gICAgICAgICAgICBpZiAoYnYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goYnYpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgeWllbGQqIHRoaXMuc3RlcCgpO1xuICAgIH1cbiAgICAqZmxvd0NvbGxlY3Rpb24oZmMpIHtcbiAgICAgICAgY29uc3QgaXQgPSBmYy5pdGVtc1tmYy5pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2Zsb3ctZXJyb3ItZW5kJykge1xuICAgICAgICAgICAgbGV0IHRvcDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB0b3AgPSB0aGlzLnBlZWsoMSk7XG4gICAgICAgICAgICB9IHdoaWxlICh0b3A/LnR5cGUgPT09ICdmbG93LWNvbGxlY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmYy5lbmQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NvbW1hJzpcbiAgICAgICAgICAgICAgICBjYXNlICdleHBsaWNpdC1rZXktaW5kJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdCB8fCBpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgICAgICBmYy5pdGVtcy5wdXNoKHsgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgaXQuc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgJ21hcC12YWx1ZS1pbmQnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0IHx8IGl0LnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZmMuaXRlbXMucHVzaCh7IHN0YXJ0OiBbXSwga2V5OiBudWxsLCBzZXA6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXQuc2VwKVxuICAgICAgICAgICAgICAgICAgICAgICAgaXQuc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaXQsIHsga2V5OiBudWxsLCBzZXA6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICBjYXNlICdhbmNob3InOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3RhZyc6XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXQgfHwgaXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBmYy5pdGVtcy5wdXNoKHsgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXQuc2VwKVxuICAgICAgICAgICAgICAgICAgICAgICAgaXQuc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0LnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlICdhbGlhcyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdzaW5nbGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnZG91YmxlLXF1b3RlZC1zY2FsYXInOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZzID0gdGhpcy5mbG93U2NhbGFyKHRoaXMudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXQgfHwgaXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBmYy5pdGVtcy5wdXNoKHsgc3RhcnQ6IFtdLCBrZXk6IGZzLCBzZXA6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goZnMpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGl0LCB7IGtleTogZnMsIHNlcDogW10gfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnZmxvdy1tYXAtZW5kJzpcbiAgICAgICAgICAgICAgICBjYXNlICdmbG93LXNlcS1lbmQnOlxuICAgICAgICAgICAgICAgICAgICBmYy5lbmQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYnYgPSB0aGlzLnN0YXJ0QmxvY2tWYWx1ZShmYyk7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgICAgICAgICAgaWYgKGJ2KVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChidik7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5zdGVwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnBlZWsoMik7XG4gICAgICAgICAgICBpZiAocGFyZW50LnR5cGUgPT09ICdibG9jay1tYXAnICYmXG4gICAgICAgICAgICAgICAgKCh0aGlzLnR5cGUgPT09ICdtYXAtdmFsdWUtaW5kJyAmJiBwYXJlbnQuaW5kZW50ID09PSBmYy5pbmRlbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgICh0aGlzLnR5cGUgPT09ICduZXdsaW5lJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXBhcmVudC5pdGVtc1twYXJlbnQuaXRlbXMubGVuZ3RoIC0gMV0uc2VwKSkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5zdGVwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdtYXAtdmFsdWUtaW5kJyAmJlxuICAgICAgICAgICAgICAgIHBhcmVudC50eXBlICE9PSAnZmxvdy1jb2xsZWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBnZXRQcmV2UHJvcHMocGFyZW50KTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IGdldEZpcnN0S2V5U3RhcnRQcm9wcyhwcmV2KTtcbiAgICAgICAgICAgICAgICBmaXhGbG93U2VxSXRlbXMoZmMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlcCA9IGZjLmVuZC5zcGxpY2UoMSwgZmMuZW5kLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFwID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2stbWFwJyxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBmYy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGluZGVudDogZmMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICBpdGVtczogW3sgc3RhcnQsIGtleTogZmMsIHNlcCB9XVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXSA9IG1hcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLmxpbmVFbmQoZmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZsb3dTY2FsYXIodHlwZSkge1xuICAgICAgICBpZiAodGhpcy5vbk5ld0xpbmUpIHtcbiAgICAgICAgICAgIGxldCBubCA9IHRoaXMuc291cmNlLmluZGV4T2YoJ1xcbicpICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChubCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25OZXdMaW5lKHRoaXMub2Zmc2V0ICsgbmwpO1xuICAgICAgICAgICAgICAgIG5sID0gdGhpcy5zb3VyY2UuaW5kZXhPZignXFxuJywgbmwpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGFydEJsb2NrVmFsdWUocGFyZW50KSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdhbGlhcyc6XG4gICAgICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICAgICAgY2FzZSAnc2luZ2xlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgY2FzZSAnZG91YmxlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZsb3dTY2FsYXIodGhpcy50eXBlKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLXNjYWxhci1oZWFkZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1zY2FsYXInLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICBwcm9wczogW3RoaXMuc291cmNlVG9rZW5dLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6ICcnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ2Zsb3ctbWFwLXN0YXJ0JzpcbiAgICAgICAgICAgIGNhc2UgJ2Zsb3ctc2VxLXN0YXJ0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZmxvdy1jb2xsZWN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50OiB0aGlzLmluZGVudCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHRoaXMuc291cmNlVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBbXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICdzZXEtaXRlbS1pbmQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1zZXEnLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICBpdGVtczogW3sgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9XVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICdleHBsaWNpdC1rZXktaW5kJzoge1xuICAgICAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gZ2V0UHJldlByb3BzKHBhcmVudCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBnZXRGaXJzdEtleVN0YXJ0UHJvcHMocHJldik7XG4gICAgICAgICAgICAgICAgc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2stbWFwJyxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50OiB0aGlzLmluZGVudCxcbiAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFt7IHN0YXJ0LCBleHBsaWNpdEtleTogdHJ1ZSB9XVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdtYXAtdmFsdWUtaW5kJzoge1xuICAgICAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gZ2V0UHJldlByb3BzKHBhcmVudCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBnZXRGaXJzdEtleVN0YXJ0UHJvcHMocHJldik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jsb2NrLW1hcCcsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbeyBzdGFydCwga2V5OiBudWxsLCBzZXA6IFt0aGlzLnNvdXJjZVRva2VuXSB9XVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGF0SW5kZW50ZWRDb21tZW50KHN0YXJ0LCBpbmRlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gJ2NvbW1lbnQnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5pbmRlbnQgPD0gaW5kZW50KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gc3RhcnQuZXZlcnkoc3QgPT4gc3QudHlwZSA9PT0gJ25ld2xpbmUnIHx8IHN0LnR5cGUgPT09ICdzcGFjZScpO1xuICAgIH1cbiAgICAqZG9jdW1lbnRFbmQoZG9jRW5kKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09ICdkb2MtbW9kZScpIHtcbiAgICAgICAgICAgIGlmIChkb2NFbmQuZW5kKVxuICAgICAgICAgICAgICAgIGRvY0VuZC5lbmQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBkb2NFbmQuZW5kID0gW3RoaXMuc291cmNlVG9rZW5dO1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ25ld2xpbmUnKVxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgICpsaW5lRW5kKHRva2VuKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdjb21tYSc6XG4gICAgICAgICAgICBjYXNlICdkb2Mtc3RhcnQnOlxuICAgICAgICAgICAgY2FzZSAnZG9jLWVuZCc6XG4gICAgICAgICAgICBjYXNlICdmbG93LXNlcS1lbmQnOlxuICAgICAgICAgICAgY2FzZSAnZmxvdy1tYXAtZW5kJzpcbiAgICAgICAgICAgIGNhc2UgJ21hcC12YWx1ZS1pbmQnOlxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnN0ZXAoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBmYWxsdGhyb3VnaFxuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIGFsbCBvdGhlciB2YWx1ZXMgYXJlIGVycm9yc1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbi5lbmQpXG4gICAgICAgICAgICAgICAgICAgIHRva2VuLmVuZC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4uZW5kID0gW3RoaXMuc291cmNlVG9rZW5dO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICduZXdsaW5lJylcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydHMuUGFyc2VyID0gUGFyc2VyO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBjb21wb3NlciA9IHJlcXVpcmUoJy4vY29tcG9zZS9jb21wb3Nlci5qcycpO1xudmFyIERvY3VtZW50ID0gcmVxdWlyZSgnLi9kb2MvRG9jdW1lbnQuanMnKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycy5qcycpO1xudmFyIGxvZyA9IHJlcXVpcmUoJy4vbG9nLmpzJyk7XG52YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuL25vZGVzL2lkZW50aXR5LmpzJyk7XG52YXIgbGluZUNvdW50ZXIgPSByZXF1aXJlKCcuL3BhcnNlL2xpbmUtY291bnRlci5qcycpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2UvcGFyc2VyLmpzJyk7XG5cbmZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgY29uc3QgcHJldHR5RXJyb3JzID0gb3B0aW9ucy5wcmV0dHlFcnJvcnMgIT09IGZhbHNlO1xuICAgIGNvbnN0IGxpbmVDb3VudGVyJDEgPSBvcHRpb25zLmxpbmVDb3VudGVyIHx8IChwcmV0dHlFcnJvcnMgJiYgbmV3IGxpbmVDb3VudGVyLkxpbmVDb3VudGVyKCkpIHx8IG51bGw7XG4gICAgcmV0dXJuIHsgbGluZUNvdW50ZXI6IGxpbmVDb3VudGVyJDEsIHByZXR0eUVycm9ycyB9O1xufVxuLyoqXG4gKiBQYXJzZSB0aGUgaW5wdXQgYXMgYSBzdHJlYW0gb2YgWUFNTCBkb2N1bWVudHMuXG4gKlxuICogRG9jdW1lbnRzIHNob3VsZCBiZSBzZXBhcmF0ZWQgZnJvbSBlYWNoIG90aGVyIGJ5IGAuLi5gIG9yIGAtLS1gIG1hcmtlciBsaW5lcy5cbiAqXG4gKiBAcmV0dXJucyBJZiBhbiBlbXB0eSBgZG9jc2AgYXJyYXkgaXMgcmV0dXJuZWQsIGl0IHdpbGwgYmUgb2YgdHlwZVxuICogICBFbXB0eVN0cmVhbSBhbmQgY29udGFpbiBhZGRpdGlvbmFsIHN0cmVhbSBpbmZvcm1hdGlvbi4gSW5cbiAqICAgVHlwZVNjcmlwdCwgeW91IHNob3VsZCB1c2UgYCdlbXB0eScgaW4gZG9jc2AgYXMgYSB0eXBlIGd1YXJkIGZvciBpdC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VBbGxEb2N1bWVudHMoc291cmNlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGxpbmVDb3VudGVyLCBwcmV0dHlFcnJvcnMgfSA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCBwYXJzZXIkMSA9IG5ldyBwYXJzZXIuUGFyc2VyKGxpbmVDb3VudGVyPy5hZGROZXdMaW5lKTtcbiAgICBjb25zdCBjb21wb3NlciQxID0gbmV3IGNvbXBvc2VyLkNvbXBvc2VyKG9wdGlvbnMpO1xuICAgIGNvbnN0IGRvY3MgPSBBcnJheS5mcm9tKGNvbXBvc2VyJDEuY29tcG9zZShwYXJzZXIkMS5wYXJzZShzb3VyY2UpKSk7XG4gICAgaWYgKHByZXR0eUVycm9ycyAmJiBsaW5lQ291bnRlcilcbiAgICAgICAgZm9yIChjb25zdCBkb2Mgb2YgZG9jcykge1xuICAgICAgICAgICAgZG9jLmVycm9ycy5mb3JFYWNoKGVycm9ycy5wcmV0dGlmeUVycm9yKHNvdXJjZSwgbGluZUNvdW50ZXIpKTtcbiAgICAgICAgICAgIGRvYy53YXJuaW5ncy5mb3JFYWNoKGVycm9ycy5wcmV0dGlmeUVycm9yKHNvdXJjZSwgbGluZUNvdW50ZXIpKTtcbiAgICAgICAgfVxuICAgIGlmIChkb2NzLmxlbmd0aCA+IDApXG4gICAgICAgIHJldHVybiBkb2NzO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKFtdLCB7IGVtcHR5OiB0cnVlIH0sIGNvbXBvc2VyJDEuc3RyZWFtSW5mbygpKTtcbn1cbi8qKiBQYXJzZSBhbiBpbnB1dCBzdHJpbmcgaW50byBhIHNpbmdsZSBZQU1MLkRvY3VtZW50ICovXG5mdW5jdGlvbiBwYXJzZURvY3VtZW50KHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBsaW5lQ291bnRlciwgcHJldHR5RXJyb3JzIH0gPSBwYXJzZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgY29uc3QgcGFyc2VyJDEgPSBuZXcgcGFyc2VyLlBhcnNlcihsaW5lQ291bnRlcj8uYWRkTmV3TGluZSk7XG4gICAgY29uc3QgY29tcG9zZXIkMSA9IG5ldyBjb21wb3Nlci5Db21wb3NlcihvcHRpb25zKTtcbiAgICAvLyBgZG9jYCBpcyBhbHdheXMgc2V0IGJ5IGNvbXBvc2UuZW5kKHRydWUpIGF0IHRoZSB2ZXJ5IGxhdGVzdFxuICAgIGxldCBkb2MgPSBudWxsO1xuICAgIGZvciAoY29uc3QgX2RvYyBvZiBjb21wb3NlciQxLmNvbXBvc2UocGFyc2VyJDEucGFyc2Uoc291cmNlKSwgdHJ1ZSwgc291cmNlLmxlbmd0aCkpIHtcbiAgICAgICAgaWYgKCFkb2MpXG4gICAgICAgICAgICBkb2MgPSBfZG9jO1xuICAgICAgICBlbHNlIGlmIChkb2Mub3B0aW9ucy5sb2dMZXZlbCAhPT0gJ3NpbGVudCcpIHtcbiAgICAgICAgICAgIGRvYy5lcnJvcnMucHVzaChuZXcgZXJyb3JzLllBTUxQYXJzZUVycm9yKF9kb2MucmFuZ2Uuc2xpY2UoMCwgMiksICdNVUxUSVBMRV9ET0NTJywgJ1NvdXJjZSBjb250YWlucyBtdWx0aXBsZSBkb2N1bWVudHM7IHBsZWFzZSB1c2UgWUFNTC5wYXJzZUFsbERvY3VtZW50cygpJykpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByZXR0eUVycm9ycyAmJiBsaW5lQ291bnRlcikge1xuICAgICAgICBkb2MuZXJyb3JzLmZvckVhY2goZXJyb3JzLnByZXR0aWZ5RXJyb3Ioc291cmNlLCBsaW5lQ291bnRlcikpO1xuICAgICAgICBkb2Mud2FybmluZ3MuZm9yRWFjaChlcnJvcnMucHJldHRpZnlFcnJvcihzb3VyY2UsIGxpbmVDb3VudGVyKSk7XG4gICAgfVxuICAgIHJldHVybiBkb2M7XG59XG5mdW5jdGlvbiBwYXJzZShzcmMsIHJldml2ZXIsIG9wdGlvbnMpIHtcbiAgICBsZXQgX3Jldml2ZXIgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHR5cGVvZiByZXZpdmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIF9yZXZpdmVyID0gcmV2aXZlcjtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkICYmIHJldml2ZXIgJiYgdHlwZW9mIHJldml2ZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG9wdGlvbnMgPSByZXZpdmVyO1xuICAgIH1cbiAgICBjb25zdCBkb2MgPSBwYXJzZURvY3VtZW50KHNyYywgb3B0aW9ucyk7XG4gICAgaWYgKCFkb2MpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGRvYy53YXJuaW5ncy5mb3JFYWNoKHdhcm5pbmcgPT4gbG9nLndhcm4oZG9jLm9wdGlvbnMubG9nTGV2ZWwsIHdhcm5pbmcpKTtcbiAgICBpZiAoZG9jLmVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChkb2Mub3B0aW9ucy5sb2dMZXZlbCAhPT0gJ3NpbGVudCcpXG4gICAgICAgICAgICB0aHJvdyBkb2MuZXJyb3JzWzBdO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBkb2MuZXJyb3JzID0gW107XG4gICAgfVxuICAgIHJldHVybiBkb2MudG9KUyhPYmplY3QuYXNzaWduKHsgcmV2aXZlcjogX3Jldml2ZXIgfSwgb3B0aW9ucykpO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5KHZhbHVlLCByZXBsYWNlciwgb3B0aW9ucykge1xuICAgIGxldCBfcmVwbGFjZXIgPSBudWxsO1xuICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicgfHwgQXJyYXkuaXNBcnJheShyZXBsYWNlcikpIHtcbiAgICAgICAgX3JlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCAmJiByZXBsYWNlcikge1xuICAgICAgICBvcHRpb25zID0gcmVwbGFjZXI7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zLmxlbmd0aDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbnN0IGluZGVudCA9IE1hdGgucm91bmQob3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMgPSBpbmRlbnQgPCAxID8gdW5kZWZpbmVkIDogaW5kZW50ID4gOCA/IHsgaW5kZW50OiA4IH0gOiB7IGluZGVudCB9O1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB7IGtlZXBVbmRlZmluZWQgfSA9IG9wdGlvbnMgPz8gcmVwbGFjZXIgPz8ge307XG4gICAgICAgIGlmICgha2VlcFVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChpZGVudGl0eS5pc0RvY3VtZW50KHZhbHVlKSAmJiAhX3JlcGxhY2VyKVxuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcob3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBEb2N1bWVudC5Eb2N1bWVudCh2YWx1ZSwgX3JlcGxhY2VyLCBvcHRpb25zKS50b1N0cmluZyhvcHRpb25zKTtcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZXhwb3J0cy5wYXJzZUFsbERvY3VtZW50cyA9IHBhcnNlQWxsRG9jdW1lbnRzO1xuZXhwb3J0cy5wYXJzZURvY3VtZW50ID0gcGFyc2VEb2N1bWVudDtcbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBjb21wb3NlciA9IHJlcXVpcmUoJy4vY29tcG9zZS9jb21wb3Nlci5qcycpO1xudmFyIERvY3VtZW50ID0gcmVxdWlyZSgnLi9kb2MvRG9jdW1lbnQuanMnKTtcbnZhciBTY2hlbWEgPSByZXF1aXJlKCcuL3NjaGVtYS9TY2hlbWEuanMnKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycy5qcycpO1xudmFyIEFsaWFzID0gcmVxdWlyZSgnLi9ub2Rlcy9BbGlhcy5qcycpO1xudmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9ub2Rlcy9pZGVudGl0eS5qcycpO1xudmFyIFBhaXIgPSByZXF1aXJlKCcuL25vZGVzL1BhaXIuanMnKTtcbnZhciBTY2FsYXIgPSByZXF1aXJlKCcuL25vZGVzL1NjYWxhci5qcycpO1xudmFyIFlBTUxNYXAgPSByZXF1aXJlKCcuL25vZGVzL1lBTUxNYXAuanMnKTtcbnZhciBZQU1MU2VxID0gcmVxdWlyZSgnLi9ub2Rlcy9ZQU1MU2VxLmpzJyk7XG52YXIgY3N0ID0gcmVxdWlyZSgnLi9wYXJzZS9jc3QuanMnKTtcbnZhciBsZXhlciA9IHJlcXVpcmUoJy4vcGFyc2UvbGV4ZXIuanMnKTtcbnZhciBsaW5lQ291bnRlciA9IHJlcXVpcmUoJy4vcGFyc2UvbGluZS1jb3VudGVyLmpzJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZS9wYXJzZXIuanMnKTtcbnZhciBwdWJsaWNBcGkgPSByZXF1aXJlKCcuL3B1YmxpYy1hcGkuanMnKTtcbnZhciB2aXNpdCA9IHJlcXVpcmUoJy4vdmlzaXQuanMnKTtcblxuXG5cbmV4cG9ydHMuQ29tcG9zZXIgPSBjb21wb3Nlci5Db21wb3NlcjtcbmV4cG9ydHMuRG9jdW1lbnQgPSBEb2N1bWVudC5Eb2N1bWVudDtcbmV4cG9ydHMuU2NoZW1hID0gU2NoZW1hLlNjaGVtYTtcbmV4cG9ydHMuWUFNTEVycm9yID0gZXJyb3JzLllBTUxFcnJvcjtcbmV4cG9ydHMuWUFNTFBhcnNlRXJyb3IgPSBlcnJvcnMuWUFNTFBhcnNlRXJyb3I7XG5leHBvcnRzLllBTUxXYXJuaW5nID0gZXJyb3JzLllBTUxXYXJuaW5nO1xuZXhwb3J0cy5BbGlhcyA9IEFsaWFzLkFsaWFzO1xuZXhwb3J0cy5pc0FsaWFzID0gaWRlbnRpdHkuaXNBbGlhcztcbmV4cG9ydHMuaXNDb2xsZWN0aW9uID0gaWRlbnRpdHkuaXNDb2xsZWN0aW9uO1xuZXhwb3J0cy5pc0RvY3VtZW50ID0gaWRlbnRpdHkuaXNEb2N1bWVudDtcbmV4cG9ydHMuaXNNYXAgPSBpZGVudGl0eS5pc01hcDtcbmV4cG9ydHMuaXNOb2RlID0gaWRlbnRpdHkuaXNOb2RlO1xuZXhwb3J0cy5pc1BhaXIgPSBpZGVudGl0eS5pc1BhaXI7XG5leHBvcnRzLmlzU2NhbGFyID0gaWRlbnRpdHkuaXNTY2FsYXI7XG5leHBvcnRzLmlzU2VxID0gaWRlbnRpdHkuaXNTZXE7XG5leHBvcnRzLlBhaXIgPSBQYWlyLlBhaXI7XG5leHBvcnRzLlNjYWxhciA9IFNjYWxhci5TY2FsYXI7XG5leHBvcnRzLllBTUxNYXAgPSBZQU1MTWFwLllBTUxNYXA7XG5leHBvcnRzLllBTUxTZXEgPSBZQU1MU2VxLllBTUxTZXE7XG5leHBvcnRzLkNTVCA9IGNzdDtcbmV4cG9ydHMuTGV4ZXIgPSBsZXhlci5MZXhlcjtcbmV4cG9ydHMuTGluZUNvdW50ZXIgPSBsaW5lQ291bnRlci5MaW5lQ291bnRlcjtcbmV4cG9ydHMuUGFyc2VyID0gcGFyc2VyLlBhcnNlcjtcbmV4cG9ydHMucGFyc2UgPSBwdWJsaWNBcGkucGFyc2U7XG5leHBvcnRzLnBhcnNlQWxsRG9jdW1lbnRzID0gcHVibGljQXBpLnBhcnNlQWxsRG9jdW1lbnRzO1xuZXhwb3J0cy5wYXJzZURvY3VtZW50ID0gcHVibGljQXBpLnBhcnNlRG9jdW1lbnQ7XG5leHBvcnRzLnN0cmluZ2lmeSA9IHB1YmxpY0FwaS5zdHJpbmdpZnk7XG5leHBvcnRzLnZpc2l0ID0gdmlzaXQudmlzaXQ7XG5leHBvcnRzLnZpc2l0QXN5bmMgPSB2aXNpdC52aXNpdEFzeW5jO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEVTQyA9ICdcXHgxQic7XG5jb25zdCBDU0kgPSBgJHtFU0N9W2A7XG5jb25zdCBiZWVwID0gJ1xcdTAwMDcnO1xuXG5jb25zdCBjdXJzb3IgPSB7XG4gIHRvKHgsIHkpIHtcbiAgICBpZiAoIXkpIHJldHVybiBgJHtDU0l9JHt4ICsgMX1HYDtcbiAgICByZXR1cm4gYCR7Q1NJfSR7eSArIDF9OyR7eCArIDF9SGA7XG4gIH0sXG4gIG1vdmUoeCwgeSkge1xuICAgIGxldCByZXQgPSAnJztcblxuICAgIGlmICh4IDwgMCkgcmV0ICs9IGAke0NTSX0key14fURgO1xuICAgIGVsc2UgaWYgKHggPiAwKSByZXQgKz0gYCR7Q1NJfSR7eH1DYDtcblxuICAgIGlmICh5IDwgMCkgcmV0ICs9IGAke0NTSX0key15fUFgO1xuICAgIGVsc2UgaWYgKHkgPiAwKSByZXQgKz0gYCR7Q1NJfSR7eX1CYDtcblxuICAgIHJldHVybiByZXQ7XG4gIH0sXG4gIHVwOiAoY291bnQgPSAxKSA9PiBgJHtDU0l9JHtjb3VudH1BYCxcbiAgZG93bjogKGNvdW50ID0gMSkgPT4gYCR7Q1NJfSR7Y291bnR9QmAsXG4gIGZvcndhcmQ6IChjb3VudCA9IDEpID0+IGAke0NTSX0ke2NvdW50fUNgLFxuICBiYWNrd2FyZDogKGNvdW50ID0gMSkgPT4gYCR7Q1NJfSR7Y291bnR9RGAsXG4gIG5leHRMaW5lOiAoY291bnQgPSAxKSA9PiBgJHtDU0l9RWAucmVwZWF0KGNvdW50KSxcbiAgcHJldkxpbmU6IChjb3VudCA9IDEpID0+IGAke0NTSX1GYC5yZXBlYXQoY291bnQpLFxuICBsZWZ0OiBgJHtDU0l9R2AsXG4gIGhpZGU6IGAke0NTSX0/MjVsYCxcbiAgc2hvdzogYCR7Q1NJfT8yNWhgLFxuICBzYXZlOiBgJHtFU0N9N2AsXG4gIHJlc3RvcmU6IGAke0VTQ304YFxufVxuXG5jb25zdCBzY3JvbGwgPSB7XG4gIHVwOiAoY291bnQgPSAxKSA9PiBgJHtDU0l9U2AucmVwZWF0KGNvdW50KSxcbiAgZG93bjogKGNvdW50ID0gMSkgPT4gYCR7Q1NJfVRgLnJlcGVhdChjb3VudClcbn1cblxuY29uc3QgZXJhc2UgPSB7XG4gIHNjcmVlbjogYCR7Q1NJfTJKYCxcbiAgdXA6IChjb3VudCA9IDEpID0+IGAke0NTSX0xSmAucmVwZWF0KGNvdW50KSxcbiAgZG93bjogKGNvdW50ID0gMSkgPT4gYCR7Q1NJfUpgLnJlcGVhdChjb3VudCksXG4gIGxpbmU6IGAke0NTSX0yS2AsXG4gIGxpbmVFbmQ6IGAke0NTSX1LYCxcbiAgbGluZVN0YXJ0OiBgJHtDU0l9MUtgLFxuICBsaW5lcyhjb3VudCkge1xuICAgIGxldCBjbGVhciA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKylcbiAgICAgIGNsZWFyICs9IHRoaXMubGluZSArIChpIDwgY291bnQgLSAxID8gY3Vyc29yLnVwKCkgOiAnJyk7XG4gICAgaWYgKGNvdW50KVxuICAgICAgY2xlYXIgKz0gY3Vyc29yLmxlZnQ7XG4gICAgcmV0dXJuIGNsZWFyO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBjdXJzb3IsIHNjcm9sbCwgZXJhc2UsIGJlZXAgfTtcbiIsCiAgICAibGV0IHAgPSBwcm9jZXNzIHx8IHt9LCBhcmd2ID0gcC5hcmd2IHx8IFtdLCBlbnYgPSBwLmVudiB8fCB7fVxubGV0IGlzQ29sb3JTdXBwb3J0ZWQgPVxuXHQhKCEhZW52Lk5PX0NPTE9SIHx8IGFyZ3YuaW5jbHVkZXMoXCItLW5vLWNvbG9yXCIpKSAmJlxuXHQoISFlbnYuRk9SQ0VfQ09MT1IgfHwgYXJndi5pbmNsdWRlcyhcIi0tY29sb3JcIikgfHwgcC5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiIHx8ICgocC5zdGRvdXQgfHwge30pLmlzVFRZICYmIGVudi5URVJNICE9PSBcImR1bWJcIikgfHwgISFlbnYuQ0kpXG5cbmxldCBmb3JtYXR0ZXIgPSAob3BlbiwgY2xvc2UsIHJlcGxhY2UgPSBvcGVuKSA9PlxuXHRpbnB1dCA9PiB7XG5cdFx0bGV0IHN0cmluZyA9IFwiXCIgKyBpbnB1dCwgaW5kZXggPSBzdHJpbmcuaW5kZXhPZihjbG9zZSwgb3Blbi5sZW5ndGgpXG5cdFx0cmV0dXJuIH5pbmRleCA/IG9wZW4gKyByZXBsYWNlQ2xvc2Uoc3RyaW5nLCBjbG9zZSwgcmVwbGFjZSwgaW5kZXgpICsgY2xvc2UgOiBvcGVuICsgc3RyaW5nICsgY2xvc2Vcblx0fVxuXG5sZXQgcmVwbGFjZUNsb3NlID0gKHN0cmluZywgY2xvc2UsIHJlcGxhY2UsIGluZGV4KSA9PiB7XG5cdGxldCByZXN1bHQgPSBcIlwiLCBjdXJzb3IgPSAwXG5cdGRvIHtcblx0XHRyZXN1bHQgKz0gc3RyaW5nLnN1YnN0cmluZyhjdXJzb3IsIGluZGV4KSArIHJlcGxhY2Vcblx0XHRjdXJzb3IgPSBpbmRleCArIGNsb3NlLmxlbmd0aFxuXHRcdGluZGV4ID0gc3RyaW5nLmluZGV4T2YoY2xvc2UsIGN1cnNvcilcblx0fSB3aGlsZSAofmluZGV4KVxuXHRyZXR1cm4gcmVzdWx0ICsgc3RyaW5nLnN1YnN0cmluZyhjdXJzb3IpXG59XG5cbmxldCBjcmVhdGVDb2xvcnMgPSAoZW5hYmxlZCA9IGlzQ29sb3JTdXBwb3J0ZWQpID0+IHtcblx0bGV0IGYgPSBlbmFibGVkID8gZm9ybWF0dGVyIDogKCkgPT4gU3RyaW5nXG5cdHJldHVybiB7XG5cdFx0aXNDb2xvclN1cHBvcnRlZDogZW5hYmxlZCxcblx0XHRyZXNldDogZihcIlxceDFiWzBtXCIsIFwiXFx4MWJbMG1cIiksXG5cdFx0Ym9sZDogZihcIlxceDFiWzFtXCIsIFwiXFx4MWJbMjJtXCIsIFwiXFx4MWJbMjJtXFx4MWJbMW1cIiksXG5cdFx0ZGltOiBmKFwiXFx4MWJbMm1cIiwgXCJcXHgxYlsyMm1cIiwgXCJcXHgxYlsyMm1cXHgxYlsybVwiKSxcblx0XHRpdGFsaWM6IGYoXCJcXHgxYlszbVwiLCBcIlxceDFiWzIzbVwiKSxcblx0XHR1bmRlcmxpbmU6IGYoXCJcXHgxYls0bVwiLCBcIlxceDFiWzI0bVwiKSxcblx0XHRpbnZlcnNlOiBmKFwiXFx4MWJbN21cIiwgXCJcXHgxYlsyN21cIiksXG5cdFx0aGlkZGVuOiBmKFwiXFx4MWJbOG1cIiwgXCJcXHgxYlsyOG1cIiksXG5cdFx0c3RyaWtldGhyb3VnaDogZihcIlxceDFiWzltXCIsIFwiXFx4MWJbMjltXCIpLFxuXG5cdFx0YmxhY2s6IGYoXCJcXHgxYlszMG1cIiwgXCJcXHgxYlszOW1cIiksXG5cdFx0cmVkOiBmKFwiXFx4MWJbMzFtXCIsIFwiXFx4MWJbMzltXCIpLFxuXHRcdGdyZWVuOiBmKFwiXFx4MWJbMzJtXCIsIFwiXFx4MWJbMzltXCIpLFxuXHRcdHllbGxvdzogZihcIlxceDFiWzMzbVwiLCBcIlxceDFiWzM5bVwiKSxcblx0XHRibHVlOiBmKFwiXFx4MWJbMzRtXCIsIFwiXFx4MWJbMzltXCIpLFxuXHRcdG1hZ2VudGE6IGYoXCJcXHgxYlszNW1cIiwgXCJcXHgxYlszOW1cIiksXG5cdFx0Y3lhbjogZihcIlxceDFiWzM2bVwiLCBcIlxceDFiWzM5bVwiKSxcblx0XHR3aGl0ZTogZihcIlxceDFiWzM3bVwiLCBcIlxceDFiWzM5bVwiKSxcblx0XHRncmF5OiBmKFwiXFx4MWJbOTBtXCIsIFwiXFx4MWJbMzltXCIpLFxuXG5cdFx0YmdCbGFjazogZihcIlxceDFiWzQwbVwiLCBcIlxceDFiWzQ5bVwiKSxcblx0XHRiZ1JlZDogZihcIlxceDFiWzQxbVwiLCBcIlxceDFiWzQ5bVwiKSxcblx0XHRiZ0dyZWVuOiBmKFwiXFx4MWJbNDJtXCIsIFwiXFx4MWJbNDltXCIpLFxuXHRcdGJnWWVsbG93OiBmKFwiXFx4MWJbNDNtXCIsIFwiXFx4MWJbNDltXCIpLFxuXHRcdGJnQmx1ZTogZihcIlxceDFiWzQ0bVwiLCBcIlxceDFiWzQ5bVwiKSxcblx0XHRiZ01hZ2VudGE6IGYoXCJcXHgxYls0NW1cIiwgXCJcXHgxYls0OW1cIiksXG5cdFx0YmdDeWFuOiBmKFwiXFx4MWJbNDZtXCIsIFwiXFx4MWJbNDltXCIpLFxuXHRcdGJnV2hpdGU6IGYoXCJcXHgxYls0N21cIiwgXCJcXHgxYls0OW1cIiksXG5cblx0XHRibGFja0JyaWdodDogZihcIlxceDFiWzkwbVwiLCBcIlxceDFiWzM5bVwiKSxcblx0XHRyZWRCcmlnaHQ6IGYoXCJcXHgxYls5MW1cIiwgXCJcXHgxYlszOW1cIiksXG5cdFx0Z3JlZW5CcmlnaHQ6IGYoXCJcXHgxYls5Mm1cIiwgXCJcXHgxYlszOW1cIiksXG5cdFx0eWVsbG93QnJpZ2h0OiBmKFwiXFx4MWJbOTNtXCIsIFwiXFx4MWJbMzltXCIpLFxuXHRcdGJsdWVCcmlnaHQ6IGYoXCJcXHgxYls5NG1cIiwgXCJcXHgxYlszOW1cIiksXG5cdFx0bWFnZW50YUJyaWdodDogZihcIlxceDFiWzk1bVwiLCBcIlxceDFiWzM5bVwiKSxcblx0XHRjeWFuQnJpZ2h0OiBmKFwiXFx4MWJbOTZtXCIsIFwiXFx4MWJbMzltXCIpLFxuXHRcdHdoaXRlQnJpZ2h0OiBmKFwiXFx4MWJbOTdtXCIsIFwiXFx4MWJbMzltXCIpLFxuXG5cdFx0YmdCbGFja0JyaWdodDogZihcIlxceDFiWzEwMG1cIiwgXCJcXHgxYls0OW1cIiksXG5cdFx0YmdSZWRCcmlnaHQ6IGYoXCJcXHgxYlsxMDFtXCIsIFwiXFx4MWJbNDltXCIpLFxuXHRcdGJnR3JlZW5CcmlnaHQ6IGYoXCJcXHgxYlsxMDJtXCIsIFwiXFx4MWJbNDltXCIpLFxuXHRcdGJnWWVsbG93QnJpZ2h0OiBmKFwiXFx4MWJbMTAzbVwiLCBcIlxceDFiWzQ5bVwiKSxcblx0XHRiZ0JsdWVCcmlnaHQ6IGYoXCJcXHgxYlsxMDRtXCIsIFwiXFx4MWJbNDltXCIpLFxuXHRcdGJnTWFnZW50YUJyaWdodDogZihcIlxceDFiWzEwNW1cIiwgXCJcXHgxYls0OW1cIiksXG5cdFx0YmdDeWFuQnJpZ2h0OiBmKFwiXFx4MWJbMTA2bVwiLCBcIlxceDFiWzQ5bVwiKSxcblx0XHRiZ1doaXRlQnJpZ2h0OiBmKFwiXFx4MWJbMTA3bVwiLCBcIlxceDFiWzQ5bVwiKSxcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUNvbG9ycygpXG5tb2R1bGUuZXhwb3J0cy5jcmVhdGVDb2xvcnMgPSBjcmVhdGVDb2xvcnNcbiIsCiAgICAiLyoqXG4gKiBDTEkgVUkgdXRpbGl0aWVzIGZvciBhaS1lbmcgcmFscGhcbiAqXG4gKiBDb25zb2xlIHN0eWxpbmcgYW5kIG91dHB1dCBoZWxwZXJzXG4gKi9cbmltcG9ydCB7IEVPTCB9IGZyb20gXCJub2RlOm9zXCI7XG5cbmV4cG9ydCBuYW1lc3BhY2UgVUkge1xuICAgIGV4cG9ydCBjb25zdCBTdHlsZSA9IHtcbiAgICAgICAgLy8gQ29sb3JzXG4gICAgICAgIFRFWFRfSElHSExJR0hUOiBcIlxceDFiWzk2bVwiLFxuICAgICAgICBURVhUX0hJR0hMSUdIVF9CT0xEOiBcIlxceDFiWzk2bVxceDFiWzFtXCIsXG4gICAgICAgIFRFWFRfRElNOiBcIlxceDFiWzkwbVwiLFxuICAgICAgICBURVhUX0RJTV9CT0xEOiBcIlxceDFiWzkwbVxceDFiWzFtXCIsXG4gICAgICAgIFRFWFRfTk9STUFMOiBcIlxceDFiWzBtXCIsXG4gICAgICAgIFRFWFRfTk9STUFMX0JPTEQ6IFwiXFx4MWJbMW1cIixcbiAgICAgICAgVEVYVF9XQVJOSU5HOiBcIlxceDFiWzkzbVwiLFxuICAgICAgICBURVhUX1dBUk5JTkdfQk9MRDogXCJcXHgxYls5M21cXHgxYlsxbVwiLFxuICAgICAgICBURVhUX0RBTkdFUjogXCJcXHgxYls5MW1cIixcbiAgICAgICAgVEVYVF9EQU5HRVJfQk9MRDogXCJcXHgxYls5MW1cXHgxYlsxbVwiLFxuICAgICAgICBURVhUX1NVQ0NFU1M6IFwiXFx4MWJbOTJtXCIsXG4gICAgICAgIFRFWFRfU1VDQ0VTU19CT0xEOiBcIlxceDFiWzkybVxceDFiWzFtXCIsXG4gICAgICAgIFRFWFRfSU5GTzogXCJcXHgxYls5NG1cIixcbiAgICAgICAgVEVYVF9JTkZPX0JPTEQ6IFwiXFx4MWJbOTRtXFx4MWJbMW1cIixcbiAgICB9O1xuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHByaW50bG4oLi4ubWVzc2FnZTogc3RyaW5nW10pOiB2b2lkIHtcbiAgICAgICAgcHJvY2Vzcy5zdGRlcnIud3JpdGUobWVzc2FnZS5qb2luKFwiIFwiKSArIEVPTCk7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHByaW50KC4uLm1lc3NhZ2U6IHN0cmluZ1tdKTogdm9pZCB7XG4gICAgICAgIHByb2Nlc3Muc3RkZXJyLndyaXRlKG1lc3NhZ2Uuam9pbihcIiBcIikpO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBlcnJvcihtZXNzYWdlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgcHJpbnRsbihcbiAgICAgICAgICAgIGAke1N0eWxlLlRFWFRfREFOR0VSX0JPTER9RXJyb3I6ICR7U3R5bGUuVEVYVF9OT1JNQUx9JHttZXNzYWdlfWAsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHN1Y2Nlc3MobWVzc2FnZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHByaW50bG4oYCR7U3R5bGUuVEVYVF9TVUNDRVNTX0JPTER94pyTICR7U3R5bGUuVEVYVF9OT1JNQUx9JHttZXNzYWdlfWApO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBpbmZvKG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBwcmludGxuKGAke1N0eWxlLlRFWFRfSU5GT19CT0xEfeKEuSAke1N0eWxlLlRFWFRfTk9STUFMfSR7bWVzc2FnZX1gKTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gd2FybihtZXNzYWdlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgcHJpbnRsbihgJHtTdHlsZS5URVhUX1dBUk5JTkdfQk9MRH0hICR7U3R5bGUuVEVYVF9OT1JNQUx9JHttZXNzYWdlfWApO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBoZWFkZXIodGl0bGU6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBwcmludGxuKCk7XG4gICAgICAgIHByaW50bG4oU3R5bGUuVEVYVF9ISUdITElHSFRfQk9MRCArIHRpdGxlICsgU3R5bGUuVEVYVF9OT1JNQUwpO1xuICAgICAgICBwcmludGxuKFN0eWxlLlRFWFRfRElNICsgXCLilIBcIi5yZXBlYXQoNTApICsgU3R5bGUuVEVYVF9OT1JNQUwpO1xuICAgIH1cbn1cbiIsCiAgICAiLyoqXG4gKiBJbml0aWFsaXplIGFpLWVuZyBjb25maWd1cmF0aW9uIGZpbGVcbiAqL1xuXG5pbXBvcnQgeyBleGlzdHNTeW5jIH0gZnJvbSBcIm5vZGU6ZnNcIjtcbmltcG9ydCB7IHdyaXRlRmlsZSB9IGZyb20gXCJub2RlOmZzL3Byb21pc2VzXCI7XG5pbXBvcnQgeyBqb2luIH0gZnJvbSBcIm5vZGU6cGF0aFwiO1xuaW1wb3J0IFlBTUwgZnJvbSBcInlhbWxcIjtcbmltcG9ydCB0eXBlIHsgSW5pdEZsYWdzIH0gZnJvbSBcIi4uL2NsaS9mbGFnc1wiO1xuaW1wb3J0IHsgVUkgfSBmcm9tIFwiLi4vY2xpL3VpXCI7XG5pbXBvcnQgeyBERUZBVUxUX0NPTkZJRyB9IGZyb20gXCIuLi9jb25maWcvc2NoZW1hXCI7XG5cbi8qKlxuICogRGVmYXVsdCBjb25maWd1cmF0aW9uIHRlbXBsYXRlXG4gKi9cbmNvbnN0IENPTkZJR19URU1QTEFURSA9IHtcbiAgICB2ZXJzaW9uOiAxLFxuICAgIHJ1bm5lcjoge1xuICAgICAgICBiYWNrZW5kOiBcIm9wZW5jb2RlXCIsXG4gICAgICAgIHJldmlldzogXCJvcGVuY29kZVwiLFxuICAgICAgICBhcnRpZmFjdHNEaXI6IFwiLmFpLWVuZy9ydW5zXCIsXG4gICAgICAgIG1heEl0ZXJzOiAzLFxuICAgICAgICBwcmludExvZ3M6IGZhbHNlLFxuICAgICAgICBsb2dMZXZlbDogXCJJTkZPXCIsXG4gICAgfSxcbiAgICBsb29wOiB7XG4gICAgICAgIG1heEN5Y2xlczogNTAsXG4gICAgICAgIGN5Y2xlUmV0cmllczogMixcbiAgICAgICAgY2hlY2twb2ludEZyZXF1ZW5jeTogMSxcbiAgICAgICAgc3R1Y2tUaHJlc2hvbGQ6IDUsXG4gICAgfSxcbiAgICBkZWJ1Zzoge1xuICAgICAgICB3b3JrOiBmYWxzZSxcbiAgICB9LFxuICAgIG9wZW5jb2RlOiB7XG4gICAgICAgIG1vZGVsOiBcImNsYXVkZS0zLTUtc29ubmV0LWxhdGVzdFwiLFxuICAgICAgICB0ZW1wZXJhdHVyZTogMC4yLFxuICAgICAgICBwcm9tcHRUaW1lb3V0TXM6IDEyMDAwMCxcbiAgICB9LFxuICAgIGFudGhyb3BpYzoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgbW9kZWw6IFwiY2xhdWRlLTMtNS1zb25uZXQtbGF0ZXN0XCIsXG4gICAgfSxcbiAgICBnYXRlczoge1xuICAgICAgICBsaW50OiB7IGNvbW1hbmQ6IFwiYnVuIHJ1biBsaW50XCIgfSxcbiAgICAgICAgdHlwZWNoZWNrOiB7IGNvbW1hbmQ6IFwiYnVuIHJ1biB0eXBlY2hlY2tcIiB9LFxuICAgICAgICB0ZXN0OiB7IGNvbW1hbmQ6IFwiYnVuIHRlc3RcIiB9LFxuICAgICAgICBidWlsZDogeyBjb21tYW5kOiBcImJ1biBydW4gYnVpbGRcIiB9LFxuICAgICAgICBhY2NlcHRhbmNlOiB7IGNvbW1hbmQ6IFwiZ2l0IGRpZmYgLS1uYW1lLW9ubHlcIiB9LFxuICAgIH0sXG4gICAgbW9kZWxzOiB7XG4gICAgICAgIHJlc2VhcmNoOiBcImdpdGh1Yi1jb3BpbG90L2dwdC01LjJcIixcbiAgICAgICAgcGxhbm5pbmc6IFwiZ2l0aHViLWNvcGlsb3QvZ3B0LTUuMlwiLFxuICAgICAgICBleHBsb3JhdGlvbjogXCJnaXRodWItY29waWxvdC9ncHQtNS4yXCIsXG4gICAgICAgIGNvZGluZzogXCJnaXRodWItY29waWxvdC9ncHQtNS4yXCIsXG4gICAgICAgIGRlZmF1bHQ6IFwiZ2l0aHViLWNvcGlsb3QvZ3B0LTUuMlwiLFxuICAgIH0sXG4gICAgbm90aWZpY2F0aW9uczoge1xuICAgICAgICBkaXNjb3JkOiB7XG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHVzZXJuYW1lOiBcIlJhbHBoXCIsXG4gICAgICAgICAgICB3ZWJob29rOiB7XG4gICAgICAgICAgICAgICAgc291cmNlOiBcImVudlwiLFxuICAgICAgICAgICAgICAgIGVudlZhcjogXCJESVNDT1JEX1dFQkhPT0tfVVJMXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgdWk6IHtcbiAgICAgICAgc2lsZW50OiBmYWxzZSxcbiAgICB9LFxufTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGNvbmZpZ3VyYXRpb24gZmlsZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW5pdENvbmZpZyhmbGFnczogSW5pdEZsYWdzKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgY29uZmlnRGlyID0gam9pbihwcm9jZXNzLmN3ZCgpLCBcIi5haS1lbmdcIik7XG4gICAgY29uc3QgY29uZmlnUGF0aCA9IGpvaW4oY29uZmlnRGlyLCBcImNvbmZpZy55YW1sXCIpO1xuXG4gICAgLy8gQ2hlY2sgaWYgY29uZmlnIGFscmVhZHkgZXhpc3RzXG4gICAgaWYgKGV4aXN0c1N5bmMoY29uZmlnUGF0aCkgJiYgIWZsYWdzLm92ZXJ3cml0ZSkge1xuICAgICAgICBVSS5lcnJvcihcIkNvbmZpZ3VyYXRpb24gZmlsZSBhbHJlYWR5IGV4aXN0czpcIik7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYCAgJHtjb25maWdQYXRofWApO1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCJVc2UgLS1vdmVyd3JpdGUgdG8gcmVwbGFjZSBpdCwgb3IgZWRpdCB0aGUgZXhpc3RpbmcgZmlsZS5cIixcbiAgICAgICAgKTtcbiAgICAgICAgcHJvY2Vzcy5leGl0KDEpO1xuICAgIH1cblxuICAgIGlmIChmbGFncy5pbnRlcmFjdGl2ZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIuKaoO+4jyAgSW50ZXJhY3RpdmUgbW9kZSByZXF1aXJlcyBhZGRpdGlvbmFsIGRlcGVuZGVuY2llcy5cIik7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiICBucG0gaW5zdGFsbCBAY2xhY2svcHJvbXB0c1wiKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJGb3Igbm93LCBjcmVhdGluZyBjb25maWcgd2l0aCBkZWZhdWx0cy4uLlxcblwiKTtcbiAgICB9XG5cbiAgICAvLyBXcml0ZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb25cbiAgICB0cnkge1xuICAgICAgICBjb25zdCB5YW1sQ29udGVudCA9IFlBTUwuc3RyaW5naWZ5KENPTkZJR19URU1QTEFURSwge1xuICAgICAgICAgICAgaW5kZW50OiAyLFxuICAgICAgICAgICAgbGluZVdpZHRoOiAwLFxuICAgICAgICB9KTtcblxuICAgICAgICBhd2FpdCB3cml0ZUZpbGUoY29uZmlnUGF0aCwgeWFtbENvbnRlbnQsIFwidXRmLThcIik7XG4gICAgICAgIGNvbnNvbGUubG9nKFwi4pyFIEluaXRpYWxpemVkIC5haS1lbmcvY29uZmlnLnlhbWwgd2l0aCBkZWZhdWx0c1wiKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJcXG7wn5OLIE5leHQgc3RlcHM6XCIpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIiAgMS4gRWRpdCAuYWktZW5nL2NvbmZpZy55YW1sIHRvIGN1c3RvbWl6ZSBzZXR0aW5nc1wiKTtcbiAgICAgICAgY29uc29sZS5sb2coXCIgIDIuIFNldCB1cCBBSSBtb2RlbHMgYW5kIGJhY2tlbmRzXCIpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIiAgMy4gQ29uZmlndXJlIHF1YWxpdHkgZ2F0ZXMgZm9yIHlvdXIgcHJvamVjdFwiKTtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBcIiAgNC4gUnVuICdhaS1lbmcgcmFscGggXFxcInlvdXIgdGFza1xcXCInIHRvIHN0YXJ0IGRldmVsb3BtZW50XCIsXG4gICAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byB3cml0ZSBjb25maWd1cmF0aW9uIGZpbGVcIik7XG4gICAgICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgICB9XG59XG4iLAogICAgIi8qKlxuICogYWktZW5nIGluc3RhbGwgY29tbWFuZFxuICpcbiAqIEluc3RhbGxzIE9wZW5Db2RlL0NsYXVkZSBhc3NldHMgdG8gcHJvamVjdCBvciBnbG9iYWwgbG9jYXRpb24uXG4gKiBSZXBsYWNlcyB0aGUgYXV0b21hdGljIHBvc3RpbnN0YWxsIGJlaGF2aW9yLlxuICovXG5cbmltcG9ydCBmcyBmcm9tIFwibm9kZTpmc1wiO1xuaW1wb3J0IHBhdGggZnJvbSBcIm5vZGU6cGF0aFwiO1xuaW1wb3J0IHsgZmlsZVVSTFRvUGF0aCB9IGZyb20gXCJub2RlOnVybFwiO1xuXG5jb25zdCBfX2ZpbGVuYW1lID0gZmlsZVVSTFRvUGF0aChpbXBvcnQubWV0YS51cmwpO1xuY29uc3QgX19kaXJuYW1lID0gcGF0aC5kaXJuYW1lKF9fZmlsZW5hbWUpO1xuY29uc3QgUk9PVCA9IHBhdGguZGlybmFtZShfX2Rpcm5hbWUpO1xuY29uc3QgTkFNRVNQQUNFX1BSRUZJWCA9IFwiYWktZW5nXCI7XG5cbmludGVyZmFjZSBJbnN0YWxsRmxhZ3Mge1xuICAgIHNjb3BlPzogXCJwcm9qZWN0XCIgfCBcImdsb2JhbFwiIHwgXCJhdXRvXCI7XG4gICAgZHJ5UnVuPzogYm9vbGVhbjtcbiAgICB5ZXM/OiBib29sZWFuO1xuICAgIHZlcmJvc2U/OiBib29sZWFuO1xufVxuXG5hc3luYyBmdW5jdGlvbiBjbGVhbk5hbWVzcGFjZWREaXJlY3RvcnkoXG4gICAgYmFzZURpcjogc3RyaW5nLFxuICAgIHN1YmRpcjogc3RyaW5nLFxuICAgIG5hbWVzcGFjZTogc3RyaW5nLFxuICAgIHNpbGVudCA9IGZhbHNlLFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgZGlyID0gcGF0aC5qb2luKGJhc2VEaXIsIHN1YmRpciwgbmFtZXNwYWNlKTtcbiAgICBpZiAoZnMuZXhpc3RzU3luYyhkaXIpKSB7XG4gICAgICAgIGZzLnJtU3luYyhkaXIsIHsgcmVjdXJzaXZlOiB0cnVlLCBmb3JjZTogdHJ1ZSB9KTtcbiAgICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAgIOKchSBDbGVhbmVkIGV4aXN0aW5nICR7c3ViZGlyfS8ke25hbWVzcGFjZX0vYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNsZWFuQWlFbmdTa2lsbHMoXG4gICAgdGFyZ2V0T3BlbkNvZGVEaXI6IHN0cmluZyxcbiAgICBkaXN0T3BlbkNvZGVEaXI6IHN0cmluZyxcbiAgICBzaWxlbnQgPSBmYWxzZSxcbik6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHRhcmdldFNraWxsRGlyID0gcGF0aC5qb2luKHRhcmdldE9wZW5Db2RlRGlyLCBcInNraWxsXCIpO1xuICAgIGNvbnN0IGRpc3RTa2lsbERpciA9IHBhdGguam9pbihkaXN0T3BlbkNvZGVEaXIsIFwic2tpbGxcIik7XG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKGRpc3RTa2lsbERpcikpIHJldHVybjtcblxuICAgIGNvbnN0IGFpRW5nU2tpbGxOYW1lcyA9IGZzXG4gICAgICAgIC5yZWFkZGlyU3luYyhkaXN0U2tpbGxEaXIsIHsgd2l0aEZpbGVUeXBlczogdHJ1ZSB9KVxuICAgICAgICAuZmlsdGVyKChlbnRyeSkgPT4gZW50cnkuaXNEaXJlY3RvcnkoKSlcbiAgICAgICAgLm1hcCgoZW50cnkpID0+IGVudHJ5Lm5hbWUpO1xuXG4gICAgaWYgKGFpRW5nU2tpbGxOYW1lcy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgIGxldCBjbGVhbmVkQ291bnQgPSAwO1xuICAgIGZvciAoY29uc3Qgc2tpbGxOYW1lIG9mIGFpRW5nU2tpbGxOYW1lcykge1xuICAgICAgICBjb25zdCBza2lsbFBhdGggPSBwYXRoLmpvaW4odGFyZ2V0U2tpbGxEaXIsIHNraWxsTmFtZSk7XG4gICAgICAgIGlmIChmcy5leGlzdHNTeW5jKHNraWxsUGF0aCkpIHtcbiAgICAgICAgICAgIGZzLnJtU3luYyhza2lsbFBhdGgsIHsgcmVjdXJzaXZlOiB0cnVlLCBmb3JjZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGNsZWFuZWRDb3VudCsrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFzaWxlbnQgJiYgY2xlYW5lZENvdW50ID4gMCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgICDinIUgQ2xlYW5lZCAke2NsZWFuZWRDb3VudH0gZXhpc3RpbmcgYWktZW5nIHNraWxsc2ApO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNQbHVnaW5SZWZlcmVuY2VkKGNvbmZpZ1BhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZ0NvbnRlbnQgPSBmcy5yZWFkRmlsZVN5bmMoY29uZmlnUGF0aCwgXCJ1dGYtOFwiKTtcbiAgICAgICAgY29uc3QgY29uZmlnID0gSlNPTi5wYXJzZShjb25maWdDb250ZW50KTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnLnBsdWdpbikpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25maWcucGx1Z2luLmluY2x1ZGVzKFwiYWktZW5nLXN5c3RlbVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRPcGVuQ29kZUNvbmZpZyhcbiAgICBwcm9qZWN0RGlyOiBzdHJpbmcsXG4pOiB7IHBhdGg6IHN0cmluZzsgaXNHbG9iYWw6IGJvb2xlYW4gfSB8IG51bGwge1xuICAgIGNvbnN0IGhvbWVEaXIgPSBwcm9jZXNzLmVudi5IT01FIHx8IHByb2Nlc3MuZW52LlVTRVJQUk9GSUxFIHx8IFwiXCI7XG5cbiAgICAvLyBDaGVjayBwcm9qZWN0IC5vcGVuY29kZS9cbiAgICBjb25zdCBwcm9qZWN0Q29uZmlnID0gcGF0aC5qb2luKHByb2plY3REaXIsIFwiLm9wZW5jb2RlXCIsIFwib3BlbmNvZGUuanNvbmNcIik7XG4gICAgaWYgKGZzLmV4aXN0c1N5bmMocHJvamVjdENvbmZpZykpIHtcbiAgICAgICAgcmV0dXJuIHsgcGF0aDogcHJvamVjdENvbmZpZywgaXNHbG9iYWw6IGZhbHNlIH07XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZ2xvYmFsIH4vLmNvbmZpZy9vcGVuY29kZS9cbiAgICBjb25zdCBnbG9iYWxDb25maWcgPSBwYXRoLmpvaW4oXG4gICAgICAgIGhvbWVEaXIsXG4gICAgICAgIFwiLmNvbmZpZ1wiLFxuICAgICAgICBcIm9wZW5jb2RlXCIsXG4gICAgICAgIFwib3BlbmNvZGUuanNvbmNcIixcbiAgICApO1xuICAgIGlmIChmcy5leGlzdHNTeW5jKGdsb2JhbENvbmZpZykpIHtcbiAgICAgICAgcmV0dXJuIHsgcGF0aDogZ2xvYmFsQ29uZmlnLCBpc0dsb2JhbDogdHJ1ZSB9O1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBkZXRlY3RJbnN0YWxsYXRpb25TY29wZShcbiAgICBwcm9qZWN0RGlyOiBzdHJpbmcsXG4pOiBcInByb2plY3RcIiB8IFwiZ2xvYmFsXCIgfCBudWxsIHtcbiAgICBjb25zdCBjb25maWcgPSBmaW5kT3BlbkNvZGVDb25maWcocHJvamVjdERpcik7XG4gICAgaWYgKGNvbmZpZykgcmV0dXJuIGNvbmZpZy5pc0dsb2JhbCA/IFwiZ2xvYmFsXCIgOiBcInByb2plY3RcIjtcblxuICAgIC8vIElmIG5vIGNvbmZpZyBleGlzdHMsIGNoZWNrIGlmIHdlJ3JlIGluIGEgcHJvamVjdCB3aXRoIHBhY2thZ2UuanNvblxuICAgIGlmIChmcy5leGlzdHNTeW5jKHBhdGguam9pbihwcm9qZWN0RGlyLCBcInBhY2thZ2UuanNvblwiKSkpIHtcbiAgICAgICAgcmV0dXJuIFwicHJvamVjdFwiO1xuICAgIH1cblxuICAgIHJldHVybiBcImdsb2JhbFwiO1xufVxuXG5hc3luYyBmdW5jdGlvbiBydW5JbnN0YWxsZXIoZmxhZ3M6IEluc3RhbGxGbGFncyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHByb2plY3REaXIgPSBwcm9jZXNzLmN3ZCgpO1xuICAgIGNvbnN0IGhvbWVEaXIgPSBwcm9jZXNzLmVudi5IT01FIHx8IHByb2Nlc3MuZW52LlVTRVJQUk9GSUxFIHx8IFwiXCI7XG4gICAgY29uc3QgZGlzdE9wZW5Db2RlRGlyID0gcGF0aC5qb2luKFJPT1QsIFwiZGlzdFwiLCBcIi5vcGVuY29kZVwiKTtcblxuICAgIC8vIERldGVybWluZSBpbnN0YWxsYXRpb24gc2NvcGVcbiAgICBsZXQgc2NvcGUgPSBmbGFncy5zY29wZTtcbiAgICBpZiAoIXNjb3BlIHx8IHNjb3BlID09PSBcImF1dG9cIikge1xuICAgICAgICBjb25zdCBkZXRlY3RlZCA9IGRldGVjdEluc3RhbGxhdGlvblNjb3BlKHByb2plY3REaXIpO1xuICAgICAgICBpZiAoIWRldGVjdGVkKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICBcIuKdjCBDb3VsZCBub3QgZGV0ZWN0IGluc3RhbGxhdGlvbiBzY29wZS4gVXNlIC0tc2NvcGUgcHJvamVjdHxnbG9iYWxcIixcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBwcm9jZXNzLmV4aXQoMSk7XG4gICAgICAgIH1cbiAgICAgICAgc2NvcGUgPSBkZXRlY3RlZDtcbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXRPcGVuQ29kZURpciA9XG4gICAgICAgIHNjb3BlID09PSBcImdsb2JhbFwiXG4gICAgICAgICAgICA/IHBhdGguam9pbihob21lRGlyLCBcIi5jb25maWdcIiwgXCJvcGVuY29kZVwiKVxuICAgICAgICAgICAgOiBwYXRoLmpvaW4ocHJvamVjdERpciwgXCIub3BlbmNvZGVcIik7XG5cbiAgICBpZiAoZmxhZ3MudmVyYm9zZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhgSW5zdGFsbGluZyB0bzogJHt0YXJnZXRPcGVuQ29kZURpcn1gKTtcbiAgICAgICAgY29uc29sZS5sb2coYFNjb3BlOiAke3Njb3BlfWApO1xuICAgIH1cblxuICAgIC8vIFZhbGlkYXRlIHRhcmdldCBkaXJlY3RvcnlcbiAgICBpZiAoc2NvcGUgPT09IFwicHJvamVjdFwiKSB7XG4gICAgICAgIGNvbnN0IG9wZW5jb2RlRGlyID0gcGF0aC5qb2luKHByb2plY3REaXIsIFwiLm9wZW5jb2RlXCIpO1xuICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMob3BlbmNvZGVEaXIpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIuKdjCBObyAub3BlbmNvZGUvIGRpcmVjdG9yeSBmb3VuZCBpbiBwcm9qZWN0XCIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCIgICBSdW4gJ29wZW5jb2RlIGluaXQnIGZpcnN0IG9yIHVzZSAtLXNjb3BlIGdsb2JhbFwiKTtcbiAgICAgICAgICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBhaS1lbmctc3lzdGVtIHBsdWdpbiByZWZlcmVuY2VcbiAgICBjb25zdCBjb25maWcgPSBmaW5kT3BlbkNvZGVDb25maWcocHJvamVjdERpcik7XG4gICAgaWYgKGNvbmZpZyAmJiAhaXNQbHVnaW5SZWZlcmVuY2VkKGNvbmZpZy5wYXRoKSkge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgIFwi4pqg77iPICBvcGVuY29kZS5qc29uYyBkb2VzIG5vdCByZWZlcmVuY2UgYWktZW5nLXN5c3RlbSBwbHVnaW5cIixcbiAgICAgICAgKTtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBcIiAgIEFkZCAnYWktZW5nLXN5c3RlbScgdG8gdGhlIHBsdWdpbiBhcnJheSBpbiBvcGVuY29kZS5qc29uY1wiLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGlmIChmbGFncy5kcnlSdW4pIHtcbiAgICAgICAgY29uc29sZS5sb2coXCLwn5SNIGRyeS1ydW46IFdvdWxkIGluc3RhbGwgdGhlIGZvbGxvd2luZyBmaWxlczpcIik7XG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgYCAgIENvbW1hbmRzIC0+ICR7dGFyZ2V0T3BlbkNvZGVEaXJ9L2NvbW1hbmQvJHtOQU1FU1BBQ0VfUFJFRklYfS9gLFxuICAgICAgICApO1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgIGAgICBBZ2VudHMgICAtPiAke3RhcmdldE9wZW5Db2RlRGlyfS9hZ2VudC8ke05BTUVTUEFDRV9QUkVGSVh9L2AsXG4gICAgICAgICk7XG4gICAgICAgIGNvbnNvbGUubG9nKGAgICBTa2lsbHMgICAtPiAke3RhcmdldE9wZW5Db2RlRGlyfS9za2lsbC9gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEluc3RhbGwgY29tbWFuZHNcbiAgICBjb25zdCBjb21tYW5kc0RpciA9IHBhdGguam9pbihcbiAgICAgICAgdGFyZ2V0T3BlbkNvZGVEaXIsXG4gICAgICAgIFwiY29tbWFuZFwiLFxuICAgICAgICBOQU1FU1BBQ0VfUFJFRklYLFxuICAgICk7XG4gICAgY29uc3QgZGlzdENvbW1hbmRzRGlyID0gcGF0aC5qb2luKFxuICAgICAgICBkaXN0T3BlbkNvZGVEaXIsXG4gICAgICAgIFwiY29tbWFuZFwiLFxuICAgICAgICBOQU1FU1BBQ0VfUFJFRklYLFxuICAgICk7XG5cbiAgICBpZiAoZnMuZXhpc3RzU3luYyhkaXN0Q29tbWFuZHNEaXIpKSB7XG4gICAgICAgIGF3YWl0IGNsZWFuTmFtZXNwYWNlZERpcmVjdG9yeShcbiAgICAgICAgICAgIHRhcmdldE9wZW5Db2RlRGlyLFxuICAgICAgICAgICAgXCJjb21tYW5kXCIsXG4gICAgICAgICAgICBOQU1FU1BBQ0VfUFJFRklYLFxuICAgICAgICApO1xuICAgICAgICBmcy5jcFN5bmMoZGlzdENvbW1hbmRzRGlyLCBjb21tYW5kc0RpciwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGAgIOKchSBJbnN0YWxsZWQgY29tbWFuZHMgdG8gJHtjb21tYW5kc0Rpcn1gKTtcbiAgICB9XG5cbiAgICAvLyBJbnN0YWxsIGFnZW50c1xuICAgIGNvbnN0IGFnZW50c0RpciA9IHBhdGguam9pbih0YXJnZXRPcGVuQ29kZURpciwgXCJhZ2VudFwiLCBOQU1FU1BBQ0VfUFJFRklYKTtcbiAgICBjb25zdCBkaXN0QWdlbnRzRGlyID0gcGF0aC5qb2luKGRpc3RPcGVuQ29kZURpciwgXCJhZ2VudFwiLCBOQU1FU1BBQ0VfUFJFRklYKTtcblxuICAgIGlmIChmcy5leGlzdHNTeW5jKGRpc3RBZ2VudHNEaXIpKSB7XG4gICAgICAgIGF3YWl0IGNsZWFuTmFtZXNwYWNlZERpcmVjdG9yeShcbiAgICAgICAgICAgIHRhcmdldE9wZW5Db2RlRGlyLFxuICAgICAgICAgICAgXCJhZ2VudFwiLFxuICAgICAgICAgICAgTkFNRVNQQUNFX1BSRUZJWCxcbiAgICAgICAgKTtcbiAgICAgICAgZnMuY3BTeW5jKGRpc3RBZ2VudHNEaXIsIGFnZW50c0RpciwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGAgIOKchSBJbnN0YWxsZWQgYWdlbnRzIHRvICR7YWdlbnRzRGlyfWApO1xuICAgIH1cblxuICAgIC8vIEluc3RhbGwgc2tpbGxzXG4gICAgY29uc3Qgc2tpbGxzRGlyID0gcGF0aC5qb2luKHRhcmdldE9wZW5Db2RlRGlyLCBcInNraWxsXCIpO1xuICAgIGNvbnN0IGRpc3RTa2lsbHNEaXIgPSBwYXRoLmpvaW4oZGlzdE9wZW5Db2RlRGlyLCBcInNraWxsXCIpO1xuXG4gICAgaWYgKGZzLmV4aXN0c1N5bmMoZGlzdFNraWxsc0RpcikpIHtcbiAgICAgICAgYXdhaXQgY2xlYW5BaUVuZ1NraWxscyh0YXJnZXRPcGVuQ29kZURpciwgZGlzdE9wZW5Db2RlRGlyKTtcbiAgICAgICAgZnMuY3BTeW5jKGRpc3RTa2lsbHNEaXIsIHNraWxsc0RpciwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGAgIOKchSBJbnN0YWxsZWQgc2tpbGxzIHRvICR7c2tpbGxzRGlyfWApO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKFwiXFxu4pyFIEluc3RhbGxhdGlvbiBjb21wbGV0ZSFcIik7XG4gICAgY29uc29sZS5sb2coXG4gICAgICAgIFwiICAgUmVzdGFydCBPcGVuQ29kZSBvciBDbGF1ZGUgQ29kZSB0byB1c2UgbmV3IGNvbW1hbmRzIGFuZCBhZ2VudHMuXCIsXG4gICAgKTtcbn1cblxuZXhwb3J0IHsgcnVuSW5zdGFsbGVyIH07XG4iLAogICAgIiMhL3Vzci9iaW4vZW52IG5vZGVcbi8qKlxuICogQ0xJIGVudHJ5IHBvaW50IGZvciBhaS1lbmctc3lzdGVtXG4gKlxuICogRGlzcGF0Y2hlciB0aGF0IHJvdXRlcyB0byBzdWJjb21tYW5kczpcbiAqICAgLSBhaS1lbmcgcmFscGggLi4uICAgICA6IEl0ZXJhdGlvbiBsb29wIHJ1bm5lciAoZGVmYXVsdCBiZWhhdmlvcilcbiAqICAgLSBhaS1lbmcgaW5zdGFsbCAgICAgIDogSW5zdGFsbCBPcGVuQ29kZS9DbGF1ZGUgYXNzZXRzXG4gKiAgIC0gYWktZW5nIFwicHJvbXB0XCIgICAgIDogRGVmYXVsdHMgdG8gcmFscGggKHNob3J0Y3V0KVxuICovXG5cbmltcG9ydCB7IHBhcnNlQXJncyB9IGZyb20gXCJub2RlOnV0aWxcIjtcbmltcG9ydCB7IGxvYWRDb25maWcgfSBmcm9tIFwiLi4vY29uZmlnL2xvYWRDb25maWdcIjtcbmltcG9ydCB7IExvZyB9IGZyb20gXCIuLi91dGlsL2xvZ1wiO1xuaW1wb3J0IHR5cGUgeyBMb2dMZXZlbCwgUmFscGhGbGFncyB9IGZyb20gXCIuL2ZsYWdzXCI7XG5pbXBvcnQgeyBydW5DbGkgfSBmcm9tIFwiLi9ydW4tY2xpXCI7XG5pbXBvcnQgeyBVSSB9IGZyb20gXCIuL3VpXCI7XG5cbi8vIFRVSSBpcyBsb2FkZWQgZHluYW1pY2FsbHkgdG8gYXZvaWQgYnVuZGxpbmcgaXNzdWVzXG4vLyBpbXBvcnQgeyBsYXVuY2hUdWkgfSBmcm9tIFwiLi90dWkvQXBwXCI7XG5cbmNvbnN0IFRPUF9IRUxQX1RFWFQgPSBgXG5haS1lbmcgLSBBSSBFbmdpbmVlcmluZyBTeXN0ZW0gQ0xJXG5cblVTQUdFOlxuICBhaS1lbmcgPGNvbW1hbmQ+IFtvcHRpb25zXVxuICBhaS1lbmcgXCJwcm9tcHRcIiBbb3B0aW9uc10gICAgICAgICAgIyBTaG9ydGN1dDogZGVmYXVsdHMgdG8gJ3JhbHBoJ1xuXG5DT01NQU5EUzpcbiAgaW5pdCBbb3B0aW9uc10gICAgICAgICAgICAgICAgICAgICAjIEluaXRpYWxpemUgLmFpLWVuZy9jb25maWcueWFtbCB3aXRoIGRlZmF1bHRzXG4gIHJhbHBoIDxwcm9tcHR8d29ya2Zsb3c+IFtvcHRpb25zXSAgIyBJdGVyYXRpb24gbG9vcCBydW5uZXJcbiAgaW5zdGFsbCBbb3B0aW9uc10gICAgICAgICAgICAgICAgICAjIEluc3RhbGwgT3BlbkNvZGUvQ2xhdWRlIGFzc2V0c1xuXG5HTE9CQUwgT1BUSU9OUzpcbiAgLWgsIC0taGVscCAgICAgICAgICAgICAgICAgICAgICAgICBTaG93IHRoaXMgaGVscCBtZXNzYWdlXG4gIC12LCAtLXZlcmJvc2UgICAgICAgICAgICAgICAgICAgICAgVmVyYm9zZSBvdXRwdXQgKERFQlVHIGxldmVsIGxvZ3MpXG5cbkVYQU1QTEVTOlxuICBhaS1lbmcgaW5pdCAgICAgICAgICAgICAgICAgICAgIyBJbml0aWFsaXplIGNvbmZpZyB3aXRoIGRlZmF1bHRzXG4gIGFpLWVuZyBpbml0IC0taW50ZXJhY3RpdmUgICAgICAgIyBJbnRlcmFjdGl2ZSBjb25maWcgc2V0dXBcbiAgYWktZW5nIFwiaW1wbGVtZW50IHVzZXIgYXV0aGVudGljYXRpb25cIlxuICBhaS1lbmcgcmFscGggXCJmaXggYnVnXCIgLS1wcmludC1sb2dzIC0tbG9nLWxldmVsIERFQlVHXG4gIGFpLWVuZyBpbnN0YWxsIC0tc2NvcGUgcHJvamVjdFxuICBhaS1lbmcgcmFscGggZmVhdHVyZS1zcGVjLnltbCAtLW1heC1pdGVycyA1XG4gIGFpLWVuZyByYWxwaCAtLXR1aSAtLXJlc3VtZVxuICBhaS1lbmcgcmFscGggXCJtYWtlIGZsZWV0dG9vbHMgdXNhYmxlXCIgLS1zaGlwIC0tbWF4LWN5Y2xlcyAzMFxuICBhaS1lbmcgcmFscGggXCJtYWtlIGZsZWV0dG9vbHMgdXNhYmxlXCIgLS1kcmFmdCAtLW1heC1jeWNsZXMgMTAgLS1jaVxuYDtcblxuY29uc3QgSU5JVF9IRUxQX1RFWFQgPSBgXG5haS1lbmcgaW5pdCAtIEluaXRpYWxpemUgLmFpLWVuZy9jb25maWcueWFtbCB3aXRoIGRlZmF1bHRzXG5cblVTQUdFOlxuICBhaS1lbmcgaW5pdCBbb3B0aW9uc11cblxuT1BUSU9OUzpcbiAgLWksIC0taW50ZXJhY3RpdmUgICAgSW50ZXJhY3RpdmUgY29uZmlndXJhdGlvbiBzZXR1cFxuICAtLW92ZXJ3cml0ZSAgICAgICAgICAgT3ZlcndyaXRlIGV4aXN0aW5nIGNvbmZpZyBmaWxlXG4gIC1oLCAtLWhlbHAgICAgICAgICAgU2hvdyB0aGlzIGhlbHAgbWVzc2FnZVxuICAtdiwgLS12ZXJib3NlICAgICAgICAgVmVyYm9zZSBvdXRwdXRcblxuRVhBTVBMRVM6XG4gIGFpLWVuZyBpbml0ICAgICAgICAgICAgICAgICAgICAjIENyZWF0ZSBjb25maWcgd2l0aCBkZWZhdWx0c1xuICBhaS1lbmcgaW5pdCAtLWludGVyYWN0aXZlICAgICAgICMgSW50ZXJhY3RpdmUgc2V0dXAgd2l0aCBwcm9tcHRzXG4gIGFpLWVuZyBpbml0IC0tb3ZlcndyaXRlICAgICAgICAgICMgUmVwbGFjZSBleGlzdGluZyBjb25maWdcbmA7XG5cbmNvbnN0IElOU1RBTExfSEVMUF9URVhUID0gYFxuYWktZW5nIGluc3RhbGwgLSBJbnN0YWxsIE9wZW5Db2RlL0NsYXVkZSBhc3NldHNcblxuVVNBR0U6XG4gIGFpLWVuZyBpbnN0YWxsIFtvcHRpb25zXVxuXG5PUFRJT05TOlxuICAtLXNjb3BlIHByb2plY3R8Z2xvYmFsfGF1dG8gICAgICAgIFdoZXJlIHRvIGluc3RhbGwgKGRlZmF1bHQ6IGF1dG8tZGV0ZWN0KVxuICAtLWRyeS1ydW4gICAgICAgICAgICAgICAgICAgICAgICAgIFNob3cgd2hhdCB3b3VsZCBiZSBkb25lIHdpdGhvdXQgd3JpdGluZ1xuICAtLXllcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNraXAgY29uZmlybWF0aW9uIHByb21wdHNcbiAgLXYsIC0tdmVyYm9zZSAgICAgICAgICAgICAgICAgICAgICBWZXJib3NlIG91dHB1dFxuXG5FWEFNUExFUzpcbiAgYWktZW5nIGluc3RhbGwgICAgICAgICAgICAgICAgICAgICAgICAgICMgQXV0by1kZXRlY3QgcHJvamVjdCB2cyBnbG9iYWxcbiAgYWktZW5nIGluc3RhbGwgLS1zY29wZSBwcm9qZWN0ICAgICAgICAgICMgSW5zdGFsbCB0byBwcm9qZWN0IC5vcGVuY29kZS9cbiAgYWktZW5nIGluc3RhbGwgLS1zY29wZSBnbG9iYWwgICAgICAgICAgICMgSW5zdGFsbCB0byB+Ly5jb25maWcvb3BlbmNvZGUvXG4gIGFpLWVuZyBpbnN0YWxsIC0tZHJ5LXJ1biAgICAgICAgICAgICAgICAjIFByZXZpZXcgb3BlcmF0aW9uc1xuYDtcblxuY29uc3QgUkFMUEhfSEVMUF9URVhUID0gYFxuYWktZW5nIHJhbHBoIC0gSXRlcmF0aW9uIGxvb3AgcnVubmVyIGZvciBhaS1lbmctc3lzdGVtXG5cblVTQUdFOlxuICBhaS1lbmcgcmFscGggPHByb21wdHx3b3JrZmxvdz4gW29wdGlvbnNdXG5cblBPU0lUSU9OQUw6XG4gIHByb21wdC93b3JrZmxvdyAgICBUYXNrIHByb21wdCBvciBwYXRoIHRvIHdvcmtmbG93IHNwZWNpZmljYXRpb25cblxuT1BUSU9OUzpcbiAgLS1tYXgtaXRlcnMgPG4+ICAgICBNYXhpbXVtIGl0ZXJhdGlvbnMgKGRlZmF1bHQ6IGZyb20gY29uZmlnKVxuICAtLWdhdGVzIDxnMSxnMj4gICAgIENvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIHF1YWxpdHkgZ2F0ZXNcbiAgLS1yZXZpZXcgPG1vZGU+ICAgICBSZXZpZXcgbW9kZTogbm9uZXxvcGVuY29kZXxhbnRocm9waWN8Ym90aFxuICAtLXJlc3VtZSAgICAgICAgICAgIFJlc3VtZSBwcmV2aW91cyBydW5cbiAgLS1ydW4taWQgPGlkPiAgICAgICBTcGVjaWZpYyBydW4gSUQgdG8gcmVzdW1lXG4gIC0tZHJ5LXJ1biAgICAgICAgICAgU2hvdyB3aGF0IHdvdWxkIGJlIGRvbmUgd2l0aG91dCBleGVjdXRpbmdcbiAgLS1jaSAgICAgICAgICAgICAgICBSdW4gaW4gQ0kgbW9kZSAobm8gaW50ZXJhY3RpdmUgcHJvbXB0cylcblxuICAtLXByaW50LWxvZ3MgICAgICAgIFByaW50IGRldGFpbGVkIGxvZ3MgdG8gc3RkZXJyXG4gIC0tbG9nLWxldmVsIDxsdmw+ICAgTG9nIGxldmVsOiBERUJVR3xJTkZPfFdBUk58RVJST1IgKGRlZmF1bHQ6IElORk8pXG4gIC12LCAtLXZlcmJvc2UgICAgICAgVmVyYm9zZSBvdXRwdXQgKHNhbWUgYXMgLS1sb2ctbGV2ZWwgREVCVUcpXG4gIC0tdHVpICAgICAgICAgICAgICAgVXNlIFRVSSBtb2RlIGluc3RlYWQgb2YgQ0xJXG4gIC0tbm8tc3RyZWFtICAgICAgICAgRGlzYWJsZSBzdHJlYW1pbmcgb3V0cHV0IChidWZmZXJlZCBtb2RlKVxuXG4gIC0tbm8tbG9vcCAgICAgICAgICAgUnVuIHNpbmdsZSBpdGVyYXRpb24gb25seSAoZGlzYWJsZSBsb29wIG1vZGUpXG4gIC0tY29tcGxldGlvbiA8dG9rPiAgTG9vcCBleGl0IHRva2VuIChyZXF1aXJlZCwgZS5nLiwgLS1jb21wbGV0aW9uIFwiPHByb21pc2U+RE9ORTwvcHJvbWlzZT5cIilcbiAgLS1zaGlwICAgICAgICAgICAgICBBdXRvLWV4aXQgd2hlbiBhZ2VudCBvdXRwdXRzIFwiPHByb21pc2U+U0hJUDwvcHJvbWlzZT5cIlxuICAtLWRyYWZ0ICAgICAgICAgICAgIFJ1biBmb3IgbWF4LWN5Y2xlcyB0aGVuIHN0b3AgZm9yIHlvdXIgcmV2aWV3IChkZWZhdWx0IGJlaGF2aW9yKVxuICAtLW1heC1jeWNsZXMgPG4+ICAgIE1heGltdW0gbG9vcCBjeWNsZXMgKGRlZmF1bHQ6IDUwKVxuICAtLXN0dWNrLXRocmVzaG9sZCA8bj4gQWJvcnQgYWZ0ZXIgTiBjeWNsZXMgd2l0aCBubyBwcm9ncmVzcyAoZGVmYXVsdDogNSlcbiAgLS1jaGVja3BvaW50IDxuPiAgICBTYXZlIGNoZWNrcG9pbnQgZXZlcnkgTiBjeWNsZXMgKGRlZmF1bHQ6IDEpXG4gIC0tZGVidWctd29yayAgICAgICAgUHJpbnQgZXZlcnkgdG9vbCBpbnZvY2F0aW9uIGlucHV0L291dHB1dCB0byBjb25zb2xlIGFuZCBsb2dzXG5cbiAgLS1oZWxwICAgICAgICAgICAgICBTaG93IHRoaXMgaGVscCBtZXNzYWdlXG5cbkVYQU1QTEVTOlxuICBhaS1lbmcgcmFscGggXCJpbXBsZW1lbnQgdXNlciBhdXRoZW50aWNhdGlvblwiXG4gIGFpLWVuZyByYWxwaCBmZWF0dXJlLXNwZWMueW1sIC0tbWF4LWl0ZXJzIDVcbiAgYWktZW5nIHJhbHBoIFwiZml4IHRoZSBidWdcIiAtLXByaW50LWxvZ3MgLS1sb2ctbGV2ZWwgREVCVUdcbiAgYWktZW5nIHJhbHBoIC0tdHVpIC0tcmVzdW1lXG4gIGFpLWVuZyByYWxwaCBcIm1ha2UgZmxlZXR0b29scyB1c2FibGVcIiAtLXNoaXAgLS1tYXgtY3ljbGVzIDMwXG4gIGFpLWVuZyByYWxwaCBcIm1ha2UgZmxlZXR0b29scyB1c2FibGVcIiAtLWRyYWZ0IC0tbWF4LWN5Y2xlcyAxMCAtLWNpXG4gIGFpLWVuZyByYWxwaCAtLW5vLWxvb3AgXCJzaW5nbGUtc2hvdCB0YXNrXCJcbmA7XG5cbmludGVyZmFjZSBJbnN0YWxsRmxhZ3Mge1xuICAgIHNjb3BlPzogXCJwcm9qZWN0XCIgfCBcImdsb2JhbFwiIHwgXCJhdXRvXCI7XG4gICAgZHJ5UnVuPzogYm9vbGVhbjtcbiAgICB5ZXM/OiBib29sZWFuO1xuICAgIHZlcmJvc2U/OiBib29sZWFuO1xuICAgIGhlbHA/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgSW5pdEZsYWdzIHtcbiAgICBpbnRlcmFjdGl2ZT86IGJvb2xlYW47XG4gICAgb3ZlcndyaXRlPzogYm9vbGVhbjtcbiAgICBoZWxwPzogYm9vbGVhbjtcbiAgICB2ZXJib3NlPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBIYW5kbGUgdGhlICdpbml0JyBzdWJjb21tYW5kXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJ1bkluaXQoYXJnczogc3RyaW5nW10pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCB7IHZhbHVlcywgcG9zaXRpb25hbHMgfSA9IHBhcnNlQXJncyh7XG4gICAgICAgIGFyZ3MsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGludGVyYWN0aXZlOiB7IHR5cGU6IFwiYm9vbGVhblwiLCBzaG9ydDogXCJpXCIgfSxcbiAgICAgICAgICAgIG92ZXJ3cml0ZTogeyB0eXBlOiBcImJvb2xlYW5cIiB9LFxuICAgICAgICAgICAgaGVscDogeyB0eXBlOiBcImJvb2xlYW5cIiB9LFxuICAgICAgICAgICAgdmVyYm9zZTogeyB0eXBlOiBcImJvb2xlYW5cIiwgc2hvcnQ6IFwidlwiIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGFsbG93UG9zaXRpb25hbHM6IHRydWUsXG4gICAgfSk7XG5cbiAgICBjb25zdCBmbGFnczogSW5pdEZsYWdzID0ge1xuICAgICAgICBpbnRlcmFjdGl2ZTogdmFsdWVzLmludGVyYWN0aXZlLFxuICAgICAgICBvdmVyd3JpdGU6IHZhbHVlcy5vdmVyd3JpdGUsXG4gICAgICAgIGhlbHA6IHZhbHVlcy5oZWxwLFxuICAgICAgICB2ZXJib3NlOiB2YWx1ZXMudmVyYm9zZSxcbiAgICB9O1xuXG4gICAgaWYgKGZsYWdzLmhlbHApIHtcbiAgICAgICAgY29uc29sZS5sb2coSU5JVF9IRUxQX1RFWFQpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYXdhaXQgTG9nLmluaXQoe1xuICAgICAgICBwcmludDogZmFsc2UsXG4gICAgICAgIGxldmVsOiBmbGFncy52ZXJib3NlID8gXCJERUJVR1wiIDogXCJJTkZPXCIsXG4gICAgICAgIGxvZ0RpcjogXCIuYWktZW5nL2xvZ3NcIixcbiAgICB9KTtcblxuICAgIGNvbnN0IHsgaW5pdENvbmZpZyB9ID0gYXdhaXQgaW1wb3J0KFwiLi4vaW5zdGFsbC9pbml0XCIpO1xuICAgIGF3YWl0IGluaXRDb25maWcoZmxhZ3MpO1xufVxuXG4vKipcbiAqIEhhbmRsZSB0aGUgJ2luc3RhbGwnIHN1YmNvbW1hbmRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcnVuSW5zdGFsbChhcmdzOiBzdHJpbmdbXSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHsgdmFsdWVzLCBwb3NpdGlvbmFscyB9ID0gcGFyc2VBcmdzKHtcbiAgICAgICAgYXJncyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgc2NvcGU6IHsgdHlwZTogXCJzdHJpbmdcIiB9LFxuICAgICAgICAgICAgXCJkcnktcnVuXCI6IHsgdHlwZTogXCJib29sZWFuXCIgfSxcbiAgICAgICAgICAgIHllczogeyB0eXBlOiBcImJvb2xlYW5cIiB9LFxuICAgICAgICAgICAgdmVyYm9zZTogeyB0eXBlOiBcImJvb2xlYW5cIiwgc2hvcnQ6IFwidlwiIH0sXG4gICAgICAgICAgICBoZWxwOiB7IHR5cGU6IFwiYm9vbGVhblwiIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGFsbG93UG9zaXRpb25hbHM6IHRydWUsXG4gICAgfSk7XG5cbiAgICBjb25zdCBmbGFnczogSW5zdGFsbEZsYWdzID0ge1xuICAgICAgICBzY29wZTogdmFsdWVzLnNjb3BlIGFzIEluc3RhbGxGbGFnc1tcInNjb3BlXCJdLFxuICAgICAgICBkcnlSdW46IHZhbHVlc1tcImRyeS1ydW5cIl0sXG4gICAgICAgIHllczogdmFsdWVzLnllcyxcbiAgICAgICAgdmVyYm9zZTogdmFsdWVzLnZlcmJvc2UsXG4gICAgICAgIGhlbHA6IHZhbHVlcy5oZWxwLFxuICAgIH07XG5cbiAgICBpZiAoZmxhZ3MuaGVscCkge1xuICAgICAgICBjb25zb2xlLmxvZyhJTlNUQUxMX0hFTFBfVEVYVCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBEeW5hbWljIGltcG9ydCB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXMgYW5kIHRvIGFsbG93IGluc3RhbGwgbG9naWMgdG8gYmUgb3B0aW9uYWxcbiAgICBjb25zdCB7IHJ1bkluc3RhbGxlciB9ID0gYXdhaXQgaW1wb3J0KFwiLi4vaW5zdGFsbC9pbnN0YWxsXCIpO1xuICAgIGF3YWl0IHJ1bkluc3RhbGxlcihmbGFncyk7XG59XG5cbi8qKlxuICogUGFyc2UgUmFscGggZmxhZ3MgZnJvbSByYXcgYXJndlxuICovXG5mdW5jdGlvbiBwYXJzZVJhbHBoRmxhZ3MoYXJnczogc3RyaW5nW10pOiB7XG4gICAgZmxhZ3M6IFJhbHBoRmxhZ3M7XG4gICAgcmVtYWluaW5nOiBzdHJpbmdbXTtcbn0ge1xuICAgIGNvbnN0IHsgdmFsdWVzLCBwb3NpdGlvbmFscyB9ID0gcGFyc2VBcmdzKHtcbiAgICAgICAgYXJncyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgXCJtYXgtaXRlcnNcIjogeyB0eXBlOiBcInN0cmluZ1wiIH0sXG4gICAgICAgICAgICBnYXRlczogeyB0eXBlOiBcInN0cmluZ1wiIH0sXG4gICAgICAgICAgICByZXZpZXc6IHsgdHlwZTogXCJzdHJpbmdcIiB9LFxuICAgICAgICAgICAgcmVzdW1lOiB7IHR5cGU6IFwiYm9vbGVhblwiIH0sXG4gICAgICAgICAgICBcInJ1bi1pZFwiOiB7IHR5cGU6IFwic3RyaW5nXCIgfSxcbiAgICAgICAgICAgIFwiZHJ5LXJ1blwiOiB7IHR5cGU6IFwiYm9vbGVhblwiIH0sXG4gICAgICAgICAgICBjaTogeyB0eXBlOiBcImJvb2xlYW5cIiB9LFxuICAgICAgICAgICAgaGVscDogeyB0eXBlOiBcImJvb2xlYW5cIiB9LFxuICAgICAgICAgICAgXCJwcmludC1sb2dzXCI6IHsgdHlwZTogXCJib29sZWFuXCIgfSxcbiAgICAgICAgICAgIFwibG9nLWxldmVsXCI6IHsgdHlwZTogXCJzdHJpbmdcIiB9LFxuICAgICAgICAgICAgdmVyYm9zZTogeyB0eXBlOiBcImJvb2xlYW5cIiwgc2hvcnQ6IFwidlwiIH0sXG4gICAgICAgICAgICB0dWk6IHsgdHlwZTogXCJib29sZWFuXCIgfSxcbiAgICAgICAgICAgIFwibm8tc3RyZWFtXCI6IHsgdHlwZTogXCJib29sZWFuXCIgfSxcbiAgICAgICAgICAgIFwibm8tbG9vcFwiOiB7IHR5cGU6IFwiYm9vbGVhblwiIH0sXG4gICAgICAgICAgICBjb21wbGV0aW9uOiB7IHR5cGU6IFwic3RyaW5nXCIgfSxcbiAgICAgICAgICAgIHNoaXA6IHsgdHlwZTogXCJib29sZWFuXCIgfSxcbiAgICAgICAgICAgIGRyYWZ0OiB7IHR5cGU6IFwiYm9vbGVhblwiIH0sXG4gICAgICAgICAgICBcIm1heC1jeWNsZXNcIjogeyB0eXBlOiBcInN0cmluZ1wiIH0sXG4gICAgICAgICAgICBcInN0dWNrLXRocmVzaG9sZFwiOiB7IHR5cGU6IFwic3RyaW5nXCIgfSxcbiAgICAgICAgICAgIGNoZWNrcG9pbnQ6IHsgdHlwZTogXCJzdHJpbmdcIiB9LFxuICAgICAgICAgICAgXCJkZWJ1Zy13b3JrXCI6IHsgdHlwZTogXCJib29sZWFuXCIgfSxcbiAgICAgICAgfSxcbiAgICAgICAgYWxsb3dQb3NpdGlvbmFsczogdHJ1ZSxcbiAgICB9KTtcblxuICAgIGNvbnN0IGZsYWdzOiBSYWxwaEZsYWdzID0ge1xuICAgICAgICB3b3JrZmxvdzogcG9zaXRpb25hbHNbMF0sXG4gICAgICAgIG1heEl0ZXJzOiB2YWx1ZXNbXCJtYXgtaXRlcnNcIl1cbiAgICAgICAgICAgID8gTnVtYmVyLnBhcnNlSW50KHZhbHVlc1tcIm1heC1pdGVyc1wiXSlcbiAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICBnYXRlczogdmFsdWVzLmdhdGVzXG4gICAgICAgICAgICA/IHZhbHVlcy5nYXRlcy5zcGxpdChcIixcIikubWFwKChnKSA9PiBnLnRyaW0oKSlcbiAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICByZXZpZXc6IHZhbHVlcy5yZXZpZXcgYXMgUmFscGhGbGFnc1tcInJldmlld1wiXSxcbiAgICAgICAgcmVzdW1lOiB2YWx1ZXMucmVzdW1lLFxuICAgICAgICBydW5JZDogdmFsdWVzW1wicnVuLWlkXCJdLFxuICAgICAgICBkcnlSdW46IHZhbHVlc1tcImRyeS1ydW5cIl0sXG4gICAgICAgIGNpOiB2YWx1ZXMuY2ksXG4gICAgICAgIGhlbHA6IHZhbHVlcy5oZWxwLFxuICAgICAgICBwcmludExvZ3M6IHZhbHVlc1tcInByaW50LWxvZ3NcIl0sXG4gICAgICAgIGxvZ0xldmVsOlxuICAgICAgICAgICAgKHZhbHVlc1tcImxvZy1sZXZlbFwiXSBhcyBMb2dMZXZlbCkgPz9cbiAgICAgICAgICAgICh2YWx1ZXMudmVyYm9zZSA/IFwiREVCVUdcIiA6IHVuZGVmaW5lZCksXG4gICAgICAgIHZlcmJvc2U6IHZhbHVlcy52ZXJib3NlLFxuICAgICAgICB0dWk6IHZhbHVlcy50dWksXG4gICAgICAgIG5vU3RyZWFtOiB2YWx1ZXNbXCJuby1zdHJlYW1cIl0sXG4gICAgICAgIGxvb3A6ICF2YWx1ZXNbXCJuby1sb29wXCJdLFxuICAgICAgICBub0xvb3A6IHZhbHVlc1tcIm5vLWxvb3BcIl0sXG4gICAgICAgIGNvbXBsZXRpb25Qcm9taXNlOiB2YWx1ZXMuY29tcGxldGlvbixcbiAgICAgICAgc2hpcDogdmFsdWVzLnNoaXAsXG4gICAgICAgIGRyYWZ0OiB2YWx1ZXMuZHJhZnQsXG4gICAgICAgIG1heEN5Y2xlczogdmFsdWVzW1wibWF4LWN5Y2xlc1wiXVxuICAgICAgICAgICAgPyBOdW1iZXIucGFyc2VJbnQodmFsdWVzW1wibWF4LWN5Y2xlc1wiXSlcbiAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICBzdHVja1RocmVzaG9sZDogdmFsdWVzW1wic3R1Y2stdGhyZXNob2xkXCJdXG4gICAgICAgICAgICA/IE51bWJlci5wYXJzZUludCh2YWx1ZXNbXCJzdHVjay10aHJlc2hvbGRcIl0pXG4gICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgY2hlY2twb2ludEZyZXF1ZW5jeTogdmFsdWVzLmNoZWNrcG9pbnRcbiAgICAgICAgICAgID8gTnVtYmVyLnBhcnNlSW50KHZhbHVlcy5jaGVja3BvaW50KVxuICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIGRlYnVnV29yazogdmFsdWVzW1wiZGVidWctd29ya1wiXSxcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJuIHRoZSBmbGFncyBwbHVzIHRoZSByZW1haW5pbmcgcG9zaXRpb25hbHMgKGZvciBmdXR1cmUgZXh0ZW5zaWJpbGl0eSlcbiAgICByZXR1cm4geyBmbGFncywgcmVtYWluaW5nOiBwb3NpdGlvbmFscy5zbGljZSgxKSB9O1xufVxuXG4vKipcbiAqIFJ1biB0aGUgUmFscGggQ0xJXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJ1blJhbHBoKGFyZ3M6IHN0cmluZ1tdKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgeyBmbGFncyB9ID0gcGFyc2VSYWxwaEZsYWdzKGFyZ3MpO1xuXG4gICAgLy8gU2hvdyBoZWxwXG4gICAgaWYgKGZsYWdzLmhlbHApIHtcbiAgICAgICAgY29uc29sZS5sb2coUkFMUEhfSEVMUF9URVhUKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgbG9nZ2luZ1xuICAgIGF3YWl0IExvZy5pbml0KHtcbiAgICAgICAgcHJpbnQ6IGZsYWdzLnByaW50TG9ncyA/PyBmYWxzZSxcbiAgICAgICAgbGV2ZWw6IGZsYWdzLmxvZ0xldmVsID8/IFwiSU5GT1wiLFxuICAgICAgICBsb2dEaXI6IFwiLmFpLWVuZy9sb2dzXCIsXG4gICAgfSk7XG5cbiAgICBMb2cuRGVmYXVsdC5pbmZvKFwiYWktZW5nIHJhbHBoIHN0YXJ0aW5nXCIsIHtcbiAgICAgICAgZmxhZ3M6IEpTT04uc3RyaW5naWZ5KGZsYWdzKSxcbiAgICB9KTtcblxuICAgIC8vIExvYWQgY29uZmlnXG4gICAgY29uc3QgY29uZmlnID0gYXdhaXQgbG9hZENvbmZpZyhmbGFncyk7XG5cbiAgICAvLyBUVUkgbW9kZSByZXF1aXJlcyBkeW5hbWljIGltcG9ydCAtIGZvciBub3csIHNob3cgaW5mbyBhbmQgZmFsbCBiYWNrIHRvIENMSVxuICAgIGlmIChmbGFncy50dWkpIHtcbiAgICAgICAgVUkuaW5mbyhcIlRVSSBtb2RlIHJlcXVlc3RlZCAtIGZhbGxpbmcgYmFjayB0byBDTEkgbW9kZVwiKTtcbiAgICAgICAgVUkuaW5mbyhcIihUVUkgcmVxdWlyZXM6IGJ1biBydW4gLS13YXRjaCBvciBmdWxsIFRVSSBzZXR1cClcIik7XG4gICAgfVxuICAgIGF3YWl0IHJ1bkNsaShjb25maWcsIGZsYWdzKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gbWFpbigpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBHZXQgcmF3IGFyZ3MgKGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIHByb2dyYW0gbmFtZSlcbiAgICAgICAgY29uc3QgcmF3QXJncyA9IHByb2Nlc3MuYXJndi5zbGljZSgyKTtcblxuICAgICAgICAvLyBIYW5kbGUgbm8gYXJndW1lbnRzXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHJhd0FyZ3MubGVuZ3RoID09PSAwIHx8XG4gICAgICAgICAgICByYXdBcmdzWzBdID09PSBcIi0taGVscFwiIHx8XG4gICAgICAgICAgICByYXdBcmdzWzBdID09PSBcIi1oXCJcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhUT1BfSEVMUF9URVhUKTtcbiAgICAgICAgICAgIHByb2Nlc3MuZXhpdCgwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN1YmNvbW1hbmQgPSByYXdBcmdzWzBdO1xuICAgICAgICBjb25zdCBzdWJjb21tYW5kQXJncyA9IHJhd0FyZ3Muc2xpY2UoMSk7XG5cbiAgICAgICAgLy8gUm91dGUgdG8gc3ViY29tbWFuZFxuICAgICAgICBzd2l0Y2ggKHN1YmNvbW1hbmQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJpbml0XCI6XG4gICAgICAgICAgICAgICAgYXdhaXQgcnVuSW5pdChzdWJjb21tYW5kQXJncyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJpbnN0YWxsXCI6XG4gICAgICAgICAgICBjYXNlIFwiaVwiOlxuICAgICAgICAgICAgICAgIGF3YWl0IHJ1bkluc3RhbGwoc3ViY29tbWFuZEFyZ3MpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwicmFscGhcIjpcbiAgICAgICAgICAgIGNhc2UgXCJyXCI6XG4gICAgICAgICAgICAgICAgYXdhaXQgcnVuUmFscGgoc3ViY29tbWFuZEFyZ3MpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiLS1oZWxwXCI6XG4gICAgICAgICAgICBjYXNlIFwiLWhcIjpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhUT1BfSEVMUF9URVhUKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IHRvIHJhbHBoOiB0cmVhdCB0aGUgc3ViY29tbWFuZCBhcyB0aGUgcHJvbXB0L3dvcmtmbG93XG4gICAgICAgICAgICAgICAgLy8gYW5kIHBhc3MgdGhlIGVudGlyZSBvcmlnaW5hbCBhcmdzIHRvIHJhbHBoXG4gICAgICAgICAgICAgICAgYXdhaXQgcnVuUmFscGgocmF3QXJncyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBVSS5lcnJvcihlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcikpO1xuICAgICAgICBwcm9jZXNzLmV4aXQoMSk7XG4gICAgfVxufVxuXG4vLyBFeHBvcnQgbWFpbiBmb3IgdXNlIGFzIGEgbW9kdWxlXG5leHBvcnQgeyBtYWluIGFzIHJ1bk1haW4gfTtcblxuLy8gTm90ZTogVGhlIENMSSBzaGltIChkaXN0L2NsaS9ydW4uanMpIGhhbmRsZXMgZGlyZWN0IGV4ZWN1dGlvbi5cbi8vIFRoaXMgZmlsZSBzaG91bGQgb25seSBiZSBydW4gdmlhIGltcG9ydCBmcm9tIHRoZSBzaGltLlxuIiwKICAgICIvKipcbiAqIENvbmZpZ3VyYXRpb24gTG9hZGVyIGZvciBhaS1lbmcgcmFscGhcbiAqL1xuXG5pbXBvcnQgeyByZWFkRmlsZSB9IGZyb20gXCJub2RlOmZzL3Byb21pc2VzXCI7XG5pbXBvcnQgeyBqb2luIH0gZnJvbSBcIm5vZGU6cGF0aFwiO1xuaW1wb3J0IHsgZmlsZVVSTFRvUGF0aCB9IGZyb20gXCJub2RlOnVybFwiO1xuaW1wb3J0IFlBTUwgZnJvbSBcInlhbWxcIjtcbmltcG9ydCB0eXBlIHsgUmFscGhGbGFncyB9IGZyb20gXCIuLi9jbGkvZmxhZ3NcIjtcbmltcG9ydCB0eXBlIHsgQWlFbmdDb25maWcsIERFRkFVTFRfQ09ORklHIH0gZnJvbSBcIi4vc2NoZW1hXCI7XG5pbXBvcnQgeyBERUZBVUxUX0NPTkZJRyBhcyBIQVJEQ09ERURfREVGQVVMVFMgfSBmcm9tIFwiLi9zY2hlbWFcIjtcblxuLy8gVXNlIGN1cnJlbnQgd29ya2luZyBkaXJlY3Rvcnkgd2hlcmUgY29tbWFuZCBpcyBjYWxsZWQgZnJvbVxuLy8gVGhpcyBlbnN1cmVzIC5haS1lbmcvY29uZmlnLnlhbWwgaXMgbG9hZGVkIGZyb20gdXNlcidzIHByb2plY3QgZGlyZWN0b3J5XG5jb25zdCBST09UID0gcHJvY2Vzcy5lbnYuVEVTVF9ST09UID8/IHByb2Nlc3MuY3dkKCk7XG5cbi8qKlxuICogRW52aXJvbm1lbnQgdmFyaWFibGUgdG8gY29uZmlnIGtleSBtYXBwaW5nXG4gKi9cbmNvbnN0IEVOVl9WQVJfTUFQUElORzogUmVjb3JkPHN0cmluZywga2V5b2YgQWlFbmdDb25maWc+ID0ge1xuICAgIC8vIE9wZW5Db2RlXG4gICAgT1BFTkNPREVfVVJMOiBcIm9wZW5jb2RlXCIsXG4gICAgT1BFTkNPREVfRElSRUNUT1JZOiBcIm9wZW5jb2RlXCIsXG4gICAgT1BFTkNPREVfUFJPTVBUX1RJTUVPVVRfTVM6IFwib3BlbmNvZGVcIixcbiAgICAvLyBEaXNjb3JkIChub24tc2VjcmV0KVxuICAgIERJU0NPUkRfQk9UX1VTRVJOQU1FOiBcIm5vdGlmaWNhdGlvbnNcIixcbiAgICBESVNDT1JEX0JPVF9BVkFUQVJfVVJMOiBcIm5vdGlmaWNhdGlvbnNcIixcbiAgICAvLyBVSVxuICAgIEFJX0VOR19TSUxFTlQ6IFwidWlcIixcbiAgICAvLyBMb29wXG4gICAgQUlfRU5HX0NZQ0xFX1JFVFJJRVM6IFwibG9vcFwiLFxuICAgIC8vIERlYnVnXG4gICAgQUlfRU5HX0RFQlVHX1dPUks6IFwiZGVidWdcIixcbiAgICAvLyBHYXRlcyAoY29tbWFuZHMpXG4gICAgQUlfRU5HX1RFU1RfQ01EOiBcImdhdGVzXCIsXG4gICAgQUlfRU5HX0xJTlRfQ01EOiBcImdhdGVzXCIsXG4gICAgQUlfRU5HX0FDQ0VQVEFOQ0VfQ01EOiBcImdhdGVzXCIsXG4gICAgQUlfRU5HX1RZUEVDSEVDS19DTUQ6IFwiZ2F0ZXNcIixcbiAgICBBSV9FTkdfQlVJTERfQ01EOiBcImdhdGVzXCIsXG59O1xuXG4vKipcbiAqIEdldCBuZXN0ZWQgdmFsdWUgZnJvbSBvYmplY3QgdXNpbmcgZG90IG5vdGF0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldE5lc3RlZFZhbHVlKG9iajogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sIHBhdGg6IHN0cmluZyk6IHVua25vd24ge1xuICAgIHJldHVybiBwYXRoLnNwbGl0KFwiLlwiKS5yZWR1Y2U8dW5rbm93bj4oKGN1cnJlbnQsIGtleSkgPT4ge1xuICAgICAgICBpZiAoY3VycmVudCAmJiB0eXBlb2YgY3VycmVudCA9PT0gXCJvYmplY3RcIiAmJiBrZXkgaW4gY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIChjdXJyZW50IGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSwgb2JqKTtcbn1cblxuLyoqXG4gKiBTZXQgbmVzdGVkIHZhbHVlIGluIG9iamVjdCB1c2luZyBkb3Qgbm90YXRpb25cbiAqL1xuZnVuY3Rpb24gc2V0TmVzdGVkVmFsdWUoXG4gICAgb2JqOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPixcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgdmFsdWU6IHVua25vd24sXG4pOiB2b2lkIHtcbiAgICBjb25zdCBrZXlzID0gcGF0aC5zcGxpdChcIi5cIik7XG4gICAgY29uc3QgbGFzdEtleSA9IGtleXMucG9wKCkhO1xuICAgIGNvbnN0IHRhcmdldCA9IGtleXMucmVkdWNlPFJlY29yZDxzdHJpbmcsIHVua25vd24+PigoY3VycmVudCwga2V5KSA9PiB7XG4gICAgICAgIGlmICghY3VycmVudFtrZXldIHx8IHR5cGVvZiBjdXJyZW50W2tleV0gIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGN1cnJlbnRba2V5XSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyZW50W2tleV0gYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gICAgfSwgb2JqKTtcbiAgICB0YXJnZXRbbGFzdEtleV0gPSB2YWx1ZTtcbn1cblxuLyoqXG4gKiBBcHBseSBlbnZpcm9ubWVudCB2YXJpYWJsZSBvdmVycmlkZXMgdG8gY29uZmlnXG4gKi9cbmZ1bmN0aW9uIGFwcGx5RW52T3ZlcnJpZGVzKGNvbmZpZzogQWlFbmdDb25maWcpOiB2b2lkIHtcbiAgICAvLyBPcGVuQ29kZSBvdmVycmlkZXNcbiAgICBpZiAocHJvY2Vzcy5lbnYuT1BFTkNPREVfVVJMKSB7XG4gICAgICAgIGNvbmZpZy5vcGVuY29kZS5zZXJ2ZXJVcmwgPSBwcm9jZXNzLmVudi5PUEVOQ09ERV9VUkw7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5PUEVOQ09ERV9ESVJFQ1RPUlkpIHtcbiAgICAgICAgY29uZmlnLm9wZW5jb2RlLmRpcmVjdG9yeSA9IHByb2Nlc3MuZW52Lk9QRU5DT0RFX0RJUkVDVE9SWTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk9QRU5DT0RFX1BST01QVF9USU1FT1VUX01TKSB7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSBOdW1iZXIucGFyc2VJbnQoXG4gICAgICAgICAgICBwcm9jZXNzLmVudi5PUEVOQ09ERV9QUk9NUFRfVElNRU9VVF9NUyxcbiAgICAgICAgICAgIDEwLFxuICAgICAgICApO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKHRpbWVvdXQpKSB7XG4gICAgICAgICAgICBjb25maWcub3BlbmNvZGUucHJvbXB0VGltZW91dE1zID0gdGltZW91dDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIERpc2NvcmQgb3ZlcnJpZGVzIChub24tc2VjcmV0KVxuICAgIGlmIChwcm9jZXNzLmVudi5ESVNDT1JEX0JPVF9VU0VSTkFNRSkge1xuICAgICAgICBjb25maWcubm90aWZpY2F0aW9ucy5kaXNjb3JkLnVzZXJuYW1lID1cbiAgICAgICAgICAgIHByb2Nlc3MuZW52LkRJU0NPUkRfQk9UX1VTRVJOQU1FO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuRElTQ09SRF9CT1RfQVZBVEFSX1VSTCkge1xuICAgICAgICBjb25maWcubm90aWZpY2F0aW9ucy5kaXNjb3JkLmF2YXRhclVybCA9XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5ESVNDT1JEX0JPVF9BVkFUQVJfVVJMO1xuICAgIH1cblxuICAgIC8vIFVJIG92ZXJyaWRlXG4gICAgaWYgKHByb2Nlc3MuZW52LkFJX0VOR19TSUxFTlQpIHtcbiAgICAgICAgY29uZmlnLnVpLnNpbGVudCA9XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5BSV9FTkdfU0lMRU5UID09PSBcIjFcIiB8fFxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuQUlfRU5HX1NJTEVOVCA9PT0gXCJ0cnVlXCI7XG4gICAgfVxuXG4gICAgLy8gTG9vcCBvdmVycmlkZXNcbiAgICBpZiAocHJvY2Vzcy5lbnYuQUlfRU5HX0NZQ0xFX1JFVFJJRVMpIHtcbiAgICAgICAgY29uc3QgcmV0cmllcyA9IE51bWJlci5wYXJzZUludChwcm9jZXNzLmVudi5BSV9FTkdfQ1lDTEVfUkVUUklFUywgMTApO1xuICAgICAgICBpZiAoIU51bWJlci5pc05hTihyZXRyaWVzKSkge1xuICAgICAgICAgICAgY29uZmlnLmxvb3AuY3ljbGVSZXRyaWVzID0gcmV0cmllcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlYnVnIG92ZXJyaWRlc1xuICAgIGlmIChwcm9jZXNzLmVudi5BSV9FTkdfREVCVUdfV09SSykge1xuICAgICAgICBjb25maWcuZGVidWcud29yayA9XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5BSV9FTkdfREVCVUdfV09SSyA9PT0gXCIxXCIgfHxcbiAgICAgICAgICAgIHByb2Nlc3MuZW52LkFJX0VOR19ERUJVR19XT1JLID09PSBcInRydWVcIjtcbiAgICB9XG5cbiAgICAvLyBHYXRlIGNvbW1hbmQgb3ZlcnJpZGVzXG4gICAgaWYgKHByb2Nlc3MuZW52LkFJX0VOR19URVNUX0NNRCkge1xuICAgICAgICBjb25maWcuZ2F0ZXMudGVzdC5jb21tYW5kID0gcHJvY2Vzcy5lbnYuQUlfRU5HX1RFU1RfQ01EO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuQUlfRU5HX0xJTlRfQ01EKSB7XG4gICAgICAgIGNvbmZpZy5nYXRlcy5saW50LmNvbW1hbmQgPSBwcm9jZXNzLmVudi5BSV9FTkdfTElOVF9DTUQ7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5BSV9FTkdfQUNDRVBUQU5DRV9DTUQpIHtcbiAgICAgICAgY29uZmlnLmdhdGVzLmFjY2VwdGFuY2UuY29tbWFuZCA9IHByb2Nlc3MuZW52LkFJX0VOR19BQ0NFUFRBTkNFX0NNRDtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52LkFJX0VOR19UWVBFQ0hFQ0tfQ01EKSB7XG4gICAgICAgIGNvbmZpZy5nYXRlcy50eXBlY2hlY2suY29tbWFuZCA9IHByb2Nlc3MuZW52LkFJX0VOR19UWVBFQ0hFQ0tfQ01EO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuQUlfRU5HX0JVSUxEX0NNRCkge1xuICAgICAgICBjb25maWcuZ2F0ZXMuYnVpbGQuY29tbWFuZCA9IHByb2Nlc3MuZW52LkFJX0VOR19CVUlMRF9DTUQ7XG4gICAgfVxufVxuXG4vKipcbiAqIERlZXAgbWVyZ2UgdHdvIG9iamVjdHMgKHRhcmdldCA8LSBzb3VyY2UpXG4gKi9cbmZ1bmN0aW9uIGRlZXBNZXJnZTxUIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4+KFxuICAgIHRhcmdldDogVCxcbiAgICBzb3VyY2U6IFBhcnRpYWw8VD4sXG4pOiBUIHtcbiAgICBjb25zdCByZXN1bHQgPSB7IC4uLnRhcmdldCB9IGFzIFQ7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc291cmNlKSBhcyBBcnJheTxrZXlvZiBUPikge1xuICAgICAgICBjb25zdCBzb3VyY2VWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgICAgICBjb25zdCB0YXJnZXRWYWx1ZSA9IHRhcmdldFtrZXldO1xuXG4gICAgICAgIGlmIChzb3VyY2VWYWx1ZSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICBzb3VyY2VWYWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHNvdXJjZVZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAhQXJyYXkuaXNBcnJheShzb3VyY2VWYWx1ZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgdGFyZ2V0VmFsdWUgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgdGFyZ2V0VmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheSh0YXJnZXRWYWx1ZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBkZWVwTWVyZ2UoXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFZhbHVlIGFzIGFueSxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlVmFsdWUgYXMgYW55LFxuICAgICAgICAgICAgICAgICkgYXMgYW55O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHNvdXJjZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2VWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIE1lcmdlIGdhdGUgY29tbWFuZCBjb25maWdzIChoYW5kbGUgbGVnYWN5IHN0cmluZyBmb3JtYXQpXG4gKi9cbmZ1bmN0aW9uIG1lcmdlR2F0ZUNvbmZpZyhcbiAgICBleGlzdGluZzogeyBjb21tYW5kOiBzdHJpbmcgfSxcbiAgICBpbmNvbWluZzogc3RyaW5nIHwgeyBjb21tYW5kPzogc3RyaW5nIH0sXG4pOiB7IGNvbW1hbmQ6IHN0cmluZyB9IHtcbiAgICBpZiAodHlwZW9mIGluY29taW5nID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB7IGNvbW1hbmQ6IGluY29taW5nIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNvbW1hbmQ6IGluY29taW5nLmNvbW1hbmQgPz8gZXhpc3RpbmcuY29tbWFuZCxcbiAgICB9O1xufVxuXG4vKipcbiAqIExvYWQgY29uZmlndXJhdGlvbiBmcm9tIC5haS1lbmcvY29uZmlnLnlhbWxcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRDb25maWcoZmxhZ3M6IFJhbHBoRmxhZ3MpOiBQcm9taXNlPEFpRW5nQ29uZmlnPiB7XG4gICAgLy8gU3RhcnQgd2l0aCBkZWZhdWx0IGNvbmZpZ1xuICAgIGNvbnN0IGNvbmZpZzogQWlFbmdDb25maWcgPSB7XG4gICAgICAgIHZlcnNpb246IEhBUkRDT0RFRF9ERUZBVUxUUy52ZXJzaW9uLFxuICAgICAgICBydW5uZXI6IHsgLi4uSEFSRENPREVEX0RFRkFVTFRTLnJ1bm5lciB9LFxuICAgICAgICBsb29wOiB7IC4uLkhBUkRDT0RFRF9ERUZBVUxUUy5sb29wIH0sXG4gICAgICAgIGRlYnVnOiB7IC4uLkhBUkRDT0RFRF9ERUZBVUxUUy5kZWJ1ZyB9LFxuICAgICAgICBvcGVuY29kZTogeyAuLi5IQVJEQ09ERURfREVGQVVMVFMub3BlbmNvZGUgfSxcbiAgICAgICAgYW50aHJvcGljOiB7IC4uLkhBUkRDT0RFRF9ERUZBVUxUUy5hbnRocm9waWMgfSxcbiAgICAgICAgZ2F0ZXM6IHtcbiAgICAgICAgICAgIGxpbnQ6IHsgLi4uSEFSRENPREVEX0RFRkFVTFRTLmdhdGVzLmxpbnQgfSxcbiAgICAgICAgICAgIHR5cGVjaGVjazogeyAuLi5IQVJEQ09ERURfREVGQVVMVFMuZ2F0ZXMudHlwZWNoZWNrIH0sXG4gICAgICAgICAgICB0ZXN0OiB7IC4uLkhBUkRDT0RFRF9ERUZBVUxUUy5nYXRlcy50ZXN0IH0sXG4gICAgICAgICAgICBidWlsZDogeyAuLi5IQVJEQ09ERURfREVGQVVMVFMuZ2F0ZXMuYnVpbGQgfSxcbiAgICAgICAgICAgIGFjY2VwdGFuY2U6IHsgLi4uSEFSRENPREVEX0RFRkFVTFRTLmdhdGVzLmFjY2VwdGFuY2UgfSxcbiAgICAgICAgfSxcbiAgICAgICAgbW9kZWxzOiB7IC4uLkhBUkRDT0RFRF9ERUZBVUxUUy5tb2RlbHMgfSxcbiAgICAgICAgbm90aWZpY2F0aW9uczoge1xuICAgICAgICAgICAgZGlzY29yZDogeyAuLi5IQVJEQ09ERURfREVGQVVMVFMubm90aWZpY2F0aW9ucy5kaXNjb3JkIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHVpOiB7IC4uLkhBUkRDT0RFRF9ERUZBVUxUUy51aSB9LFxuICAgIH07XG5cbiAgICAvLyBUcnkgdG8gbG9hZCBmcm9tIGNvbmZpZyBmaWxlXG4gICAgY29uc3QgY29uZmlnUGF0aCA9IGpvaW4oUk9PVCwgXCIuYWktZW5nXCIsIFwiY29uZmlnLnlhbWxcIik7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY29uZmlnQ29udGVudCA9IGF3YWl0IHJlYWRGaWxlKGNvbmZpZ1BhdGgsIFwidXRmLThcIik7XG4gICAgICAgIGNvbnN0IHVzZXJDb25maWcgPSBZQU1MLnBhcnNlKGNvbmZpZ0NvbnRlbnQpO1xuXG4gICAgICAgIGlmICh1c2VyQ29uZmlnLnZlcnNpb24pIHtcbiAgICAgICAgICAgIGNvbmZpZy52ZXJzaW9uID0gdXNlckNvbmZpZy52ZXJzaW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VyQ29uZmlnLnJ1bm5lcikge1xuICAgICAgICAgICAgY29uZmlnLnJ1bm5lciA9IHsgLi4uY29uZmlnLnJ1bm5lciwgLi4udXNlckNvbmZpZy5ydW5uZXIgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlckNvbmZpZy5sb29wKSB7XG4gICAgICAgICAgICBjb25maWcubG9vcCA9IHsgLi4uY29uZmlnLmxvb3AsIC4uLnVzZXJDb25maWcubG9vcCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VyQ29uZmlnLmRlYnVnKSB7XG4gICAgICAgICAgICBjb25maWcuZGVidWcgPSB7IC4uLmNvbmZpZy5kZWJ1ZywgLi4udXNlckNvbmZpZy5kZWJ1ZyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VyQ29uZmlnLm9wZW5jb2RlKSB7XG4gICAgICAgICAgICBjb25maWcub3BlbmNvZGUgPSB7IC4uLmNvbmZpZy5vcGVuY29kZSwgLi4udXNlckNvbmZpZy5vcGVuY29kZSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VyQ29uZmlnLmFudGhyb3BpYykge1xuICAgICAgICAgICAgY29uZmlnLmFudGhyb3BpYyA9IHsgLi4uY29uZmlnLmFudGhyb3BpYywgLi4udXNlckNvbmZpZy5hbnRocm9waWMgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlckNvbmZpZy5nYXRlcykge1xuICAgICAgICAgICAgaWYgKHVzZXJDb25maWcuZ2F0ZXMubGludCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5nYXRlcy5saW50ID0gbWVyZ2VHYXRlQ29uZmlnKFxuICAgICAgICAgICAgICAgICAgICBjb25maWcuZ2F0ZXMubGludCxcbiAgICAgICAgICAgICAgICAgICAgdXNlckNvbmZpZy5nYXRlcy5saW50LFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXNlckNvbmZpZy5nYXRlcy50eXBlY2hlY2spIHtcbiAgICAgICAgICAgICAgICBjb25maWcuZ2F0ZXMudHlwZWNoZWNrID0gbWVyZ2VHYXRlQ29uZmlnKFxuICAgICAgICAgICAgICAgICAgICBjb25maWcuZ2F0ZXMudHlwZWNoZWNrLFxuICAgICAgICAgICAgICAgICAgICB1c2VyQ29uZmlnLmdhdGVzLnR5cGVjaGVjayxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVzZXJDb25maWcuZ2F0ZXMudGVzdCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5nYXRlcy50ZXN0ID0gbWVyZ2VHYXRlQ29uZmlnKFxuICAgICAgICAgICAgICAgICAgICBjb25maWcuZ2F0ZXMudGVzdCxcbiAgICAgICAgICAgICAgICAgICAgdXNlckNvbmZpZy5nYXRlcy50ZXN0LFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXNlckNvbmZpZy5nYXRlcy5idWlsZCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5nYXRlcy5idWlsZCA9IG1lcmdlR2F0ZUNvbmZpZyhcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmdhdGVzLmJ1aWxkLFxuICAgICAgICAgICAgICAgICAgICB1c2VyQ29uZmlnLmdhdGVzLmJ1aWxkLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXNlckNvbmZpZy5nYXRlcy5hY2NlcHRhbmNlKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLmdhdGVzLmFjY2VwdGFuY2UgPSBtZXJnZUdhdGVDb25maWcoXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5nYXRlcy5hY2NlcHRhbmNlLFxuICAgICAgICAgICAgICAgICAgICB1c2VyQ29uZmlnLmdhdGVzLmFjY2VwdGFuY2UsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlckNvbmZpZy5tb2RlbHMpIHtcbiAgICAgICAgICAgIGNvbmZpZy5tb2RlbHMgPSB7IC4uLmNvbmZpZy5tb2RlbHMsIC4uLnVzZXJDb25maWcubW9kZWxzIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzZXJDb25maWcubm90aWZpY2F0aW9ucykge1xuICAgICAgICAgICAgaWYgKHVzZXJDb25maWcubm90aWZpY2F0aW9ucy5kaXNjb3JkKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLm5vdGlmaWNhdGlvbnMuZGlzY29yZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY29uZmlnLm5vdGlmaWNhdGlvbnMuZGlzY29yZCxcbiAgICAgICAgICAgICAgICAgICAgLi4udXNlckNvbmZpZy5ub3RpZmljYXRpb25zLmRpc2NvcmQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlckNvbmZpZy51aSkge1xuICAgICAgICAgICAgY29uZmlnLnVpID0geyAuLi5jb25maWcudWksIC4uLnVzZXJDb25maWcudWkgfTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIENvbmZpZyBmaWxlIG5vdCBmb3VuZCBvciBpbnZhbGlkIC0gdXNlIGRlZmF1bHRzXG4gICAgICAgIGlmICghKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcIkVOT0VOVFwiKSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICBgV2FybmluZzogRmFpbGVkIHRvIGxvYWQgY29uZmlnIGZyb20gJHtjb25maWdQYXRofSwgdXNpbmcgZGVmYXVsdHNgLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFwcGx5IGVudmlyb25tZW50IHZhcmlhYmxlIG92ZXJyaWRlcyAoZW52IHRha2VzIHByZWNlZGVuY2Ugb3ZlciB5YW1sKVxuICAgIGFwcGx5RW52T3ZlcnJpZGVzKGNvbmZpZyk7XG5cbiAgICAvLyBPdmVycmlkZSB3aXRoIENMSSBmbGFncyAoaGlnaGVzdCBwcmlvcml0eSlcbiAgICBpZiAoZmxhZ3MubWF4SXRlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25maWcucnVubmVyLm1heEl0ZXJzID0gZmxhZ3MubWF4SXRlcnM7XG4gICAgfVxuICAgIGlmIChmbGFncy5yZXZpZXcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25maWcucnVubmVyLnJldmlldyA9IGZsYWdzLnJldmlldztcbiAgICB9XG4gICAgaWYgKGZsYWdzLm1heEN5Y2xlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbmZpZy5sb29wLm1heEN5Y2xlcyA9IGZsYWdzLm1heEN5Y2xlcztcbiAgICB9XG4gICAgaWYgKGZsYWdzLnN0dWNrVGhyZXNob2xkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uZmlnLmxvb3Auc3R1Y2tUaHJlc2hvbGQgPSBmbGFncy5zdHVja1RocmVzaG9sZDtcbiAgICB9XG4gICAgaWYgKGZsYWdzLmNoZWNrcG9pbnRGcmVxdWVuY3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25maWcubG9vcC5jaGVja3BvaW50RnJlcXVlbmN5ID0gZmxhZ3MuY2hlY2twb2ludEZyZXF1ZW5jeTtcbiAgICB9XG4gICAgaWYgKGZsYWdzLnByaW50TG9ncyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbmZpZy5ydW5uZXIucHJpbnRMb2dzID0gZmxhZ3MucHJpbnRMb2dzO1xuICAgIH1cbiAgICBpZiAoZmxhZ3MubG9nTGV2ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25maWcucnVubmVyLmxvZ0xldmVsID0gZmxhZ3MubG9nTGV2ZWw7XG4gICAgfVxuICAgIGlmIChmbGFncy52ZXJib3NlKSB7XG4gICAgICAgIGNvbmZpZy5ydW5uZXIubG9nTGV2ZWwgPSBcIkRFQlVHXCI7XG4gICAgfVxuICAgIGlmIChmbGFncy53b3JraW5nRGlyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uZmlnLm9wZW5jb2RlLmRpcmVjdG9yeSA9IGZsYWdzLndvcmtpbmdEaXI7XG4gICAgfVxuICAgIGlmIChmbGFncy5kcnlSdW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBkcnlSdW4gY291bGQgYmUgdXNlZCBieSBnYXRlcyBvciBvdGhlciBjb21wb25lbnRzXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmZpZztcbn1cbiIsCiAgICAiLyoqXG4gKiBBSSBFbmdpbmVlcmluZyBTeXN0ZW0gQ29uZmlndXJhdGlvbiBTY2hlbWFcbiAqL1xuXG4vKipcbiAqIFJ1bm5lciBDb25maWd1cmF0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUnVubmVyQ29uZmlnIHtcbiAgICAvKiogQmFja2VuZCB0byB1c2UgZm9yIGV4ZWN1dGlvbiAqL1xuICAgIGJhY2tlbmQ6IFwib3BlbmNvZGVcIiB8IFwiYW50aHJvcGljXCI7XG4gICAgLyoqIFJldmlldyBtb2RlIGZvciBBSSByZXZpZXdzICovXG4gICAgcmV2aWV3OiBcIm5vbmVcIiB8IFwib3BlbmNvZGVcIiB8IFwiYW50aHJvcGljXCIgfCBcImJvdGhcIjtcbiAgICAvKiogRGlyZWN0b3J5IGZvciBydW4gYXJ0aWZhY3RzICovXG4gICAgYXJ0aWZhY3RzRGlyOiBzdHJpbmc7XG4gICAgLyoqIE1heGltdW0gaXRlcmF0aW9ucyBwZXIgcnVuICovXG4gICAgbWF4SXRlcnM6IG51bWJlcjtcbiAgICAvKiogUHJpbnQgbG9ncyB0byBzdGRlcnIgKi9cbiAgICBwcmludExvZ3M/OiBib29sZWFuO1xuICAgIC8qKiBMb2cgbGV2ZWwgKi9cbiAgICBsb2dMZXZlbD86IFwiREVCVUdcIiB8IFwiSU5GT1wiIHwgXCJXQVJOXCIgfCBcIkVSUk9SXCI7XG59XG5cbi8qKlxuICogTG9vcCBDb25maWd1cmF0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTG9vcENvbmZpZyB7XG4gICAgLyoqIE1heGltdW0gbnVtYmVyIG9mIGxvb3AgY3ljbGVzICovXG4gICAgbWF4Q3ljbGVzOiBudW1iZXI7XG4gICAgLyoqIE51bWJlciBvZiByZXRyeSBhdHRlbXB0cyBwZXIgY3ljbGUgb24gZmFpbHVyZSAqL1xuICAgIGN5Y2xlUmV0cmllczogbnVtYmVyO1xuICAgIC8qKiBDaGVja3BvaW50IGZyZXF1ZW5jeSAoc2F2ZSBzdGF0ZSBldmVyeSBOIGN5Y2xlcykgKi9cbiAgICBjaGVja3BvaW50RnJlcXVlbmN5OiBudW1iZXI7XG4gICAgLyoqIFN0dWNrIGRldGVjdGlvbiB0aHJlc2hvbGQgLSBhYm9ydCBhZnRlciBOIGN5Y2xlcyB3aXRoIG5vIHByb2dyZXNzICovXG4gICAgc3R1Y2tUaHJlc2hvbGQ6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBEZWJ1ZyBDb25maWd1cmF0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRGVidWdDb25maWcge1xuICAgIC8qKiBQcmludCBldmVyeSB0b29sIGludm9jYXRpb24gaW5wdXQvb3V0cHV0IHRvIGNvbnNvbGUgYW5kIGxvZ3MgKi9cbiAgICB3b3JrOiBib29sZWFuO1xufVxuXG4vKipcbiAqIE9wZW5Db2RlIENvbmZpZ3VyYXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBPcGVuQ29kZUNvbmZpZyB7XG4gICAgLyoqIE1vZGVsIHRvIHVzZSBmb3IgT3BlbkNvZGUgKi9cbiAgICBtb2RlbDogc3RyaW5nO1xuICAgIC8qKiBUZW1wZXJhdHVyZSBmb3IgZ2VuZXJhdGlvbiAqL1xuICAgIHRlbXBlcmF0dXJlOiBudW1iZXI7XG4gICAgLyoqIEV4aXN0aW5nIHNlcnZlciBVUkwgKG9wdGlvbmFsIC0gd2lsbCBzcGF3biBpZiBub3QgcHJvdmlkZWQpICovXG4gICAgc2VydmVyVXJsPzogc3RyaW5nO1xuICAgIC8qKiBXb3JraW5nIGRpcmVjdG9yeSBmb3IgT3BlbkNvZGUgc2Vzc2lvbiAqL1xuICAgIGRpcmVjdG9yeT86IHN0cmluZztcbiAgICAvKiogUHJvbXB0IHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzICovXG4gICAgcHJvbXB0VGltZW91dE1zPzogbnVtYmVyO1xufVxuXG4vKipcbiAqIEFudGhyb3BpYyBDb25maWd1cmF0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQW50aHJvcGljQ29uZmlnIHtcbiAgICAvKiogV2hldGhlciBBbnRocm9waWMgYmFja2VuZCBpcyBlbmFibGVkICovXG4gICAgZW5hYmxlZDogYm9vbGVhbjtcbiAgICAvKiogTW9kZWwgdG8gdXNlIGZvciBBbnRocm9waWMgKi9cbiAgICBtb2RlbDogc3RyaW5nO1xufVxuXG4vKipcbiAqIEdhdGUgQ29tbWFuZCBDb25maWd1cmF0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgR2F0ZUNvbW1hbmRDb25maWcge1xuICAgIC8qKiBDb21tYW5kIHRvIGV4ZWN1dGUgZm9yIHRoaXMgZ2F0ZSAqL1xuICAgIGNvbW1hbmQ6IHN0cmluZztcbn1cblxuLyoqXG4gKiBRdWFsaXR5IEdhdGVzIENvbmZpZ3VyYXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBHYXRlc0NvbmZpZyB7XG4gICAgLyoqIExpbnQgZ2F0ZSBjb25maWd1cmF0aW9uICovXG4gICAgbGludDogR2F0ZUNvbW1hbmRDb25maWc7XG4gICAgLyoqIFR5cGUgY2hlY2sgZ2F0ZSBjb25maWd1cmF0aW9uICovXG4gICAgdHlwZWNoZWNrOiBHYXRlQ29tbWFuZENvbmZpZztcbiAgICAvKiogVGVzdCBnYXRlIGNvbmZpZ3VyYXRpb24gKi9cbiAgICB0ZXN0OiBHYXRlQ29tbWFuZENvbmZpZztcbiAgICAvKiogQnVpbGQgZ2F0ZSBjb25maWd1cmF0aW9uICovXG4gICAgYnVpbGQ6IEdhdGVDb21tYW5kQ29uZmlnO1xuICAgIC8qKiBBY2NlcHRhbmNlIGdhdGUgY29uZmlndXJhdGlvbiAoZS5nLiwgZ2l0IGRpZmYgLS1uYW1lLW9ubHkpICovXG4gICAgYWNjZXB0YW5jZTogR2F0ZUNvbW1hbmRDb25maWc7XG59XG5cbi8qKlxuICogTW9kZWxzIENvbmZpZ3VyYXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNb2RlbHNDb25maWcge1xuICAgIC8qKiBNb2RlbCBmb3IgcmVzZWFyY2ggdGFza3MgKi9cbiAgICByZXNlYXJjaDogc3RyaW5nO1xuICAgIC8qKiBNb2RlbCBmb3IgcGxhbm5pbmcgdGFza3MgKi9cbiAgICBwbGFubmluZzogc3RyaW5nO1xuICAgIC8qKiBNb2RlbCBmb3IgY29kZWJhc2UgZXhwbG9yYXRpb24gKi9cbiAgICBleHBsb3JhdGlvbjogc3RyaW5nO1xuICAgIC8qKiBNb2RlbCBmb3IgY29kaW5nL2ltcGxlbWVudGF0aW9uICovXG4gICAgY29kaW5nOiBzdHJpbmc7XG4gICAgLyoqIERlZmF1bHQgZmFsbGJhY2sgbW9kZWwgKi9cbiAgICBkZWZhdWx0OiBzdHJpbmc7XG59XG5cbi8qKlxuICogTm90aWZpY2F0aW9uIENvbmZpZ3VyYXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOb3RpZmljYXRpb25zQ29uZmlnIHtcbiAgICAvKiogRGlzY29yZCBub3RpZmljYXRpb24gc2V0dGluZ3MgKi9cbiAgICBkaXNjb3JkOiB7XG4gICAgICAgIC8qKiBFbmFibGUgRGlzY29yZCBub3RpZmljYXRpb25zICovXG4gICAgICAgIGVuYWJsZWQ6IGJvb2xlYW47XG4gICAgICAgIC8qKiBCb3QgdXNlcm5hbWUgKi9cbiAgICAgICAgdXNlcm5hbWU6IHN0cmluZztcbiAgICAgICAgLyoqIEJvdCBhdmF0YXIgVVJMICovXG4gICAgICAgIGF2YXRhclVybD86IHN0cmluZztcbiAgICAgICAgLyoqIFdlYmhvb2sgVVJMIChzaG91bGQgY29tZSBmcm9tIGVudiwgbmV2ZXIgaGFyZGNvZGVkKSAqL1xuICAgICAgICB3ZWJob29rPzoge1xuICAgICAgICAgICAgLyoqIFNvdXJjZSB0eXBlIC0gb25seSAnZW52JyBzdXBwb3J0ZWQgZm9yIHNlY3JldHMgKi9cbiAgICAgICAgICAgIHNvdXJjZTogXCJlbnZcIjtcbiAgICAgICAgICAgIC8qKiBFbnZpcm9ubWVudCB2YXJpYWJsZSBuYW1lIGZvciB0aGUgd2ViaG9vayBVUkwgKi9cbiAgICAgICAgICAgIGVudlZhcjogc3RyaW5nO1xuICAgICAgICB9O1xuICAgIH07XG59XG5cbi8qKlxuICogVUkgQ29uZmlndXJhdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIFVpQ29uZmlnIHtcbiAgICAvKiogU3VwcHJlc3Mgbm9pc3kgd2FybmluZ3MvbG9ncyAqL1xuICAgIHNpbGVudDogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBNYWluIENvbmZpZ3VyYXRpb24gU2NoZW1hXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQWlFbmdDb25maWcge1xuICAgIC8qKiBDb25maWd1cmF0aW9uIHZlcnNpb24gKi9cbiAgICB2ZXJzaW9uOiBudW1iZXI7XG4gICAgLyoqIFJ1bm5lciBjb25maWd1cmF0aW9uICovXG4gICAgcnVubmVyOiBSdW5uZXJDb25maWc7XG4gICAgLyoqIExvb3AgY29uZmlndXJhdGlvbiAqL1xuICAgIGxvb3A6IExvb3BDb25maWc7XG4gICAgLyoqIERlYnVnIGNvbmZpZ3VyYXRpb24gKi9cbiAgICBkZWJ1ZzogRGVidWdDb25maWc7XG4gICAgLyoqIE9wZW5Db2RlIGNvbmZpZ3VyYXRpb24gKi9cbiAgICBvcGVuY29kZTogT3BlbkNvZGVDb25maWc7XG4gICAgLyoqIEFudGhyb3BpYyBjb25maWd1cmF0aW9uICovXG4gICAgYW50aHJvcGljOiBBbnRocm9waWNDb25maWc7XG4gICAgLyoqIFF1YWxpdHkgZ2F0ZXMgY29uZmlndXJhdGlvbiAqL1xuICAgIGdhdGVzOiBHYXRlc0NvbmZpZztcbiAgICAvKiogTW9kZWxzIGNvbmZpZ3VyYXRpb24gKi9cbiAgICBtb2RlbHM6IE1vZGVsc0NvbmZpZztcbiAgICAvKiogTm90aWZpY2F0aW9ucyBjb25maWd1cmF0aW9uICovXG4gICAgbm90aWZpY2F0aW9uczogTm90aWZpY2F0aW9uc0NvbmZpZztcbiAgICAvKiogVUkgY29uZmlndXJhdGlvbiAqL1xuICAgIHVpOiBVaUNvbmZpZztcbn1cblxuLyoqXG4gKiBEZWZhdWx0IGNvbmZpZ3VyYXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfQ09ORklHOiBBaUVuZ0NvbmZpZyA9IHtcbiAgICB2ZXJzaW9uOiAxLFxuICAgIHJ1bm5lcjoge1xuICAgICAgICBiYWNrZW5kOiBcIm9wZW5jb2RlXCIsXG4gICAgICAgIHJldmlldzogXCJvcGVuY29kZVwiLFxuICAgICAgICBhcnRpZmFjdHNEaXI6IFwiLmFpLWVuZy9ydW5zXCIsXG4gICAgICAgIG1heEl0ZXJzOiAzLFxuICAgICAgICBwcmludExvZ3M6IGZhbHNlLFxuICAgICAgICBsb2dMZXZlbDogXCJJTkZPXCIsXG4gICAgfSxcbiAgICBsb29wOiB7XG4gICAgICAgIG1heEN5Y2xlczogNTAsXG4gICAgICAgIGN5Y2xlUmV0cmllczogMixcbiAgICAgICAgY2hlY2twb2ludEZyZXF1ZW5jeTogMSxcbiAgICAgICAgc3R1Y2tUaHJlc2hvbGQ6IDUsXG4gICAgfSxcbiAgICBkZWJ1Zzoge1xuICAgICAgICB3b3JrOiBmYWxzZSxcbiAgICB9LFxuICAgIG9wZW5jb2RlOiB7XG4gICAgICAgIG1vZGVsOiBcImNsYXVkZS0zLTUtc29ubmV0LWxhdGVzdFwiLFxuICAgICAgICB0ZW1wZXJhdHVyZTogMC4yLFxuICAgICAgICBzZXJ2ZXJVcmw6IHVuZGVmaW5lZCxcbiAgICAgICAgZGlyZWN0b3J5OiB1bmRlZmluZWQsXG4gICAgICAgIHByb21wdFRpbWVvdXRNczogMTIwMDAwLFxuICAgIH0sXG4gICAgYW50aHJvcGljOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBtb2RlbDogXCJjbGF1ZGUtMy01LXNvbm5ldC1sYXRlc3RcIixcbiAgICB9LFxuICAgIGdhdGVzOiB7XG4gICAgICAgIGxpbnQ6IHsgY29tbWFuZDogXCJidW4gcnVuIGxpbnRcIiB9LFxuICAgICAgICB0eXBlY2hlY2s6IHsgY29tbWFuZDogXCJidW4gcnVuIHR5cGVjaGVja1wiIH0sXG4gICAgICAgIHRlc3Q6IHsgY29tbWFuZDogXCJidW4gdGVzdFwiIH0sXG4gICAgICAgIGJ1aWxkOiB7IGNvbW1hbmQ6IFwiYnVuIHJ1biBidWlsZFwiIH0sXG4gICAgICAgIGFjY2VwdGFuY2U6IHsgY29tbWFuZDogXCJnaXQgZGlmZiAtLW5hbWUtb25seVwiIH0sXG4gICAgfSxcbiAgICBtb2RlbHM6IHtcbiAgICAgICAgcmVzZWFyY2g6IFwiZ2l0aHViLWNvcGlsb3QvZ3B0LTUuMlwiLFxuICAgICAgICBwbGFubmluZzogXCJnaXRodWItY29waWxvdC9ncHQtNS4yXCIsXG4gICAgICAgIGV4cGxvcmF0aW9uOiBcImdpdGh1Yi1jb3BpbG90L2dwdC01LjJcIixcbiAgICAgICAgY29kaW5nOiBcImdpdGh1Yi1jb3BpbG90L2dwdC01LjJcIixcbiAgICAgICAgZGVmYXVsdDogXCJnaXRodWItY29waWxvdC9ncHQtNS4yXCIsXG4gICAgfSxcbiAgICBub3RpZmljYXRpb25zOiB7XG4gICAgICAgIGRpc2NvcmQ6IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgdXNlcm5hbWU6IFwiUmFscGhcIixcbiAgICAgICAgICAgIGF2YXRhclVybDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgd2ViaG9vazoge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogXCJlbnZcIixcbiAgICAgICAgICAgICAgICBlbnZWYXI6IFwiRElTQ09SRF9XRUJIT09LX1VSTFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHVpOiB7XG4gICAgICAgIHNpbGVudDogZmFsc2UsXG4gICAgfSxcbn07XG4iLAogICAgImltcG9ydCBmcyBmcm9tIFwibm9kZTpmcy9wcm9taXNlc1wiO1xuLyoqXG4gKiBTdHJ1Y3R1cmVkIGxvZ2dpbmcgZm9yIGFpLWVuZyByYWxwaFxuICpcbiAqIFN1cHBvcnRzIGJvdGggc3RkZXJyIG91dHB1dCAod2l0aCAtLXByaW50LWxvZ3MpIGFuZCBmaWxlLWJhc2VkIGxvZ2dpbmdcbiAqL1xuaW1wb3J0IHBhdGggZnJvbSBcIm5vZGU6cGF0aFwiO1xuXG5leHBvcnQgbmFtZXNwYWNlIExvZyB7XG4gICAgZXhwb3J0IHR5cGUgTGV2ZWwgPSBcIkRFQlVHXCIgfCBcIklORk9cIiB8IFwiV0FSTlwiIHwgXCJFUlJPUlwiO1xuXG4gICAgY29uc3QgbGV2ZWxQcmlvcml0eTogUmVjb3JkPExldmVsLCBudW1iZXI+ID0ge1xuICAgICAgICBERUJVRzogMCxcbiAgICAgICAgSU5GTzogMSxcbiAgICAgICAgV0FSTjogMixcbiAgICAgICAgRVJST1I6IDMsXG4gICAgfTtcblxuICAgIGxldCBjdXJyZW50TGV2ZWw6IExldmVsID0gXCJJTkZPXCI7XG4gICAgbGV0IGxvZ1BhdGggPSBcIlwiO1xuICAgIGxldCB3cml0ZTogKG1zZzogc3RyaW5nKSA9PiBhbnkgPSAobXNnKSA9PiBwcm9jZXNzLnN0ZGVyci53cml0ZShtc2cpO1xuXG4gICAgZnVuY3Rpb24gc2hvdWxkTG9nKGxldmVsOiBMZXZlbCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gbGV2ZWxQcmlvcml0eVtsZXZlbF0gPj0gbGV2ZWxQcmlvcml0eVtjdXJyZW50TGV2ZWxdO1xuICAgIH1cblxuICAgIGV4cG9ydCBpbnRlcmZhY2UgT3B0aW9ucyB7XG4gICAgICAgIHByaW50OiBib29sZWFuOyAvLyBXaGVuIHRydWUsIHdyaXRlIHRvIHN0ZGVyclxuICAgICAgICBsZXZlbD86IExldmVsO1xuICAgICAgICBsb2dEaXI/OiBzdHJpbmc7IC8vIERpcmVjdG9yeSBmb3IgbG9nIGZpbGVzXG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGZpbGUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGxvZ1BhdGg7XG4gICAgfVxuXG4gICAgZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluaXQob3B0aW9uczogT3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBpZiAob3B0aW9ucy5sZXZlbCkgY3VycmVudExldmVsID0gb3B0aW9ucy5sZXZlbDtcblxuICAgICAgICAvLyBCdWlsZCB0aGUgd3JpdGUgZnVuY3Rpb24gdGhhdCBvdXRwdXRzIHRvIEJPVEggc3RkZXJyIEFORCBmaWxlXG4gICAgICAgIGNvbnN0IHN0ZGVycldyaXRlciA9IChtc2c6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgcHJvY2Vzcy5zdGRlcnIud3JpdGUobXNnKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAob3B0aW9ucy5sb2dEaXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKClcbiAgICAgICAgICAgICAgICAudG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9bOi5dL2csIFwiLVwiKVxuICAgICAgICAgICAgICAgIC5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICBsb2dQYXRoID0gcGF0aC5qb2luKG9wdGlvbnMubG9nRGlyLCBgcmFscGgtJHt0aW1lc3RhbXB9LmxvZ2ApO1xuICAgICAgICAgICAgYXdhaXQgZnMubWtkaXIob3B0aW9ucy5sb2dEaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuXG4gICAgICAgICAgICBjb25zdCBmaWxlID0gQnVuLmZpbGUobG9nUGF0aCk7XG4gICAgICAgICAgICBjb25zdCBmaWxlV3JpdGVyID0gZmlsZS53cml0ZXIoKTtcblxuICAgICAgICAgICAgLy8gQWx3YXlzIHdyaXRlIHRvIHN0ZGVyciBpZiBwcmludCBpcyBlbmFibGVkXG4gICAgICAgICAgICAvLyBBbHNvIGFsd2F5cyB3cml0ZSB0byBmaWxlIGlmIGxvZ0RpciBpcyBwcm92aWRlZFxuICAgICAgICAgICAgd3JpdGUgPSAobXNnKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucHJpbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RkZXJyV3JpdGVyKG1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbGVXcml0ZXIud3JpdGUobXNnKTtcbiAgICAgICAgICAgICAgICBmaWxlV3JpdGVyLmZsdXNoKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMucHJpbnQpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgcHJpbnQgdG8gc3RkZXJyXG4gICAgICAgICAgICB3cml0ZSA9IHN0ZGVycldyaXRlcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydCBpbnRlcmZhY2UgTG9nZ2VyIHtcbiAgICAgICAgZGVidWcobWVzc2FnZTogc3RyaW5nLCBleHRyYT86IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkO1xuICAgICAgICBpbmZvKG1lc3NhZ2U6IHN0cmluZywgZXh0cmE/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZDtcbiAgICAgICAgd2FybihtZXNzYWdlOiBzdHJpbmcsIGV4dHJhPzogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQ7XG4gICAgICAgIGVycm9yKG1lc3NhZ2U6IHN0cmluZywgZXh0cmE/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRFeHRyYShleHRyYT86IFJlY29yZDxzdHJpbmcsIGFueT4pOiBzdHJpbmcge1xuICAgICAgICBpZiAoIWV4dHJhKSByZXR1cm4gXCJcIjtcbiAgICAgICAgY29uc3QgZXh0cmFTdHIgPSBPYmplY3QuZW50cmllcyhleHRyYSlcbiAgICAgICAgICAgIC5tYXAoXG4gICAgICAgICAgICAgICAgKFtrLCB2XSkgPT5cbiAgICAgICAgICAgICAgICAgICAgYCR7a309JHt0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiA/IEpTT04uc3RyaW5naWZ5KHYpIDogdn1gLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmpvaW4oXCIgXCIpO1xuICAgICAgICByZXR1cm4gZXh0cmFTdHIgPyBgICR7ZXh0cmFTdHJ9YCA6IFwiXCI7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSh0YWdzPzogUmVjb3JkPHN0cmluZywgc3RyaW5nPik6IExvZ2dlciB7XG4gICAgICAgIGNvbnN0IHRhZ1N0ciA9IHRhZ3NcbiAgICAgICAgICAgID8gT2JqZWN0LmVudHJpZXModGFncylcbiAgICAgICAgICAgICAgICAgIC5tYXAoKFtrLCB2XSkgPT4gYCR7a309JHt2fWApXG4gICAgICAgICAgICAgICAgICAuam9pbihcIiBcIilcbiAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgY29uc3QgdGFnU3RyV2l0aFNwYWNlID0gdGFnU3RyID8gYCR7dGFnU3RyfSBgIDogXCJcIjtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVidWcobWVzc2FnZTogc3RyaW5nLCBleHRyYT86IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkTG9nKFwiREVCVUdcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICBgREVCVUcgJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9ICR7dGFnU3RyfSR7bWVzc2FnZX0ke2Zvcm1hdEV4dHJhKGV4dHJhKX1cXG5gLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbmZvKG1lc3NhZ2U6IHN0cmluZywgZXh0cmE/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZExvZyhcIklORk9cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICBgSU5GTyAgJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9ICR7dGFnU3RyfSR7bWVzc2FnZX0ke2Zvcm1hdEV4dHJhKGV4dHJhKX1cXG5gLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3YXJuKG1lc3NhZ2U6IHN0cmluZywgZXh0cmE/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZExvZyhcIldBUk5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICBgV0FSTiAgJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9ICR7dGFnU3RyfSR7bWVzc2FnZX0ke2Zvcm1hdEV4dHJhKGV4dHJhKX1cXG5gLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlcnJvcihtZXNzYWdlOiBzdHJpbmcsIGV4dHJhPzogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRMb2coXCJFUlJPUlwiKSkge1xuICAgICAgICAgICAgICAgICAgICB3cml0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGBFUlJPUiAke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX0gJHt0YWdTdHJ9JHttZXNzYWdlfSR7Zm9ybWF0RXh0cmEoZXh0cmEpfVxcbmAsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBleHBvcnQgY29uc3QgRGVmYXVsdCA9IGNyZWF0ZSh7IHNlcnZpY2U6IFwicmFscGhcIiB9KTtcbn1cbiIsCiAgICAiaW1wb3J0e2N1cnNvciBhcyBsLGVyYXNlIGFzIGJ9ZnJvbVwic2lzdGVyYW5zaVwiO2ltcG9ydHtzdGRpbiBhcyBqLHN0ZG91dCBhcyBNfWZyb21cIm5vZGU6cHJvY2Vzc1wiO2ltcG9ydCphcyBnIGZyb21cIm5vZGU6cmVhZGxpbmVcIjtpbXBvcnQgTyBmcm9tXCJub2RlOnJlYWRsaW5lXCI7aW1wb3J0e1dyaXRhYmxlIGFzIFh9ZnJvbVwibm9kZTpzdHJlYW1cIjtpbXBvcnQgdiBmcm9tXCJwaWNvY29sb3JzXCI7ZnVuY3Rpb24gREQoe29ubHlGaXJzdDplPSExfT17fSl7Y29uc3QgdD1bXCJbXFxcXHUwMDFCXFxcXHUwMDlCXVtbXFxcXF0oKSM7P10qKD86KD86KD86KD86O1stYS16QS1aXFxcXGRcXFxcLyMmLjo9PyVAfl9dKykqfFthLXpBLVpcXFxcZF0rKD86O1stYS16QS1aXFxcXGRcXFxcLyMmLjo9PyVAfl9dKikqKT8oPzpcXFxcdTAwMDd8XFxcXHUwMDFCXFxcXHUwMDVDfFxcXFx1MDA5QykpXCIsXCIoPzooPzpcXFxcZHsxLDR9KD86O1xcXFxkezAsNH0pKik/W1xcXFxkQS1QUi1UWmNmLW5xLXV5PT48fl0pKVwiXS5qb2luKFwifFwiKTtyZXR1cm4gbmV3IFJlZ0V4cCh0LGU/dm9pZCAwOlwiZ1wiKX1jb25zdCB1RD1ERCgpO2Z1bmN0aW9uIFAoZSl7aWYodHlwZW9mIGUhPVwic3RyaW5nXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgYSBcXGBzdHJpbmdcXGAsIGdvdCBcXGAke3R5cGVvZiBlfVxcYGApO3JldHVybiBlLnJlcGxhY2UodUQsXCJcIil9ZnVuY3Rpb24gTChlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlJiZPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxcImRlZmF1bHRcIik/ZS5kZWZhdWx0OmV9dmFyIFc9e2V4cG9ydHM6e319OyhmdW5jdGlvbihlKXt2YXIgdT17fTtlLmV4cG9ydHM9dSx1LmVhc3RBc2lhbldpZHRoPWZ1bmN0aW9uKEYpe3ZhciBzPUYuY2hhckNvZGVBdCgwKSxpPUYubGVuZ3RoPT0yP0YuY2hhckNvZGVBdCgxKTowLEQ9cztyZXR1cm4gNTUyOTY8PXMmJnM8PTU2MzE5JiY1NjMyMDw9aSYmaTw9NTczNDMmJihzJj0xMDIzLGkmPTEwMjMsRD1zPDwxMHxpLEQrPTY1NTM2KSxEPT0xMjI4OHx8NjUyODE8PUQmJkQ8PTY1Mzc2fHw2NTUwNDw9RCYmRDw9NjU1MTA/XCJGXCI6RD09ODM2MXx8NjUzNzc8PUQmJkQ8PTY1NDcwfHw2NTQ3NDw9RCYmRDw9NjU0Nzl8fDY1NDgyPD1EJiZEPD02NTQ4N3x8NjU0OTA8PUQmJkQ8PTY1NDk1fHw2NTQ5ODw9RCYmRDw9NjU1MDB8fDY1NTEyPD1EJiZEPD02NTUxOD9cIkhcIjo0MzUyPD1EJiZEPD00NDQ3fHw0NTE1PD1EJiZEPD00NTE5fHw0NjAyPD1EJiZEPD00NjA3fHw5MDAxPD1EJiZEPD05MDAyfHwxMTkwNDw9RCYmRDw9MTE5Mjl8fDExOTMxPD1EJiZEPD0xMjAxOXx8MTIwMzI8PUQmJkQ8PTEyMjQ1fHwxMjI3Mjw9RCYmRDw9MTIyODN8fDEyMjg5PD1EJiZEPD0xMjM1MHx8MTIzNTM8PUQmJkQ8PTEyNDM4fHwxMjQ0MTw9RCYmRDw9MTI1NDN8fDEyNTQ5PD1EJiZEPD0xMjU4OXx8MTI1OTM8PUQmJkQ8PTEyNjg2fHwxMjY4ODw9RCYmRDw9MTI3MzB8fDEyNzM2PD1EJiZEPD0xMjc3MXx8MTI3ODQ8PUQmJkQ8PTEyODMwfHwxMjgzMjw9RCYmRDw9MTI4NzF8fDEyODgwPD1EJiZEPD0xMzA1NHx8MTMwNTY8PUQmJkQ8PTE5OTAzfHwxOTk2ODw9RCYmRDw9NDIxMjR8fDQyMTI4PD1EJiZEPD00MjE4Mnx8NDMzNjA8PUQmJkQ8PTQzMzg4fHw0NDAzMjw9RCYmRDw9NTUyMDN8fDU1MjE2PD1EJiZEPD01NTIzOHx8NTUyNDM8PUQmJkQ8PTU1MjkxfHw2Mzc0NDw9RCYmRDw9NjQyNTV8fDY1MDQwPD1EJiZEPD02NTA0OXx8NjUwNzI8PUQmJkQ8PTY1MTA2fHw2NTEwODw9RCYmRDw9NjUxMjZ8fDY1MTI4PD1EJiZEPD02NTEzMXx8MTEwNTkyPD1EJiZEPD0xMTA1OTN8fDEyNzQ4ODw9RCYmRDw9MTI3NDkwfHwxMjc1MDQ8PUQmJkQ8PTEyNzU0Nnx8MTI3NTUyPD1EJiZEPD0xMjc1NjB8fDEyNzU2ODw9RCYmRDw9MTI3NTY5fHwxMzEwNzI8PUQmJkQ8PTE5NDM2N3x8MTc3OTg0PD1EJiZEPD0xOTY2MDV8fDE5NjYwODw9RCYmRDw9MjYyMTQxP1wiV1wiOjMyPD1EJiZEPD0xMjZ8fDE2Mjw9RCYmRDw9MTYzfHwxNjU8PUQmJkQ8PTE2Nnx8RD09MTcyfHxEPT0xNzV8fDEwMjE0PD1EJiZEPD0xMDIyMXx8MTA2Mjk8PUQmJkQ8PTEwNjMwP1wiTmFcIjpEPT0xNjF8fEQ9PTE2NHx8MTY3PD1EJiZEPD0xNjh8fEQ9PTE3MHx8MTczPD1EJiZEPD0xNzR8fDE3Njw9RCYmRDw9MTgwfHwxODI8PUQmJkQ8PTE4Nnx8MTg4PD1EJiZEPD0xOTF8fEQ9PTE5OHx8RD09MjA4fHwyMTU8PUQmJkQ8PTIxNnx8MjIyPD1EJiZEPD0yMjV8fEQ9PTIzMHx8MjMyPD1EJiZEPD0yMzR8fDIzNjw9RCYmRDw9MjM3fHxEPT0yNDB8fDI0Mjw9RCYmRDw9MjQzfHwyNDc8PUQmJkQ8PTI1MHx8RD09MjUyfHxEPT0yNTR8fEQ9PTI1N3x8RD09MjczfHxEPT0yNzV8fEQ9PTI4M3x8Mjk0PD1EJiZEPD0yOTV8fEQ9PTI5OXx8MzA1PD1EJiZEPD0zMDd8fEQ9PTMxMnx8MzE5PD1EJiZEPD0zMjJ8fEQ9PTMyNHx8MzI4PD1EJiZEPD0zMzF8fEQ9PTMzM3x8MzM4PD1EJiZEPD0zMzl8fDM1ODw9RCYmRDw9MzU5fHxEPT0zNjN8fEQ9PTQ2Mnx8RD09NDY0fHxEPT00NjZ8fEQ9PTQ2OHx8RD09NDcwfHxEPT00NzJ8fEQ9PTQ3NHx8RD09NDc2fHxEPT01OTN8fEQ9PTYwOXx8RD09NzA4fHxEPT03MTF8fDcxMzw9RCYmRDw9NzE1fHxEPT03MTd8fEQ9PTcyMHx8NzI4PD1EJiZEPD03MzF8fEQ9PTczM3x8RD09NzM1fHw3Njg8PUQmJkQ8PTg3OXx8OTEzPD1EJiZEPD05Mjl8fDkzMTw9RCYmRDw9OTM3fHw5NDU8PUQmJkQ8PTk2MXx8OTYzPD1EJiZEPD05Njl8fEQ9PTEwMjV8fDEwNDA8PUQmJkQ8PTExMDN8fEQ9PTExMDV8fEQ9PTgyMDh8fDgyMTE8PUQmJkQ8PTgyMTR8fDgyMTY8PUQmJkQ8PTgyMTd8fDgyMjA8PUQmJkQ8PTgyMjF8fDgyMjQ8PUQmJkQ8PTgyMjZ8fDgyMjg8PUQmJkQ8PTgyMzF8fEQ9PTgyNDB8fDgyNDI8PUQmJkQ8PTgyNDN8fEQ9PTgyNDV8fEQ9PTgyNTF8fEQ9PTgyNTR8fEQ9PTgzMDh8fEQ9PTgzMTl8fDgzMjE8PUQmJkQ8PTgzMjR8fEQ9PTgzNjR8fEQ9PTg0NTF8fEQ9PTg0NTN8fEQ9PTg0NTd8fEQ9PTg0Njd8fEQ9PTg0NzB8fDg0ODE8PUQmJkQ8PTg0ODJ8fEQ9PTg0ODZ8fEQ9PTg0OTF8fDg1MzE8PUQmJkQ8PTg1MzJ8fDg1Mzk8PUQmJkQ8PTg1NDJ8fDg1NDQ8PUQmJkQ8PTg1NTV8fDg1NjA8PUQmJkQ8PTg1Njl8fEQ9PTg1ODV8fDg1OTI8PUQmJkQ8PTg2MDF8fDg2MzI8PUQmJkQ8PTg2MzN8fEQ9PTg2NTh8fEQ9PTg2NjB8fEQ9PTg2Nzl8fEQ9PTg3MDR8fDg3MDY8PUQmJkQ8PTg3MDd8fDg3MTE8PUQmJkQ8PTg3MTJ8fEQ9PTg3MTV8fEQ9PTg3MTl8fEQ9PTg3MjF8fEQ9PTg3MjV8fEQ9PTg3MzB8fDg3MzM8PUQmJkQ8PTg3MzZ8fEQ9PTg3Mzl8fEQ9PTg3NDF8fDg3NDM8PUQmJkQ8PTg3NDh8fEQ9PTg3NTB8fDg3NTY8PUQmJkQ8PTg3NTl8fDg3NjQ8PUQmJkQ8PTg3NjV8fEQ9PTg3NzZ8fEQ9PTg3ODB8fEQ9PTg3ODZ8fDg4MDA8PUQmJkQ8PTg4MDF8fDg4MDQ8PUQmJkQ8PTg4MDd8fDg4MTA8PUQmJkQ8PTg4MTF8fDg4MTQ8PUQmJkQ8PTg4MTV8fDg4MzQ8PUQmJkQ8PTg4MzV8fDg4Mzg8PUQmJkQ8PTg4Mzl8fEQ9PTg4NTN8fEQ9PTg4NTd8fEQ9PTg4Njl8fEQ9PTg4OTV8fEQ9PTg5Nzh8fDkzMTI8PUQmJkQ8PTk0NDl8fDk0NTE8PUQmJkQ8PTk1NDd8fDk1NTI8PUQmJkQ8PTk1ODd8fDk2MDA8PUQmJkQ8PTk2MTV8fDk2MTg8PUQmJkQ8PTk2MjF8fDk2MzI8PUQmJkQ8PTk2MzN8fDk2MzU8PUQmJkQ8PTk2NDF8fDk2NTA8PUQmJkQ8PTk2NTF8fDk2NTQ8PUQmJkQ8PTk2NTV8fDk2NjA8PUQmJkQ8PTk2NjF8fDk2NjQ8PUQmJkQ8PTk2NjV8fDk2NzA8PUQmJkQ8PTk2NzJ8fEQ9PTk2NzV8fDk2Nzg8PUQmJkQ8PTk2ODF8fDk2OTg8PUQmJkQ8PTk3MDF8fEQ9PTk3MTF8fDk3MzM8PUQmJkQ8PTk3MzR8fEQ9PTk3Mzd8fDk3NDI8PUQmJkQ8PTk3NDN8fDk3NDg8PUQmJkQ8PTk3NDl8fEQ9PTk3NTZ8fEQ9PTk3NTh8fEQ9PTk3OTJ8fEQ9PTk3OTR8fDk4MjQ8PUQmJkQ8PTk4MjV8fDk4Mjc8PUQmJkQ8PTk4Mjl8fDk4MzE8PUQmJkQ8PTk4MzR8fDk4MzY8PUQmJkQ8PTk4Mzd8fEQ9PTk4Mzl8fDk4ODY8PUQmJkQ8PTk4ODd8fDk5MTg8PUQmJkQ8PTk5MTl8fDk5MjQ8PUQmJkQ8PTk5MzN8fDk5MzU8PUQmJkQ8PTk5NTN8fEQ9PTk5NTV8fDk5NjA8PUQmJkQ8PTk5ODN8fEQ9PTEwMDQ1fHxEPT0xMDA3MXx8MTAxMDI8PUQmJkQ8PTEwMTExfHwxMTA5Mzw9RCYmRDw9MTEwOTd8fDEyODcyPD1EJiZEPD0xMjg3OXx8NTczNDQ8PUQmJkQ8PTYzNzQzfHw2NTAyNDw9RCYmRDw9NjUwMzl8fEQ9PTY1NTMzfHwxMjcyMzI8PUQmJkQ8PTEyNzI0Mnx8MTI3MjQ4PD1EJiZEPD0xMjcyNzd8fDEyNzI4MDw9RCYmRDw9MTI3MzM3fHwxMjczNDQ8PUQmJkQ8PTEyNzM4Nnx8OTE3NzYwPD1EJiZEPD05MTc5OTl8fDk4MzA0MDw9RCYmRDw9MTA0ODU3M3x8MTA0ODU3Njw9RCYmRDw9MTExNDEwOT9cIkFcIjpcIk5cIn0sdS5jaGFyYWN0ZXJMZW5ndGg9ZnVuY3Rpb24oRil7dmFyIHM9dGhpcy5lYXN0QXNpYW5XaWR0aChGKTtyZXR1cm4gcz09XCJGXCJ8fHM9PVwiV1wifHxzPT1cIkFcIj8yOjF9O2Z1bmN0aW9uIHQoRil7cmV0dXJuIEYubWF0Y2goL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl18W15cXHVEODAwLVxcdURGRkZdL2cpfHxbXX11Lmxlbmd0aD1mdW5jdGlvbihGKXtmb3IodmFyIHM9dChGKSxpPTAsRD0wO0Q8cy5sZW5ndGg7RCsrKWk9aSt0aGlzLmNoYXJhY3Rlckxlbmd0aChzW0RdKTtyZXR1cm4gaX0sdS5zbGljZT1mdW5jdGlvbihGLHMsaSl7dGV4dExlbj11Lmxlbmd0aChGKSxzPXN8fDAsaT1pfHwxLHM8MCYmKHM9dGV4dExlbitzKSxpPDAmJihpPXRleHRMZW4raSk7Zm9yKHZhciBEPVwiXCIsQz0wLG49dChGKSxFPTA7RTxuLmxlbmd0aDtFKyspe3ZhciBhPW5bRV0sbz11Lmxlbmd0aChhKTtpZihDPj1zLShvPT0yPzE6MCkpaWYoQytvPD1pKUQrPWE7ZWxzZSBicmVhaztDKz1vfXJldHVybiBEfX0pKFcpO3ZhciB0RD1XLmV4cG9ydHM7Y29uc3QgZUQ9TCh0RCk7dmFyIEZEPWZ1bmN0aW9uKCl7cmV0dXJuL1xcdUQ4M0NcXHVERkY0XFx1REI0MFxcdURDNjdcXHVEQjQwXFx1REM2Mig/OlxcdURCNDBcXHVEQzc3XFx1REI0MFxcdURDNkNcXHVEQjQwXFx1REM3M3xcXHVEQjQwXFx1REM3M1xcdURCNDBcXHVEQzYzXFx1REI0MFxcdURDNzR8XFx1REI0MFxcdURDNjVcXHVEQjQwXFx1REM2RVxcdURCNDBcXHVEQzY3KVxcdURCNDBcXHVEQzdGfCg/OlxcdUQ4M0VcXHVEREQxXFx1RDgzQ1xcdURGRkZcXHUyMDBEXFx1Mjc2NFxcdUZFMEZcXHUyMDBEKD86XFx1RDgzRFxcdURDOEJcXHUyMDBEKT9cXHVEODNFXFx1REREMXxcXHVEODNEXFx1REM2OVxcdUQ4M0NcXHVERkZGXFx1MjAwRFxcdUQ4M0VcXHVERDFEXFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2OFxcdURDNjldKSkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRV0pfCg/OlxcdUQ4M0VcXHVEREQxXFx1RDgzQ1xcdURGRkVcXHUyMDBEXFx1Mjc2NFxcdUZFMEZcXHUyMDBEKD86XFx1RDgzRFxcdURDOEJcXHUyMDBEKT9cXHVEODNFXFx1REREMXxcXHVEODNEXFx1REM2OVxcdUQ4M0NcXHVERkZFXFx1MjAwRFxcdUQ4M0VcXHVERDFEXFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2OFxcdURDNjldKSkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRFxcdURGRkZdKXwoPzpcXHVEODNFXFx1REREMVxcdUQ4M0NcXHVERkZEXFx1MjAwRFxcdTI3NjRcXHVGRTBGXFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzhCXFx1MjAwRCk/XFx1RDgzRVxcdURERDF8XFx1RDgzRFxcdURDNjlcXHVEODNDXFx1REZGRFxcdTIwMERcXHVEODNFXFx1REQxRFxcdTIwMEQoPzpcXHVEODNEW1xcdURDNjhcXHVEQzY5XSkpKD86XFx1RDgzQ1tcXHVERkZCXFx1REZGQ1xcdURGRkVcXHVERkZGXSl8KD86XFx1RDgzRVxcdURERDFcXHVEODNDXFx1REZGQ1xcdTIwMERcXHUyNzY0XFx1RkUwRlxcdTIwMEQoPzpcXHVEODNEXFx1REM4QlxcdTIwMEQpP1xcdUQ4M0VcXHVEREQxfFxcdUQ4M0RcXHVEQzY5XFx1RDgzQ1xcdURGRkNcXHUyMDBEXFx1RDgzRVxcdUREMURcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pKSg/OlxcdUQ4M0NbXFx1REZGQlxcdURGRkQtXFx1REZGRl0pfCg/OlxcdUQ4M0VcXHVEREQxXFx1RDgzQ1xcdURGRkJcXHUyMDBEXFx1Mjc2NFxcdUZFMEZcXHUyMDBEKD86XFx1RDgzRFxcdURDOEJcXHUyMDBEKT9cXHVEODNFXFx1REREMXxcXHVEODNEXFx1REM2OVxcdUQ4M0NcXHVERkZCXFx1MjAwRFxcdUQ4M0VcXHVERDFEXFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2OFxcdURDNjldKSkoPzpcXHVEODNDW1xcdURGRkMtXFx1REZGRl0pfFxcdUQ4M0RcXHVEQzY4KD86XFx1RDgzQ1xcdURGRkIoPzpcXHUyMDBEKD86XFx1Mjc2NFxcdUZFMEZcXHUyMDBEKD86XFx1RDgzRFxcdURDOEJcXHUyMDBEXFx1RDgzRFxcdURDNjgoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfFxcdUQ4M0RcXHVEQzY4KD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKSl8XFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjgoPzpcXHVEODNDW1xcdURGRkMtXFx1REZGRl0pfFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRnxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pKT98KD86XFx1RDgzQ1tcXHVERkZDLVxcdURGRkZdKVxcdTIwMERcXHUyNzY0XFx1RkUwRlxcdTIwMEQoPzpcXHVEODNEXFx1REM4QlxcdTIwMERcXHVEODNEXFx1REM2OCg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSl8XFx1RDgzRFxcdURDNjgoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pKXxcXHUyMDBEKD86XFx1Mjc2NFxcdUZFMEZcXHUyMDBEKD86XFx1RDgzRFxcdURDOEJcXHUyMDBEKT9cXHVEODNEXFx1REM2OHwoPzpcXHVEODNEW1xcdURDNjhcXHVEQzY5XSlcXHUyMDBEKD86XFx1RDgzRFxcdURDNjZcXHUyMDBEXFx1RDgzRFxcdURDNjZ8XFx1RDgzRFxcdURDNjdcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY2XFx1REM2N10pKXxcXHVEODNEXFx1REM2NlxcdTIwMERcXHVEODNEXFx1REM2NnxcXHVEODNEXFx1REM2N1xcdTIwMEQoPzpcXHVEODNEW1xcdURDNjZcXHVEQzY3XSl8XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXxcXHVEODNDXFx1REZGRlxcdTIwMEQoPzpcXHVEODNFXFx1REQxRFxcdTIwMERcXHVEODNEXFx1REM2OCg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZFXSl8XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXxcXHVEODNDXFx1REZGRVxcdTIwMEQoPzpcXHVEODNFXFx1REQxRFxcdTIwMERcXHVEODNEXFx1REM2OCg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZEXFx1REZGRl0pfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1xcdURGRkRcXHUyMDBEKD86XFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjgoPzpcXHVEODNDW1xcdURGRkJcXHVERkZDXFx1REZGRVxcdURGRkZdKXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdUQ4M0NcXHVERkZDXFx1MjAwRCg/OlxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY4KD86XFx1RDgzQ1tcXHVERkZCXFx1REZGRC1cXHVERkZGXSl8XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXwoPzpcXHVEODNDXFx1REZGRlxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHVEODNDXFx1REZGRVxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHVEODNDXFx1REZGRFxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHVEODNDXFx1REZGQ1xcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF0pXFx1RkUwRnxcXHUyMDBEKD86KD86XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pXFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2NlxcdURDNjddKXxcXHVEODNEW1xcdURDNjZcXHVEQzY3XSl8XFx1RDgzQ1xcdURGRkZ8XFx1RDgzQ1xcdURGRkV8XFx1RDgzQ1xcdURGRkR8XFx1RDgzQ1xcdURGRkMpP3woPzpcXHVEODNEXFx1REM2OSg/OlxcdUQ4M0NcXHVERkZCXFx1MjAwRFxcdTI3NjRcXHVGRTBGXFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzhCXFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2OFxcdURDNjldKXxcXHVEODNEW1xcdURDNjhcXHVEQzY5XSl8KD86XFx1RDgzQ1tcXHVERkZDLVxcdURGRkZdKVxcdTIwMERcXHUyNzY0XFx1RkUwRlxcdTIwMEQoPzpcXHVEODNEXFx1REM4QlxcdTIwMEQoPzpcXHVEODNEW1xcdURDNjhcXHVEQzY5XSl8XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pKXxcXHVEODNFXFx1REREMSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSlcXHUyMDBEXFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRVxcdURERDEpKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKXxcXHVEODNEXFx1REM2OVxcdTIwMERcXHVEODNEXFx1REM2OVxcdTIwMEQoPzpcXHVEODNEXFx1REM2NlxcdTIwMERcXHVEODNEXFx1REM2NnxcXHVEODNEXFx1REM2N1xcdTIwMEQoPzpcXHVEODNEW1xcdURDNjZcXHVEQzY3XSkpfFxcdUQ4M0RcXHVEQzY5KD86XFx1MjAwRCg/OlxcdTI3NjRcXHVGRTBGXFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzhCXFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2OFxcdURDNjldKXxcXHVEODNEW1xcdURDNjhcXHVEQzY5XSl8XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXxcXHVEODNDXFx1REZGRlxcdTIwMEQoPzpcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdUQ4M0NcXHVERkZFXFx1MjAwRCg/OlxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1xcdURGRkRcXHUyMDBEKD86XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXxcXHVEODNDXFx1REZGQ1xcdTIwMEQoPzpcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdUQ4M0NcXHVERkZCXFx1MjAwRCg/OlxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSkpfFxcdUQ4M0VcXHVEREQxKD86XFx1MjAwRCg/OlxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0VcXHVEREQxfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY4NFxcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdUQ4M0NcXHVERkZGXFx1MjAwRCg/OlxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY4NFxcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdUQ4M0NcXHVERkZFXFx1MjAwRCg/OlxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY4NFxcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdUQ4M0NcXHVERkZEXFx1MjAwRCg/OlxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY4NFxcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdUQ4M0NcXHVERkZDXFx1MjAwRCg/OlxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY4NFxcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdUQ4M0NcXHVERkZCXFx1MjAwRCg/OlxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY4NFxcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pKXxcXHVEODNEXFx1REM2OVxcdTIwMERcXHVEODNEXFx1REM2NlxcdTIwMERcXHVEODNEXFx1REM2NnxcXHVEODNEXFx1REM2OVxcdTIwMERcXHVEODNEXFx1REM2OVxcdTIwMEQoPzpcXHVEODNEW1xcdURDNjZcXHVEQzY3XSl8XFx1RDgzRFxcdURDNjlcXHUyMDBEXFx1RDgzRFxcdURDNjdcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY2XFx1REM2N10pfCg/OlxcdUQ4M0RcXHVEQzQxXFx1RkUwRlxcdTIwMERcXHVEODNEXFx1RERFOHxcXHVEODNFXFx1REREMSg/OlxcdUQ4M0NcXHVERkZGXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdUQ4M0NcXHVERkZFXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdUQ4M0NcXHVERkZEXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdUQ4M0NcXHVERkZDXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdUQ4M0NcXHVERkZCXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XSl8XFx1RDgzRFxcdURDNjkoPzpcXHVEODNDXFx1REZGRlxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHVEODNDXFx1REZGRVxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHVEODNDXFx1REZGRFxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHVEODNDXFx1REZGQ1xcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHVEODNDXFx1REZGQlxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF0pfFxcdUQ4M0RcXHVERTM2XFx1MjAwRFxcdUQ4M0NcXHVERjJCfFxcdUQ4M0NcXHVERkYzXFx1RkUwRlxcdTIwMERcXHUyNkE3fFxcdUQ4M0RcXHVEQzNCXFx1MjAwRFxcdTI3NDR8KD86KD86XFx1RDgzQ1tcXHVERkMzXFx1REZDNFxcdURGQ0FdfFxcdUQ4M0RbXFx1REM2RVxcdURDNzBcXHVEQzcxXFx1REM3M1xcdURDNzdcXHVEQzgxXFx1REM4MlxcdURDODZcXHVEQzg3XFx1REU0NS1cXHVERTQ3XFx1REU0QlxcdURFNERcXHVERTRFXFx1REVBM1xcdURFQjQtXFx1REVCNl18XFx1RDgzRVtcXHVERDI2XFx1REQzNVxcdUREMzctXFx1REQzOVxcdUREM0RcXHVERDNFXFx1RERCOFxcdUREQjlcXHVERENELVxcdUREQ0ZcXHVEREQ0XFx1RERENi1cXHVEREREXSkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfFxcdUQ4M0RcXHVEQzZGfFxcdUQ4M0VbXFx1REQzQ1xcdUREREVcXHVERERGXSlcXHUyMDBEW1xcdTI2NDBcXHUyNjQyXXwoPzpcXHUyNkY5fFxcdUQ4M0NbXFx1REZDQlxcdURGQ0NdfFxcdUQ4M0RcXHVERDc1KSg/OlxcdUZFMEZ8XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKVxcdTIwMERbXFx1MjY0MFxcdTI2NDJdfFxcdUQ4M0NcXHVERkY0XFx1MjAwRFxcdTI2MjB8KD86XFx1RDgzQ1tcXHVERkMzXFx1REZDNFxcdURGQ0FdfFxcdUQ4M0RbXFx1REM2RVxcdURDNzBcXHVEQzcxXFx1REM3M1xcdURDNzdcXHVEQzgxXFx1REM4MlxcdURDODZcXHVEQzg3XFx1REU0NS1cXHVERTQ3XFx1REU0QlxcdURFNERcXHVERTRFXFx1REVBM1xcdURFQjQtXFx1REVCNl18XFx1RDgzRVtcXHVERDI2XFx1REQzNVxcdUREMzctXFx1REQzOVxcdUREM0RcXHVERDNFXFx1RERCOFxcdUREQjlcXHVERENELVxcdUREQ0ZcXHVEREQ0XFx1RERENi1cXHVEREREXSlcXHUyMDBEW1xcdTI2NDBcXHUyNjQyXXxbXFx4QTlcXHhBRVxcdTIwM0NcXHUyMDQ5XFx1MjEyMlxcdTIxMzlcXHUyMTk0LVxcdTIxOTlcXHUyMUE5XFx1MjFBQVxcdTIzMjhcXHUyM0NGXFx1MjNFRC1cXHUyM0VGXFx1MjNGMVxcdTIzRjJcXHUyM0Y4LVxcdTIzRkFcXHUyNEMyXFx1MjVBQVxcdTI1QUJcXHUyNUI2XFx1MjVDMFxcdTI1RkJcXHUyNUZDXFx1MjYwMC1cXHUyNjA0XFx1MjYwRVxcdTI2MTFcXHUyNjE4XFx1MjYyMFxcdTI2MjJcXHUyNjIzXFx1MjYyNlxcdTI2MkFcXHUyNjJFXFx1MjYyRlxcdTI2MzgtXFx1MjYzQVxcdTI2NDBcXHUyNjQyXFx1MjY1RlxcdTI2NjBcXHUyNjYzXFx1MjY2NVxcdTI2NjZcXHUyNjY4XFx1MjY3QlxcdTI2N0VcXHUyNjkyXFx1MjY5NC1cXHUyNjk3XFx1MjY5OVxcdTI2OUJcXHUyNjlDXFx1MjZBMFxcdTI2QTdcXHUyNkIwXFx1MjZCMVxcdTI2QzhcXHUyNkNGXFx1MjZEMVxcdTI2RDNcXHUyNkU5XFx1MjZGMFxcdTI2RjFcXHUyNkY0XFx1MjZGN1xcdTI2RjhcXHUyNzAyXFx1MjcwOFxcdTI3MDlcXHUyNzBGXFx1MjcxMlxcdTI3MTRcXHUyNzE2XFx1MjcxRFxcdTI3MjFcXHUyNzMzXFx1MjczNFxcdTI3NDRcXHUyNzQ3XFx1Mjc2M1xcdTI3QTFcXHUyOTM0XFx1MjkzNVxcdTJCMDUtXFx1MkIwN1xcdTMwMzBcXHUzMDNEXFx1MzI5N1xcdTMyOTldfFxcdUQ4M0NbXFx1REQ3MFxcdURENzFcXHVERDdFXFx1REQ3RlxcdURFMDJcXHVERTM3XFx1REYyMVxcdURGMjQtXFx1REYyQ1xcdURGMzZcXHVERjdEXFx1REY5NlxcdURGOTdcXHVERjk5LVxcdURGOUJcXHVERjlFXFx1REY5RlxcdURGQ0RcXHVERkNFXFx1REZENC1cXHVERkRGXFx1REZGNVxcdURGRjddfFxcdUQ4M0RbXFx1REMzRlxcdURDRkRcXHVERDQ5XFx1REQ0QVxcdURENkZcXHVERDcwXFx1REQ3M1xcdURENzYtXFx1REQ3OVxcdUREODdcXHVERDhBLVxcdUREOERcXHVEREE1XFx1RERBOFxcdUREQjFcXHVEREIyXFx1RERCQ1xcdUREQzItXFx1RERDNFxcdURERDEtXFx1REREM1xcdUREREMtXFx1RERERVxcdURERTFcXHVEREUzXFx1RERFOFxcdURERUZcXHVEREYzXFx1RERGQVxcdURFQ0JcXHVERUNELVxcdURFQ0ZcXHVERUUwLVxcdURFRTVcXHVERUU5XFx1REVGMFxcdURFRjNdKVxcdUZFMEZ8XFx1RDgzQ1xcdURGRjNcXHVGRTBGXFx1MjAwRFxcdUQ4M0NcXHVERjA4fFxcdUQ4M0RcXHVEQzY5XFx1MjAwRFxcdUQ4M0RcXHVEQzY3fFxcdUQ4M0RcXHVEQzY5XFx1MjAwRFxcdUQ4M0RcXHVEQzY2fFxcdUQ4M0RcXHVERTM1XFx1MjAwRFxcdUQ4M0RcXHVEQ0FCfFxcdUQ4M0RcXHVERTJFXFx1MjAwRFxcdUQ4M0RcXHVEQ0E4fFxcdUQ4M0RcXHVEQzE1XFx1MjAwRFxcdUQ4M0VcXHVEREJBfFxcdUQ4M0VcXHVEREQxKD86XFx1RDgzQ1xcdURGRkZ8XFx1RDgzQ1xcdURGRkV8XFx1RDgzQ1xcdURGRkR8XFx1RDgzQ1xcdURGRkN8XFx1RDgzQ1xcdURGRkIpP3xcXHVEODNEXFx1REM2OSg/OlxcdUQ4M0NcXHVERkZGfFxcdUQ4M0NcXHVERkZFfFxcdUQ4M0NcXHVERkZEfFxcdUQ4M0NcXHVERkZDfFxcdUQ4M0NcXHVERkZCKT98XFx1RDgzQ1xcdURERkRcXHVEODNDXFx1RERGMHxcXHVEODNDXFx1RERGNlxcdUQ4M0NcXHVEREU2fFxcdUQ4M0NcXHVEREY0XFx1RDgzQ1xcdURERjJ8XFx1RDgzRFxcdURDMDhcXHUyMDBEXFx1MkIxQnxcXHUyNzY0XFx1RkUwRlxcdTIwMEQoPzpcXHVEODNEXFx1REQyNXxcXHVEODNFXFx1REU3OSl8XFx1RDgzRFxcdURDNDFcXHVGRTBGfFxcdUQ4M0NcXHVERkYzXFx1RkUwRnxcXHVEODNDXFx1RERGRig/OlxcdUQ4M0NbXFx1RERFNlxcdURERjJcXHVEREZDXSl8XFx1RDgzQ1xcdURERkUoPzpcXHVEODNDW1xcdURERUFcXHVEREY5XSl8XFx1RDgzQ1xcdURERkMoPzpcXHVEODNDW1xcdURERUJcXHVEREY4XSl8XFx1RDgzQ1xcdURERkIoPzpcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFQVxcdURERUNcXHVEREVFXFx1RERGM1xcdURERkFdKXxcXHVEODNDXFx1RERGQSg/OlxcdUQ4M0NbXFx1RERFNlxcdURERUNcXHVEREYyXFx1RERGM1xcdURERjhcXHVEREZFXFx1RERGRl0pfFxcdUQ4M0NcXHVEREY5KD86XFx1RDgzQ1tcXHVEREU2XFx1RERFOFxcdURERTlcXHVEREVCLVxcdURERURcXHVEREVGLVxcdURERjRcXHVEREY3XFx1RERGOVxcdURERkJcXHVEREZDXFx1RERGRl0pfFxcdUQ4M0NcXHVEREY4KD86XFx1RDgzQ1tcXHVEREU2LVxcdURERUFcXHVEREVDLVxcdURERjRcXHVEREY3LVxcdURERjlcXHVEREZCXFx1RERGRC1cXHVEREZGXSl8XFx1RDgzQ1xcdURERjcoPzpcXHVEODNDW1xcdURERUFcXHVEREY0XFx1RERGOFxcdURERkFcXHVEREZDXSl8XFx1RDgzQ1xcdURERjUoPzpcXHVEODNDW1xcdURERTZcXHVEREVBLVxcdURERURcXHVEREYwLVxcdURERjNcXHVEREY3LVxcdURERjlcXHVEREZDXFx1RERGRV0pfFxcdUQ4M0NcXHVEREYzKD86XFx1RDgzQ1tcXHVEREU2XFx1RERFOFxcdURERUEtXFx1RERFQ1xcdURERUVcXHVEREYxXFx1RERGNFxcdURERjVcXHVEREY3XFx1RERGQVxcdURERkZdKXxcXHVEODNDXFx1RERGMig/OlxcdUQ4M0NbXFx1RERFNlxcdURERTgtXFx1RERFRFxcdURERjAtXFx1RERGRl0pfFxcdUQ4M0NcXHVEREYxKD86XFx1RDgzQ1tcXHVEREU2LVxcdURERThcXHVEREVFXFx1RERGMFxcdURERjctXFx1RERGQlxcdURERkVdKXxcXHVEODNDXFx1RERGMCg/OlxcdUQ4M0NbXFx1RERFQVxcdURERUMtXFx1RERFRVxcdURERjJcXHVEREYzXFx1RERGNVxcdURERjdcXHVEREZDXFx1RERGRVxcdURERkZdKXxcXHVEODNDXFx1RERFRig/OlxcdUQ4M0NbXFx1RERFQVxcdURERjJcXHVEREY0XFx1RERGNV0pfFxcdUQ4M0NcXHVEREVFKD86XFx1RDgzQ1tcXHVEREU4LVxcdURERUFcXHVEREYxLVxcdURERjRcXHVEREY2LVxcdURERjldKXxcXHVEODNDXFx1RERFRCg/OlxcdUQ4M0NbXFx1RERGMFxcdURERjJcXHVEREYzXFx1RERGN1xcdURERjlcXHVEREZBXSl8XFx1RDgzQ1xcdURERUMoPzpcXHVEODNDW1xcdURERTZcXHVEREU3XFx1RERFOS1cXHVEREVFXFx1RERGMS1cXHVEREYzXFx1RERGNS1cXHVEREZBXFx1RERGQ1xcdURERkVdKXxcXHVEODNDXFx1RERFQig/OlxcdUQ4M0NbXFx1RERFRS1cXHVEREYwXFx1RERGMlxcdURERjRcXHVEREY3XSl8XFx1RDgzQ1xcdURERUEoPzpcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFQVxcdURERUNcXHVEREVEXFx1RERGNy1cXHVEREZBXSl8XFx1RDgzQ1xcdURERTkoPzpcXHVEODNDW1xcdURERUFcXHVEREVDXFx1RERFRlxcdURERjBcXHVEREYyXFx1RERGNFxcdURERkZdKXxcXHVEODNDXFx1RERFOCg/OlxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREU5XFx1RERFQi1cXHVEREVFXFx1RERGMC1cXHVEREY1XFx1RERGN1xcdURERkEtXFx1RERGRl0pfFxcdUQ4M0NcXHVEREU3KD86XFx1RDgzQ1tcXHVEREU2XFx1RERFN1xcdURERTktXFx1RERFRlxcdURERjEtXFx1RERGNFxcdURERjYtXFx1RERGOVxcdURERkJcXHVEREZDXFx1RERGRVxcdURERkZdKXxcXHVEODNDXFx1RERFNig/OlxcdUQ4M0NbXFx1RERFOC1cXHVEREVDXFx1RERFRVxcdURERjFcXHVEREYyXFx1RERGNFxcdURERjYtXFx1RERGQVxcdURERkNcXHVEREZEXFx1RERGRl0pfFsjXFwqMC05XVxcdUZFMEZcXHUyMEUzfFxcdTI3NjRcXHVGRTBGfCg/OlxcdUQ4M0NbXFx1REZDM1xcdURGQzRcXHVERkNBXXxcXHVEODNEW1xcdURDNkVcXHVEQzcwXFx1REM3MVxcdURDNzNcXHVEQzc3XFx1REM4MVxcdURDODJcXHVEQzg2XFx1REM4N1xcdURFNDUtXFx1REU0N1xcdURFNEJcXHVERTREXFx1REU0RVxcdURFQTNcXHVERUI0LVxcdURFQjZdfFxcdUQ4M0VbXFx1REQyNlxcdUREMzVcXHVERDM3LVxcdUREMzlcXHVERDNEXFx1REQzRVxcdUREQjhcXHVEREI5XFx1RERDRC1cXHVERENGXFx1RERENFxcdURERDYtXFx1RERERF0pKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKXwoPzpcXHUyNkY5fFxcdUQ4M0NbXFx1REZDQlxcdURGQ0NdfFxcdUQ4M0RcXHVERDc1KSg/OlxcdUZFMEZ8XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKXxcXHVEODNDXFx1REZGNHwoPzpbXFx1MjcwQVxcdTI3MEJdfFxcdUQ4M0NbXFx1REY4NVxcdURGQzJcXHVERkM3XXxcXHVEODNEW1xcdURDNDJcXHVEQzQzXFx1REM0Ni1cXHVEQzUwXFx1REM2NlxcdURDNjdcXHVEQzZCLVxcdURDNkRcXHVEQzcyXFx1REM3NC1cXHVEQzc2XFx1REM3OFxcdURDN0NcXHVEQzgzXFx1REM4NVxcdURDOEZcXHVEQzkxXFx1RENBQVxcdUREN0FcXHVERDk1XFx1REQ5NlxcdURFNENcXHVERTRGXFx1REVDMFxcdURFQ0NdfFxcdUQ4M0VbXFx1REQwQ1xcdUREMEZcXHVERDE4LVxcdUREMUNcXHVERDFFXFx1REQxRlxcdUREMzAtXFx1REQzNFxcdUREMzZcXHVERDc3XFx1RERCNVxcdUREQjZcXHVEREJCXFx1REREMlxcdURERDNcXHVEREQ1XSkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfCg/OltcXHUyNjFEXFx1MjcwQ1xcdTI3MERdfFxcdUQ4M0RbXFx1REQ3NFxcdUREOTBdKSg/OlxcdUZFMEZ8XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKXxbXFx1MjcwQVxcdTI3MEJdfFxcdUQ4M0NbXFx1REY4NVxcdURGQzJcXHVERkM3XXxcXHVEODNEW1xcdURDMDhcXHVEQzE1XFx1REMzQlxcdURDNDJcXHVEQzQzXFx1REM0Ni1cXHVEQzUwXFx1REM2NlxcdURDNjdcXHVEQzZCLVxcdURDNkRcXHVEQzcyXFx1REM3NC1cXHVEQzc2XFx1REM3OFxcdURDN0NcXHVEQzgzXFx1REM4NVxcdURDOEZcXHVEQzkxXFx1RENBQVxcdUREN0FcXHVERDk1XFx1REQ5NlxcdURFMkVcXHVERTM1XFx1REUzNlxcdURFNENcXHVERTRGXFx1REVDMFxcdURFQ0NdfFxcdUQ4M0VbXFx1REQwQ1xcdUREMEZcXHVERDE4LVxcdUREMUNcXHVERDFFXFx1REQxRlxcdUREMzAtXFx1REQzNFxcdUREMzZcXHVERDc3XFx1RERCNVxcdUREQjZcXHVEREJCXFx1REREMlxcdURERDNcXHVEREQ1XXxcXHVEODNDW1xcdURGQzNcXHVERkM0XFx1REZDQV18XFx1RDgzRFtcXHVEQzZFXFx1REM3MFxcdURDNzFcXHVEQzczXFx1REM3N1xcdURDODFcXHVEQzgyXFx1REM4NlxcdURDODdcXHVERTQ1LVxcdURFNDdcXHVERTRCXFx1REU0RFxcdURFNEVcXHVERUEzXFx1REVCNC1cXHVERUI2XXxcXHVEODNFW1xcdUREMjZcXHVERDM1XFx1REQzNy1cXHVERDM5XFx1REQzRFxcdUREM0VcXHVEREI4XFx1RERCOVxcdUREQ0QtXFx1RERDRlxcdURERDRcXHVEREQ2LVxcdURERERdfFxcdUQ4M0RcXHVEQzZGfFxcdUQ4M0VbXFx1REQzQ1xcdUREREVcXHVERERGXXxbXFx1MjMxQVxcdTIzMUJcXHUyM0U5LVxcdTIzRUNcXHUyM0YwXFx1MjNGM1xcdTI1RkRcXHUyNUZFXFx1MjYxNFxcdTI2MTVcXHUyNjQ4LVxcdTI2NTNcXHUyNjdGXFx1MjY5M1xcdTI2QTFcXHUyNkFBXFx1MjZBQlxcdTI2QkRcXHUyNkJFXFx1MjZDNFxcdTI2QzVcXHUyNkNFXFx1MjZENFxcdTI2RUFcXHUyNkYyXFx1MjZGM1xcdTI2RjVcXHUyNkZBXFx1MjZGRFxcdTI3MDVcXHUyNzI4XFx1Mjc0Q1xcdTI3NEVcXHUyNzUzLVxcdTI3NTVcXHUyNzU3XFx1Mjc5NS1cXHUyNzk3XFx1MjdCMFxcdTI3QkZcXHUyQjFCXFx1MkIxQ1xcdTJCNTBcXHUyQjU1XXxcXHVEODNDW1xcdURDMDRcXHVEQ0NGXFx1REQ4RVxcdUREOTEtXFx1REQ5QVxcdURFMDFcXHVERTFBXFx1REUyRlxcdURFMzItXFx1REUzNlxcdURFMzgtXFx1REUzQVxcdURFNTBcXHVERTUxXFx1REYwMC1cXHVERjIwXFx1REYyRC1cXHVERjM1XFx1REYzNy1cXHVERjdDXFx1REY3RS1cXHVERjg0XFx1REY4Ni1cXHVERjkzXFx1REZBMC1cXHVERkMxXFx1REZDNVxcdURGQzZcXHVERkM4XFx1REZDOVxcdURGQ0YtXFx1REZEM1xcdURGRTAtXFx1REZGMFxcdURGRjgtXFx1REZGRl18XFx1RDgzRFtcXHVEQzAwLVxcdURDMDdcXHVEQzA5LVxcdURDMTRcXHVEQzE2LVxcdURDM0FcXHVEQzNDLVxcdURDM0VcXHVEQzQwXFx1REM0NFxcdURDNDVcXHVEQzUxLVxcdURDNjVcXHVEQzZBXFx1REM3OS1cXHVEQzdCXFx1REM3RC1cXHVEQzgwXFx1REM4NFxcdURDODgtXFx1REM4RVxcdURDOTBcXHVEQzkyLVxcdURDQTlcXHVEQ0FCLVxcdURDRkNcXHVEQ0ZGLVxcdUREM0RcXHVERDRCLVxcdURENEVcXHVERDUwLVxcdURENjdcXHVEREE0XFx1RERGQi1cXHVERTJEXFx1REUyRi1cXHVERTM0XFx1REUzNy1cXHVERTQ0XFx1REU0OC1cXHVERTRBXFx1REU4MC1cXHVERUEyXFx1REVBNC1cXHVERUIzXFx1REVCNy1cXHVERUJGXFx1REVDMS1cXHVERUM1XFx1REVEMC1cXHVERUQyXFx1REVENS1cXHVERUQ3XFx1REVFQlxcdURFRUNcXHVERUY0LVxcdURFRkNcXHVERkUwLVxcdURGRUJdfFxcdUQ4M0VbXFx1REQwRFxcdUREMEVcXHVERDEwLVxcdUREMTdcXHVERDFEXFx1REQyMC1cXHVERDI1XFx1REQyNy1cXHVERDJGXFx1REQzQVxcdUREM0YtXFx1REQ0NVxcdURENDctXFx1REQ3NlxcdURENzhcXHVERDdBLVxcdUREQjRcXHVEREI3XFx1RERCQVxcdUREQkMtXFx1RERDQlxcdURERDBcXHVEREUwLVxcdURERkZcXHVERTcwLVxcdURFNzRcXHVERTc4LVxcdURFN0FcXHVERTgwLVxcdURFODZcXHVERTkwLVxcdURFQThcXHVERUIwLVxcdURFQjZcXHVERUMwLVxcdURFQzJcXHVERUQwLVxcdURFRDZdfCg/OltcXHUyMzFBXFx1MjMxQlxcdTIzRTktXFx1MjNFQ1xcdTIzRjBcXHUyM0YzXFx1MjVGRFxcdTI1RkVcXHUyNjE0XFx1MjYxNVxcdTI2NDgtXFx1MjY1M1xcdTI2N0ZcXHUyNjkzXFx1MjZBMVxcdTI2QUFcXHUyNkFCXFx1MjZCRFxcdTI2QkVcXHUyNkM0XFx1MjZDNVxcdTI2Q0VcXHUyNkQ0XFx1MjZFQVxcdTI2RjJcXHUyNkYzXFx1MjZGNVxcdTI2RkFcXHUyNkZEXFx1MjcwNVxcdTI3MEFcXHUyNzBCXFx1MjcyOFxcdTI3NENcXHUyNzRFXFx1Mjc1My1cXHUyNzU1XFx1Mjc1N1xcdTI3OTUtXFx1Mjc5N1xcdTI3QjBcXHUyN0JGXFx1MkIxQlxcdTJCMUNcXHUyQjUwXFx1MkI1NV18XFx1RDgzQ1tcXHVEQzA0XFx1RENDRlxcdUREOEVcXHVERDkxLVxcdUREOUFcXHVEREU2LVxcdURERkZcXHVERTAxXFx1REUxQVxcdURFMkZcXHVERTMyLVxcdURFMzZcXHVERTM4LVxcdURFM0FcXHVERTUwXFx1REU1MVxcdURGMDAtXFx1REYyMFxcdURGMkQtXFx1REYzNVxcdURGMzctXFx1REY3Q1xcdURGN0UtXFx1REY5M1xcdURGQTAtXFx1REZDQVxcdURGQ0YtXFx1REZEM1xcdURGRTAtXFx1REZGMFxcdURGRjRcXHVERkY4LVxcdURGRkZdfFxcdUQ4M0RbXFx1REMwMC1cXHVEQzNFXFx1REM0MFxcdURDNDItXFx1RENGQ1xcdURDRkYtXFx1REQzRFxcdURENEItXFx1REQ0RVxcdURENTAtXFx1REQ2N1xcdUREN0FcXHVERDk1XFx1REQ5NlxcdUREQTRcXHVEREZCLVxcdURFNEZcXHVERTgwLVxcdURFQzVcXHVERUNDXFx1REVEMC1cXHVERUQyXFx1REVENS1cXHVERUQ3XFx1REVFQlxcdURFRUNcXHVERUY0LVxcdURFRkNcXHVERkUwLVxcdURGRUJdfFxcdUQ4M0VbXFx1REQwQy1cXHVERDNBXFx1REQzQy1cXHVERDQ1XFx1REQ0Ny1cXHVERDc4XFx1REQ3QS1cXHVERENCXFx1RERDRC1cXHVEREZGXFx1REU3MC1cXHVERTc0XFx1REU3OC1cXHVERTdBXFx1REU4MC1cXHVERTg2XFx1REU5MC1cXHVERUE4XFx1REVCMC1cXHVERUI2XFx1REVDMC1cXHVERUMyXFx1REVEMC1cXHVERUQ2XSl8KD86WyNcXCowLTlcXHhBOVxceEFFXFx1MjAzQ1xcdTIwNDlcXHUyMTIyXFx1MjEzOVxcdTIxOTQtXFx1MjE5OVxcdTIxQTlcXHUyMUFBXFx1MjMxQVxcdTIzMUJcXHUyMzI4XFx1MjNDRlxcdTIzRTktXFx1MjNGM1xcdTIzRjgtXFx1MjNGQVxcdTI0QzJcXHUyNUFBXFx1MjVBQlxcdTI1QjZcXHUyNUMwXFx1MjVGQi1cXHUyNUZFXFx1MjYwMC1cXHUyNjA0XFx1MjYwRVxcdTI2MTFcXHUyNjE0XFx1MjYxNVxcdTI2MThcXHUyNjFEXFx1MjYyMFxcdTI2MjJcXHUyNjIzXFx1MjYyNlxcdTI2MkFcXHUyNjJFXFx1MjYyRlxcdTI2MzgtXFx1MjYzQVxcdTI2NDBcXHUyNjQyXFx1MjY0OC1cXHUyNjUzXFx1MjY1RlxcdTI2NjBcXHUyNjYzXFx1MjY2NVxcdTI2NjZcXHUyNjY4XFx1MjY3QlxcdTI2N0VcXHUyNjdGXFx1MjY5Mi1cXHUyNjk3XFx1MjY5OVxcdTI2OUJcXHUyNjlDXFx1MjZBMFxcdTI2QTFcXHUyNkE3XFx1MjZBQVxcdTI2QUJcXHUyNkIwXFx1MjZCMVxcdTI2QkRcXHUyNkJFXFx1MjZDNFxcdTI2QzVcXHUyNkM4XFx1MjZDRVxcdTI2Q0ZcXHUyNkQxXFx1MjZEM1xcdTI2RDRcXHUyNkU5XFx1MjZFQVxcdTI2RjAtXFx1MjZGNVxcdTI2RjctXFx1MjZGQVxcdTI2RkRcXHUyNzAyXFx1MjcwNVxcdTI3MDgtXFx1MjcwRFxcdTI3MEZcXHUyNzEyXFx1MjcxNFxcdTI3MTZcXHUyNzFEXFx1MjcyMVxcdTI3MjhcXHUyNzMzXFx1MjczNFxcdTI3NDRcXHUyNzQ3XFx1Mjc0Q1xcdTI3NEVcXHUyNzUzLVxcdTI3NTVcXHUyNzU3XFx1Mjc2M1xcdTI3NjRcXHUyNzk1LVxcdTI3OTdcXHUyN0ExXFx1MjdCMFxcdTI3QkZcXHUyOTM0XFx1MjkzNVxcdTJCMDUtXFx1MkIwN1xcdTJCMUJcXHUyQjFDXFx1MkI1MFxcdTJCNTVcXHUzMDMwXFx1MzAzRFxcdTMyOTdcXHUzMjk5XXxcXHVEODNDW1xcdURDMDRcXHVEQ0NGXFx1REQ3MFxcdURENzFcXHVERDdFXFx1REQ3RlxcdUREOEVcXHVERDkxLVxcdUREOUFcXHVEREU2LVxcdURERkZcXHVERTAxXFx1REUwMlxcdURFMUFcXHVERTJGXFx1REUzMi1cXHVERTNBXFx1REU1MFxcdURFNTFcXHVERjAwLVxcdURGMjFcXHVERjI0LVxcdURGOTNcXHVERjk2XFx1REY5N1xcdURGOTktXFx1REY5QlxcdURGOUUtXFx1REZGMFxcdURGRjMtXFx1REZGNVxcdURGRjctXFx1REZGRl18XFx1RDgzRFtcXHVEQzAwLVxcdURDRkRcXHVEQ0ZGLVxcdUREM0RcXHVERDQ5LVxcdURENEVcXHVERDUwLVxcdURENjdcXHVERDZGXFx1REQ3MFxcdURENzMtXFx1REQ3QVxcdUREODdcXHVERDhBLVxcdUREOERcXHVERDkwXFx1REQ5NVxcdUREOTZcXHVEREE0XFx1RERBNVxcdUREQThcXHVEREIxXFx1RERCMlxcdUREQkNcXHVEREMyLVxcdUREQzRcXHVEREQxLVxcdURERDNcXHVERERDLVxcdUREREVcXHVEREUxXFx1RERFM1xcdURERThcXHVEREVGXFx1RERGM1xcdURERkEtXFx1REU0RlxcdURFODAtXFx1REVDNVxcdURFQ0ItXFx1REVEMlxcdURFRDUtXFx1REVEN1xcdURFRTAtXFx1REVFNVxcdURFRTlcXHVERUVCXFx1REVFQ1xcdURFRjBcXHVERUYzLVxcdURFRkNcXHVERkUwLVxcdURGRUJdfFxcdUQ4M0VbXFx1REQwQy1cXHVERDNBXFx1REQzQy1cXHVERDQ1XFx1REQ0Ny1cXHVERDc4XFx1REQ3QS1cXHVERENCXFx1RERDRC1cXHVEREZGXFx1REU3MC1cXHVERTc0XFx1REU3OC1cXHVERTdBXFx1REU4MC1cXHVERTg2XFx1REU5MC1cXHVERUE4XFx1REVCMC1cXHVERUI2XFx1REVDMC1cXHVERUMyXFx1REVEMC1cXHVERUQ2XSlcXHVGRTBGfCg/OltcXHUyNjFEXFx1MjZGOVxcdTI3MEEtXFx1MjcwRF18XFx1RDgzQ1tcXHVERjg1XFx1REZDMi1cXHVERkM0XFx1REZDN1xcdURGQ0EtXFx1REZDQ118XFx1RDgzRFtcXHVEQzQyXFx1REM0M1xcdURDNDYtXFx1REM1MFxcdURDNjYtXFx1REM3OFxcdURDN0NcXHVEQzgxLVxcdURDODNcXHVEQzg1LVxcdURDODdcXHVEQzhGXFx1REM5MVxcdURDQUFcXHVERDc0XFx1REQ3NVxcdUREN0FcXHVERDkwXFx1REQ5NVxcdUREOTZcXHVERTQ1LVxcdURFNDdcXHVERTRCLVxcdURFNEZcXHVERUEzXFx1REVCNC1cXHVERUI2XFx1REVDMFxcdURFQ0NdfFxcdUQ4M0VbXFx1REQwQ1xcdUREMEZcXHVERDE4LVxcdUREMUZcXHVERDI2XFx1REQzMC1cXHVERDM5XFx1REQzQy1cXHVERDNFXFx1REQ3N1xcdUREQjVcXHVEREI2XFx1RERCOFxcdUREQjlcXHVEREJCXFx1RERDRC1cXHVERENGXFx1REREMS1cXHVEREREXSkvZ307Y29uc3Qgc0Q9TChGRCk7ZnVuY3Rpb24gcChlLHU9e30pe2lmKHR5cGVvZiBlIT1cInN0cmluZ1wifHxlLmxlbmd0aD09PTB8fCh1PXthbWJpZ3VvdXNJc05hcnJvdzohMCwuLi51fSxlPVAoZSksZS5sZW5ndGg9PT0wKSlyZXR1cm4gMDtlPWUucmVwbGFjZShzRCgpLFwiICBcIik7Y29uc3QgdD11LmFtYmlndW91c0lzTmFycm93PzE6MjtsZXQgRj0wO2Zvcihjb25zdCBzIG9mIGUpe2NvbnN0IGk9cy5jb2RlUG9pbnRBdCgwKTtpZihpPD0zMXx8aT49MTI3JiZpPD0xNTl8fGk+PTc2OCYmaTw9ODc5KWNvbnRpbnVlO3N3aXRjaChlRC5lYXN0QXNpYW5XaWR0aChzKSl7Y2FzZVwiRlwiOmNhc2VcIldcIjpGKz0yO2JyZWFrO2Nhc2VcIkFcIjpGKz10O2JyZWFrO2RlZmF1bHQ6Ris9MX19cmV0dXJuIEZ9Y29uc3Qgdz0xMCxOPShlPTApPT51PT5gXFx4MUJbJHt1K2V9bWAsST0oZT0wKT0+dT0+YFxceDFCWyR7MzgrZX07NTske3V9bWAsUj0oZT0wKT0+KHUsdCxGKT0+YFxceDFCWyR7MzgrZX07Mjske3V9OyR7dH07JHtGfW1gLHI9e21vZGlmaWVyOntyZXNldDpbMCwwXSxib2xkOlsxLDIyXSxkaW06WzIsMjJdLGl0YWxpYzpbMywyM10sdW5kZXJsaW5lOls0LDI0XSxvdmVybGluZTpbNTMsNTVdLGludmVyc2U6WzcsMjddLGhpZGRlbjpbOCwyOF0sc3RyaWtldGhyb3VnaDpbOSwyOV19LGNvbG9yOntibGFjazpbMzAsMzldLHJlZDpbMzEsMzldLGdyZWVuOlszMiwzOV0seWVsbG93OlszMywzOV0sYmx1ZTpbMzQsMzldLG1hZ2VudGE6WzM1LDM5XSxjeWFuOlszNiwzOV0sd2hpdGU6WzM3LDM5XSxibGFja0JyaWdodDpbOTAsMzldLGdyYXk6WzkwLDM5XSxncmV5Ols5MCwzOV0scmVkQnJpZ2h0Ols5MSwzOV0sZ3JlZW5CcmlnaHQ6WzkyLDM5XSx5ZWxsb3dCcmlnaHQ6WzkzLDM5XSxibHVlQnJpZ2h0Ols5NCwzOV0sbWFnZW50YUJyaWdodDpbOTUsMzldLGN5YW5CcmlnaHQ6Wzk2LDM5XSx3aGl0ZUJyaWdodDpbOTcsMzldfSxiZ0NvbG9yOntiZ0JsYWNrOls0MCw0OV0sYmdSZWQ6WzQxLDQ5XSxiZ0dyZWVuOls0Miw0OV0sYmdZZWxsb3c6WzQzLDQ5XSxiZ0JsdWU6WzQ0LDQ5XSxiZ01hZ2VudGE6WzQ1LDQ5XSxiZ0N5YW46WzQ2LDQ5XSxiZ1doaXRlOls0Nyw0OV0sYmdCbGFja0JyaWdodDpbMTAwLDQ5XSxiZ0dyYXk6WzEwMCw0OV0sYmdHcmV5OlsxMDAsNDldLGJnUmVkQnJpZ2h0OlsxMDEsNDldLGJnR3JlZW5CcmlnaHQ6WzEwMiw0OV0sYmdZZWxsb3dCcmlnaHQ6WzEwMyw0OV0sYmdCbHVlQnJpZ2h0OlsxMDQsNDldLGJnTWFnZW50YUJyaWdodDpbMTA1LDQ5XSxiZ0N5YW5CcmlnaHQ6WzEwNiw0OV0sYmdXaGl0ZUJyaWdodDpbMTA3LDQ5XX19O09iamVjdC5rZXlzKHIubW9kaWZpZXIpO2NvbnN0IGlEPU9iamVjdC5rZXlzKHIuY29sb3IpLENEPU9iamVjdC5rZXlzKHIuYmdDb2xvcik7Wy4uLmlELC4uLkNEXTtmdW5jdGlvbiByRCgpe2NvbnN0IGU9bmV3IE1hcDtmb3IoY29uc3RbdSx0XW9mIE9iamVjdC5lbnRyaWVzKHIpKXtmb3IoY29uc3RbRixzXW9mIE9iamVjdC5lbnRyaWVzKHQpKXJbRl09e29wZW46YFxceDFCWyR7c1swXX1tYCxjbG9zZTpgXFx4MUJbJHtzWzFdfW1gfSx0W0ZdPXJbRl0sZS5zZXQoc1swXSxzWzFdKTtPYmplY3QuZGVmaW5lUHJvcGVydHkocix1LHt2YWx1ZTp0LGVudW1lcmFibGU6ITF9KX1yZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJjb2Rlc1wiLHt2YWx1ZTplLGVudW1lcmFibGU6ITF9KSxyLmNvbG9yLmNsb3NlPVwiXFx4MUJbMzltXCIsci5iZ0NvbG9yLmNsb3NlPVwiXFx4MUJbNDltXCIsci5jb2xvci5hbnNpPU4oKSxyLmNvbG9yLmFuc2kyNTY9SSgpLHIuY29sb3IuYW5zaTE2bT1SKCksci5iZ0NvbG9yLmFuc2k9Tih3KSxyLmJnQ29sb3IuYW5zaTI1Nj1JKHcpLHIuYmdDb2xvci5hbnNpMTZtPVIodyksT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocix7cmdiVG9BbnNpMjU2Ont2YWx1ZToodSx0LEYpPT51PT09dCYmdD09PUY/dTw4PzE2OnU+MjQ4PzIzMTpNYXRoLnJvdW5kKCh1LTgpLzI0NyoyNCkrMjMyOjE2KzM2Kk1hdGgucm91bmQodS8yNTUqNSkrNipNYXRoLnJvdW5kKHQvMjU1KjUpK01hdGgucm91bmQoRi8yNTUqNSksZW51bWVyYWJsZTohMX0saGV4VG9SZ2I6e3ZhbHVlOnU9Pntjb25zdCB0PS9bYS1mXFxkXXs2fXxbYS1mXFxkXXszfS9pLmV4ZWModS50b1N0cmluZygxNikpO2lmKCF0KXJldHVyblswLDAsMF07bGV0W0ZdPXQ7Ri5sZW5ndGg9PT0zJiYoRj1bLi4uRl0ubWFwKGk9PmkraSkuam9pbihcIlwiKSk7Y29uc3Qgcz1OdW1iZXIucGFyc2VJbnQoRiwxNik7cmV0dXJuW3M+PjE2JjI1NSxzPj44JjI1NSxzJjI1NV19LGVudW1lcmFibGU6ITF9LGhleFRvQW5zaTI1Njp7dmFsdWU6dT0+ci5yZ2JUb0Fuc2kyNTYoLi4uci5oZXhUb1JnYih1KSksZW51bWVyYWJsZTohMX0sYW5zaTI1NlRvQW5zaTp7dmFsdWU6dT0+e2lmKHU8OClyZXR1cm4gMzArdTtpZih1PDE2KXJldHVybiA5MCsodS04KTtsZXQgdCxGLHM7aWYodT49MjMyKXQ9KCh1LTIzMikqMTArOCkvMjU1LEY9dCxzPXQ7ZWxzZXt1LT0xNjtjb25zdCBDPXUlMzY7dD1NYXRoLmZsb29yKHUvMzYpLzUsRj1NYXRoLmZsb29yKEMvNikvNSxzPUMlNi81fWNvbnN0IGk9TWF0aC5tYXgodCxGLHMpKjI7aWYoaT09PTApcmV0dXJuIDMwO2xldCBEPTMwKyhNYXRoLnJvdW5kKHMpPDwyfE1hdGgucm91bmQoRik8PDF8TWF0aC5yb3VuZCh0KSk7cmV0dXJuIGk9PT0yJiYoRCs9NjApLER9LGVudW1lcmFibGU6ITF9LHJnYlRvQW5zaTp7dmFsdWU6KHUsdCxGKT0+ci5hbnNpMjU2VG9BbnNpKHIucmdiVG9BbnNpMjU2KHUsdCxGKSksZW51bWVyYWJsZTohMX0saGV4VG9BbnNpOnt2YWx1ZTp1PT5yLmFuc2kyNTZUb0Fuc2koci5oZXhUb0Fuc2kyNTYodSkpLGVudW1lcmFibGU6ITF9fSkscn1jb25zdCBFRD1yRCgpLGQ9bmV3IFNldChbXCJcXHgxQlwiLFwiXFx4OUJcIl0pLG9EPTM5LHk9XCJcXHgwN1wiLFY9XCJbXCIsbkQ9XCJdXCIsRz1cIm1cIixfPWAke25EfTg7O2Asej1lPT5gJHtkLnZhbHVlcygpLm5leHQoKS52YWx1ZX0ke1Z9JHtlfSR7R31gLEs9ZT0+YCR7ZC52YWx1ZXMoKS5uZXh0KCkudmFsdWV9JHtffSR7ZX0ke3l9YCxhRD1lPT5lLnNwbGl0KFwiIFwiKS5tYXAodT0+cCh1KSksaz0oZSx1LHQpPT57Y29uc3QgRj1bLi4udV07bGV0IHM9ITEsaT0hMSxEPXAoUChlW2UubGVuZ3RoLTFdKSk7Zm9yKGNvbnN0W0Msbl1vZiBGLmVudHJpZXMoKSl7Y29uc3QgRT1wKG4pO2lmKEQrRTw9dD9lW2UubGVuZ3RoLTFdKz1uOihlLnB1c2gobiksRD0wKSxkLmhhcyhuKSYmKHM9ITAsaT1GLnNsaWNlKEMrMSkuam9pbihcIlwiKS5zdGFydHNXaXRoKF8pKSxzKXtpP249PT15JiYocz0hMSxpPSExKTpuPT09RyYmKHM9ITEpO2NvbnRpbnVlfUQrPUUsRD09PXQmJkM8Ri5sZW5ndGgtMSYmKGUucHVzaChcIlwiKSxEPTApfSFEJiZlW2UubGVuZ3RoLTFdLmxlbmd0aD4wJiZlLmxlbmd0aD4xJiYoZVtlLmxlbmd0aC0yXSs9ZS5wb3AoKSl9LGhEPWU9Pntjb25zdCB1PWUuc3BsaXQoXCIgXCIpO2xldCB0PXUubGVuZ3RoO2Zvcig7dD4wJiYhKHAodVt0LTFdKT4wKTspdC0tO3JldHVybiB0PT09dS5sZW5ndGg/ZTp1LnNsaWNlKDAsdCkuam9pbihcIiBcIikrdS5zbGljZSh0KS5qb2luKFwiXCIpfSxsRD0oZSx1LHQ9e30pPT57aWYodC50cmltIT09ITEmJmUudHJpbSgpPT09XCJcIilyZXR1cm5cIlwiO2xldCBGPVwiXCIscyxpO2NvbnN0IEQ9YUQoZSk7bGV0IEM9W1wiXCJdO2Zvcihjb25zdFtFLGFdb2YgZS5zcGxpdChcIiBcIikuZW50cmllcygpKXt0LnRyaW0hPT0hMSYmKENbQy5sZW5ndGgtMV09Q1tDLmxlbmd0aC0xXS50cmltU3RhcnQoKSk7bGV0IG89cChDW0MubGVuZ3RoLTFdKTtpZihFIT09MCYmKG8+PXUmJih0LndvcmRXcmFwPT09ITF8fHQudHJpbT09PSExKSYmKEMucHVzaChcIlwiKSxvPTApLChvPjB8fHQudHJpbT09PSExKSYmKENbQy5sZW5ndGgtMV0rPVwiIFwiLG8rKykpLHQuaGFyZCYmRFtFXT51KXtjb25zdCBjPXUtbyxmPTErTWF0aC5mbG9vcigoRFtFXS1jLTEpL3UpO01hdGguZmxvb3IoKERbRV0tMSkvdSk8ZiYmQy5wdXNoKFwiXCIpLGsoQyxhLHUpO2NvbnRpbnVlfWlmKG8rRFtFXT51JiZvPjAmJkRbRV0+MCl7aWYodC53b3JkV3JhcD09PSExJiZvPHUpe2soQyxhLHUpO2NvbnRpbnVlfUMucHVzaChcIlwiKX1pZihvK0RbRV0+dSYmdC53b3JkV3JhcD09PSExKXtrKEMsYSx1KTtjb250aW51ZX1DW0MubGVuZ3RoLTFdKz1hfXQudHJpbSE9PSExJiYoQz1DLm1hcChFPT5oRChFKSkpO2NvbnN0IG49Wy4uLkMuam9pbihgXG5gKV07Zm9yKGNvbnN0W0UsYV1vZiBuLmVudHJpZXMoKSl7aWYoRis9YSxkLmhhcyhhKSl7Y29uc3R7Z3JvdXBzOmN9PW5ldyBSZWdFeHAoYCg/OlxcXFwke1Z9KD88Y29kZT5cXFxcZCspbXxcXFxcJHtffSg/PHVyaT4uKikke3l9KWApLmV4ZWMobi5zbGljZShFKS5qb2luKFwiXCIpKXx8e2dyb3Vwczp7fX07aWYoYy5jb2RlIT09dm9pZCAwKXtjb25zdCBmPU51bWJlci5wYXJzZUZsb2F0KGMuY29kZSk7cz1mPT09b0Q/dm9pZCAwOmZ9ZWxzZSBjLnVyaSE9PXZvaWQgMCYmKGk9Yy51cmkubGVuZ3RoPT09MD92b2lkIDA6Yy51cmkpfWNvbnN0IG89RUQuY29kZXMuZ2V0KE51bWJlcihzKSk7bltFKzFdPT09YFxuYD8oaSYmKEYrPUsoXCJcIikpLHMmJm8mJihGKz16KG8pKSk6YT09PWBcbmAmJihzJiZvJiYoRis9eihzKSksaSYmKEYrPUsoaSkpKX1yZXR1cm4gRn07ZnVuY3Rpb24gWShlLHUsdCl7cmV0dXJuIFN0cmluZyhlKS5ub3JtYWxpemUoKS5yZXBsYWNlKC9cXHJcXG4vZyxgXG5gKS5zcGxpdChgXG5gKS5tYXAoRj0+bEQoRix1LHQpKS5qb2luKGBcbmApfWNvbnN0IHhEPVtcInVwXCIsXCJkb3duXCIsXCJsZWZ0XCIsXCJyaWdodFwiLFwic3BhY2VcIixcImVudGVyXCIsXCJjYW5jZWxcIl0sQj17YWN0aW9uczpuZXcgU2V0KHhEKSxhbGlhc2VzOm5ldyBNYXAoW1tcImtcIixcInVwXCJdLFtcImpcIixcImRvd25cIl0sW1wiaFwiLFwibGVmdFwiXSxbXCJsXCIsXCJyaWdodFwiXSxbXCJcdTAwMDNcIixcImNhbmNlbFwiXSxbXCJlc2NhcGVcIixcImNhbmNlbFwiXV0pfTtmdW5jdGlvbiBjRChlKXtmb3IoY29uc3QgdSBpbiBlKXtjb25zdCB0PXU7aWYoIU9iamVjdC5oYXNPd24oZSx0KSljb250aW51ZTtjb25zdCBGPWVbdF07c3dpdGNoKHQpe2Nhc2VcImFsaWFzZXNcIjp7Zm9yKGNvbnN0IHMgaW4gRilPYmplY3QuaGFzT3duKEYscykmJihCLmFsaWFzZXMuaGFzKHMpfHxCLmFsaWFzZXMuc2V0KHMsRltzXSkpO2JyZWFrfX19fWZ1bmN0aW9uICQoZSx1KXtpZih0eXBlb2YgZT09XCJzdHJpbmdcIilyZXR1cm4gQi5hbGlhc2VzLmdldChlKT09PXU7Zm9yKGNvbnN0IHQgb2YgZSlpZih0IT09dm9pZCAwJiYkKHQsdSkpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gQkQoZSx1KXtpZihlPT09dSlyZXR1cm47Y29uc3QgdD1lLnNwbGl0KGBcbmApLEY9dS5zcGxpdChgXG5gKSxzPVtdO2ZvcihsZXQgaT0wO2k8TWF0aC5tYXgodC5sZW5ndGgsRi5sZW5ndGgpO2krKyl0W2ldIT09RltpXSYmcy5wdXNoKGkpO3JldHVybiBzfWNvbnN0IEFEPWdsb2JhbFRoaXMucHJvY2Vzcy5wbGF0Zm9ybS5zdGFydHNXaXRoKFwid2luXCIpLFM9U3ltYm9sKFwiY2xhY2s6Y2FuY2VsXCIpO2Z1bmN0aW9uIHBEKGUpe3JldHVybiBlPT09U31mdW5jdGlvbiBtKGUsdSl7Y29uc3QgdD1lO3QuaXNUVFkmJnQuc2V0UmF3TW9kZSh1KX1mdW5jdGlvbiBmRCh7aW5wdXQ6ZT1qLG91dHB1dDp1PU0sb3ZlcndyaXRlOnQ9ITAsaGlkZUN1cnNvcjpGPSEwfT17fSl7Y29uc3Qgcz1nLmNyZWF0ZUludGVyZmFjZSh7aW5wdXQ6ZSxvdXRwdXQ6dSxwcm9tcHQ6XCJcIix0YWJTaXplOjF9KTtnLmVtaXRLZXlwcmVzc0V2ZW50cyhlLHMpLGUuaXNUVFkmJmUuc2V0UmF3TW9kZSghMCk7Y29uc3QgaT0oRCx7bmFtZTpDLHNlcXVlbmNlOm59KT0+e2NvbnN0IEU9U3RyaW5nKEQpO2lmKCQoW0UsQyxuXSxcImNhbmNlbFwiKSl7RiYmdS53cml0ZShsLnNob3cpLHByb2Nlc3MuZXhpdCgwKTtyZXR1cm59aWYoIXQpcmV0dXJuO2NvbnN0IGE9Qz09PVwicmV0dXJuXCI/MDotMSxvPUM9PT1cInJldHVyblwiPy0xOjA7Zy5tb3ZlQ3Vyc29yKHUsYSxvLCgpPT57Zy5jbGVhckxpbmUodSwxLCgpPT57ZS5vbmNlKFwia2V5cHJlc3NcIixpKX0pfSl9O3JldHVybiBGJiZ1LndyaXRlKGwuaGlkZSksZS5vbmNlKFwia2V5cHJlc3NcIixpKSwoKT0+e2Uub2ZmKFwia2V5cHJlc3NcIixpKSxGJiZ1LndyaXRlKGwuc2hvdyksZS5pc1RUWSYmIUFEJiZlLnNldFJhd01vZGUoITEpLHMudGVybWluYWw9ITEscy5jbG9zZSgpfX12YXIgZ0Q9T2JqZWN0LmRlZmluZVByb3BlcnR5LHZEPShlLHUsdCk9PnUgaW4gZT9nRChlLHUse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnR9KTplW3VdPXQsaD0oZSx1LHQpPT4odkQoZSx0eXBlb2YgdSE9XCJzeW1ib2xcIj91K1wiXCI6dSx0KSx0KTtjbGFzcyB4e2NvbnN0cnVjdG9yKHUsdD0hMCl7aCh0aGlzLFwiaW5wdXRcIiksaCh0aGlzLFwib3V0cHV0XCIpLGgodGhpcyxcIl9hYm9ydFNpZ25hbFwiKSxoKHRoaXMsXCJybFwiKSxoKHRoaXMsXCJvcHRzXCIpLGgodGhpcyxcIl9yZW5kZXJcIiksaCh0aGlzLFwiX3RyYWNrXCIsITEpLGgodGhpcyxcIl9wcmV2RnJhbWVcIixcIlwiKSxoKHRoaXMsXCJfc3Vic2NyaWJlcnNcIixuZXcgTWFwKSxoKHRoaXMsXCJfY3Vyc29yXCIsMCksaCh0aGlzLFwic3RhdGVcIixcImluaXRpYWxcIiksaCh0aGlzLFwiZXJyb3JcIixcIlwiKSxoKHRoaXMsXCJ2YWx1ZVwiKTtjb25zdHtpbnB1dDpGPWosb3V0cHV0OnM9TSxyZW5kZXI6aSxzaWduYWw6RCwuLi5DfT11O3RoaXMub3B0cz1DLHRoaXMub25LZXlwcmVzcz10aGlzLm9uS2V5cHJlc3MuYmluZCh0aGlzKSx0aGlzLmNsb3NlPXRoaXMuY2xvc2UuYmluZCh0aGlzKSx0aGlzLnJlbmRlcj10aGlzLnJlbmRlci5iaW5kKHRoaXMpLHRoaXMuX3JlbmRlcj1pLmJpbmQodGhpcyksdGhpcy5fdHJhY2s9dCx0aGlzLl9hYm9ydFNpZ25hbD1ELHRoaXMuaW5wdXQ9Rix0aGlzLm91dHB1dD1zfXVuc3Vic2NyaWJlKCl7dGhpcy5fc3Vic2NyaWJlcnMuY2xlYXIoKX1zZXRTdWJzY3JpYmVyKHUsdCl7Y29uc3QgRj10aGlzLl9zdWJzY3JpYmVycy5nZXQodSk/P1tdO0YucHVzaCh0KSx0aGlzLl9zdWJzY3JpYmVycy5zZXQodSxGKX1vbih1LHQpe3RoaXMuc2V0U3Vic2NyaWJlcih1LHtjYjp0fSl9b25jZSh1LHQpe3RoaXMuc2V0U3Vic2NyaWJlcih1LHtjYjp0LG9uY2U6ITB9KX1lbWl0KHUsLi4udCl7Y29uc3QgRj10aGlzLl9zdWJzY3JpYmVycy5nZXQodSk/P1tdLHM9W107Zm9yKGNvbnN0IGkgb2YgRilpLmNiKC4uLnQpLGkub25jZSYmcy5wdXNoKCgpPT5GLnNwbGljZShGLmluZGV4T2YoaSksMSkpO2Zvcihjb25zdCBpIG9mIHMpaSgpfXByb21wdCgpe3JldHVybiBuZXcgUHJvbWlzZSgodSx0KT0+e2lmKHRoaXMuX2Fib3J0U2lnbmFsKXtpZih0aGlzLl9hYm9ydFNpZ25hbC5hYm9ydGVkKXJldHVybiB0aGlzLnN0YXRlPVwiY2FuY2VsXCIsdGhpcy5jbG9zZSgpLHUoUyk7dGhpcy5fYWJvcnRTaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsKCk9Pnt0aGlzLnN0YXRlPVwiY2FuY2VsXCIsdGhpcy5jbG9zZSgpfSx7b25jZTohMH0pfWNvbnN0IEY9bmV3IFg7Ri5fd3JpdGU9KHMsaSxEKT0+e3RoaXMuX3RyYWNrJiYodGhpcy52YWx1ZT10aGlzLnJsPy5saW5lLnJlcGxhY2UoL1xcdC9nLFwiXCIpLHRoaXMuX2N1cnNvcj10aGlzLnJsPy5jdXJzb3I/PzAsdGhpcy5lbWl0KFwidmFsdWVcIix0aGlzLnZhbHVlKSksRCgpfSx0aGlzLmlucHV0LnBpcGUoRiksdGhpcy5ybD1PLmNyZWF0ZUludGVyZmFjZSh7aW5wdXQ6dGhpcy5pbnB1dCxvdXRwdXQ6Rix0YWJTaXplOjIscHJvbXB0OlwiXCIsZXNjYXBlQ29kZVRpbWVvdXQ6NTAsdGVybWluYWw6ITB9KSxPLmVtaXRLZXlwcmVzc0V2ZW50cyh0aGlzLmlucHV0LHRoaXMucmwpLHRoaXMucmwucHJvbXB0KCksdGhpcy5vcHRzLmluaXRpYWxWYWx1ZSE9PXZvaWQgMCYmdGhpcy5fdHJhY2smJnRoaXMucmwud3JpdGUodGhpcy5vcHRzLmluaXRpYWxWYWx1ZSksdGhpcy5pbnB1dC5vbihcImtleXByZXNzXCIsdGhpcy5vbktleXByZXNzKSxtKHRoaXMuaW5wdXQsITApLHRoaXMub3V0cHV0Lm9uKFwicmVzaXplXCIsdGhpcy5yZW5kZXIpLHRoaXMucmVuZGVyKCksdGhpcy5vbmNlKFwic3VibWl0XCIsKCk9Pnt0aGlzLm91dHB1dC53cml0ZShsLnNob3cpLHRoaXMub3V0cHV0Lm9mZihcInJlc2l6ZVwiLHRoaXMucmVuZGVyKSxtKHRoaXMuaW5wdXQsITEpLHUodGhpcy52YWx1ZSl9KSx0aGlzLm9uY2UoXCJjYW5jZWxcIiwoKT0+e3RoaXMub3V0cHV0LndyaXRlKGwuc2hvdyksdGhpcy5vdXRwdXQub2ZmKFwicmVzaXplXCIsdGhpcy5yZW5kZXIpLG0odGhpcy5pbnB1dCwhMSksdShTKX0pfSl9b25LZXlwcmVzcyh1LHQpe2lmKHRoaXMuc3RhdGU9PT1cImVycm9yXCImJih0aGlzLnN0YXRlPVwiYWN0aXZlXCIpLHQ/Lm5hbWUmJighdGhpcy5fdHJhY2smJkIuYWxpYXNlcy5oYXModC5uYW1lKSYmdGhpcy5lbWl0KFwiY3Vyc29yXCIsQi5hbGlhc2VzLmdldCh0Lm5hbWUpKSxCLmFjdGlvbnMuaGFzKHQubmFtZSkmJnRoaXMuZW1pdChcImN1cnNvclwiLHQubmFtZSkpLHUmJih1LnRvTG93ZXJDYXNlKCk9PT1cInlcInx8dS50b0xvd2VyQ2FzZSgpPT09XCJuXCIpJiZ0aGlzLmVtaXQoXCJjb25maXJtXCIsdS50b0xvd2VyQ2FzZSgpPT09XCJ5XCIpLHU9PT1cIlx0XCImJnRoaXMub3B0cy5wbGFjZWhvbGRlciYmKHRoaXMudmFsdWV8fCh0aGlzLnJsPy53cml0ZSh0aGlzLm9wdHMucGxhY2Vob2xkZXIpLHRoaXMuZW1pdChcInZhbHVlXCIsdGhpcy5vcHRzLnBsYWNlaG9sZGVyKSkpLHUmJnRoaXMuZW1pdChcImtleVwiLHUudG9Mb3dlckNhc2UoKSksdD8ubmFtZT09PVwicmV0dXJuXCIpe2lmKHRoaXMub3B0cy52YWxpZGF0ZSl7Y29uc3QgRj10aGlzLm9wdHMudmFsaWRhdGUodGhpcy52YWx1ZSk7RiYmKHRoaXMuZXJyb3I9RiBpbnN0YW5jZW9mIEVycm9yP0YubWVzc2FnZTpGLHRoaXMuc3RhdGU9XCJlcnJvclwiLHRoaXMucmw/LndyaXRlKHRoaXMudmFsdWUpKX10aGlzLnN0YXRlIT09XCJlcnJvclwiJiYodGhpcy5zdGF0ZT1cInN1Ym1pdFwiKX0kKFt1LHQ/Lm5hbWUsdD8uc2VxdWVuY2VdLFwiY2FuY2VsXCIpJiYodGhpcy5zdGF0ZT1cImNhbmNlbFwiKSwodGhpcy5zdGF0ZT09PVwic3VibWl0XCJ8fHRoaXMuc3RhdGU9PT1cImNhbmNlbFwiKSYmdGhpcy5lbWl0KFwiZmluYWxpemVcIiksdGhpcy5yZW5kZXIoKSwodGhpcy5zdGF0ZT09PVwic3VibWl0XCJ8fHRoaXMuc3RhdGU9PT1cImNhbmNlbFwiKSYmdGhpcy5jbG9zZSgpfWNsb3NlKCl7dGhpcy5pbnB1dC51bnBpcGUoKSx0aGlzLmlucHV0LnJlbW92ZUxpc3RlbmVyKFwia2V5cHJlc3NcIix0aGlzLm9uS2V5cHJlc3MpLHRoaXMub3V0cHV0LndyaXRlKGBcbmApLG0odGhpcy5pbnB1dCwhMSksdGhpcy5ybD8uY2xvc2UoKSx0aGlzLnJsPXZvaWQgMCx0aGlzLmVtaXQoYCR7dGhpcy5zdGF0ZX1gLHRoaXMudmFsdWUpLHRoaXMudW5zdWJzY3JpYmUoKX1yZXN0b3JlQ3Vyc29yKCl7Y29uc3QgdT1ZKHRoaXMuX3ByZXZGcmFtZSxwcm9jZXNzLnN0ZG91dC5jb2x1bW5zLHtoYXJkOiEwfSkuc3BsaXQoYFxuYCkubGVuZ3RoLTE7dGhpcy5vdXRwdXQud3JpdGUobC5tb3ZlKC05OTksdSotMSkpfXJlbmRlcigpe2NvbnN0IHU9WSh0aGlzLl9yZW5kZXIodGhpcyk/P1wiXCIscHJvY2Vzcy5zdGRvdXQuY29sdW1ucyx7aGFyZDohMH0pO2lmKHUhPT10aGlzLl9wcmV2RnJhbWUpe2lmKHRoaXMuc3RhdGU9PT1cImluaXRpYWxcIil0aGlzLm91dHB1dC53cml0ZShsLmhpZGUpO2Vsc2V7Y29uc3QgdD1CRCh0aGlzLl9wcmV2RnJhbWUsdSk7aWYodGhpcy5yZXN0b3JlQ3Vyc29yKCksdCYmdD8ubGVuZ3RoPT09MSl7Y29uc3QgRj10WzBdO3RoaXMub3V0cHV0LndyaXRlKGwubW92ZSgwLEYpKSx0aGlzLm91dHB1dC53cml0ZShiLmxpbmVzKDEpKTtjb25zdCBzPXUuc3BsaXQoYFxuYCk7dGhpcy5vdXRwdXQud3JpdGUoc1tGXSksdGhpcy5fcHJldkZyYW1lPXUsdGhpcy5vdXRwdXQud3JpdGUobC5tb3ZlKDAscy5sZW5ndGgtRi0xKSk7cmV0dXJufWlmKHQmJnQ/Lmxlbmd0aD4xKXtjb25zdCBGPXRbMF07dGhpcy5vdXRwdXQud3JpdGUobC5tb3ZlKDAsRikpLHRoaXMub3V0cHV0LndyaXRlKGIuZG93bigpKTtjb25zdCBzPXUuc3BsaXQoYFxuYCkuc2xpY2UoRik7dGhpcy5vdXRwdXQud3JpdGUocy5qb2luKGBcbmApKSx0aGlzLl9wcmV2RnJhbWU9dTtyZXR1cm59dGhpcy5vdXRwdXQud3JpdGUoYi5kb3duKCkpfXRoaXMub3V0cHV0LndyaXRlKHUpLHRoaXMuc3RhdGU9PT1cImluaXRpYWxcIiYmKHRoaXMuc3RhdGU9XCJhY3RpdmVcIiksdGhpcy5fcHJldkZyYW1lPXV9fX1jbGFzcyBkRCBleHRlbmRzIHh7Z2V0IGN1cnNvcigpe3JldHVybiB0aGlzLnZhbHVlPzA6MX1nZXQgX3ZhbHVlKCl7cmV0dXJuIHRoaXMuY3Vyc29yPT09MH1jb25zdHJ1Y3Rvcih1KXtzdXBlcih1LCExKSx0aGlzLnZhbHVlPSEhdS5pbml0aWFsVmFsdWUsdGhpcy5vbihcInZhbHVlXCIsKCk9Pnt0aGlzLnZhbHVlPXRoaXMuX3ZhbHVlfSksdGhpcy5vbihcImNvbmZpcm1cIix0PT57dGhpcy5vdXRwdXQud3JpdGUobC5tb3ZlKDAsLTEpKSx0aGlzLnZhbHVlPXQsdGhpcy5zdGF0ZT1cInN1Ym1pdFwiLHRoaXMuY2xvc2UoKX0pLHRoaXMub24oXCJjdXJzb3JcIiwoKT0+e3RoaXMudmFsdWU9IXRoaXMudmFsdWV9KX19dmFyIG1EPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSxiRD0oZSx1LHQpPT51IGluIGU/bUQoZSx1LHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp0fSk6ZVt1XT10LFo9KGUsdSx0KT0+KGJEKGUsdHlwZW9mIHUhPVwic3ltYm9sXCI/dStcIlwiOnUsdCksdCkscT0oZSx1LHQpPT57aWYoIXUuaGFzKGUpKXRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBcIit0KX0sVD0oZSx1LHQpPT4ocShlLHUsXCJyZWFkIGZyb20gcHJpdmF0ZSBmaWVsZFwiKSx0P3QuY2FsbChlKTp1LmdldChlKSksd0Q9KGUsdSx0KT0+e2lmKHUuaGFzKGUpKXRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIik7dSBpbnN0YW5jZW9mIFdlYWtTZXQ/dS5hZGQoZSk6dS5zZXQoZSx0KX0seUQ9KGUsdSx0LEYpPT4ocShlLHUsXCJ3cml0ZSB0byBwcml2YXRlIGZpZWxkXCIpLEY/Ri5jYWxsKGUsdCk6dS5zZXQoZSx0KSx0KSxBO2xldCBfRD1jbGFzcyBleHRlbmRzIHh7Y29uc3RydWN0b3IodSl7c3VwZXIodSwhMSksWih0aGlzLFwib3B0aW9uc1wiKSxaKHRoaXMsXCJjdXJzb3JcIiwwKSx3RCh0aGlzLEEsdm9pZCAwKTtjb25zdHtvcHRpb25zOnR9PXU7eUQodGhpcyxBLHUuc2VsZWN0YWJsZUdyb3VwcyE9PSExKSx0aGlzLm9wdGlvbnM9T2JqZWN0LmVudHJpZXModCkuZmxhdE1hcCgoW0Ysc10pPT5be3ZhbHVlOkYsZ3JvdXA6ITAsbGFiZWw6Rn0sLi4ucy5tYXAoaT0+KHsuLi5pLGdyb3VwOkZ9KSldKSx0aGlzLnZhbHVlPVsuLi51LmluaXRpYWxWYWx1ZXM/P1tdXSx0aGlzLmN1cnNvcj1NYXRoLm1heCh0aGlzLm9wdGlvbnMuZmluZEluZGV4KCh7dmFsdWU6Rn0pPT5GPT09dS5jdXJzb3JBdCksVCh0aGlzLEEpPzA6MSksdGhpcy5vbihcImN1cnNvclwiLEY9Pntzd2l0Y2goRil7Y2FzZVwibGVmdFwiOmNhc2VcInVwXCI6e3RoaXMuY3Vyc29yPXRoaXMuY3Vyc29yPT09MD90aGlzLm9wdGlvbnMubGVuZ3RoLTE6dGhpcy5jdXJzb3ItMTtjb25zdCBzPXRoaXMub3B0aW9uc1t0aGlzLmN1cnNvcl0/Lmdyb3VwPT09ITA7IVQodGhpcyxBKSYmcyYmKHRoaXMuY3Vyc29yPXRoaXMuY3Vyc29yPT09MD90aGlzLm9wdGlvbnMubGVuZ3RoLTE6dGhpcy5jdXJzb3ItMSk7YnJlYWt9Y2FzZVwiZG93blwiOmNhc2VcInJpZ2h0XCI6e3RoaXMuY3Vyc29yPXRoaXMuY3Vyc29yPT09dGhpcy5vcHRpb25zLmxlbmd0aC0xPzA6dGhpcy5jdXJzb3IrMTtjb25zdCBzPXRoaXMub3B0aW9uc1t0aGlzLmN1cnNvcl0/Lmdyb3VwPT09ITA7IVQodGhpcyxBKSYmcyYmKHRoaXMuY3Vyc29yPXRoaXMuY3Vyc29yPT09dGhpcy5vcHRpb25zLmxlbmd0aC0xPzA6dGhpcy5jdXJzb3IrMSk7YnJlYWt9Y2FzZVwic3BhY2VcIjp0aGlzLnRvZ2dsZVZhbHVlKCk7YnJlYWt9fSl9Z2V0R3JvdXBJdGVtcyh1KXtyZXR1cm4gdGhpcy5vcHRpb25zLmZpbHRlcih0PT50Lmdyb3VwPT09dSl9aXNHcm91cFNlbGVjdGVkKHUpe3JldHVybiB0aGlzLmdldEdyb3VwSXRlbXModSkuZXZlcnkodD0+dGhpcy52YWx1ZS5pbmNsdWRlcyh0LnZhbHVlKSl9dG9nZ2xlVmFsdWUoKXtjb25zdCB1PXRoaXMub3B0aW9uc1t0aGlzLmN1cnNvcl07aWYodS5ncm91cD09PSEwKXtjb25zdCB0PXUudmFsdWUsRj10aGlzLmdldEdyb3VwSXRlbXModCk7dGhpcy5pc0dyb3VwU2VsZWN0ZWQodCk/dGhpcy52YWx1ZT10aGlzLnZhbHVlLmZpbHRlcihzPT5GLmZpbmRJbmRleChpPT5pLnZhbHVlPT09cyk9PT0tMSk6dGhpcy52YWx1ZT1bLi4udGhpcy52YWx1ZSwuLi5GLm1hcChzPT5zLnZhbHVlKV0sdGhpcy52YWx1ZT1BcnJheS5mcm9tKG5ldyBTZXQodGhpcy52YWx1ZSkpfWVsc2V7Y29uc3QgdD10aGlzLnZhbHVlLmluY2x1ZGVzKHUudmFsdWUpO3RoaXMudmFsdWU9dD90aGlzLnZhbHVlLmZpbHRlcihGPT5GIT09dS52YWx1ZSk6Wy4uLnRoaXMudmFsdWUsdS52YWx1ZV19fX07QT1uZXcgV2Vha01hcDt2YXIga0Q9T2JqZWN0LmRlZmluZVByb3BlcnR5LCREPShlLHUsdCk9PnUgaW4gZT9rRChlLHUse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnR9KTplW3VdPXQsSD0oZSx1LHQpPT4oJEQoZSx0eXBlb2YgdSE9XCJzeW1ib2xcIj91K1wiXCI6dSx0KSx0KTtsZXQgU0Q9Y2xhc3MgZXh0ZW5kcyB4e2NvbnN0cnVjdG9yKHUpe3N1cGVyKHUsITEpLEgodGhpcyxcIm9wdGlvbnNcIiksSCh0aGlzLFwiY3Vyc29yXCIsMCksdGhpcy5vcHRpb25zPXUub3B0aW9ucyx0aGlzLnZhbHVlPVsuLi51LmluaXRpYWxWYWx1ZXM/P1tdXSx0aGlzLmN1cnNvcj1NYXRoLm1heCh0aGlzLm9wdGlvbnMuZmluZEluZGV4KCh7dmFsdWU6dH0pPT50PT09dS5jdXJzb3JBdCksMCksdGhpcy5vbihcImtleVwiLHQ9Pnt0PT09XCJhXCImJnRoaXMudG9nZ2xlQWxsKCl9KSx0aGlzLm9uKFwiY3Vyc29yXCIsdD0+e3N3aXRjaCh0KXtjYXNlXCJsZWZ0XCI6Y2FzZVwidXBcIjp0aGlzLmN1cnNvcj10aGlzLmN1cnNvcj09PTA/dGhpcy5vcHRpb25zLmxlbmd0aC0xOnRoaXMuY3Vyc29yLTE7YnJlYWs7Y2FzZVwiZG93blwiOmNhc2VcInJpZ2h0XCI6dGhpcy5jdXJzb3I9dGhpcy5jdXJzb3I9PT10aGlzLm9wdGlvbnMubGVuZ3RoLTE/MDp0aGlzLmN1cnNvcisxO2JyZWFrO2Nhc2VcInNwYWNlXCI6dGhpcy50b2dnbGVWYWx1ZSgpO2JyZWFrfX0pfWdldCBfdmFsdWUoKXtyZXR1cm4gdGhpcy5vcHRpb25zW3RoaXMuY3Vyc29yXS52YWx1ZX10b2dnbGVBbGwoKXtjb25zdCB1PXRoaXMudmFsdWUubGVuZ3RoPT09dGhpcy5vcHRpb25zLmxlbmd0aDt0aGlzLnZhbHVlPXU/W106dGhpcy5vcHRpb25zLm1hcCh0PT50LnZhbHVlKX10b2dnbGVWYWx1ZSgpe2NvbnN0IHU9dGhpcy52YWx1ZS5pbmNsdWRlcyh0aGlzLl92YWx1ZSk7dGhpcy52YWx1ZT11P3RoaXMudmFsdWUuZmlsdGVyKHQ9PnQhPT10aGlzLl92YWx1ZSk6Wy4uLnRoaXMudmFsdWUsdGhpcy5fdmFsdWVdfX07dmFyIFREPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSxqRD0oZSx1LHQpPT51IGluIGU/VEQoZSx1LHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp0fSk6ZVt1XT10LFU9KGUsdSx0KT0+KGpEKGUsdHlwZW9mIHUhPVwic3ltYm9sXCI/dStcIlwiOnUsdCksdCk7Y2xhc3MgTUQgZXh0ZW5kcyB4e2NvbnN0cnVjdG9yKHttYXNrOnUsLi4udH0pe3N1cGVyKHQpLFUodGhpcyxcInZhbHVlV2l0aEN1cnNvclwiLFwiXCIpLFUodGhpcyxcIl9tYXNrXCIsXCJcXHUyMDIyXCIpLHRoaXMuX21hc2s9dT8/XCJcXHUyMDIyXCIsdGhpcy5vbihcImZpbmFsaXplXCIsKCk9Pnt0aGlzLnZhbHVlV2l0aEN1cnNvcj10aGlzLm1hc2tlZH0pLHRoaXMub24oXCJ2YWx1ZVwiLCgpPT57aWYodGhpcy5jdXJzb3I+PXRoaXMudmFsdWUubGVuZ3RoKXRoaXMudmFsdWVXaXRoQ3Vyc29yPWAke3RoaXMubWFza2VkfSR7di5pbnZlcnNlKHYuaGlkZGVuKFwiX1wiKSl9YDtlbHNle2NvbnN0IEY9dGhpcy5tYXNrZWQuc2xpY2UoMCx0aGlzLmN1cnNvcikscz10aGlzLm1hc2tlZC5zbGljZSh0aGlzLmN1cnNvcik7dGhpcy52YWx1ZVdpdGhDdXJzb3I9YCR7Rn0ke3YuaW52ZXJzZShzWzBdKX0ke3Muc2xpY2UoMSl9YH19KX1nZXQgY3Vyc29yKCl7cmV0dXJuIHRoaXMuX2N1cnNvcn1nZXQgbWFza2VkKCl7cmV0dXJuIHRoaXMudmFsdWUucmVwbGFjZUFsbCgvLi9nLHRoaXMuX21hc2spfX12YXIgT0Q9T2JqZWN0LmRlZmluZVByb3BlcnR5LFBEPShlLHUsdCk9PnUgaW4gZT9PRChlLHUse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnR9KTplW3VdPXQsSj0oZSx1LHQpPT4oUEQoZSx0eXBlb2YgdSE9XCJzeW1ib2xcIj91K1wiXCI6dSx0KSx0KTtjbGFzcyBMRCBleHRlbmRzIHh7Y29uc3RydWN0b3IodSl7c3VwZXIodSwhMSksSih0aGlzLFwib3B0aW9uc1wiKSxKKHRoaXMsXCJjdXJzb3JcIiwwKSx0aGlzLm9wdGlvbnM9dS5vcHRpb25zLHRoaXMuY3Vyc29yPXRoaXMub3B0aW9ucy5maW5kSW5kZXgoKHt2YWx1ZTp0fSk9PnQ9PT11LmluaXRpYWxWYWx1ZSksdGhpcy5jdXJzb3I9PT0tMSYmKHRoaXMuY3Vyc29yPTApLHRoaXMuY2hhbmdlVmFsdWUoKSx0aGlzLm9uKFwiY3Vyc29yXCIsdD0+e3N3aXRjaCh0KXtjYXNlXCJsZWZ0XCI6Y2FzZVwidXBcIjp0aGlzLmN1cnNvcj10aGlzLmN1cnNvcj09PTA/dGhpcy5vcHRpb25zLmxlbmd0aC0xOnRoaXMuY3Vyc29yLTE7YnJlYWs7Y2FzZVwiZG93blwiOmNhc2VcInJpZ2h0XCI6dGhpcy5jdXJzb3I9dGhpcy5jdXJzb3I9PT10aGlzLm9wdGlvbnMubGVuZ3RoLTE/MDp0aGlzLmN1cnNvcisxO2JyZWFrfXRoaXMuY2hhbmdlVmFsdWUoKX0pfWdldCBfdmFsdWUoKXtyZXR1cm4gdGhpcy5vcHRpb25zW3RoaXMuY3Vyc29yXX1jaGFuZ2VWYWx1ZSgpe3RoaXMudmFsdWU9dGhpcy5fdmFsdWUudmFsdWV9fXZhciBXRD1PYmplY3QuZGVmaW5lUHJvcGVydHksTkQ9KGUsdSx0KT0+dSBpbiBlP1dEKGUsdSx7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dH0pOmVbdV09dCxRPShlLHUsdCk9PihORChlLHR5cGVvZiB1IT1cInN5bWJvbFwiP3UrXCJcIjp1LHQpLHQpO2NsYXNzIElEIGV4dGVuZHMgeHtjb25zdHJ1Y3Rvcih1KXtzdXBlcih1LCExKSxRKHRoaXMsXCJvcHRpb25zXCIpLFEodGhpcyxcImN1cnNvclwiLDApLHRoaXMub3B0aW9ucz11Lm9wdGlvbnM7Y29uc3QgdD10aGlzLm9wdGlvbnMubWFwKCh7dmFsdWU6W0ZdfSk9PkY/LnRvTG93ZXJDYXNlKCkpO3RoaXMuY3Vyc29yPU1hdGgubWF4KHQuaW5kZXhPZih1LmluaXRpYWxWYWx1ZSksMCksdGhpcy5vbihcImtleVwiLEY9PntpZighdC5pbmNsdWRlcyhGKSlyZXR1cm47Y29uc3Qgcz10aGlzLm9wdGlvbnMuZmluZCgoe3ZhbHVlOltpXX0pPT5pPy50b0xvd2VyQ2FzZSgpPT09Rik7cyYmKHRoaXMudmFsdWU9cy52YWx1ZSx0aGlzLnN0YXRlPVwic3VibWl0XCIsdGhpcy5lbWl0KFwic3VibWl0XCIpKX0pfX1jbGFzcyBSRCBleHRlbmRzIHh7Z2V0IHZhbHVlV2l0aEN1cnNvcigpe2lmKHRoaXMuc3RhdGU9PT1cInN1Ym1pdFwiKXJldHVybiB0aGlzLnZhbHVlO2lmKHRoaXMuY3Vyc29yPj10aGlzLnZhbHVlLmxlbmd0aClyZXR1cm5gJHt0aGlzLnZhbHVlfVxcdTI1ODhgO2NvbnN0IHU9dGhpcy52YWx1ZS5zbGljZSgwLHRoaXMuY3Vyc29yKSxbdCwuLi5GXT10aGlzLnZhbHVlLnNsaWNlKHRoaXMuY3Vyc29yKTtyZXR1cm5gJHt1fSR7di5pbnZlcnNlKHQpfSR7Ri5qb2luKFwiXCIpfWB9Z2V0IGN1cnNvcigpe3JldHVybiB0aGlzLl9jdXJzb3J9Y29uc3RydWN0b3IodSl7c3VwZXIodSksdGhpcy5vbihcImZpbmFsaXplXCIsKCk9Pnt0aGlzLnZhbHVlfHwodGhpcy52YWx1ZT11LmRlZmF1bHRWYWx1ZSl9KX19ZXhwb3J0e2REIGFzIENvbmZpcm1Qcm9tcHQsX0QgYXMgR3JvdXBNdWx0aVNlbGVjdFByb21wdCxTRCBhcyBNdWx0aVNlbGVjdFByb21wdCxNRCBhcyBQYXNzd29yZFByb21wdCx4IGFzIFByb21wdCxJRCBhcyBTZWxlY3RLZXlQcm9tcHQsTEQgYXMgU2VsZWN0UHJvbXB0LFJEIGFzIFRleHRQcm9tcHQsZkQgYXMgYmxvY2sscEQgYXMgaXNDYW5jZWwsY0QgYXMgdXBkYXRlU2V0dGluZ3N9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwKICAgICJpbXBvcnR7c3RyaXBWVENvbnRyb2xDaGFyYWN0ZXJzIGFzIFN9ZnJvbVwibm9kZTp1dGlsXCI7aW1wb3J0e1RleHRQcm9tcHQgYXMgUSxQYXNzd29yZFByb21wdCBhcyBYLENvbmZpcm1Qcm9tcHQgYXMgWixTZWxlY3RQcm9tcHQgYXMgZWUsU2VsZWN0S2V5UHJvbXB0IGFzIHRlLE11bHRpU2VsZWN0UHJvbXB0IGFzIHJlLEdyb3VwTXVsdGlTZWxlY3RQcm9tcHQgYXMgc2UsaXNDYW5jZWwgYXMgaWUsYmxvY2sgYXMgbmV9ZnJvbVwiQGNsYWNrL2NvcmVcIjtleHBvcnR7aXNDYW5jZWwsdXBkYXRlU2V0dGluZ3N9ZnJvbVwiQGNsYWNrL2NvcmVcIjtpbXBvcnQgeSBmcm9tXCJub2RlOnByb2Nlc3NcIjtpbXBvcnQgZSBmcm9tXCJwaWNvY29sb3JzXCI7aW1wb3J0e2N1cnNvciBhcyBvZSxlcmFzZSBhcyBhZX1mcm9tXCJzaXN0ZXJhbnNpXCI7ZnVuY3Rpb24gY2UoKXtyZXR1cm4geS5wbGF0Zm9ybSE9PVwid2luMzJcIj95LmVudi5URVJNIT09XCJsaW51eFwiOiEheS5lbnYuQ0l8fCEheS5lbnYuV1RfU0VTU0lPTnx8ISF5LmVudi5URVJNSU5VU19TVUJMSU1FfHx5LmVudi5Db25FbXVUYXNrPT09XCJ7Y21kOjpDbWRlcn1cInx8eS5lbnYuVEVSTV9QUk9HUkFNPT09XCJUZXJtaW51cy1TdWJsaW1lXCJ8fHkuZW52LlRFUk1fUFJPR1JBTT09PVwidnNjb2RlXCJ8fHkuZW52LlRFUk09PT1cInh0ZXJtLTI1NmNvbG9yXCJ8fHkuZW52LlRFUk09PT1cImFsYWNyaXR0eVwifHx5LmVudi5URVJNSU5BTF9FTVVMQVRPUj09PVwiSmV0QnJhaW5zLUplZGlUZXJtXCJ9Y29uc3QgVj1jZSgpLHU9KHQsbik9PlY/dDpuLGxlPXUoXCJcXHUyNUM2XCIsXCIqXCIpLEw9dShcIlxcdTI1QTBcIixcInhcIiksVz11KFwiXFx1MjVCMlwiLFwieFwiKSxDPXUoXCJcXHUyNUM3XCIsXCJvXCIpLHVlPXUoXCJcXHUyNTBDXCIsXCJUXCIpLG89dShcIlxcdTI1MDJcIixcInxcIiksZD11KFwiXFx1MjUxNFwiLFwiXFx1MjAxNFwiKSxrPXUoXCJcXHUyNUNGXCIsXCI+XCIpLFA9dShcIlxcdTI1Q0JcIixcIiBcIiksQT11KFwiXFx1MjVGQlwiLFwiW1xcdTIwMjJdXCIpLFQ9dShcIlxcdTI1RkNcIixcIlsrXVwiKSxGPXUoXCJcXHUyNUZCXCIsXCJbIF1cIiksJGU9dShcIlxcdTI1QUFcIixcIlxcdTIwMjJcIiksXz11KFwiXFx1MjUwMFwiLFwiLVwiKSxtZT11KFwiXFx1MjU2RVwiLFwiK1wiKSxkZT11KFwiXFx1MjUxQ1wiLFwiK1wiKSxwZT11KFwiXFx1MjU2RlwiLFwiK1wiKSxxPXUoXCJcXHUyNUNGXCIsXCJcXHUyMDIyXCIpLEQ9dShcIlxcdTI1QzZcIixcIipcIiksVT11KFwiXFx1MjVCMlwiLFwiIVwiKSxLPXUoXCJcXHUyNUEwXCIsXCJ4XCIpLGI9dD0+e3N3aXRjaCh0KXtjYXNlXCJpbml0aWFsXCI6Y2FzZVwiYWN0aXZlXCI6cmV0dXJuIGUuY3lhbihsZSk7Y2FzZVwiY2FuY2VsXCI6cmV0dXJuIGUucmVkKEwpO2Nhc2VcImVycm9yXCI6cmV0dXJuIGUueWVsbG93KFcpO2Nhc2VcInN1Ym1pdFwiOnJldHVybiBlLmdyZWVuKEMpfX0sRz10PT57Y29uc3R7Y3Vyc29yOm4sb3B0aW9uczpyLHN0eWxlOml9PXQscz10Lm1heEl0ZW1zPz9OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksYz1NYXRoLm1heChwcm9jZXNzLnN0ZG91dC5yb3dzLTQsMCksYT1NYXRoLm1pbihjLE1hdGgubWF4KHMsNSkpO2xldCBsPTA7bj49bCthLTM/bD1NYXRoLm1heChNYXRoLm1pbihuLWErMyxyLmxlbmd0aC1hKSwwKTpuPGwrMiYmKGw9TWF0aC5tYXgobi0yLDApKTtjb25zdCAkPWE8ci5sZW5ndGgmJmw+MCxnPWE8ci5sZW5ndGgmJmwrYTxyLmxlbmd0aDtyZXR1cm4gci5zbGljZShsLGwrYSkubWFwKChwLHYsZik9Pntjb25zdCBqPXY9PT0wJiYkLEU9dj09PWYubGVuZ3RoLTEmJmc7cmV0dXJuIGp8fEU/ZS5kaW0oXCIuLi5cIik6aShwLHYrbD09PW4pfSl9LGhlPXQ9Pm5ldyBRKHt2YWxpZGF0ZTp0LnZhbGlkYXRlLHBsYWNlaG9sZGVyOnQucGxhY2Vob2xkZXIsZGVmYXVsdFZhbHVlOnQuZGVmYXVsdFZhbHVlLGluaXRpYWxWYWx1ZTp0LmluaXRpYWxWYWx1ZSxyZW5kZXIoKXtjb25zdCBuPWAke2UuZ3JheShvKX1cbiR7Yih0aGlzLnN0YXRlKX0gICR7dC5tZXNzYWdlfVxuYCxyPXQucGxhY2Vob2xkZXI/ZS5pbnZlcnNlKHQucGxhY2Vob2xkZXJbMF0pK2UuZGltKHQucGxhY2Vob2xkZXIuc2xpY2UoMSkpOmUuaW52ZXJzZShlLmhpZGRlbihcIl9cIikpLGk9dGhpcy52YWx1ZT90aGlzLnZhbHVlV2l0aEN1cnNvcjpyO3N3aXRjaCh0aGlzLnN0YXRlKXtjYXNlXCJlcnJvclwiOnJldHVybmAke24udHJpbSgpfVxuJHtlLnllbGxvdyhvKX0gICR7aX1cbiR7ZS55ZWxsb3coZCl9ICAke2UueWVsbG93KHRoaXMuZXJyb3IpfVxuYDtjYXNlXCJzdWJtaXRcIjpyZXR1cm5gJHtufSR7ZS5ncmF5KG8pfSAgJHtlLmRpbSh0aGlzLnZhbHVlfHx0LnBsYWNlaG9sZGVyKX1gO2Nhc2VcImNhbmNlbFwiOnJldHVybmAke259JHtlLmdyYXkobyl9ICAke2Uuc3RyaWtldGhyb3VnaChlLmRpbSh0aGlzLnZhbHVlPz9cIlwiKSl9JHt0aGlzLnZhbHVlPy50cmltKCk/YFxuJHtlLmdyYXkobyl9YDpcIlwifWA7ZGVmYXVsdDpyZXR1cm5gJHtufSR7ZS5jeWFuKG8pfSAgJHtpfVxuJHtlLmN5YW4oZCl9XG5gfX19KS5wcm9tcHQoKSxnZT10PT5uZXcgWCh7dmFsaWRhdGU6dC52YWxpZGF0ZSxtYXNrOnQubWFzaz8/JGUscmVuZGVyKCl7Y29uc3Qgbj1gJHtlLmdyYXkobyl9XG4ke2IodGhpcy5zdGF0ZSl9ICAke3QubWVzc2FnZX1cbmAscj10aGlzLnZhbHVlV2l0aEN1cnNvcixpPXRoaXMubWFza2VkO3N3aXRjaCh0aGlzLnN0YXRlKXtjYXNlXCJlcnJvclwiOnJldHVybmAke24udHJpbSgpfVxuJHtlLnllbGxvdyhvKX0gICR7aX1cbiR7ZS55ZWxsb3coZCl9ICAke2UueWVsbG93KHRoaXMuZXJyb3IpfVxuYDtjYXNlXCJzdWJtaXRcIjpyZXR1cm5gJHtufSR7ZS5ncmF5KG8pfSAgJHtlLmRpbShpKX1gO2Nhc2VcImNhbmNlbFwiOnJldHVybmAke259JHtlLmdyYXkobyl9ICAke2Uuc3RyaWtldGhyb3VnaChlLmRpbShpPz9cIlwiKSl9JHtpP2BcbiR7ZS5ncmF5KG8pfWA6XCJcIn1gO2RlZmF1bHQ6cmV0dXJuYCR7bn0ke2UuY3lhbihvKX0gICR7cn1cbiR7ZS5jeWFuKGQpfVxuYH19fSkucHJvbXB0KCkseWU9dD0+e2NvbnN0IG49dC5hY3RpdmU/P1wiWWVzXCIscj10LmluYWN0aXZlPz9cIk5vXCI7cmV0dXJuIG5ldyBaKHthY3RpdmU6bixpbmFjdGl2ZTpyLGluaXRpYWxWYWx1ZTp0LmluaXRpYWxWYWx1ZT8/ITAscmVuZGVyKCl7Y29uc3QgaT1gJHtlLmdyYXkobyl9XG4ke2IodGhpcy5zdGF0ZSl9ICAke3QubWVzc2FnZX1cbmAscz10aGlzLnZhbHVlP246cjtzd2l0Y2godGhpcy5zdGF0ZSl7Y2FzZVwic3VibWl0XCI6cmV0dXJuYCR7aX0ke2UuZ3JheShvKX0gICR7ZS5kaW0ocyl9YDtjYXNlXCJjYW5jZWxcIjpyZXR1cm5gJHtpfSR7ZS5ncmF5KG8pfSAgJHtlLnN0cmlrZXRocm91Z2goZS5kaW0ocykpfVxuJHtlLmdyYXkobyl9YDtkZWZhdWx0OnJldHVybmAke2l9JHtlLmN5YW4obyl9ICAke3RoaXMudmFsdWU/YCR7ZS5ncmVlbihrKX0gJHtufWA6YCR7ZS5kaW0oUCl9ICR7ZS5kaW0obil9YH0gJHtlLmRpbShcIi9cIil9ICR7dGhpcy52YWx1ZT9gJHtlLmRpbShQKX0gJHtlLmRpbShyKX1gOmAke2UuZ3JlZW4oayl9ICR7cn1gfVxuJHtlLmN5YW4oZCl9XG5gfX19KS5wcm9tcHQoKX0sdmU9dD0+e2NvbnN0IG49KHIsaSk9Pntjb25zdCBzPXIubGFiZWw/P1N0cmluZyhyLnZhbHVlKTtzd2l0Y2goaSl7Y2FzZVwic2VsZWN0ZWRcIjpyZXR1cm5gJHtlLmRpbShzKX1gO2Nhc2VcImFjdGl2ZVwiOnJldHVybmAke2UuZ3JlZW4oayl9ICR7c30gJHtyLmhpbnQ/ZS5kaW0oYCgke3IuaGludH0pYCk6XCJcIn1gO2Nhc2VcImNhbmNlbGxlZFwiOnJldHVybmAke2Uuc3RyaWtldGhyb3VnaChlLmRpbShzKSl9YDtkZWZhdWx0OnJldHVybmAke2UuZGltKFApfSAke2UuZGltKHMpfWB9fTtyZXR1cm4gbmV3IGVlKHtvcHRpb25zOnQub3B0aW9ucyxpbml0aWFsVmFsdWU6dC5pbml0aWFsVmFsdWUscmVuZGVyKCl7Y29uc3Qgcj1gJHtlLmdyYXkobyl9XG4ke2IodGhpcy5zdGF0ZSl9ICAke3QubWVzc2FnZX1cbmA7c3dpdGNoKHRoaXMuc3RhdGUpe2Nhc2VcInN1Ym1pdFwiOnJldHVybmAke3J9JHtlLmdyYXkobyl9ICAke24odGhpcy5vcHRpb25zW3RoaXMuY3Vyc29yXSxcInNlbGVjdGVkXCIpfWA7Y2FzZVwiY2FuY2VsXCI6cmV0dXJuYCR7cn0ke2UuZ3JheShvKX0gICR7bih0aGlzLm9wdGlvbnNbdGhpcy5jdXJzb3JdLFwiY2FuY2VsbGVkXCIpfVxuJHtlLmdyYXkobyl9YDtkZWZhdWx0OnJldHVybmAke3J9JHtlLmN5YW4obyl9ICAke0coe2N1cnNvcjp0aGlzLmN1cnNvcixvcHRpb25zOnRoaXMub3B0aW9ucyxtYXhJdGVtczp0Lm1heEl0ZW1zLHN0eWxlOihpLHMpPT5uKGkscz9cImFjdGl2ZVwiOlwiaW5hY3RpdmVcIil9KS5qb2luKGBcbiR7ZS5jeWFuKG8pfSAgYCl9XG4ke2UuY3lhbihkKX1cbmB9fX0pLnByb21wdCgpfSx3ZT10PT57Y29uc3Qgbj0ocixpPVwiaW5hY3RpdmVcIik9Pntjb25zdCBzPXIubGFiZWw/P1N0cmluZyhyLnZhbHVlKTtyZXR1cm4gaT09PVwic2VsZWN0ZWRcIj9gJHtlLmRpbShzKX1gOmk9PT1cImNhbmNlbGxlZFwiP2Ake2Uuc3RyaWtldGhyb3VnaChlLmRpbShzKSl9YDppPT09XCJhY3RpdmVcIj9gJHtlLmJnQ3lhbihlLmdyYXkoYCAke3IudmFsdWV9IGApKX0gJHtzfSAke3IuaGludD9lLmRpbShgKCR7ci5oaW50fSlgKTpcIlwifWA6YCR7ZS5ncmF5KGUuYmdXaGl0ZShlLmludmVyc2UoYCAke3IudmFsdWV9IGApKSl9ICR7c30gJHtyLmhpbnQ/ZS5kaW0oYCgke3IuaGludH0pYCk6XCJcIn1gfTtyZXR1cm4gbmV3IHRlKHtvcHRpb25zOnQub3B0aW9ucyxpbml0aWFsVmFsdWU6dC5pbml0aWFsVmFsdWUscmVuZGVyKCl7Y29uc3Qgcj1gJHtlLmdyYXkobyl9XG4ke2IodGhpcy5zdGF0ZSl9ICAke3QubWVzc2FnZX1cbmA7c3dpdGNoKHRoaXMuc3RhdGUpe2Nhc2VcInN1Ym1pdFwiOnJldHVybmAke3J9JHtlLmdyYXkobyl9ICAke24odGhpcy5vcHRpb25zLmZpbmQoaT0+aS52YWx1ZT09PXRoaXMudmFsdWUpPz90Lm9wdGlvbnNbMF0sXCJzZWxlY3RlZFwiKX1gO2Nhc2VcImNhbmNlbFwiOnJldHVybmAke3J9JHtlLmdyYXkobyl9ICAke24odGhpcy5vcHRpb25zWzBdLFwiY2FuY2VsbGVkXCIpfVxuJHtlLmdyYXkobyl9YDtkZWZhdWx0OnJldHVybmAke3J9JHtlLmN5YW4obyl9ICAke3RoaXMub3B0aW9ucy5tYXAoKGkscyk9Pm4oaSxzPT09dGhpcy5jdXJzb3I/XCJhY3RpdmVcIjpcImluYWN0aXZlXCIpKS5qb2luKGBcbiR7ZS5jeWFuKG8pfSAgYCl9XG4ke2UuY3lhbihkKX1cbmB9fX0pLnByb21wdCgpfSxmZT10PT57Y29uc3Qgbj0ocixpKT0+e2NvbnN0IHM9ci5sYWJlbD8/U3RyaW5nKHIudmFsdWUpO3JldHVybiBpPT09XCJhY3RpdmVcIj9gJHtlLmN5YW4oQSl9ICR7c30gJHtyLmhpbnQ/ZS5kaW0oYCgke3IuaGludH0pYCk6XCJcIn1gOmk9PT1cInNlbGVjdGVkXCI/YCR7ZS5ncmVlbihUKX0gJHtlLmRpbShzKX0gJHtyLmhpbnQ/ZS5kaW0oYCgke3IuaGludH0pYCk6XCJcIn1gOmk9PT1cImNhbmNlbGxlZFwiP2Ake2Uuc3RyaWtldGhyb3VnaChlLmRpbShzKSl9YDppPT09XCJhY3RpdmUtc2VsZWN0ZWRcIj9gJHtlLmdyZWVuKFQpfSAke3N9ICR7ci5oaW50P2UuZGltKGAoJHtyLmhpbnR9KWApOlwiXCJ9YDppPT09XCJzdWJtaXR0ZWRcIj9gJHtlLmRpbShzKX1gOmAke2UuZGltKEYpfSAke2UuZGltKHMpfWB9O3JldHVybiBuZXcgcmUoe29wdGlvbnM6dC5vcHRpb25zLGluaXRpYWxWYWx1ZXM6dC5pbml0aWFsVmFsdWVzLHJlcXVpcmVkOnQucmVxdWlyZWQ/PyEwLGN1cnNvckF0OnQuY3Vyc29yQXQsdmFsaWRhdGUocil7aWYodGhpcy5yZXF1aXJlZCYmci5sZW5ndGg9PT0wKXJldHVybmBQbGVhc2Ugc2VsZWN0IGF0IGxlYXN0IG9uZSBvcHRpb24uXG4ke2UucmVzZXQoZS5kaW0oYFByZXNzICR7ZS5ncmF5KGUuYmdXaGl0ZShlLmludmVyc2UoXCIgc3BhY2UgXCIpKSl9IHRvIHNlbGVjdCwgJHtlLmdyYXkoZS5iZ1doaXRlKGUuaW52ZXJzZShcIiBlbnRlciBcIikpKX0gdG8gc3VibWl0YCkpfWB9LHJlbmRlcigpe2NvbnN0IHI9YCR7ZS5ncmF5KG8pfVxuJHtiKHRoaXMuc3RhdGUpfSAgJHt0Lm1lc3NhZ2V9XG5gLGk9KHMsYyk9Pntjb25zdCBhPXRoaXMudmFsdWUuaW5jbHVkZXMocy52YWx1ZSk7cmV0dXJuIGMmJmE/bihzLFwiYWN0aXZlLXNlbGVjdGVkXCIpOmE/bihzLFwic2VsZWN0ZWRcIik6bihzLGM/XCJhY3RpdmVcIjpcImluYWN0aXZlXCIpfTtzd2l0Y2godGhpcy5zdGF0ZSl7Y2FzZVwic3VibWl0XCI6cmV0dXJuYCR7cn0ke2UuZ3JheShvKX0gICR7dGhpcy5vcHRpb25zLmZpbHRlcigoe3ZhbHVlOnN9KT0+dGhpcy52YWx1ZS5pbmNsdWRlcyhzKSkubWFwKHM9Pm4ocyxcInN1Ym1pdHRlZFwiKSkuam9pbihlLmRpbShcIiwgXCIpKXx8ZS5kaW0oXCJub25lXCIpfWA7Y2FzZVwiY2FuY2VsXCI6e2NvbnN0IHM9dGhpcy5vcHRpb25zLmZpbHRlcigoe3ZhbHVlOmN9KT0+dGhpcy52YWx1ZS5pbmNsdWRlcyhjKSkubWFwKGM9Pm4oYyxcImNhbmNlbGxlZFwiKSkuam9pbihlLmRpbShcIiwgXCIpKTtyZXR1cm5gJHtyfSR7ZS5ncmF5KG8pfSAgJHtzLnRyaW0oKT9gJHtzfVxuJHtlLmdyYXkobyl9YDpcIlwifWB9Y2FzZVwiZXJyb3JcIjp7Y29uc3Qgcz10aGlzLmVycm9yLnNwbGl0KGBcbmApLm1hcCgoYyxhKT0+YT09PTA/YCR7ZS55ZWxsb3coZCl9ICAke2UueWVsbG93KGMpfWA6YCAgICR7Y31gKS5qb2luKGBcbmApO3JldHVybmAke3IrZS55ZWxsb3cobyl9ICAke0coe29wdGlvbnM6dGhpcy5vcHRpb25zLGN1cnNvcjp0aGlzLmN1cnNvcixtYXhJdGVtczp0Lm1heEl0ZW1zLHN0eWxlOml9KS5qb2luKGBcbiR7ZS55ZWxsb3cobyl9ICBgKX1cbiR7c31cbmB9ZGVmYXVsdDpyZXR1cm5gJHtyfSR7ZS5jeWFuKG8pfSAgJHtHKHtvcHRpb25zOnRoaXMub3B0aW9ucyxjdXJzb3I6dGhpcy5jdXJzb3IsbWF4SXRlbXM6dC5tYXhJdGVtcyxzdHlsZTppfSkuam9pbihgXG4ke2UuY3lhbihvKX0gIGApfVxuJHtlLmN5YW4oZCl9XG5gfX19KS5wcm9tcHQoKX0sYmU9dD0+e2NvbnN0e3NlbGVjdGFibGVHcm91cHM6bj0hMH09dCxyPShpLHMsYz1bXSk9Pntjb25zdCBhPWkubGFiZWw/P1N0cmluZyhpLnZhbHVlKSxsPXR5cGVvZiBpLmdyb3VwPT1cInN0cmluZ1wiLCQ9bCYmKGNbYy5pbmRleE9mKGkpKzFdPz97Z3JvdXA6ITB9KSxnPWwmJiQuZ3JvdXA9PT0hMCxwPWw/bj9gJHtnP2Q6b30gYDpcIiAgXCI6XCJcIjtpZihzPT09XCJhY3RpdmVcIilyZXR1cm5gJHtlLmRpbShwKX0ke2UuY3lhbihBKX0gJHthfSAke2kuaGludD9lLmRpbShgKCR7aS5oaW50fSlgKTpcIlwifWA7aWYocz09PVwiZ3JvdXAtYWN0aXZlXCIpcmV0dXJuYCR7cH0ke2UuY3lhbihBKX0gJHtlLmRpbShhKX1gO2lmKHM9PT1cImdyb3VwLWFjdGl2ZS1zZWxlY3RlZFwiKXJldHVybmAke3B9JHtlLmdyZWVuKFQpfSAke2UuZGltKGEpfWA7aWYocz09PVwic2VsZWN0ZWRcIil7Y29uc3QgZj1sfHxuP2UuZ3JlZW4oVCk6XCJcIjtyZXR1cm5gJHtlLmRpbShwKX0ke2Z9ICR7ZS5kaW0oYSl9ICR7aS5oaW50P2UuZGltKGAoJHtpLmhpbnR9KWApOlwiXCJ9YH1pZihzPT09XCJjYW5jZWxsZWRcIilyZXR1cm5gJHtlLnN0cmlrZXRocm91Z2goZS5kaW0oYSkpfWA7aWYocz09PVwiYWN0aXZlLXNlbGVjdGVkXCIpcmV0dXJuYCR7ZS5kaW0ocCl9JHtlLmdyZWVuKFQpfSAke2F9ICR7aS5oaW50P2UuZGltKGAoJHtpLmhpbnR9KWApOlwiXCJ9YDtpZihzPT09XCJzdWJtaXR0ZWRcIilyZXR1cm5gJHtlLmRpbShhKX1gO2NvbnN0IHY9bHx8bj9lLmRpbShGKTpcIlwiO3JldHVybmAke2UuZGltKHApfSR7dn0gJHtlLmRpbShhKX1gfTtyZXR1cm4gbmV3IHNlKHtvcHRpb25zOnQub3B0aW9ucyxpbml0aWFsVmFsdWVzOnQuaW5pdGlhbFZhbHVlcyxyZXF1aXJlZDp0LnJlcXVpcmVkPz8hMCxjdXJzb3JBdDp0LmN1cnNvckF0LHNlbGVjdGFibGVHcm91cHM6bix2YWxpZGF0ZShpKXtpZih0aGlzLnJlcXVpcmVkJiZpLmxlbmd0aD09PTApcmV0dXJuYFBsZWFzZSBzZWxlY3QgYXQgbGVhc3Qgb25lIG9wdGlvbi5cbiR7ZS5yZXNldChlLmRpbShgUHJlc3MgJHtlLmdyYXkoZS5iZ1doaXRlKGUuaW52ZXJzZShcIiBzcGFjZSBcIikpKX0gdG8gc2VsZWN0LCAke2UuZ3JheShlLmJnV2hpdGUoZS5pbnZlcnNlKFwiIGVudGVyIFwiKSkpfSB0byBzdWJtaXRgKSl9YH0scmVuZGVyKCl7Y29uc3QgaT1gJHtlLmdyYXkobyl9XG4ke2IodGhpcy5zdGF0ZSl9ICAke3QubWVzc2FnZX1cbmA7c3dpdGNoKHRoaXMuc3RhdGUpe2Nhc2VcInN1Ym1pdFwiOnJldHVybmAke2l9JHtlLmdyYXkobyl9ICAke3RoaXMub3B0aW9ucy5maWx0ZXIoKHt2YWx1ZTpzfSk9PnRoaXMudmFsdWUuaW5jbHVkZXMocykpLm1hcChzPT5yKHMsXCJzdWJtaXR0ZWRcIikpLmpvaW4oZS5kaW0oXCIsIFwiKSl9YDtjYXNlXCJjYW5jZWxcIjp7Y29uc3Qgcz10aGlzLm9wdGlvbnMuZmlsdGVyKCh7dmFsdWU6Y30pPT50aGlzLnZhbHVlLmluY2x1ZGVzKGMpKS5tYXAoYz0+cihjLFwiY2FuY2VsbGVkXCIpKS5qb2luKGUuZGltKFwiLCBcIikpO3JldHVybmAke2l9JHtlLmdyYXkobyl9ICAke3MudHJpbSgpP2Ake3N9XG4ke2UuZ3JheShvKX1gOlwiXCJ9YH1jYXNlXCJlcnJvclwiOntjb25zdCBzPXRoaXMuZXJyb3Iuc3BsaXQoYFxuYCkubWFwKChjLGEpPT5hPT09MD9gJHtlLnllbGxvdyhkKX0gICR7ZS55ZWxsb3coYyl9YDpgICAgJHtjfWApLmpvaW4oYFxuYCk7cmV0dXJuYCR7aX0ke2UueWVsbG93KG8pfSAgJHt0aGlzLm9wdGlvbnMubWFwKChjLGEsbCk9Pntjb25zdCAkPXRoaXMudmFsdWUuaW5jbHVkZXMoYy52YWx1ZSl8fGMuZ3JvdXA9PT0hMCYmdGhpcy5pc0dyb3VwU2VsZWN0ZWQoYCR7Yy52YWx1ZX1gKSxnPWE9PT10aGlzLmN1cnNvcjtyZXR1cm4hZyYmdHlwZW9mIGMuZ3JvdXA9PVwic3RyaW5nXCImJnRoaXMub3B0aW9uc1t0aGlzLmN1cnNvcl0udmFsdWU9PT1jLmdyb3VwP3IoYywkP1wiZ3JvdXAtYWN0aXZlLXNlbGVjdGVkXCI6XCJncm91cC1hY3RpdmVcIixsKTpnJiYkP3IoYyxcImFjdGl2ZS1zZWxlY3RlZFwiLGwpOiQ/cihjLFwic2VsZWN0ZWRcIixsKTpyKGMsZz9cImFjdGl2ZVwiOlwiaW5hY3RpdmVcIixsKX0pLmpvaW4oYFxuJHtlLnllbGxvdyhvKX0gIGApfVxuJHtzfVxuYH1kZWZhdWx0OnJldHVybmAke2l9JHtlLmN5YW4obyl9ICAke3RoaXMub3B0aW9ucy5tYXAoKHMsYyxhKT0+e2NvbnN0IGw9dGhpcy52YWx1ZS5pbmNsdWRlcyhzLnZhbHVlKXx8cy5ncm91cD09PSEwJiZ0aGlzLmlzR3JvdXBTZWxlY3RlZChgJHtzLnZhbHVlfWApLCQ9Yz09PXRoaXMuY3Vyc29yO3JldHVybiEkJiZ0eXBlb2Ygcy5ncm91cD09XCJzdHJpbmdcIiYmdGhpcy5vcHRpb25zW3RoaXMuY3Vyc29yXS52YWx1ZT09PXMuZ3JvdXA/cihzLGw/XCJncm91cC1hY3RpdmUtc2VsZWN0ZWRcIjpcImdyb3VwLWFjdGl2ZVwiLGEpOiQmJmw/cihzLFwiYWN0aXZlLXNlbGVjdGVkXCIsYSk6bD9yKHMsXCJzZWxlY3RlZFwiLGEpOnIocywkP1wiYWN0aXZlXCI6XCJpbmFjdGl2ZVwiLGEpfSkuam9pbihgXG4ke2UuY3lhbihvKX0gIGApfVxuJHtlLmN5YW4oZCl9XG5gfX19KS5wcm9tcHQoKX0sTWU9KHQ9XCJcIixuPVwiXCIpPT57Y29uc3Qgcj1gXG4ke3R9XG5gLnNwbGl0KGBcbmApLGk9UyhuKS5sZW5ndGgscz1NYXRoLm1heChyLnJlZHVjZSgoYSxsKT0+e2NvbnN0ICQ9UyhsKTtyZXR1cm4gJC5sZW5ndGg+YT8kLmxlbmd0aDphfSwwKSxpKSsyLGM9ci5tYXAoYT0+YCR7ZS5ncmF5KG8pfSAgJHtlLmRpbShhKX0ke1wiIFwiLnJlcGVhdChzLVMoYSkubGVuZ3RoKX0ke2UuZ3JheShvKX1gKS5qb2luKGBcbmApO3Byb2Nlc3Muc3Rkb3V0LndyaXRlKGAke2UuZ3JheShvKX1cbiR7ZS5ncmVlbihDKX0gICR7ZS5yZXNldChuKX0gJHtlLmdyYXkoXy5yZXBlYXQoTWF0aC5tYXgocy1pLTEsMSkpK21lKX1cbiR7Y31cbiR7ZS5ncmF5KGRlK18ucmVwZWF0KHMrMikrcGUpfVxuYCl9LHhlPSh0PVwiXCIpPT57cHJvY2Vzcy5zdGRvdXQud3JpdGUoYCR7ZS5ncmF5KGQpfSAgJHtlLnJlZCh0KX1cblxuYCl9LEllPSh0PVwiXCIpPT57cHJvY2Vzcy5zdGRvdXQud3JpdGUoYCR7ZS5ncmF5KHVlKX0gICR7dH1cbmApfSxTZT0odD1cIlwiKT0+e3Byb2Nlc3Muc3Rkb3V0LndyaXRlKGAke2UuZ3JheShvKX1cbiR7ZS5ncmF5KGQpfSAgJHt0fVxuXG5gKX0sTT17bWVzc2FnZToodD1cIlwiLHtzeW1ib2w6bj1lLmdyYXkobyl9PXt9KT0+e2NvbnN0IHI9W2Ake2UuZ3JheShvKX1gXTtpZih0KXtjb25zdFtpLC4uLnNdPXQuc3BsaXQoYFxuYCk7ci5wdXNoKGAke259ICAke2l9YCwuLi5zLm1hcChjPT5gJHtlLmdyYXkobyl9ICAke2N9YCkpfXByb2Nlc3Muc3Rkb3V0LndyaXRlKGAke3Iuam9pbihgXG5gKX1cbmApfSxpbmZvOnQ9PntNLm1lc3NhZ2UodCx7c3ltYm9sOmUuYmx1ZShxKX0pfSxzdWNjZXNzOnQ9PntNLm1lc3NhZ2UodCx7c3ltYm9sOmUuZ3JlZW4oRCl9KX0sc3RlcDp0PT57TS5tZXNzYWdlKHQse3N5bWJvbDplLmdyZWVuKEMpfSl9LHdhcm46dD0+e00ubWVzc2FnZSh0LHtzeW1ib2w6ZS55ZWxsb3coVSl9KX0sd2FybmluZzp0PT57TS53YXJuKHQpfSxlcnJvcjp0PT57TS5tZXNzYWdlKHQse3N5bWJvbDplLnJlZChLKX0pfX0sSj1gJHtlLmdyYXkobyl9ICBgLHg9e21lc3NhZ2U6YXN5bmModCx7c3ltYm9sOm49ZS5ncmF5KG8pfT17fSk9Pntwcm9jZXNzLnN0ZG91dC53cml0ZShgJHtlLmdyYXkobyl9XG4ke259ICBgKTtsZXQgcj0zO2ZvciBhd2FpdChsZXQgaSBvZiB0KXtpPWkucmVwbGFjZSgvXFxuL2csYFxuJHtKfWApLGkuaW5jbHVkZXMoYFxuYCkmJihyPTMrUyhpLnNsaWNlKGkubGFzdEluZGV4T2YoYFxuYCkpKS5sZW5ndGgpO2NvbnN0IHM9UyhpKS5sZW5ndGg7citzPHByb2Nlc3Muc3Rkb3V0LmNvbHVtbnM/KHIrPXMscHJvY2Vzcy5zdGRvdXQud3JpdGUoaSkpOihwcm9jZXNzLnN0ZG91dC53cml0ZShgXG4ke0p9JHtpLnRyaW1TdGFydCgpfWApLHI9MytTKGkudHJpbVN0YXJ0KCkpLmxlbmd0aCl9cHJvY2Vzcy5zdGRvdXQud3JpdGUoYFxuYCl9LGluZm86dD0+eC5tZXNzYWdlKHQse3N5bWJvbDplLmJsdWUocSl9KSxzdWNjZXNzOnQ9PngubWVzc2FnZSh0LHtzeW1ib2w6ZS5ncmVlbihEKX0pLHN0ZXA6dD0+eC5tZXNzYWdlKHQse3N5bWJvbDplLmdyZWVuKEMpfSksd2Fybjp0PT54Lm1lc3NhZ2UodCx7c3ltYm9sOmUueWVsbG93KFUpfSksd2FybmluZzp0PT54Lndhcm4odCksZXJyb3I6dD0+eC5tZXNzYWdlKHQse3N5bWJvbDplLnJlZChLKX0pfSxZPSh7aW5kaWNhdG9yOnQ9XCJkb3RzXCJ9PXt9KT0+e2NvbnN0IG49Vj9bXCJcXHUyNUQyXCIsXCJcXHUyNUQwXCIsXCJcXHUyNUQzXCIsXCJcXHUyNUQxXCJdOltcIlxcdTIwMjJcIixcIm9cIixcIk9cIixcIjBcIl0scj1WPzgwOjEyMCxpPXByb2Nlc3MuZW52LkNJPT09XCJ0cnVlXCI7bGV0IHMsYyxhPSExLGw9XCJcIiwkLGc9cGVyZm9ybWFuY2Uubm93KCk7Y29uc3QgcD1tPT57Y29uc3QgaD1tPjE/XCJTb21ldGhpbmcgd2VudCB3cm9uZ1wiOlwiQ2FuY2VsZWRcIjthJiZOKGgsbSl9LHY9KCk9PnAoMiksZj0oKT0+cCgxKSxqPSgpPT57cHJvY2Vzcy5vbihcInVuY2F1Z2h0RXhjZXB0aW9uTW9uaXRvclwiLHYpLHByb2Nlc3Mub24oXCJ1bmhhbmRsZWRSZWplY3Rpb25cIix2KSxwcm9jZXNzLm9uKFwiU0lHSU5UXCIsZikscHJvY2Vzcy5vbihcIlNJR1RFUk1cIixmKSxwcm9jZXNzLm9uKFwiZXhpdFwiLHApfSxFPSgpPT57cHJvY2Vzcy5yZW1vdmVMaXN0ZW5lcihcInVuY2F1Z2h0RXhjZXB0aW9uTW9uaXRvclwiLHYpLHByb2Nlc3MucmVtb3ZlTGlzdGVuZXIoXCJ1bmhhbmRsZWRSZWplY3Rpb25cIix2KSxwcm9jZXNzLnJlbW92ZUxpc3RlbmVyKFwiU0lHSU5UXCIsZikscHJvY2Vzcy5yZW1vdmVMaXN0ZW5lcihcIlNJR1RFUk1cIixmKSxwcm9jZXNzLnJlbW92ZUxpc3RlbmVyKFwiZXhpdFwiLHApfSxCPSgpPT57aWYoJD09PXZvaWQgMClyZXR1cm47aSYmcHJvY2Vzcy5zdGRvdXQud3JpdGUoYFxuYCk7Y29uc3QgbT0kLnNwbGl0KGBcbmApO3Byb2Nlc3Muc3Rkb3V0LndyaXRlKG9lLm1vdmUoLTk5OSxtLmxlbmd0aC0xKSkscHJvY2Vzcy5zdGRvdXQud3JpdGUoYWUuZG93bihtLmxlbmd0aCkpfSxSPW09Pm0ucmVwbGFjZSgvXFwuKyQvLFwiXCIpLE89bT0+e2NvbnN0IGg9KHBlcmZvcm1hbmNlLm5vdygpLW0pLzFlMyx3PU1hdGguZmxvb3IoaC82MCksST1NYXRoLmZsb29yKGglNjApO3JldHVybiB3PjA/YFske3d9bSAke0l9c11gOmBbJHtJfXNdYH0sSD0obT1cIlwiKT0+e2E9ITAscz1uZSgpLGw9UihtKSxnPXBlcmZvcm1hbmNlLm5vdygpLHByb2Nlc3Muc3Rkb3V0LndyaXRlKGAke2UuZ3JheShvKX1cbmApO2xldCBoPTAsdz0wO2ooKSxjPXNldEludGVydmFsKCgpPT57aWYoaSYmbD09PSQpcmV0dXJuO0IoKSwkPWw7Y29uc3QgST1lLm1hZ2VudGEobltoXSk7aWYoaSlwcm9jZXNzLnN0ZG91dC53cml0ZShgJHtJfSAgJHtsfS4uLmApO2Vsc2UgaWYodD09PVwidGltZXJcIilwcm9jZXNzLnN0ZG91dC53cml0ZShgJHtJfSAgJHtsfSAke08oZyl9YCk7ZWxzZXtjb25zdCB6PVwiLlwiLnJlcGVhdChNYXRoLmZsb29yKHcpKS5zbGljZSgwLDMpO3Byb2Nlc3Muc3Rkb3V0LndyaXRlKGAke0l9ICAke2x9JHt6fWApfWg9aCsxPG4ubGVuZ3RoP2grMTowLHc9dzxuLmxlbmd0aD93Ky4xMjU6MH0scil9LE49KG09XCJcIixoPTApPT57YT0hMSxjbGVhckludGVydmFsKGMpLEIoKTtjb25zdCB3PWg9PT0wP2UuZ3JlZW4oQyk6aD09PTE/ZS5yZWQoTCk6ZS5yZWQoVyk7bD1SKG0/P2wpLHQ9PT1cInRpbWVyXCI/cHJvY2Vzcy5zdGRvdXQud3JpdGUoYCR7d30gICR7bH0gJHtPKGcpfVxuYCk6cHJvY2Vzcy5zdGRvdXQud3JpdGUoYCR7d30gICR7bH1cbmApLEUoKSxzKCl9O3JldHVybntzdGFydDpILHN0b3A6TixtZXNzYWdlOihtPVwiXCIpPT57bD1SKG0/P2wpfX19LENlPWFzeW5jKHQsbik9Pntjb25zdCByPXt9LGk9T2JqZWN0LmtleXModCk7Zm9yKGNvbnN0IHMgb2YgaSl7Y29uc3QgYz10W3NdLGE9YXdhaXQgYyh7cmVzdWx0czpyfSk/LmNhdGNoKGw9Pnt0aHJvdyBsfSk7aWYodHlwZW9mIG4/Lm9uQ2FuY2VsPT1cImZ1bmN0aW9uXCImJmllKGEpKXtyW3NdPVwiY2FuY2VsZWRcIixuLm9uQ2FuY2VsKHtyZXN1bHRzOnJ9KTtjb250aW51ZX1yW3NdPWF9cmV0dXJuIHJ9LFRlPWFzeW5jIHQ9Pntmb3IoY29uc3QgbiBvZiB0KXtpZihuLmVuYWJsZWQ9PT0hMSljb250aW51ZTtjb25zdCByPVkoKTtyLnN0YXJ0KG4udGl0bGUpO2NvbnN0IGk9YXdhaXQgbi50YXNrKHIubWVzc2FnZSk7ci5zdG9wKGl8fG4udGl0bGUpfX07ZXhwb3J0e3hlIGFzIGNhbmNlbCx5ZSBhcyBjb25maXJtLENlIGFzIGdyb3VwLGJlIGFzIGdyb3VwTXVsdGlzZWxlY3QsSWUgYXMgaW50cm8sTSBhcyBsb2csZmUgYXMgbXVsdGlzZWxlY3QsTWUgYXMgbm90ZSxTZSBhcyBvdXRybyxnZSBhcyBwYXNzd29yZCx2ZSBhcyBzZWxlY3Qsd2UgYXMgc2VsZWN0S2V5LFkgYXMgc3Bpbm5lcix4IGFzIHN0cmVhbSxUZSBhcyB0YXNrcyxoZSBhcyB0ZXh0fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsCiAgICAiLyoqXG4gKiBPcGVuQ29kZSBTREsgQmFja2VuZCBXcmFwcGVyXG4gKlxuICogUHJvdmlkZXMgc2Vzc2lvbiBtYW5hZ2VtZW50IGFuZCBtZXNzYWdlIHNlbmRpbmcgY2FwYWJpbGl0aWVzXG4gKiBmb3IgYWktZW5nIHJhbHBoIHJ1bm5lciB1c2luZyBPcGVuQ29kZSBTREsuXG4gKi9cblxuaW1wb3J0IHsgY3JlYXRlU2VydmVyIH0gZnJvbSBcIm5vZGU6bmV0XCI7XG5pbXBvcnQge1xuICAgIHR5cGUgT3BlbmNvZGVDbGllbnQsXG4gICAgY3JlYXRlT3BlbmNvZGUsXG4gICAgY3JlYXRlT3BlbmNvZGVDbGllbnQsXG59IGZyb20gXCJAb3BlbmNvZGUtYWkvc2RrXCI7XG5pbXBvcnQgeyBMb2cgfSBmcm9tIFwiLi4vLi4vdXRpbC9sb2dcIjtcblxuY29uc3QgbG9nID0gTG9nLmNyZWF0ZSh7IHNlcnZpY2U6IFwib3BlbmNvZGUtY2xpZW50XCIgfSk7XG5cbi8qKlxuICogUmVzcG9uc2UgaW50ZXJmYWNlIGZvciBtZXNzYWdlc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIE1lc3NhZ2VSZXNwb25zZSB7XG4gICAgY29udGVudDogc3RyaW5nO1xufVxuXG4vKipcbiAqIFN0cmVhbWluZyByZXNwb25zZSBpbnRlcmZhY2VcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTdHJlYW1pbmdSZXNwb25zZSB7XG4gICAgLyoqIFJlYWRhYmxlIHN0cmVhbSBvZiByZXNwb25zZSBjaHVua3MgKi9cbiAgICBzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+O1xuICAgIC8qKiBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gY29tcGxldGUgcmVzcG9uc2Ugd2hlbiBzdHJlYW0gZW5kcyAqL1xuICAgIGNvbXBsZXRlOiBQcm9taXNlPE1lc3NhZ2VSZXNwb25zZT47XG59XG5cbi8qKlxuICogU2Vzc2lvbiBpbnRlcmZhY2UgZm9yIGFpLWVuZyBydW5uZXJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZXNzaW9uIHtcbiAgICBpZDogc3RyaW5nO1xuICAgIHNlbmRNZXNzYWdlOiAobWVzc2FnZTogc3RyaW5nKSA9PiBQcm9taXNlPE1lc3NhZ2VSZXNwb25zZT47XG4gICAgc2VuZE1lc3NhZ2VTdHJlYW06IChtZXNzYWdlOiBzdHJpbmcpID0+IFByb21pc2U8U3RyZWFtaW5nUmVzcG9uc2U+O1xuICAgIGNsb3NlOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xuICAgIC8qKiBUb29sIGludm9jYXRpb25zIGNhcHR1cmVkIGR1cmluZyB0aGlzIHNlc3Npb24gKi9cbiAgICBfdG9vbEludm9jYXRpb25zPzogQXJyYXk8e1xuICAgICAgICBpZDogc3RyaW5nO1xuICAgICAgICBuYW1lOiBzdHJpbmc7XG4gICAgICAgIGlucHV0PzogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gICAgICAgIG91dHB1dD86IHN0cmluZztcbiAgICAgICAgc3RhdHVzOiBcIm9rXCIgfCBcImVycm9yXCI7XG4gICAgICAgIGVycm9yPzogc3RyaW5nO1xuICAgICAgICBzdGFydGVkQXQ/OiBzdHJpbmc7XG4gICAgICAgIGNvbXBsZXRlZEF0Pzogc3RyaW5nO1xuICAgIH0+O1xufVxuXG4vKipcbiAqIENsaWVudCBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDbGllbnRDb25maWcge1xuICAgIC8qKiBDdXN0b20gY2xpZW50IGluc3RhbmNlIChmb3IgdGVzdGluZykgKi9cbiAgICBjbGllbnQ/OiBPcGVuY29kZUNsaWVudDtcbiAgICAvKiogQ29ubmVjdGlvbiB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyAoZGVmYXVsdDogMTAwMDApICovXG4gICAgdGltZW91dD86IG51bWJlcjtcbiAgICAvKiogUmV0cnkgYXR0ZW1wdHMgZm9yIGZhaWxlZCBvcGVyYXRpb25zICovXG4gICAgcmV0cnlBdHRlbXB0cz86IG51bWJlcjtcbiAgICAvKiogUHJvbXB0IHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzICh1c2VkIGFzIGFuIGlkbGUgdGltZW91dCBmb3Igc3RyZWFtaW5nKSAqL1xuICAgIHByb21wdFRpbWVvdXQ/OiBudW1iZXI7XG4gICAgLyoqIERpcmVjdG9yeS93b3JrdHJlZSBjb250ZXh0IHRvIHJ1biBPcGVuQ29kZSBpbiAoZGVmYXVsdHMgdG8gcHJvY2Vzcy5jd2QoKSkgKi9cbiAgICBkaXJlY3Rvcnk/OiBzdHJpbmc7XG4gICAgLyoqIFVSTCBvZiBleGlzdGluZyBPcGVuQ29kZSBzZXJ2ZXIgdG8gcmV1c2UgKGlmIHByb3ZpZGVkLCB3b24ndCBzcGF3biBuZXcgc2VydmVyKSAqL1xuICAgIGV4aXN0aW5nU2VydmVyVXJsPzogc3RyaW5nO1xuICAgIC8qKiBTZXJ2ZXIgc3RhcnR1cCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyAoZGVmYXVsdDogMTAwMDApICovXG4gICAgc2VydmVyU3RhcnR1cFRpbWVvdXQ/OiBudW1iZXI7XG4gICAgLyoqIE5PVEU6IHdvcmtpbmdEaXIgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIFNES1xuICAgICAqIFNwYXduZWQgT3BlbkNvZGUgc2VydmVycyB3aWxsIHVzZSB0aGUgY2FsbGluZyBkaXJlY3RvcnkgYnkgZGVmYXVsdCAocHJvY2Vzcy5jd2QoKSlcbiAgICAgKiBVc2UgT1BFTkNPREVfVVJMIHRvIGNvbm5lY3QgdG8gYSBkaWZmZXJlbnQgT3BlbkNvZGUgaW5zdGFuY2UgaW5zdGVhZFxuICAgICAqL1xufVxuXG4vKipcbiAqIE9wZW5Db2RlIENsaWVudCBXcmFwcGVyXG4gKlxuICogV3JhcHMgT3BlbkNvZGUgU0RLIHRvIHByb3ZpZGUgc2Vzc2lvbiBtYW5hZ2VtZW50XG4gKiBhbmQgZXJyb3IgaGFuZGxpbmcgZm9yIHJhbHBoIHJ1bm5lci5cbiAqL1xuZXhwb3J0IGNsYXNzIE9wZW5Db2RlQ2xpZW50IHtcbiAgICBwcml2YXRlIGNsaWVudDogT3BlbmNvZGVDbGllbnQ7XG4gICAgcHJpdmF0ZSB0aW1lb3V0OiBudW1iZXI7XG4gICAgcHJpdmF0ZSByZXRyeUF0dGVtcHRzOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBhY3RpdmVTZXNzaW9uczogTWFwPHN0cmluZywgU2Vzc2lvbj47XG4gICAgcHJpdmF0ZSBwcm9tcHRUaW1lb3V0OiBudW1iZXI7XG4gICAgcHJpdmF0ZSBkaXJlY3Rvcnk6IHN0cmluZyA9IHByb2Nlc3MuY3dkKCk7XG4gICAgcHJpdmF0ZSBzZXJ2ZXI6IHsgdXJsOiBzdHJpbmc7IGNsb3NlOiAoKSA9PiB2b2lkIH0gfCBudWxsID0gbnVsbDtcbiAgICBwcml2YXRlIHNlcnZlclN0YXJ0dXBUaW1lb3V0OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBQcml2YXRlIGNvbnN0cnVjdG9yIC0gdXNlIHN0YXRpYyBjcmVhdGUoKSBmYWN0b3J5IG1ldGhvZCBpbnN0ZWFkXG4gICAgICovXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3RvcihcbiAgICAgICAgY2xpZW50OiBPcGVuY29kZUNsaWVudCxcbiAgICAgICAgc2VydmVyOiB7IHVybDogc3RyaW5nOyBjbG9zZTogKCkgPT4gdm9pZCB9IHwgbnVsbCxcbiAgICAgICAgY29uZmlnOiBDbGllbnRDb25maWcgPSB7fSxcbiAgICApIHtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgICAgIHRoaXMuc2VydmVyID0gc2VydmVyO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSBjb25maWcudGltZW91dCB8fCAzMDAwMDtcbiAgICAgICAgdGhpcy5yZXRyeUF0dGVtcHRzID0gY29uZmlnLnJldHJ5QXR0ZW1wdHMgfHwgMztcblxuICAgICAgICBjb25zdCBlbnZQcm9tcHRUaW1lb3V0ID0gTnVtYmVyLnBhcnNlSW50KFxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuT1BFTkNPREVfUFJPTVBUX1RJTUVPVVRfTVMgPz8gXCJcIixcbiAgICAgICAgICAgIDEwLFxuICAgICAgICApO1xuICAgICAgICBjb25zdCByZXNvbHZlZFByb21wdFRpbWVvdXQgPSBOdW1iZXIuaXNGaW5pdGUoZW52UHJvbXB0VGltZW91dClcbiAgICAgICAgICAgID8gZW52UHJvbXB0VGltZW91dFxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgLy8gRm9yIHN0cmVhbWluZywgdGhpcyBhY3RzIGFzIGFuIGlkbGUgdGltZW91dCAocmVzZXQgb24gc3RyZWFtZWQgZXZlbnRzKVxuICAgICAgICB0aGlzLnByb21wdFRpbWVvdXQgPVxuICAgICAgICAgICAgY29uZmlnLnByb21wdFRpbWVvdXQgPz8gcmVzb2x2ZWRQcm9tcHRUaW1lb3V0ID8/IDEyMDAwMDsgLy8gMTIwIHNlY29uZHMgZGVmYXVsdFxuXG4gICAgICAgIHRoaXMuZGlyZWN0b3J5ID1cbiAgICAgICAgICAgIGNvbmZpZy5kaXJlY3RvcnkgfHwgcHJvY2Vzcy5lbnYuT1BFTkNPREVfRElSRUNUT1JZIHx8IHByb2Nlc3MuY3dkKCk7XG5cbiAgICAgICAgdGhpcy5zZXJ2ZXJTdGFydHVwVGltZW91dCA9IGNvbmZpZy5zZXJ2ZXJTdGFydHVwVGltZW91dCB8fCAxMDAwMDsgLy8gMTAgc2Vjb25kcyBkZWZhdWx0XG4gICAgICAgIHRoaXMuYWN0aXZlU2Vzc2lvbnMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgbG9nLmRlYnVnKFwiT3BlbkNvZGVDbGllbnQgaW5pdGlhbGl6ZWRcIiwge1xuICAgICAgICAgICAgaGFzT3duU2VydmVyOiAhIXRoaXMuc2VydmVyLFxuICAgICAgICAgICAgdGltZW91dDogdGhpcy50aW1lb3V0LFxuICAgICAgICAgICAgc2VydmVyU3RhcnR1cFRpbWVvdXQ6IHRoaXMuc2VydmVyU3RhcnR1cFRpbWVvdXQsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhbiBhdmFpbGFibGUgcG9ydCBmb3IgT3BlbkNvZGUgc2VydmVyXG4gICAgICpcbiAgICAgKiBJTVBPUlRBTlQ6IEFsd2F5cyBhdm9pZCBwb3J0IDQwOTYgdG8gcHJldmVudCBjb25mbGljdHMgd2l0aCB1c2VyJ3MgZXhpc3Rpbmcgc2VydmVyXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgYXN5bmMgZ2V0QXZhaWxhYmxlUG9ydCgpOiBQcm9taXNlPG51bWJlcj4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgZGVmYXVsdCBwb3J0IGlzIGluIHVzZSBhbmQgbG9nIGFjY29yZGluZ2x5XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0UG9ydCA9IDQwOTY7XG4gICAgICAgICAgICBjb25zdCBpc0RlZmF1bHRBdmFpbGFibGUgPVxuICAgICAgICAgICAgICAgIGF3YWl0IE9wZW5Db2RlQ2xpZW50LmlzUG9ydEF2YWlsYWJsZShkZWZhdWx0UG9ydCk7XG5cbiAgICAgICAgICAgIGlmICghaXNEZWZhdWx0QXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgbG9nLmluZm8oXG4gICAgICAgICAgICAgICAgICAgIFwiRXhpc3Rpbmcgc2VydmVyIGRldGVjdGVkIG9uIHBvcnQgNDA5Njsgc3Bhd25pbmcgaXNvbGF0ZWQgc2VydmVyIG9uIGR5bmFtaWMgcG9ydFwiLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZyhcbiAgICAgICAgICAgICAgICAgICAgXCJEZWZhdWx0IHBvcnQgNDA5NiBpcyBhdmFpbGFibGUgYnV0IGF2b2lkaW5nIGl0IGZvciBpc29sYXRpb25cIixcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBbHdheXMgdXNlIGR5bmFtaWMgcG9ydCB0byBhdm9pZCBjb25mbGljdHMgd2l0aCB1c2VyJ3MgZXhpc3Rpbmcgc2VydmVyXG4gICAgICAgICAgICBjb25zdCBkeW5hbWljUG9ydCA9IGF3YWl0IE9wZW5Db2RlQ2xpZW50LmZpbmRBdmFpbGFibGVQb3J0KCk7XG4gICAgICAgICAgICBsb2cuaW5mbyhcbiAgICAgICAgICAgICAgICBgU3Bhd25pbmcgaXNvbGF0ZWQgc2VydmVyIG9uIGR5bmFtaWMgcG9ydDogJHtkeW5hbWljUG9ydH1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiBkeW5hbWljUG9ydDtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTXNnID1cbiAgICAgICAgICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICAgICAgICBsb2cuZXJyb3IoXCJGYWlsZWQgdG8gc2VsZWN0IE9wZW5Db2RlIHNlcnZlciBwb3J0XCIsIHtcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JNc2csXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgRmFpbGVkIHRvIHNlbGVjdCBPcGVuQ29kZSBzZXJ2ZXIgcG9ydDogJHtlcnJvck1zZ31gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgc3BlY2lmaWMgcG9ydCBpcyBhdmFpbGFibGVcbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXRpYyBhc3luYyBpc1BvcnRBdmFpbGFibGUocG9ydDogbnVtYmVyKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VydmVyID0gY3JlYXRlU2VydmVyKCk7XG5cbiAgICAgICAgICAgIHNlcnZlci5saXN0ZW4ocG9ydCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNlcnZlci5vbmNlKFwiY2xvc2VcIiwgKCkgPT4gcmVzb2x2ZSh0cnVlKSk7XG4gICAgICAgICAgICAgICAgc2VydmVyLmNsb3NlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgc2VydmVyLm9uKFwiZXJyb3JcIiwgKCkgPT4gcmVzb2x2ZShmYWxzZSkpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGFuIGF2YWlsYWJsZSBwb3J0IGR5bmFtaWNhbGx5XG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgYXN5bmMgZmluZEF2YWlsYWJsZVBvcnQoKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZlciA9IGNyZWF0ZVNlcnZlcigpO1xuXG4gICAgICAgICAgICBzZXJ2ZXIubGlzdGVuKDAsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gc2VydmVyLmFkZHJlc3MoKTtcbiAgICAgICAgICAgICAgICBpZiAoYWRkcmVzcyAmJiB0eXBlb2YgYWRkcmVzcyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXIub25jZShcImNsb3NlXCIsICgpID0+IHJlc29sdmUoYWRkcmVzcy5wb3J0KSk7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZ2V0IHNlcnZlciBhZGRyZXNzXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgc2VydmVyLm9uKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhdGljIGZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhbiBPcGVuQ29kZUNsaWVudFxuICAgICAqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjbGllbnQgd2l0aCBlaXRoZXI6XG4gICAgICogMS4gQSBmcmVzaCBPcGVuQ29kZSBzZXJ2ZXIgKGRlZmF1bHQgYmVoYXZpb3IpXG4gICAgICogMi4gQW4gZXhpc3Rpbmcgc2VydmVyIFVSTCAoaWYgZXhpc3RpbmdTZXJ2ZXJVcmwgaXMgcHJvdmlkZWQpXG4gICAgICogMy4gQSBjdXN0b20gY2xpZW50IGluc3RhbmNlIChmb3IgdGVzdGluZylcbiAgICAgKlxuICAgICAqIE5vdGU6IFNwYXduZWQgT3BlbkNvZGUgc2VydmVycyB3aWxsIHVzZSB0byBjYWxsaW5nIGRpcmVjdG9yeSBieSBkZWZhdWx0IChwcm9jZXNzLmN3ZCgpKVxuICAgICAqIFVzZSBPUEVOQ09ERV9VUkwgdG8gY29ubmVjdCB0byBhIGRpZmZlcmVudCBPcGVuQ29kZSBpbnN0YW5jZVxuICAgICAqL1xuICAgIHN0YXRpYyBhc3luYyBjcmVhdGUoY29uZmlnOiBDbGllbnRDb25maWcgPSB7fSk6IFByb21pc2U8T3BlbkNvZGVDbGllbnQ+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIElmIGN1c3RvbSBjbGllbnQgcHJvdmlkZWQgKGZvciB0ZXN0aW5nKSwgdXNlIGl0IGRpcmVjdGx5XG4gICAgICAgICAgICBpZiAoY29uZmlnLmNsaWVudCkge1xuICAgICAgICAgICAgICAgIGxvZy5pbmZvKFwiQ3JlYXRpbmcgT3BlbkNvZGVDbGllbnQgd2l0aCBjdXN0b20gY2xpZW50IGluc3RhbmNlXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgT3BlbkNvZGVDbGllbnQoY29uZmlnLmNsaWVudCwgbnVsbCwgY29uZmlnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgZXhpc3Rpbmcgc2VydmVyIFVSTCBwcm92aWRlZCwgY29ubmVjdCB0byBpdFxuICAgICAgICAgICAgaWYgKGNvbmZpZy5leGlzdGluZ1NlcnZlclVybCkge1xuICAgICAgICAgICAgICAgIGxvZy5pbmZvKFwiQ29ubmVjdGluZyB0byBleGlzdGluZyBPcGVuQ29kZSBzZXJ2ZXJcIiwge1xuICAgICAgICAgICAgICAgICAgICB1cmw6IGNvbmZpZy5leGlzdGluZ1NlcnZlclVybCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGllbnQgPSBjcmVhdGVPcGVuY29kZUNsaWVudCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlVXJsOiBjb25maWcuZXhpc3RpbmdTZXJ2ZXJVcmwsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFZlcmlmeSBjb25uZWN0aW9uIGJ5IG1ha2luZyBhIHRlc3QgcmVxdWVzdFxuICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoXCJWZXJpZnlpbmcgY29ubmVjdGlvbiB0byBleGlzdGluZyBzZXJ2ZXIuLi5cIik7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IFdlJ2xsIHNraXAgdmVyaWZpY2F0aW9uIGZvciBub3cgdG8gYXZvaWQgdW5uZWNlc3NhcnkgQVBJIGNhbGxzXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBjb25uZWN0aW9uIHdpbGwgYmUgdmVyaWZpZWQgd2hlbiBmaXJzdCBzZXNzaW9uIGlzIGNyZWF0ZWRcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE9wZW5Db2RlQ2xpZW50KGNsaWVudCwgbnVsbCwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1zZyA9XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGxvZy5lcnJvcihcIkZhaWxlZCB0byBjb25uZWN0IHRvIGV4aXN0aW5nIHNlcnZlclwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGNvbmZpZy5leGlzdGluZ1NlcnZlclVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvck1zZyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRGVmYXVsdDogc3Bhd24gYSBuZXcgT3BlbkNvZGUgc2VydmVyXG4gICAgICAgICAgICAvLyBOb3RlOiBTcGF3bmVkIHNlcnZlcnMgd2lsbCB1c2UgdG8gY2FsbGluZyBkaXJlY3RvcnkgYnkgZGVmYXVsdFxuICAgICAgICAgICAgLy8gVXNlIE9QRU5DT0RFX1VSTCB0byBjb25uZWN0IHRvIGEgZGlmZmVyZW50IE9wZW5Db2RlIGluc3RhbmNlXG4gICAgICAgICAgICBsb2cuaW5mbyhcIlNwYXduaW5nIG5ldyBPcGVuQ29kZSBzZXJ2ZXIuLi5cIiwge1xuICAgICAgICAgICAgICAgIHRpbWVvdXQ6IGNvbmZpZy5zZXJ2ZXJTdGFydHVwVGltZW91dCB8fCAxMDAwMCxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCBhdmFpbGFibGVQb3J0ID0gYXdhaXQgT3BlbkNvZGVDbGllbnQuZ2V0QXZhaWxhYmxlUG9ydCgpO1xuXG4gICAgICAgICAgICBjb25zdCB7IGNsaWVudCwgc2VydmVyIH0gPSBhd2FpdCBjcmVhdGVPcGVuY29kZSh7XG4gICAgICAgICAgICAgICAgdGltZW91dDogY29uZmlnLnNlcnZlclN0YXJ0dXBUaW1lb3V0IHx8IDEwMDAwLFxuICAgICAgICAgICAgICAgIHBvcnQ6IGF2YWlsYWJsZVBvcnQsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbG9nLmluZm8oXCJPcGVuQ29kZSBzZXJ2ZXIgc3RhcnRlZCBzdWNjZXNzZnVsbHlcIik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE9wZW5Db2RlQ2xpZW50KGNsaWVudCwgc2VydmVyLCBjb25maWcpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JNc2cgPVxuICAgICAgICAgICAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICAgICAgICAgIGxvZy5lcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgT3BlbkNvZGVDbGllbnRcIiwgeyBlcnJvcjogZXJyb3JNc2cgfSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgT3BlbkNvZGVDbGllbnQ6ICR7ZXJyb3JNc2d9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgT3BlbkNvZGUgc2Vzc2lvbiB3aXRoIGEgZ2l2ZW4gcHJvbXB0XG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlU2Vzc2lvbihwcm9tcHQ6IHN0cmluZyk6IFByb21pc2U8U2Vzc2lvbj4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHNlc3Npb24gdXNpbmcgU0RLXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNsaWVudC5zZXNzaW9uLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJhaS1lbmcgcmFscGggc2Vzc2lvblwiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFyZXN1bHQuZGF0YSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgYEZhaWxlZCB0byBjcmVhdGUgT3BlbkNvZGUgc2Vzc2lvbjogJHtKU09OLnN0cmluZ2lmeShyZXN1bHQuZXJyb3IpfWAsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qgc2RrU2Vzc2lvbiA9IHJlc3VsdC5kYXRhO1xuXG4gICAgICAgICAgICAvLyBEZWZlciB0aGUgaW5pdGlhbCBwcm9tcHQgdW50aWwgdGhlIGZpcnN0IG1lc3NhZ2UgaXMgc2VudC5cbiAgICAgICAgICAgIC8vIFRoaXMgYXZvaWRzIGJsb2NraW5nIHNlc3Npb24gY3JlYXRpb24gYW5kIGVuYWJsZXMgc3RyZWFtaW5nIG91dHB1dFxuICAgICAgICAgICAgLy8gZXZlbiB3aGVuIHRoZSBpbml0aWFsIHByb21wdCBpcyBsYXJnZSBvciBzbG93IHRvIHByb2Nlc3MuXG4gICAgICAgICAgICBsZXQgcGVuZGluZ0luaXRpYWxQcm9tcHQgPSBwcm9tcHQudHJpbSgpO1xuICAgICAgICAgICAgY29uc3QgYnVpbGRGaXJzdE1lc3NhZ2UgPSAobWVzc2FnZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFwZW5kaW5nSW5pdGlhbFByb21wdCkgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tYmluZWQgPSBgJHtwZW5kaW5nSW5pdGlhbFByb21wdH1cXG5cXG4tLS1cXG5cXG4ke21lc3NhZ2V9YDtcbiAgICAgICAgICAgICAgICBwZW5kaW5nSW5pdGlhbFByb21wdCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbWJpbmVkO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0b29sIGludm9jYXRpb25zIHRyYWNrZXJcbiAgICAgICAgICAgIGNvbnN0IHRvb2xJbnZvY2F0aW9uczogU2Vzc2lvbltcIl90b29sSW52b2NhdGlvbnNcIl0gPSBbXTtcblxuICAgICAgICAgICAgLy8gV3JhcCB3aXRoIG91ciBzZXNzaW9uIGludGVyZmFjZVxuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbjogU2Vzc2lvbiA9IHtcbiAgICAgICAgICAgICAgICBpZDogc2RrU2Vzc2lvbi5pZCB8fCB0aGlzLmdlbmVyYXRlU2Vzc2lvbklkKCksXG4gICAgICAgICAgICAgICAgX3Rvb2xJbnZvY2F0aW9uczogdG9vbEludm9jYXRpb25zLFxuICAgICAgICAgICAgICAgIHNlbmRNZXNzYWdlOiBhc3luYyAobWVzc2FnZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlbmRNZXNzYWdlKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2RrU2Vzc2lvbi5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1aWxkRmlyc3RNZXNzYWdlKG1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2VuZE1lc3NhZ2VTdHJlYW06IGFzeW5jIChtZXNzYWdlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VuZE1lc3NhZ2VTdHJlYW0oXG4gICAgICAgICAgICAgICAgICAgICAgICBzZGtTZXNzaW9uLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnVpbGRGaXJzdE1lc3NhZ2UobWVzc2FnZSksXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sSW52b2NhdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjbG9zZTogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVTZXNzaW9uQ2xvc2Uoc2RrU2Vzc2lvbi5pZCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIFN0b3JlIGFjdGl2ZSBzZXNzaW9uXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVNlc3Npb25zLnNldChzZXNzaW9uLmlkLCBzZXNzaW9uKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNlc3Npb247XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPVxuICAgICAgICAgICAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgRmFpbGVkIHRvIGNyZWF0ZSBPcGVuQ29kZSBzZXNzaW9uOiAke2Vycm9yTWVzc2FnZX1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbmQgYSBtZXNzYWdlIHRvIGFuIGV4aXN0aW5nIHNlc3Npb25cbiAgICAgKi9cbiAgICBhc3luYyBzZW5kTWVzc2FnZShcbiAgICAgICAgc2Vzc2lvbklkOiBzdHJpbmcsXG4gICAgICAgIG1lc3NhZ2U6IHN0cmluZyxcbiAgICApOiBQcm9taXNlPE1lc3NhZ2VSZXNwb25zZT4ge1xuICAgICAgICBjb25zdCBzZXNzaW9uID0gdGhpcy5hY3RpdmVTZXNzaW9ucy5nZXQoc2Vzc2lvbklkKTtcblxuICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2Vzc2lvbiBub3QgZm91bmQ6ICR7c2Vzc2lvbklkfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2VuZE1lc3NhZ2Uoc2Vzc2lvbklkLCBtZXNzYWdlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZSBhbiBhY3RpdmUgc2Vzc2lvblxuICAgICAqL1xuICAgIGFzeW5jIGNsb3NlU2Vzc2lvbihzZXNzaW9uSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBzZXNzaW9uID0gdGhpcy5hY3RpdmVTZXNzaW9ucy5nZXQoc2Vzc2lvbklkKTtcblxuICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2Vzc2lvbiBub3QgZm91bmQ6ICR7c2Vzc2lvbklkfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgdGhpcy5oYW5kbGVTZXNzaW9uQ2xvc2Uoc2Vzc2lvbklkKTtcbiAgICAgICAgdGhpcy5hY3RpdmVTZXNzaW9ucy5kZWxldGUoc2Vzc2lvbklkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIGFjdGl2ZSBzZXNzaW9uIElEc1xuICAgICAqL1xuICAgIGdldEFjdGl2ZVNlc3Npb25zKCk6IHN0cmluZ1tdIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5hY3RpdmVTZXNzaW9ucy5rZXlzKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgc2Vzc2lvbiBpcyBhY3RpdmVcbiAgICAgKi9cbiAgICBpc1Nlc3Npb25BY3RpdmUoc2Vzc2lvbklkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlU2Vzc2lvbnMuaGFzKHNlc3Npb25JZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2UgYWxsIGFjdGl2ZSBzZXNzaW9uc1xuICAgICAqL1xuICAgIGFzeW5jIGNsb3NlQWxsU2Vzc2lvbnMoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IGNsb3NlUHJvbWlzZXMgPSBBcnJheS5mcm9tKHRoaXMuYWN0aXZlU2Vzc2lvbnMua2V5cygpKS5tYXAoXG4gICAgICAgICAgICAoc2Vzc2lvbklkKSA9PlxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlU2Vzc2lvbkNsb3NlKHNlc3Npb25JZCkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTXNnID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nLndhcm4oXCJFcnJvciBjbG9zaW5nIHNlc3Npb25cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yTXNnLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgKTtcblxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChjbG9zZVByb21pc2VzKTtcbiAgICAgICAgdGhpcy5hY3RpdmVTZXNzaW9ucy5jbGVhcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBzZW5kaW5nIGEgbWVzc2FnZSB3aXRoIHN0cmVhbWluZyBzdXBwb3J0XG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3luYyBoYW5kbGVTZW5kTWVzc2FnZVN0cmVhbShcbiAgICAgICAgc2Vzc2lvbklkOiBzdHJpbmcsXG4gICAgICAgIG1lc3NhZ2U6IHN0cmluZyxcbiAgICAgICAgdG9vbEludm9jYXRpb25zPzogU2Vzc2lvbltcIl90b29sSW52b2NhdGlvbnNcIl0sXG4gICAgKTogUHJvbWlzZTxTdHJlYW1pbmdSZXNwb25zZT4ge1xuICAgICAgICBsZXQgbGFzdEVycm9yOiBFcnJvciB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgIGNvbnN0IHN1cHBvcnRzRXZlbnRTdHJlYW1pbmcgPVxuICAgICAgICAgICAgdHlwZW9mICh0aGlzLmNsaWVudCBhcyBhbnkpPy5zZXNzaW9uPy5wcm9tcHRBc3luYyA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICB0eXBlb2YgKHRoaXMuY2xpZW50IGFzIGFueSk/LmV2ZW50Py5zdWJzY3JpYmUgPT09IFwiZnVuY3Rpb25cIjtcblxuICAgICAgICBmb3IgKGxldCBhdHRlbXB0ID0gMTsgYXR0ZW1wdCA8PSB0aGlzLnJldHJ5QXR0ZW1wdHM7IGF0dGVtcHQrKykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBUcmFuc2Zvcm1TdHJlYW0gdG8gaGFuZGxlIHRoZSBzdHJlYW1pbmcgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJlYW0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtPFVpbnQ4QXJyYXksIFVpbnQ4QXJyYXk+KCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgd3JpdGVyID0gc3RyZWFtLndyaXRhYmxlLmdldFdyaXRlcigpO1xuXG4gICAgICAgICAgICAgICAgLy8gVHJhY2sgZmluYWxpemF0aW9uIHRvIHByZXZlbnQgZG91YmxlLWNsb3NlL2Fib3J0XG4gICAgICAgICAgICAgICAgbGV0IGZpbmFsaXplZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsb3NlT25jZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsaXplZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBmaW5hbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgd3JpdGVyLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGVycm9ycyBkdXJpbmcgY2xvc2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgYWJvcnRPbmNlID0gYXN5bmMgKGVycjogdW5rbm93bikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmluYWxpemVkKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB3cml0ZXIuYWJvcnQoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZXJyb3JzIGR1cmluZyBhYm9ydFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrOiBpZiB0aGUgY2xpZW50IGRvZXNuJ3Qgc3VwcG9ydCBwcm9tcHRfYXN5bmMgKyBTU0UsIGtlZXAgdGhlXG4gICAgICAgICAgICAgICAgLy8gbGVnYWN5IGJlaGF2aW9yIChidWZmZXIgdGhlbiBzaW11bGF0ZSBzdHJlYW1pbmcpLlxuICAgICAgICAgICAgICAgIGlmICghc3VwcG9ydHNFdmVudFN0cmVhbWluZykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9tcHRQcm9taXNlID0gdGhpcy5jbGllbnQuc2Vzc2lvbi5wcm9tcHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VJRDogdGhpcy5nZW5lcmF0ZU1lc3NhZ2VJZCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0b3J5OiB0aGlzLmRpcmVjdG9yeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0gYXMgYW55KTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJlYW1pbmdUYXNrID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvbXB0UHJvbWlzZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYEludmFsaWQgcmVzcG9uc2UgZnJvbSBPcGVuQ29kZTogJHtKU09OLnN0cmluZ2lmeShyZXN1bHQuZXJyb3IpfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSByZXN1bHQuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0UGFydCA9IHJlc3BvbnNlLnBhcnRzPy5maW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocGFydDogYW55KSA9PiBwYXJ0LnR5cGUgPT09IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaW5hbENvbnRlbnQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGV4dFBhcnQgYXMgYW55KT8udGV4dCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIk5vIGNvbnRlbnQgcmVjZWl2ZWRcIjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpbXVsYXRlIHN0cmVhbWluZyBieSB3cml0aW5nIGNodW5rc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rcyA9IHRoaXMuc3BsaXRJbnRvQ2h1bmtzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbENvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHdyaXRlci53cml0ZShlbmNvZGVyLmVuY29kZShjaHVuaykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgNTApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGNsb3NlT25jZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGNvbnRlbnQ6IGZpbmFsQ29udGVudCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBhYm9ydE9uY2UoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW06IHN0cmVhbS5yZWFkYWJsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBzdHJlYW1pbmdUYXNrLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJlYWwgc3RyZWFtaW5nOiB1c2UgcHJvbXB0X2FzeW5jIGFuZCBjb25zdW1lIHRoZSBldmVudCBTU0Ugc3RyZWFtLlxuICAgICAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpZGxlVGltZW91dEVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBgUHJvbXB0IGlkbGUgdGltZW91dCBhZnRlciAke3RoaXMucHJvbXB0VGltZW91dH1tc2AsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBjb25zdCBoYXJkVGltZW91dEVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBgUHJvbXB0IGhhcmQgdGltZW91dCBhZnRlciAke3RoaXMucHJvbXB0VGltZW91dCAqIDV9bXNgLFxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICAgICAgICAgIGxldCBpZGxlVGltZXI6IFJldHVyblR5cGU8dHlwZW9mIHNldFRpbWVvdXQ+IHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGxldCBoYXJkVGltZXI6IFJldHVyblR5cGU8dHlwZW9mIHNldFRpbWVvdXQ+IHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGxldCBieXRlc1dyaXR0ZW4gPSAwO1xuICAgICAgICAgICAgICAgIGxldCBsYXN0UHJvZ3Jlc3NUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICBsZXQgaWRsZVRpbWVkT3V0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAvLyBIYXJkIHRpbWVvdXQgLSBuZXZlciByZXNldHNcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydEhhcmRUaW1lciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhcmRUaW1lcikgY2xlYXJUaW1lb3V0KGhhcmRUaW1lcik7XG4gICAgICAgICAgICAgICAgICAgIGhhcmRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nLndhcm4oXCJIYXJkIHRpbWVvdXQgcmVhY2hlZCwgYWJvcnRpbmdcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0TXM6IHRoaXMucHJvbXB0VGltZW91dCAqIDUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5hYm9ydChoYXJkVGltZW91dEVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLnByb21wdFRpbWVvdXQgKiA1KTsgLy8gNXggaWRsZSB0aW1lb3V0IGFzIGhhcmQgY2VpbGluZ1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBJZGxlIHRpbWVyIC0gcmVzZXRzIG9ubHkgb24gcmVsZXZhbnQgcHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICBjb25zdCByZXNldElkbGVUaW1lciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkbGVUaW1lcikgY2xlYXJUaW1lb3V0KGlkbGVUaW1lcik7XG4gICAgICAgICAgICAgICAgICAgIGlkbGVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWRsZVRpbWVkT3V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy53YXJuKFwiSWRsZSB0aW1lb3V0IHJlYWNoZWQsIGFib3J0aW5nXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dE1zOiB0aGlzLnByb21wdFRpbWVvdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNXcml0dGVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RQcm9ncmVzc01zQWdvOiBEYXRlLm5vdygpIC0gbGFzdFByb2dyZXNzVGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmFib3J0KGlkbGVUaW1lb3V0RXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMucHJvbXB0VGltZW91dCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmVhbWluZ1Rhc2sgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRIYXJkVGltZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0SWRsZVRpbWVyKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJNZXNzYWdlSWQgPSB0aGlzLmdlbmVyYXRlTWVzc2FnZUlkKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZyhcIlNlbmRpbmcgcHJvbXB0IHRvIE9wZW5Db2RlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZUxlbmd0aDogbWVzc2FnZS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlck1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCAodGhpcy5jbGllbnQgYXMgYW55KS5zZXNzaW9uLnByb21wdEFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VJRDogdXNlck1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdG9yeTogdGhpcy5kaXJlY3RvcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZyhcIlN1YnNjcmliaW5nIHRvIGV2ZW50c1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdG9yeTogdGhpcy5kaXJlY3RvcnksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnRzUmVzdWx0ID0gYXdhaXQgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50IGFzIGFueVxuICAgICAgICAgICAgICAgICAgICAgICAgKS5ldmVudC5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdG9yeTogdGhpcy5kaXJlY3RvcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhc3Npc3RhbnRNZXNzYWdlSWQ6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVtaXR0ZWRUZXh0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBldmVudENvdW50ID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nLmRlYnVnKFwiU3RhcnRpbmcgZXZlbnQgc3RyZWFtIHByb2Nlc3NpbmdcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGV2ZW50IG9mIGV2ZW50c1Jlc3VsdC5zdHJlYW0gYXMgQXN5bmNHZW5lcmF0b3I8YW55Pikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Q291bnQrKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZlcmJvc2UgZGVidWcgbG9nZ2luZyBmb3IgYWxsIGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZyhcIlJlY2VpdmVkIGV2ZW50XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudFR5cGU6IGV2ZW50Py50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudENvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNQcm9wZXJ0aWVzOiAhIWV2ZW50Py5wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyQWJvcnRlZDogY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQ29udHJvbGxlciBhYm9ydGVkLCBicmVha2luZyBldmVudCBsb29wXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Q291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW50IHx8IHR5cGVvZiBldmVudCAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoXCJTa2lwcGluZyBub24tb2JqZWN0IGV2ZW50XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Q291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJtZXNzYWdlLnVwZGF0ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmZvID0gKGV2ZW50IGFzIGFueSkucHJvcGVydGllcz8uaW5mbztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoXCJNZXNzYWdlIHVwZGF0ZWQgZXZlbnRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm9Sb2xlOiBpbmZvPy5yb2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mb1Nlc3Npb25JZDogaW5mbz8uc2Vzc2lvbklELFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mb1BhcmVudElkOiBpbmZvPy5wYXJlbnRJRCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm9JZDogaW5mbz8uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1JlbGV2YW50U2Vzc2lvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvPy5zZXNzaW9uSUQgPT09IHNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQXNzaXN0YW50OiBpbmZvPy5yb2xlID09PSBcImFzc2lzdGFudFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNSZXBseVRvVXNlcjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvPy5wYXJlbnRJRCA9PT0gdXNlck1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJpbWFyeSBpZGVudGlmaWNhdGlvbjogZXhhY3QgbWF0Y2ggb24gcGFyZW50SURcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mbz8ucm9sZSA9PT0gXCJhc3Npc3RhbnRcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mbz8uc2Vzc2lvbklEID09PSBzZXNzaW9uSWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm8/LnBhcmVudElEID09PSB1c2VyTWVzc2FnZUlkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzaXN0YW50TWVzc2FnZUlkID0gaW5mby5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIklkZW50aWZpZWQgYXNzaXN0YW50IG1lc3NhZ2UgKGV4YWN0IHBhcmVudElEIG1hdGNoKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3Npc3RhbnRNZXNzYWdlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFsbGJhY2s6IGlmIHdlIGhhdmVuJ3QgaWRlbnRpZmllZCBhbiBhc3Npc3RhbnQgbWVzc2FnZSB5ZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFjY2VwdCBhc3Npc3RhbnQgbWVzc2FnZXMgaW4gdGhlIHNhbWUgc2Vzc2lvbiBldmVuIGlmIHBhcmVudElEIGRvZXNuJ3QgbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBoYW5kbGVzIGNhc2VzIHdoZXJlIHBhcmVudElEIGlzIHVuZGVmaW5lZCBvciBoYXMgYSBkaWZmZXJlbnQgZm9ybWF0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWFzc2lzdGFudE1lc3NhZ2VJZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mbz8ucm9sZSA9PT0gXCJhc3Npc3RhbnRcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mbz8uc2Vzc2lvbklEID09PSBzZXNzaW9uSWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJJZGVudGlmaWVkIGFzc2lzdGFudCBtZXNzYWdlIChmYWxsYmFjayAtIG5vIGV4YWN0IHBhcmVudElEIG1hdGNoKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3Npc3RhbnRNZXNzYWdlSWQ6IGluZm8uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm9QYXJlbnRJZDogaW5mbz8ucGFyZW50SUQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJNZXNzYWdlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3Npc3RhbnRNZXNzYWdlSWQgPSBpbmZvLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgaWRsZSB0aW1lciBvbiBBTlkgYXNzaXN0YW50IG1lc3NhZ2UgYWN0aXZpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBwcmV2ZW50cyB0aW1lb3V0cyB3aGVuIGNvcnJlbGF0aW9uIGlzIGFtYmlndW91c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvPy5yb2xlID09PSBcImFzc2lzdGFudFwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvPy5zZXNzaW9uSUQgPT09IHNlc3Npb25JZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RQcm9ncmVzc1RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXRJZGxlVGltZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2lzdGFudE1lc3NhZ2VJZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mbz8uaWQgPT09IGFzc2lzdGFudE1lc3NhZ2VJZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmZvPy5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyck5hbWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvLmVycm9yLm5hbWUgfHwgXCJPcGVuQ29kZUVycm9yXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyTXNnID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mby5lcnJvci5kYXRhPy5tZXNzYWdlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mby5lcnJvci5kYXRhIHx8IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJBc3Npc3RhbnQgZXJyb3IgaW4gbWVzc2FnZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvck5hbWU6IGVyck5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2U6IGVyck1zZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYCR7ZXJyTmFtZX06ICR7ZXJyTXNnfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8/LnRpbWU/LmNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJBc3Npc3RhbnQgbWVzc2FnZSBjb21wbGV0ZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzaXN0YW50TWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVkQXQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mby50aW1lLmNvbXBsZXRlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IFwibWVzc2FnZS5wYXJ0LnVwZGF0ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IHJlc2V0IHRpbWVyIGFuZCB0cmFjayBwcm9ncmVzcyBmb3IgcmVsZXZhbnQgdXBkYXRlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0ID0gKGV2ZW50IGFzIGFueSkucHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPy5wYXJ0IGFzIGFueTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoXCJNZXNzYWdlIHBhcnQgdXBkYXRlZFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudENvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzUGFydDogISFwYXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydFR5cGU6IHBhcnQ/LnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0U2Vzc2lvbklkOiBwYXJ0Py5zZXNzaW9uSUQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0TWVzc2FnZUlkOiBwYXJ0Py5tZXNzYWdlSUQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3Npc3RhbnRNZXNzYWdlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1JlbGV2YW50OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2lzdGFudE1lc3NhZ2VJZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnQ/LnNlc3Npb25JRCA9PT0gc2Vzc2lvbklkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydD8ubWVzc2FnZUlEID09PSBhc3Npc3RhbnRNZXNzYWdlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXNzaXN0YW50TWVzc2FnZUlkKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgdG9vbCBwYXJ0cyAoY2FwdHVyZSB0b29sIGludm9jYXRpb25zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFydD8udHlwZSA9PT0gXCJ0b29sXCIgJiYgdG9vbEludm9jYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b29sSWQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnQudG9vbElkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydC5pZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGB0b29sLSR7ZXZlbnRDb3VudH1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9vbE5hbWUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnQudG9vbE5hbWUgfHwgcGFydC5uYW1lIHx8IFwidW5rbm93blwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9vbElucHV0ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0LmlucHV0IHx8IHBhcnQucGFyYW1ldGVycyB8fCB7fTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIG5ldyB0b29sIGNhbGwgb3IgYW4gdXBkYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ1Rvb2xJbmRleCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbEludm9jYXRpb25zLmZpbmRJbmRleChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHQpID0+IHQuaWQgPT09IHRvb2xJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdUb29sSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBleGlzdGluZyB0b29sIGludm9jYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xJbnZvY2F0aW9uc1tleGlzdGluZ1Rvb2xJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3Rpbmcub3V0cHV0ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydC5yZXN1bHQgPz9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydC5vdXRwdXQgPz9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3Rpbmcub3V0cHV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLnN0YXR1cyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnQuc3RhdHVzID09PSBcImVycm9yXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gXCJlcnJvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwib2tcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5lcnJvciA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnQuZXJyb3IgPz8gZXhpc3RpbmcuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcuY29tcGxldGVkQXQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0LmNvbXBsZXRlZEF0ID8/IG5vdztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZyhcIlRvb2wgaW52b2NhdGlvbiB1cGRhdGVkXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IGV4aXN0aW5nLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmV3IHRvb2wgaW52b2NhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xJbnZvY2F0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogdG9vbElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiB0b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRvb2xJbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiBwYXJ0LnJlc3VsdCA/PyBwYXJ0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydC5zdGF0dXMgPT09IFwiZXJyb3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKFwiZXJyb3JcIiBhcyBjb25zdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IChcIm9rXCIgYXMgY29uc3QpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogcGFydC5lcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRlZEF0OiBwYXJ0LnN0YXJ0ZWRBdCA/PyBub3csXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZEF0OiBwYXJ0LmNvbXBsZXRlZEF0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbEludm9jYXRpb25zLnB1c2godG9vbEludm9jYXRpb24pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nLmRlYnVnKFwiVG9vbCBpbnZvY2F0aW9uIHN0YXJ0ZWRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xJbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKS5zbGljZSgwLCAyMDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBza2lwIG5vbi1yZWxldmFudCB0b29sIHBhcnRzIC0gd2Ugd2FudCB0byBjYXB0dXJlIGFsbCB0b29sIGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHRoZSBhc3Npc3RhbnQgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnQuc2Vzc2lvbklEICE9PSBzZXNzaW9uSWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0Lm1lc3NhZ2VJRCAhPT0gYXNzaXN0YW50TWVzc2FnZUlkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGlsbCB0cmFjayBpdCBidXQgZG9uJ3QgcHJvY2VzcyBmb3Igb3V0cHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IGlkbGUgdGltZXIgb24gdG9vbCBwcm9ncmVzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RQcm9ncmVzc1RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0SWRsZVRpbWVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJ0IHx8IHBhcnQudHlwZSAhPT0gXCJ0ZXh0XCIpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFydC5zZXNzaW9uSUQgIT09IHNlc3Npb25JZCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0Lm1lc3NhZ2VJRCAhPT0gYXNzaXN0YW50TWVzc2FnZUlkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmF3RGVsdGEgPSAoZXZlbnQgYXMgYW55KS5wcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/LmRlbHRhO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkZWx0YVRleHQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmVmZXIgZGlmZmluZyBhZ2FpbnN0IHRoZSBmdWxsIGBwYXJ0LnRleHRgIHdoZW4gcHJlc2VudC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU29tZSBPcGVuQ29kZSBzZXJ2ZXIgdmVyc2lvbnMgZW1pdCBtdWx0aXBsZSB0ZXh0IHBhcnRzIG9yIHNlbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYGRlbHRhYCBhcyB0aGUgKmZ1bGwqIHRleHQsIHdoaWNoIHdvdWxkIGR1cGxpY2F0ZSBvdXRwdXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydC50ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gcGFydC50ZXh0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC5zdGFydHNXaXRoKGVtaXR0ZWRUZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbHRhVGV4dCA9IG5leHQuc2xpY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtaXR0ZWRUZXh0Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtaXR0ZWRUZXh0ID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZW1pdHRlZFRleHQuc3RhcnRzV2l0aChuZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0YWxlL2R1cGxpY2F0ZSB1cGRhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YVRleHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWxsYmFjazogdHJlYXQgYXMgYWRkaXRpdmUgY2h1bmtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YVRleHQgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtaXR0ZWRUZXh0ICs9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJhd0RlbHRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YVRleHQgPSByYXdEZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtaXR0ZWRUZXh0ICs9IHJhd0RlbHRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkZWx0YVRleHQpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBwcm9ncmVzcyB0cmFja2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0UHJvZ3Jlc3NUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNXcml0dGVuICs9IGRlbHRhVGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0SWRsZVRpbWVyKCk7IC8vIE9ubHkgcmVzZXQgb24gYWN0dWFsIGNvbnRlbnQgcHJvZ3Jlc3NcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoXCJXcml0aW5nIGRlbHRhIHRvIHN0cmVhbVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YUxlbmd0aDogZGVsdGFUZXh0Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsQnl0ZXNXcml0dGVuOiBieXRlc1dyaXR0ZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50TGVuZ3RoOiBjb250ZW50Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCArPSBkZWx0YVRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHdyaXRlci53cml0ZShlbmNvZGVyLmVuY29kZShkZWx0YVRleHQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZyhcIkV2ZW50IHN0cmVhbSBlbmRlZFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Q291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxCeXRlc1dyaXR0ZW46IGJ5dGVzV3JpdHRlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50TGVuZ3RoOiBjb250ZW50Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyQWJvcnRlZDogY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGxlVGltZWRPdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzaXN0YW50TWVzc2FnZUlkRm91bmQ6ICEhYXNzaXN0YW50TWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGNsb3NlT25jZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBjb250ZW50IHx8IFwiTm8gY29udGVudCByZWNlaXZlZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpYWdub3N0aWNzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzV3JpdHRlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudExlbmd0aDogY29udGVudC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkbGVUaW1lZE91dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzaXN0YW50TWVzc2FnZUlkRm91bmQ6ICEhYXNzaXN0YW50TWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudENvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nLmVycm9yKFwiU3RyZWFtaW5nIHRhc2sgZXJyb3JcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFN0cmluZyhlcnJvciksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlckFib3J0ZWQ6IGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXNXcml0dGVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkbGVUaW1lZE91dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3Npc3RhbnRNZXNzYWdlSWRGb3VuZDogISFhc3Npc3RhbnRNZXNzYWdlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGFib3J0ZWQsIG5vcm1hbGl6ZSB0byBvdXIgdGltZW91dCBlcnJvciBBTkQgZW5zdXJlIHN0cmVhbSBpcyBmaW5hbGl6ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgYWJvcnRPbmNlKGlkbGVUaW1lb3V0RXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGlkbGVUaW1lb3V0RXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBhYm9ydE9uY2UoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWRsZVRpbWVyKSBjbGVhclRpbWVvdXQoaWRsZVRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXJkVGltZXIpIGNsZWFyVGltZW91dChoYXJkVGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbTogc3RyZWFtLnJlYWRhYmxlLFxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogc3RyZWFtaW5nVGFzayxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsYXN0RXJyb3IgPVxuICAgICAgICAgICAgICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yKSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBpc1JhdGVMaW1pdCA9IHRoaXMuaXNSYXRlTGltaXRFcnJvcihsYXN0RXJyb3IpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGF0dGVtcHQgPT09IHRoaXMucmV0cnlBdHRlbXB0cykge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBkZWxheSA9IHRoaXMuZ2V0QmFja29mZkRlbGF5KGF0dGVtcHQsIGlzUmF0ZUxpbWl0KTtcblxuICAgICAgICAgICAgICAgIGxvZy53YXJuKFwiT3BlbkNvZGUgYXR0ZW1wdCBmYWlsZWQ7IHJldHJ5aW5nXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdCxcbiAgICAgICAgICAgICAgICAgICAgcmV0cnlBdHRlbXB0czogdGhpcy5yZXRyeUF0dGVtcHRzLFxuICAgICAgICAgICAgICAgICAgICBkZWxheU1zOiBkZWxheSxcbiAgICAgICAgICAgICAgICAgICAgaXNSYXRlTGltaXQsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBsYXN0RXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgRmFpbGVkIHRvIHN0cmVhbSBtZXNzYWdlIGFmdGVyICR7dGhpcy5yZXRyeUF0dGVtcHRzfSBhdHRlbXB0czogJHtsYXN0RXJyb3I/Lm1lc3NhZ2UgfHwgXCJVbmtub3duIGVycm9yXCJ9YCxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTcGxpdCB0ZXh0IGludG8gY2h1bmtzIGZvciBzdHJlYW1pbmcgc2ltdWxhdGlvblxuICAgICAqL1xuICAgIHByaXZhdGUgc3BsaXRJbnRvQ2h1bmtzKHRleHQ6IHN0cmluZywgY2h1bmtTaXplOiBudW1iZXIpOiBzdHJpbmdbXSB7XG4gICAgICAgIGNvbnN0IGNodW5rczogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSArPSBjaHVua1NpemUpIHtcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKHRleHQuc2xpY2UoaSwgaSArIGNodW5rU2l6ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaHVua3MubGVuZ3RoID4gMCA/IGNodW5rcyA6IFt0ZXh0XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgc2VuZGluZyBhIG1lc3NhZ2Ugd2l0aCBlcnJvciBoYW5kbGluZyBhbmQgcmV0cmllc1xuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgaGFuZGxlU2VuZE1lc3NhZ2UoXG4gICAgICAgIHNlc3Npb25JZDogc3RyaW5nLFxuICAgICAgICBtZXNzYWdlOiBzdHJpbmcsXG4gICAgKTogUHJvbWlzZTxNZXNzYWdlUmVzcG9uc2U+IHtcbiAgICAgICAgbGV0IGxhc3RFcnJvcjogRXJyb3IgfCBudWxsID0gbnVsbDtcblxuICAgICAgICBmb3IgKGxldCBhdHRlbXB0ID0gMTsgYXR0ZW1wdCA8PSB0aGlzLnJldHJ5QXR0ZW1wdHM7IGF0dGVtcHQrKykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lb3V0RXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIGBQcm9tcHQgdGltZW91dCBhZnRlciAke3RoaXMucHJvbXB0VGltZW91dH1tc2AsXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuYWJvcnQodGltZW91dEVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRoaXMucHJvbXB0VGltZW91dCk7XG5cbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0OiBhbnk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5jbGllbnQuc2Vzc2lvbi5wcm9tcHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VJRDogdGhpcy5nZW5lcmF0ZU1lc3NhZ2VJZCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0b3J5OiB0aGlzLmRpcmVjdG9yeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICB9IGFzIGFueSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHRpbWVvdXRFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgYEludmFsaWQgcmVzcG9uc2UgZnJvbSBPcGVuQ29kZTogJHtKU09OLnN0cmluZ2lmeShyZXN1bHQuZXJyb3IpfWAsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBjb250ZW50IGZyb20gcmVzcG9uc2VcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHJlc3VsdC5kYXRhO1xuXG4gICAgICAgICAgICAgICAgLy8gRmluZCB0ZXh0IGNvbnRlbnQgZnJvbSByZXNwb25zZSBwYXJ0c1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHRQYXJ0ID0gcmVzcG9uc2UucGFydHM/LmZpbmQoXG4gICAgICAgICAgICAgICAgICAgIChwYXJ0OiBhbnkpID0+IHBhcnQudHlwZSA9PT0gXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBjb250ZW50OiB0ZXh0UGFydD8udGV4dCB8fCBcIk5vIGNvbnRlbnQgcmVjZWl2ZWRcIiB9O1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsYXN0RXJyb3IgPVxuICAgICAgICAgICAgICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yKSk7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgcmF0ZSBsaW1pdCBlcnJvclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzUmF0ZUxpbWl0ID0gdGhpcy5pc1JhdGVMaW1pdEVycm9yKGxhc3RFcnJvcik7XG5cbiAgICAgICAgICAgICAgICBpZiAoYXR0ZW1wdCA9PT0gdGhpcy5yZXRyeUF0dGVtcHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFdhaXQgYmVmb3JlIHJldHJ5aW5nIHdpdGggZXhwb25lbnRpYWwgYmFja29mZlxuICAgICAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gdGhpcy5nZXRCYWNrb2ZmRGVsYXkoYXR0ZW1wdCwgaXNSYXRlTGltaXQpO1xuXG4gICAgICAgICAgICAgICAgbG9nLndhcm4oXCJPcGVuQ29kZSBhdHRlbXB0IGZhaWxlZDsgcmV0cnlpbmdcIiwge1xuICAgICAgICAgICAgICAgICAgICBhdHRlbXB0LFxuICAgICAgICAgICAgICAgICAgICByZXRyeUF0dGVtcHRzOiB0aGlzLnJldHJ5QXR0ZW1wdHMsXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5TXM6IGRlbGF5LFxuICAgICAgICAgICAgICAgICAgICBpc1JhdGVMaW1pdCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGxhc3RFcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBGYWlsZWQgdG8gc2VuZCBtZXNzYWdlIGFmdGVyICR7dGhpcy5yZXRyeUF0dGVtcHRzfSBhdHRlbXB0czogJHtsYXN0RXJyb3I/Lm1lc3NhZ2UgfHwgXCJVbmtub3duIGVycm9yXCJ9YCxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBlcnJvciBpcyBhIHJhdGUgbGltaXQgZXJyb3JcbiAgICAgKi9cbiAgICBwcml2YXRlIGlzUmF0ZUxpbWl0RXJyb3IoZXJyb3I6IEVycm9yKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IGVyciA9IGVycm9yIGFzIGFueTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGVyci5zdGF0dXMgPT09IDQyOSB8fFxuICAgICAgICAgICAgL3JhdGUgbGltaXR8cXVvdGF8b3ZlcmxvYWRlZHxjYXBhY2l0eS9pLnRlc3QoZXJyb3IubWVzc2FnZSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgYmFja29mZiBkZWxheSB3aXRoIGppdHRlclxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0QmFja29mZkRlbGF5KGF0dGVtcHQ6IG51bWJlciwgaXNSYXRlTGltaXQ6IGJvb2xlYW4pOiBudW1iZXIge1xuICAgICAgICBjb25zdCBiYXNlID0gaXNSYXRlTGltaXQgPyA1MDAwIDogMTAwMDsgLy8gNXMgZm9yIHJhdGUgbGltaXQsIDFzIG90aGVyd2lzZVxuICAgICAgICBjb25zdCBleHBvbmVudGlhbCA9IGJhc2UgKiAyICoqIChhdHRlbXB0IC0gMSk7XG4gICAgICAgIGNvbnN0IGppdHRlciA9IE1hdGgucmFuZG9tKCkgKiAxMDAwOyAvLyBBZGQgdXAgdG8gMXMgaml0dGVyXG4gICAgICAgIHJldHVybiBNYXRoLm1pbihleHBvbmVudGlhbCArIGppdHRlciwgNjAwMDApOyAvLyBtYXggNjBzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIHNlc3Npb24gY2xvc3VyZSB3aXRoIGVycm9yIGhhbmRsaW5nXG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3luYyBoYW5kbGVTZXNzaW9uQ2xvc2Uoc2Vzc2lvbklkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIE5vdGU6IE9wZW5Db2RlIFNESyBtaWdodCBub3QgaGF2ZSBhbiBleHBsaWNpdCBjbG9zZSBtZXRob2RcbiAgICAgICAgICAgIC8vIEZvciBub3csIHdlJ2xsIGp1c3QgcmVtb3ZlIGZyb20gb3VyIGFjdGl2ZSBzZXNzaW9uc1xuICAgICAgICAgICAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB3ZSdkIGNhbGwgU0RLJ3MgZGVsZXRlIG1ldGhvZCBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhcIlNlc3Npb24gY2xvc2VkXCIsIHsgc2Vzc2lvbklkIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID1cbiAgICAgICAgICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICAgICAgICBsb2cud2FybihcIkZhaWxlZCB0byBjbG9zZSBzZXNzaW9uXCIsIHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yTWVzc2FnZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSB1bmlxdWUgc2Vzc2lvbiBJRCBpZiBTREsgZG9lc24ndCBwcm92aWRlIG9uZVxuICAgICAqL1xuICAgIHByaXZhdGUgZ2VuZXJhdGVTZXNzaW9uSWQoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGBzZXNzaW9uLSR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSl9YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIHByb3Blcmx5IGZvcm1hdHRlZCBtZXNzYWdlIElEIHdpdGggbXNnXyBwcmVmaXhcbiAgICAgKiBGb3JtYXQ6IG1zZ188dGltZXN0YW1wPl88cmFuZG9tPlxuICAgICAqL1xuICAgIHByaXZhdGUgZ2VuZXJhdGVNZXNzYWdlSWQoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGBtc2dfJHtEYXRlLm5vdygpfV8ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCA4KX1gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFudXAgbWV0aG9kIHRvIGNsb3NlIGFsbCBzZXNzaW9ucyBhbmQgc2VydmVyXG4gICAgICovXG4gICAgYXN5bmMgY2xlYW51cCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhcIlN0YXJ0aW5nIGNsZWFudXAuLi5cIiwge1xuICAgICAgICAgICAgICAgIGFjdGl2ZVNlc3Npb25zOiB0aGlzLmFjdGl2ZVNlc3Npb25zLnNpemUsXG4gICAgICAgICAgICAgICAgaGFzU2VydmVyOiAhIXRoaXMuc2VydmVyLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIENsb3NlIGFsbCBhY3RpdmUgc2Vzc2lvbnNcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuY2xvc2VBbGxTZXNzaW9ucygpO1xuXG4gICAgICAgICAgICAvLyBTdG9wIHRoZSBPcGVuQ29kZSBzZXJ2ZXIgaWYgd2Ugc3RhcnRlZCBvbmVcbiAgICAgICAgICAgIGlmICh0aGlzLnNlcnZlcikge1xuICAgICAgICAgICAgICAgIGxvZy5pbmZvKFwiQ2xvc2luZyBzcGF3bmVkIE9wZW5Db2RlIHNlcnZlclwiKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlcnZlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlcnZlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGxvZy5pbmZvKFwiT3BlbkNvZGUgc2VydmVyIGNsb3NlZCBzdWNjZXNzZnVsbHlcIik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNc2cgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBsb2cuZXJyb3IoXCJFcnJvciBjbG9zaW5nIE9wZW5Db2RlIHNlcnZlclwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JNc2csXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nLmRlYnVnKFxuICAgICAgICAgICAgICAgICAgICBcIk5vIHNwYXduZWQgc2VydmVyIHRvIGNsb3NlIChjb25uZWN0ZWQgdG8gZXhpc3Rpbmcgc2VydmVyKVwiLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxvZy5pbmZvKFwiQ2xlYW51cCBjb21wbGV0ZVwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTXNnID1cbiAgICAgICAgICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICAgICAgICBsb2cuZXJyb3IoXCJFcnJvciBkdXJpbmcgT3BlbkNvZGUgY2xpZW50IGNsZWFudXBcIiwge1xuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvck1zZyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwKICAgICIvLyBUaGlzIGZpbGUgaXMgYXV0by1nZW5lcmF0ZWQgYnkgQGhleS1hcGkvb3BlbmFwaS10c1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVNzZUNsaWVudCA9ICh7IG9uU3NlRXJyb3IsIG9uU3NlRXZlbnQsIHJlc3BvbnNlVHJhbnNmb3JtZXIsIHJlc3BvbnNlVmFsaWRhdG9yLCBzc2VEZWZhdWx0UmV0cnlEZWxheSwgc3NlTWF4UmV0cnlBdHRlbXB0cywgc3NlTWF4UmV0cnlEZWxheSwgc3NlU2xlZXBGbiwgdXJsLCAuLi5vcHRpb25zIH0pID0+IHtcbiAgICBsZXQgbGFzdEV2ZW50SWQ7XG4gICAgY29uc3Qgc2xlZXAgPSBzc2VTbGVlcEZuID8/ICgobXMpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSkpO1xuICAgIGNvbnN0IGNyZWF0ZVN0cmVhbSA9IGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGxldCByZXRyeURlbGF5ID0gc3NlRGVmYXVsdFJldHJ5RGVsYXkgPz8gMzAwMDtcbiAgICAgICAgbGV0IGF0dGVtcHQgPSAwO1xuICAgICAgICBjb25zdCBzaWduYWwgPSBvcHRpb25zLnNpZ25hbCA/PyBuZXcgQWJvcnRDb250cm9sbGVyKCkuc2lnbmFsO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgaWYgKHNpZ25hbC5hYm9ydGVkKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgYXR0ZW1wdCsrO1xuICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnNcbiAgICAgICAgICAgICAgICA/IG9wdGlvbnMuaGVhZGVyc1xuICAgICAgICAgICAgICAgIDogbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgICAgIGlmIChsYXN0RXZlbnRJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVycy5zZXQoXCJMYXN0LUV2ZW50LUlEXCIsIGxhc3RFdmVudElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHsgLi4ub3B0aW9ucywgaGVhZGVycywgc2lnbmFsIH0pO1xuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU1NFIGZhaWxlZDogJHtyZXNwb25zZS5zdGF0dXN9ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLmJvZHkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGJvZHkgaW4gU1NFIHJlc3BvbnNlXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkucGlwZVRocm91Z2gobmV3IFRleHREZWNvZGVyU3RyZWFtKCkpLmdldFJlYWRlcigpO1xuICAgICAgICAgICAgICAgIGxldCBidWZmZXIgPSBcIlwiO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFib3J0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub29wXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgYWJvcnRIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyICs9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmtzID0gYnVmZmVyLnNwbGl0KFwiXFxuXFxuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gY2h1bmtzLnBvcCgpID8/IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gY2h1bmsuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YUxpbmVzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGV2ZW50TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUuc3RhcnRzV2l0aChcImRhdGE6XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhTGluZXMucHVzaChsaW5lLnJlcGxhY2UoL15kYXRhOlxccyovLCBcIlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobGluZS5zdGFydHNXaXRoKFwiZXZlbnQ6XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudE5hbWUgPSBsaW5lLnJlcGxhY2UoL15ldmVudDpcXHMqLywgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobGluZS5zdGFydHNXaXRoKFwiaWQ6XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0RXZlbnRJZCA9IGxpbmUucmVwbGFjZSgvXmlkOlxccyovLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChsaW5lLnN0YXJ0c1dpdGgoXCJyZXRyeTpcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IE51bWJlci5wYXJzZUludChsaW5lLnJlcGxhY2UoL15yZXRyeTpcXHMqLywgXCJcIiksIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghTnVtYmVyLmlzTmFOKHBhcnNlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRyeURlbGF5ID0gcGFyc2VkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwYXJzZWRKc29uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFMaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmF3RGF0YSA9IGRhdGFMaW5lcy5qb2luKFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UocmF3RGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWRKc29uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gcmF3RGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VkSnNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VWYWxpZGF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlc3BvbnNlVmFsaWRhdG9yKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZVRyYW5zZm9ybWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gYXdhaXQgcmVzcG9uc2VUcmFuc2Zvcm1lcihkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblNzZUV2ZW50Py4oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogZXZlbnROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogbGFzdEV2ZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHJ5OiByZXRyeURlbGF5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhTGluZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBzaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0SGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhazsgLy8gZXhpdCBsb29wIG9uIG5vcm1hbCBjb21wbGV0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25uZWN0aW9uIGZhaWxlZCBvciBhYm9ydGVkOyByZXRyeSBhZnRlciBkZWxheVxuICAgICAgICAgICAgICAgIG9uU3NlRXJyb3I/LihlcnJvcik7XG4gICAgICAgICAgICAgICAgaWYgKHNzZU1heFJldHJ5QXR0ZW1wdHMgIT09IHVuZGVmaW5lZCAmJiBhdHRlbXB0ID49IHNzZU1heFJldHJ5QXR0ZW1wdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IC8vIHN0b3AgYWZ0ZXIgZmlyaW5nIGVycm9yXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGV4cG9uZW50aWFsIGJhY2tvZmY6IGRvdWJsZSByZXRyeSBlYWNoIGF0dGVtcHQsIGNhcCBhdCAzMHNcbiAgICAgICAgICAgICAgICBjb25zdCBiYWNrb2ZmID0gTWF0aC5taW4ocmV0cnlEZWxheSAqIDIgKiogKGF0dGVtcHQgLSAxKSwgc3NlTWF4UmV0cnlEZWxheSA/PyAzMDAwMCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgc2xlZXAoYmFja29mZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHN0cmVhbSA9IGNyZWF0ZVN0cmVhbSgpO1xuICAgIHJldHVybiB7IHN0cmVhbSB9O1xufTtcbiIsCiAgICAiLy8gVGhpcyBmaWxlIGlzIGF1dG8tZ2VuZXJhdGVkIGJ5IEBoZXktYXBpL29wZW5hcGktdHNcbmV4cG9ydCBjb25zdCBnZXRBdXRoVG9rZW4gPSBhc3luYyAoYXV0aCwgY2FsbGJhY2spID0+IHtcbiAgICBjb25zdCB0b2tlbiA9IHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiID8gYXdhaXQgY2FsbGJhY2soYXV0aCkgOiBjYWxsYmFjaztcbiAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGF1dGguc2NoZW1lID09PSBcImJlYXJlclwiKSB7XG4gICAgICAgIHJldHVybiBgQmVhcmVyICR7dG9rZW59YDtcbiAgICB9XG4gICAgaWYgKGF1dGguc2NoZW1lID09PSBcImJhc2ljXCIpIHtcbiAgICAgICAgcmV0dXJuIGBCYXNpYyAke2J0b2EodG9rZW4pfWA7XG4gICAgfVxuICAgIHJldHVybiB0b2tlbjtcbn07XG4iLAogICAgIi8vIFRoaXMgZmlsZSBpcyBhdXRvLWdlbmVyYXRlZCBieSBAaGV5LWFwaS9vcGVuYXBpLXRzXG5jb25zdCBzZXJpYWxpemVGb3JtRGF0YVBhaXIgPSAoZGF0YSwga2V5LCB2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdmFsdWUgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIGRhdGEuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgZGF0YS5hcHBlbmQoa2V5LCB2YWx1ZS50b0lTT1N0cmluZygpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRhdGEuYXBwZW5kKGtleSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICB9XG59O1xuY29uc3Qgc2VyaWFsaXplVXJsU2VhcmNoUGFyYW1zUGFpciA9IChkYXRhLCBrZXksIHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBkYXRhLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRhdGEuYXBwZW5kKGtleSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IGZvcm1EYXRhQm9keVNlcmlhbGl6ZXIgPSB7XG4gICAgYm9keVNlcmlhbGl6ZXI6IChib2R5KSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoYm9keSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlLmZvckVhY2goKHYpID0+IHNlcmlhbGl6ZUZvcm1EYXRhUGFpcihkYXRhLCBrZXksIHYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZUZvcm1EYXRhUGFpcihkYXRhLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG59O1xuZXhwb3J0IGNvbnN0IGpzb25Cb2R5U2VyaWFsaXplciA9IHtcbiAgICBib2R5U2VyaWFsaXplcjogKGJvZHkpID0+IEpTT04uc3RyaW5naWZ5KGJvZHksIChfa2V5LCB2YWx1ZSkgPT4gKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIiA/IHZhbHVlLnRvU3RyaW5nKCkgOiB2YWx1ZSkpLFxufTtcbmV4cG9ydCBjb25zdCB1cmxTZWFyY2hQYXJhbXNCb2R5U2VyaWFsaXplciA9IHtcbiAgICBib2R5U2VyaWFsaXplcjogKGJvZHkpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoYm9keSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlLmZvckVhY2goKHYpID0+IHNlcmlhbGl6ZVVybFNlYXJjaFBhcmFtc1BhaXIoZGF0YSwga2V5LCB2KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVVcmxTZWFyY2hQYXJhbXNQYWlyKGRhdGEsIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKTtcbiAgICB9LFxufTtcbiIsCiAgICAiLy8gVGhpcyBmaWxlIGlzIGF1dG8tZ2VuZXJhdGVkIGJ5IEBoZXktYXBpL29wZW5hcGktdHNcbmV4cG9ydCBjb25zdCBzZXBhcmF0b3JBcnJheUV4cGxvZGUgPSAoc3R5bGUpID0+IHtcbiAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgICAgIGNhc2UgXCJsYWJlbFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiLlwiO1xuICAgICAgICBjYXNlIFwibWF0cml4XCI6XG4gICAgICAgICAgICByZXR1cm4gXCI7XCI7XG4gICAgICAgIGNhc2UgXCJzaW1wbGVcIjpcbiAgICAgICAgICAgIHJldHVybiBcIixcIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBcIiZcIjtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IHNlcGFyYXRvckFycmF5Tm9FeHBsb2RlID0gKHN0eWxlKSA9PiB7XG4gICAgc3dpdGNoIChzdHlsZSkge1xuICAgICAgICBjYXNlIFwiZm9ybVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiLFwiO1xuICAgICAgICBjYXNlIFwicGlwZURlbGltaXRlZFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwifFwiO1xuICAgICAgICBjYXNlIFwic3BhY2VEZWxpbWl0ZWRcIjpcbiAgICAgICAgICAgIHJldHVybiBcIiUyMFwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwiLFwiO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3Qgc2VwYXJhdG9yT2JqZWN0RXhwbG9kZSA9IChzdHlsZSkgPT4ge1xuICAgIHN3aXRjaCAoc3R5bGUpIHtcbiAgICAgICAgY2FzZSBcImxhYmVsXCI6XG4gICAgICAgICAgICByZXR1cm4gXCIuXCI7XG4gICAgICAgIGNhc2UgXCJtYXRyaXhcIjpcbiAgICAgICAgICAgIHJldHVybiBcIjtcIjtcbiAgICAgICAgY2FzZSBcInNpbXBsZVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiLFwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwiJlwiO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3Qgc2VyaWFsaXplQXJyYXlQYXJhbSA9ICh7IGFsbG93UmVzZXJ2ZWQsIGV4cGxvZGUsIG5hbWUsIHN0eWxlLCB2YWx1ZSwgfSkgPT4ge1xuICAgIGlmICghZXhwbG9kZSkge1xuICAgICAgICBjb25zdCBqb2luZWRWYWx1ZXMgPSAoYWxsb3dSZXNlcnZlZCA/IHZhbHVlIDogdmFsdWUubWFwKCh2KSA9PiBlbmNvZGVVUklDb21wb25lbnQodikpKS5qb2luKHNlcGFyYXRvckFycmF5Tm9FeHBsb2RlKHN0eWxlKSk7XG4gICAgICAgIHN3aXRjaCAoc3R5bGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJsYWJlbFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBgLiR7am9pbmVkVmFsdWVzfWA7XG4gICAgICAgICAgICBjYXNlIFwibWF0cml4XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGA7JHtuYW1lfT0ke2pvaW5lZFZhbHVlc31gO1xuICAgICAgICAgICAgY2FzZSBcInNpbXBsZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBqb2luZWRWYWx1ZXM7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtuYW1lfT0ke2pvaW5lZFZhbHVlc31gO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNlcGFyYXRvciA9IHNlcGFyYXRvckFycmF5RXhwbG9kZShzdHlsZSk7XG4gICAgY29uc3Qgam9pbmVkVmFsdWVzID0gdmFsdWVcbiAgICAgICAgLm1hcCgodikgPT4ge1xuICAgICAgICBpZiAoc3R5bGUgPT09IFwibGFiZWxcIiB8fCBzdHlsZSA9PT0gXCJzaW1wbGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIGFsbG93UmVzZXJ2ZWQgPyB2IDogZW5jb2RlVVJJQ29tcG9uZW50KHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVQcmltaXRpdmVQYXJhbSh7XG4gICAgICAgICAgICBhbGxvd1Jlc2VydmVkLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiB2LFxuICAgICAgICB9KTtcbiAgICB9KVxuICAgICAgICAuam9pbihzZXBhcmF0b3IpO1xuICAgIHJldHVybiBzdHlsZSA9PT0gXCJsYWJlbFwiIHx8IHN0eWxlID09PSBcIm1hdHJpeFwiID8gc2VwYXJhdG9yICsgam9pbmVkVmFsdWVzIDogam9pbmVkVmFsdWVzO1xufTtcbmV4cG9ydCBjb25zdCBzZXJpYWxpemVQcmltaXRpdmVQYXJhbSA9ICh7IGFsbG93UmVzZXJ2ZWQsIG5hbWUsIHZhbHVlIH0pID0+IHtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZWVwbHktbmVzdGVkIGFycmF5cy9vYmplY3RzIGFyZW7igJl0IHN1cHBvcnRlZC4gUHJvdmlkZSB5b3VyIG93biBgcXVlcnlTZXJpYWxpemVyKClgIHRvIGhhbmRsZSB0aGVzZS5cIik7XG4gICAgfVxuICAgIHJldHVybiBgJHtuYW1lfT0ke2FsbG93UmVzZXJ2ZWQgPyB2YWx1ZSA6IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSl9YDtcbn07XG5leHBvcnQgY29uc3Qgc2VyaWFsaXplT2JqZWN0UGFyYW0gPSAoeyBhbGxvd1Jlc2VydmVkLCBleHBsb2RlLCBuYW1lLCBzdHlsZSwgdmFsdWUsIHZhbHVlT25seSwgfSkgPT4ge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlT25seSA/IHZhbHVlLnRvSVNPU3RyaW5nKCkgOiBgJHtuYW1lfT0ke3ZhbHVlLnRvSVNPU3RyaW5nKCl9YDtcbiAgICB9XG4gICAgaWYgKHN0eWxlICE9PSBcImRlZXBPYmplY3RcIiAmJiAhZXhwbG9kZSkge1xuICAgICAgICBsZXQgdmFsdWVzID0gW107XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHZhbHVlKS5mb3JFYWNoKChba2V5LCB2XSkgPT4ge1xuICAgICAgICAgICAgdmFsdWVzID0gWy4uLnZhbHVlcywga2V5LCBhbGxvd1Jlc2VydmVkID8gdiA6IGVuY29kZVVSSUNvbXBvbmVudCh2KV07XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBqb2luZWRWYWx1ZXMgPSB2YWx1ZXMuam9pbihcIixcIik7XG4gICAgICAgIHN3aXRjaCAoc3R5bGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJmb3JtXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke25hbWV9PSR7am9pbmVkVmFsdWVzfWA7XG4gICAgICAgICAgICBjYXNlIFwibGFiZWxcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYC4ke2pvaW5lZFZhbHVlc31gO1xuICAgICAgICAgICAgY2FzZSBcIm1hdHJpeFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBgOyR7bmFtZX09JHtqb2luZWRWYWx1ZXN9YDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpvaW5lZFZhbHVlcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzZXBhcmF0b3IgPSBzZXBhcmF0b3JPYmplY3RFeHBsb2RlKHN0eWxlKTtcbiAgICBjb25zdCBqb2luZWRWYWx1ZXMgPSBPYmplY3QuZW50cmllcyh2YWx1ZSlcbiAgICAgICAgLm1hcCgoW2tleSwgdl0pID0+IHNlcmlhbGl6ZVByaW1pdGl2ZVBhcmFtKHtcbiAgICAgICAgYWxsb3dSZXNlcnZlZCxcbiAgICAgICAgbmFtZTogc3R5bGUgPT09IFwiZGVlcE9iamVjdFwiID8gYCR7bmFtZX1bJHtrZXl9XWAgOiBrZXksXG4gICAgICAgIHZhbHVlOiB2LFxuICAgIH0pKVxuICAgICAgICAuam9pbihzZXBhcmF0b3IpO1xuICAgIHJldHVybiBzdHlsZSA9PT0gXCJsYWJlbFwiIHx8IHN0eWxlID09PSBcIm1hdHJpeFwiID8gc2VwYXJhdG9yICsgam9pbmVkVmFsdWVzIDogam9pbmVkVmFsdWVzO1xufTtcbiIsCiAgICAiLy8gVGhpcyBmaWxlIGlzIGF1dG8tZ2VuZXJhdGVkIGJ5IEBoZXktYXBpL29wZW5hcGktdHNcbmltcG9ydCB7IHNlcmlhbGl6ZUFycmF5UGFyYW0sIHNlcmlhbGl6ZU9iamVjdFBhcmFtLCBzZXJpYWxpemVQcmltaXRpdmVQYXJhbSwgfSBmcm9tIFwiLi9wYXRoU2VyaWFsaXplci5nZW4uanNcIjtcbmV4cG9ydCBjb25zdCBQQVRIX1BBUkFNX1JFID0gL1xce1tee31dK1xcfS9nO1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRQYXRoU2VyaWFsaXplciA9ICh7IHBhdGgsIHVybDogX3VybCB9KSA9PiB7XG4gICAgbGV0IHVybCA9IF91cmw7XG4gICAgY29uc3QgbWF0Y2hlcyA9IF91cmwubWF0Y2goUEFUSF9QQVJBTV9SRSk7XG4gICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgICAgICAgICBsZXQgZXhwbG9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBtYXRjaC5zdWJzdHJpbmcoMSwgbWF0Y2gubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBsZXQgc3R5bGUgPSBcInNpbXBsZVwiO1xuICAgICAgICAgICAgaWYgKG5hbWUuZW5kc1dpdGgoXCIqXCIpKSB7XG4gICAgICAgICAgICAgICAgZXhwbG9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDAsIG5hbWUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFtZS5zdGFydHNXaXRoKFwiLlwiKSkge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICBzdHlsZSA9IFwibGFiZWxcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUuc3RhcnRzV2l0aChcIjtcIikpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgc3R5bGUgPSBcIm1hdHJpeFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXRoW25hbWVdO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKG1hdGNoLCBzZXJpYWxpemVBcnJheVBhcmFtKHsgZXhwbG9kZSwgbmFtZSwgc3R5bGUsIHZhbHVlIH0pKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShtYXRjaCwgc2VyaWFsaXplT2JqZWN0UGFyYW0oe1xuICAgICAgICAgICAgICAgICAgICBleHBsb2RlLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZU9ubHk6IHRydWUsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0eWxlID09PSBcIm1hdHJpeFwiKSB7XG4gICAgICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UobWF0Y2gsIGA7JHtzZXJpYWxpemVQcmltaXRpdmVQYXJhbSh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICB9KX1gKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VWYWx1ZSA9IGVuY29kZVVSSUNvbXBvbmVudChzdHlsZSA9PT0gXCJsYWJlbFwiID8gYC4ke3ZhbHVlfWAgOiB2YWx1ZSk7XG4gICAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShtYXRjaCwgcmVwbGFjZVZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdXJsO1xufTtcbmV4cG9ydCBjb25zdCBnZXRVcmwgPSAoeyBiYXNlVXJsLCBwYXRoLCBxdWVyeSwgcXVlcnlTZXJpYWxpemVyLCB1cmw6IF91cmwsIH0pID0+IHtcbiAgICBjb25zdCBwYXRoVXJsID0gX3VybC5zdGFydHNXaXRoKFwiL1wiKSA/IF91cmwgOiBgLyR7X3VybH1gO1xuICAgIGxldCB1cmwgPSAoYmFzZVVybCA/PyBcIlwiKSArIHBhdGhVcmw7XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgICAgdXJsID0gZGVmYXVsdFBhdGhTZXJpYWxpemVyKHsgcGF0aCwgdXJsIH0pO1xuICAgIH1cbiAgICBsZXQgc2VhcmNoID0gcXVlcnkgPyBxdWVyeVNlcmlhbGl6ZXIocXVlcnkpIDogXCJcIjtcbiAgICBpZiAoc2VhcmNoLnN0YXJ0c1dpdGgoXCI/XCIpKSB7XG4gICAgICAgIHNlYXJjaCA9IHNlYXJjaC5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIGlmIChzZWFyY2gpIHtcbiAgICAgICAgdXJsICs9IGA/JHtzZWFyY2h9YDtcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbn07XG4iLAogICAgIi8vIFRoaXMgZmlsZSBpcyBhdXRvLWdlbmVyYXRlZCBieSBAaGV5LWFwaS9vcGVuYXBpLXRzXG5pbXBvcnQgeyBnZXRBdXRoVG9rZW4gfSBmcm9tIFwiLi4vY29yZS9hdXRoLmdlbi5qc1wiO1xuaW1wb3J0IHsganNvbkJvZHlTZXJpYWxpemVyIH0gZnJvbSBcIi4uL2NvcmUvYm9keVNlcmlhbGl6ZXIuZ2VuLmpzXCI7XG5pbXBvcnQgeyBzZXJpYWxpemVBcnJheVBhcmFtLCBzZXJpYWxpemVPYmplY3RQYXJhbSwgc2VyaWFsaXplUHJpbWl0aXZlUGFyYW0gfSBmcm9tIFwiLi4vY29yZS9wYXRoU2VyaWFsaXplci5nZW4uanNcIjtcbmltcG9ydCB7IGdldFVybCB9IGZyb20gXCIuLi9jb3JlL3V0aWxzLmdlbi5qc1wiO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVF1ZXJ5U2VyaWFsaXplciA9ICh7IGFsbG93UmVzZXJ2ZWQsIGFycmF5LCBvYmplY3QgfSA9IHt9KSA9PiB7XG4gICAgY29uc3QgcXVlcnlTZXJpYWxpemVyID0gKHF1ZXJ5UGFyYW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlYXJjaCA9IFtdO1xuICAgICAgICBpZiAocXVlcnlQYXJhbXMgJiYgdHlwZW9mIHF1ZXJ5UGFyYW1zID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gcXVlcnlQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHF1ZXJ5UGFyYW1zW25hbWVdO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZEFycmF5ID0gc2VyaWFsaXplQXJyYXlQYXJhbSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd1Jlc2VydmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwbG9kZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogXCJmb3JtXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmFycmF5LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcmlhbGl6ZWRBcnJheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaC5wdXNoKHNlcmlhbGl6ZWRBcnJheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkT2JqZWN0ID0gc2VyaWFsaXplT2JqZWN0UGFyYW0oe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dSZXNlcnZlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGxvZGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IFwiZGVlcE9iamVjdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4ub2JqZWN0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcmlhbGl6ZWRPYmplY3QpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2gucHVzaChzZXJpYWxpemVkT2JqZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRQcmltaXRpdmUgPSBzZXJpYWxpemVQcmltaXRpdmVQYXJhbSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd1Jlc2VydmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXJpYWxpemVkUHJpbWl0aXZlKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoLnB1c2goc2VyaWFsaXplZFByaW1pdGl2ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWFyY2guam9pbihcIiZcIik7XG4gICAgfTtcbiAgICByZXR1cm4gcXVlcnlTZXJpYWxpemVyO1xufTtcbi8qKlxuICogSW5mZXJzIHBhcnNlQXMgdmFsdWUgZnJvbSBwcm92aWRlZCBDb250ZW50LVR5cGUgaGVhZGVyLlxuICovXG5leHBvcnQgY29uc3QgZ2V0UGFyc2VBcyA9IChjb250ZW50VHlwZSkgPT4ge1xuICAgIGlmICghY29udGVudFR5cGUpIHtcbiAgICAgICAgLy8gSWYgbm8gQ29udGVudC1UeXBlIGhlYWRlciBpcyBwcm92aWRlZCwgdGhlIGJlc3Qgd2UgY2FuIGRvIGlzIHJldHVybiB0aGUgcmF3IHJlc3BvbnNlIGJvZHksXG4gICAgICAgIC8vIHdoaWNoIGlzIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIGFzIHRoZSAnc3RyZWFtJyBvcHRpb24uXG4gICAgICAgIHJldHVybiBcInN0cmVhbVwiO1xuICAgIH1cbiAgICBjb25zdCBjbGVhbkNvbnRlbnQgPSBjb250ZW50VHlwZS5zcGxpdChcIjtcIilbMF0/LnRyaW0oKTtcbiAgICBpZiAoIWNsZWFuQ29udGVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjbGVhbkNvbnRlbnQuc3RhcnRzV2l0aChcImFwcGxpY2F0aW9uL2pzb25cIikgfHwgY2xlYW5Db250ZW50LmVuZHNXaXRoKFwiK2pzb25cIikpIHtcbiAgICAgICAgcmV0dXJuIFwianNvblwiO1xuICAgIH1cbiAgICBpZiAoY2xlYW5Db250ZW50ID09PSBcIm11bHRpcGFydC9mb3JtLWRhdGFcIikge1xuICAgICAgICByZXR1cm4gXCJmb3JtRGF0YVwiO1xuICAgIH1cbiAgICBpZiAoW1wiYXBwbGljYXRpb24vXCIsIFwiYXVkaW8vXCIsIFwiaW1hZ2UvXCIsIFwidmlkZW8vXCJdLnNvbWUoKHR5cGUpID0+IGNsZWFuQ29udGVudC5zdGFydHNXaXRoKHR5cGUpKSkge1xuICAgICAgICByZXR1cm4gXCJibG9iXCI7XG4gICAgfVxuICAgIGlmIChjbGVhbkNvbnRlbnQuc3RhcnRzV2l0aChcInRleHQvXCIpKSB7XG4gICAgICAgIHJldHVybiBcInRleHRcIjtcbiAgICB9XG4gICAgcmV0dXJuO1xufTtcbmNvbnN0IGNoZWNrRm9yRXhpc3RlbmNlID0gKG9wdGlvbnMsIG5hbWUpID0+IHtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzLmhhcyhuYW1lKSB8fCBvcHRpb25zLnF1ZXJ5Py5bbmFtZV0gfHwgb3B0aW9ucy5oZWFkZXJzLmdldChcIkNvb2tpZVwiKT8uaW5jbHVkZXMoYCR7bmFtZX09YCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5leHBvcnQgY29uc3Qgc2V0QXV0aFBhcmFtcyA9IGFzeW5jICh7IHNlY3VyaXR5LCAuLi5vcHRpb25zIH0pID0+IHtcbiAgICBmb3IgKGNvbnN0IGF1dGggb2Ygc2VjdXJpdHkpIHtcbiAgICAgICAgaWYgKGNoZWNrRm9yRXhpc3RlbmNlKG9wdGlvbnMsIGF1dGgubmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgZ2V0QXV0aFRva2VuKGF1dGgsIG9wdGlvbnMuYXV0aCk7XG4gICAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWUgPSBhdXRoLm5hbWUgPz8gXCJBdXRob3JpemF0aW9uXCI7XG4gICAgICAgIHN3aXRjaCAoYXV0aC5pbikge1xuICAgICAgICAgICAgY2FzZSBcInF1ZXJ5XCI6XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRpb25zLnF1ZXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucXVlcnkgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5xdWVyeVtuYW1lXSA9IHRva2VuO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImNvb2tpZVwiOlxuICAgICAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVycy5hcHBlbmQoXCJDb29raWVcIiwgYCR7bmFtZX09JHt0b2tlbn1gKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJoZWFkZXJcIjpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5oZWFkZXJzLnNldChuYW1lLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IGJ1aWxkVXJsID0gKG9wdGlvbnMpID0+IGdldFVybCh7XG4gICAgYmFzZVVybDogb3B0aW9ucy5iYXNlVXJsLFxuICAgIHBhdGg6IG9wdGlvbnMucGF0aCxcbiAgICBxdWVyeTogb3B0aW9ucy5xdWVyeSxcbiAgICBxdWVyeVNlcmlhbGl6ZXI6IHR5cGVvZiBvcHRpb25zLnF1ZXJ5U2VyaWFsaXplciA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgID8gb3B0aW9ucy5xdWVyeVNlcmlhbGl6ZXJcbiAgICAgICAgOiBjcmVhdGVRdWVyeVNlcmlhbGl6ZXIob3B0aW9ucy5xdWVyeVNlcmlhbGl6ZXIpLFxuICAgIHVybDogb3B0aW9ucy51cmwsXG59KTtcbmV4cG9ydCBjb25zdCBtZXJnZUNvbmZpZ3MgPSAoYSwgYikgPT4ge1xuICAgIGNvbnN0IGNvbmZpZyA9IHsgLi4uYSwgLi4uYiB9O1xuICAgIGlmIChjb25maWcuYmFzZVVybD8uZW5kc1dpdGgoXCIvXCIpKSB7XG4gICAgICAgIGNvbmZpZy5iYXNlVXJsID0gY29uZmlnLmJhc2VVcmwuc3Vic3RyaW5nKDAsIGNvbmZpZy5iYXNlVXJsLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICBjb25maWcuaGVhZGVycyA9IG1lcmdlSGVhZGVycyhhLmhlYWRlcnMsIGIuaGVhZGVycyk7XG4gICAgcmV0dXJuIGNvbmZpZztcbn07XG5leHBvcnQgY29uc3QgbWVyZ2VIZWFkZXJzID0gKC4uLmhlYWRlcnMpID0+IHtcbiAgICBjb25zdCBtZXJnZWRIZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICBmb3IgKGNvbnN0IGhlYWRlciBvZiBoZWFkZXJzKSB7XG4gICAgICAgIGlmICghaGVhZGVyIHx8IHR5cGVvZiBoZWFkZXIgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gaGVhZGVyIGluc3RhbmNlb2YgSGVhZGVycyA/IGhlYWRlci5lbnRyaWVzKCkgOiBPYmplY3QuZW50cmllcyhoZWFkZXIpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBpdGVyYXRvcikge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkSGVhZGVycy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZEhlYWRlcnMuYXBwZW5kKGtleSwgdik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIGFzc3VtZSBvYmplY3QgaGVhZGVycyBhcmUgbWVhbnQgdG8gYmUgSlNPTiBzdHJpbmdpZmllZCwgaS5lLiB0aGVpclxuICAgICAgICAgICAgICAgIC8vIGNvbnRlbnQgdmFsdWUgaW4gT3BlbkFQSSBzcGVjaWZpY2F0aW9uIGlzICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICAgICAgICAgIG1lcmdlZEhlYWRlcnMuc2V0KGtleSwgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiID8gSlNPTi5zdHJpbmdpZnkodmFsdWUpIDogdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXJnZWRIZWFkZXJzO1xufTtcbmNsYXNzIEludGVyY2VwdG9ycyB7XG4gICAgX2ZucztcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fZm5zID0gW107XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLl9mbnMgPSBbXTtcbiAgICB9XG4gICAgZ2V0SW50ZXJjZXB0b3JJbmRleChpZCkge1xuICAgICAgICBpZiAodHlwZW9mIGlkID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZm5zW2lkXSA/IGlkIDogLTE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZm5zLmluZGV4T2YoaWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4aXN0cyhpZCkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0SW50ZXJjZXB0b3JJbmRleChpZCk7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2Zuc1tpbmRleF07XG4gICAgfVxuICAgIGVqZWN0KGlkKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5nZXRJbnRlcmNlcHRvckluZGV4KGlkKTtcbiAgICAgICAgaWYgKHRoaXMuX2Zuc1tpbmRleF0pIHtcbiAgICAgICAgICAgIHRoaXMuX2Zuc1tpbmRleF0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZShpZCwgZm4pIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmdldEludGVyY2VwdG9ySW5kZXgoaWQpO1xuICAgICAgICBpZiAodGhpcy5fZm5zW2luZGV4XSkge1xuICAgICAgICAgICAgdGhpcy5fZm5zW2luZGV4XSA9IGZuO1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVzZShmbikge1xuICAgICAgICB0aGlzLl9mbnMgPSBbLi4udGhpcy5fZm5zLCBmbl07XG4gICAgICAgIHJldHVybiB0aGlzLl9mbnMubGVuZ3RoIC0gMTtcbiAgICB9XG59XG4vLyBkbyBub3QgYWRkIGBNaWRkbGV3YXJlYCBhcyByZXR1cm4gdHlwZSBzbyB3ZSBjYW4gdXNlIF9mbnMgaW50ZXJuYWxseVxuZXhwb3J0IGNvbnN0IGNyZWF0ZUludGVyY2VwdG9ycyA9ICgpID0+ICh7XG4gICAgZXJyb3I6IG5ldyBJbnRlcmNlcHRvcnMoKSxcbiAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JzKCksXG4gICAgcmVzcG9uc2U6IG5ldyBJbnRlcmNlcHRvcnMoKSxcbn0pO1xuY29uc3QgZGVmYXVsdFF1ZXJ5U2VyaWFsaXplciA9IGNyZWF0ZVF1ZXJ5U2VyaWFsaXplcih7XG4gICAgYWxsb3dSZXNlcnZlZDogZmFsc2UsXG4gICAgYXJyYXk6IHtcbiAgICAgICAgZXhwbG9kZTogdHJ1ZSxcbiAgICAgICAgc3R5bGU6IFwiZm9ybVwiLFxuICAgIH0sXG4gICAgb2JqZWN0OiB7XG4gICAgICAgIGV4cGxvZGU6IHRydWUsXG4gICAgICAgIHN0eWxlOiBcImRlZXBPYmplY3RcIixcbiAgICB9LFxufSk7XG5jb25zdCBkZWZhdWx0SGVhZGVycyA9IHtcbiAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbn07XG5leHBvcnQgY29uc3QgY3JlYXRlQ29uZmlnID0gKG92ZXJyaWRlID0ge30pID0+ICh7XG4gICAgLi4uanNvbkJvZHlTZXJpYWxpemVyLFxuICAgIGhlYWRlcnM6IGRlZmF1bHRIZWFkZXJzLFxuICAgIHBhcnNlQXM6IFwiYXV0b1wiLFxuICAgIHF1ZXJ5U2VyaWFsaXplcjogZGVmYXVsdFF1ZXJ5U2VyaWFsaXplcixcbiAgICAuLi5vdmVycmlkZSxcbn0pO1xuIiwKICAgICIvLyBUaGlzIGZpbGUgaXMgYXV0by1nZW5lcmF0ZWQgYnkgQGhleS1hcGkvb3BlbmFwaS10c1xuaW1wb3J0IHsgY3JlYXRlU3NlQ2xpZW50IH0gZnJvbSBcIi4uL2NvcmUvc2VydmVyU2VudEV2ZW50cy5nZW4uanNcIjtcbmltcG9ydCB7IGJ1aWxkVXJsLCBjcmVhdGVDb25maWcsIGNyZWF0ZUludGVyY2VwdG9ycywgZ2V0UGFyc2VBcywgbWVyZ2VDb25maWdzLCBtZXJnZUhlYWRlcnMsIHNldEF1dGhQYXJhbXMsIH0gZnJvbSBcIi4vdXRpbHMuZ2VuLmpzXCI7XG5leHBvcnQgY29uc3QgY3JlYXRlQ2xpZW50ID0gKGNvbmZpZyA9IHt9KSA9PiB7XG4gICAgbGV0IF9jb25maWcgPSBtZXJnZUNvbmZpZ3MoY3JlYXRlQ29uZmlnKCksIGNvbmZpZyk7XG4gICAgY29uc3QgZ2V0Q29uZmlnID0gKCkgPT4gKHsgLi4uX2NvbmZpZyB9KTtcbiAgICBjb25zdCBzZXRDb25maWcgPSAoY29uZmlnKSA9PiB7XG4gICAgICAgIF9jb25maWcgPSBtZXJnZUNvbmZpZ3MoX2NvbmZpZywgY29uZmlnKTtcbiAgICAgICAgcmV0dXJuIGdldENvbmZpZygpO1xuICAgIH07XG4gICAgY29uc3QgaW50ZXJjZXB0b3JzID0gY3JlYXRlSW50ZXJjZXB0b3JzKCk7XG4gICAgY29uc3QgYmVmb3JlUmVxdWVzdCA9IGFzeW5jIChvcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICAgICAgICAuLi5fY29uZmlnLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGZldGNoOiBvcHRpb25zLmZldGNoID8/IF9jb25maWcuZmV0Y2ggPz8gZ2xvYmFsVGhpcy5mZXRjaCxcbiAgICAgICAgICAgIGhlYWRlcnM6IG1lcmdlSGVhZGVycyhfY29uZmlnLmhlYWRlcnMsIG9wdGlvbnMuaGVhZGVycyksXG4gICAgICAgICAgICBzZXJpYWxpemVkQm9keTogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0cy5zZWN1cml0eSkge1xuICAgICAgICAgICAgYXdhaXQgc2V0QXV0aFBhcmFtcyh7XG4gICAgICAgICAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgICAgICAgICBzZWN1cml0eTogb3B0cy5zZWN1cml0eSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLnJlcXVlc3RWYWxpZGF0b3IpIHtcbiAgICAgICAgICAgIGF3YWl0IG9wdHMucmVxdWVzdFZhbGlkYXRvcihvcHRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5ib2R5ICYmIG9wdHMuYm9keVNlcmlhbGl6ZXIpIHtcbiAgICAgICAgICAgIG9wdHMuc2VyaWFsaXplZEJvZHkgPSBvcHRzLmJvZHlTZXJpYWxpemVyKG9wdHMuYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtb3ZlIENvbnRlbnQtVHlwZSBoZWFkZXIgaWYgYm9keSBpcyBlbXB0eSB0byBhdm9pZCBzZW5kaW5nIGludmFsaWQgcmVxdWVzdHNcbiAgICAgICAgaWYgKG9wdHMuc2VyaWFsaXplZEJvZHkgPT09IHVuZGVmaW5lZCB8fCBvcHRzLnNlcmlhbGl6ZWRCb2R5ID09PSBcIlwiKSB7XG4gICAgICAgICAgICBvcHRzLmhlYWRlcnMuZGVsZXRlKFwiQ29udGVudC1UeXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVybCA9IGJ1aWxkVXJsKG9wdHMpO1xuICAgICAgICByZXR1cm4geyBvcHRzLCB1cmwgfTtcbiAgICB9O1xuICAgIGNvbnN0IHJlcXVlc3QgPSBhc3luYyAob3B0aW9ucykgPT4ge1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGNvbnN0IHsgb3B0cywgdXJsIH0gPSBhd2FpdCBiZWZvcmVSZXF1ZXN0KG9wdGlvbnMpO1xuICAgICAgICBjb25zdCByZXF1ZXN0SW5pdCA9IHtcbiAgICAgICAgICAgIHJlZGlyZWN0OiBcImZvbGxvd1wiLFxuICAgICAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgICAgIGJvZHk6IG9wdHMuc2VyaWFsaXplZEJvZHksXG4gICAgICAgIH07XG4gICAgICAgIGxldCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QodXJsLCByZXF1ZXN0SW5pdCk7XG4gICAgICAgIGZvciAoY29uc3QgZm4gb2YgaW50ZXJjZXB0b3JzLnJlcXVlc3QuX2Zucykge1xuICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdCA9IGF3YWl0IGZuKHJlcXVlc3QsIG9wdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGZldGNoIG11c3QgYmUgYXNzaWduZWQgaGVyZSwgb3RoZXJ3aXNlIGl0IHdvdWxkIHRocm93IHRoZSBlcnJvcjpcbiAgICAgICAgLy8gVHlwZUVycm9yOiBGYWlsZWQgdG8gZXhlY3V0ZSAnZmV0Y2gnIG9uICdXaW5kb3cnOiBJbGxlZ2FsIGludm9jYXRpb25cbiAgICAgICAgY29uc3QgX2ZldGNoID0gb3B0cy5mZXRjaDtcbiAgICAgICAgbGV0IHJlc3BvbnNlID0gYXdhaXQgX2ZldGNoKHJlcXVlc3QpO1xuICAgICAgICBmb3IgKGNvbnN0IGZuIG9mIGludGVyY2VwdG9ycy5yZXNwb25zZS5fZm5zKSB7XG4gICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IGZuKHJlc3BvbnNlLCByZXF1ZXN0LCBvcHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA0IHx8IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1MZW5ndGhcIikgPT09IFwiMFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdHMucmVzcG9uc2VTdHlsZSA9PT0gXCJkYXRhXCJcbiAgICAgICAgICAgICAgICAgICAgPyB7fVxuICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFyc2VBcyA9IChvcHRzLnBhcnNlQXMgPT09IFwiYXV0b1wiID8gZ2V0UGFyc2VBcyhyZXNwb25zZS5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKSkgOiBvcHRzLnBhcnNlQXMpID8/IFwianNvblwiO1xuICAgICAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcnNlQXMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiYXJyYXlCdWZmZXJcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiYmxvYlwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJmb3JtRGF0YVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJqc29uXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGF3YWl0IHJlc3BvbnNlW3BhcnNlQXNdKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdHJlYW1cIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdHMucmVzcG9uc2VTdHlsZSA9PT0gXCJkYXRhXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzcG9uc2UuYm9keVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcmVzcG9uc2UuYm9keSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnNlQXMgPT09IFwianNvblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdHMucmVzcG9uc2VWYWxpZGF0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgb3B0cy5yZXNwb25zZVZhbGlkYXRvcihkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9wdHMucmVzcG9uc2VUcmFuc2Zvcm1lcikge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gYXdhaXQgb3B0cy5yZXNwb25zZVRyYW5zZm9ybWVyKGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvcHRzLnJlc3BvbnNlU3R5bGUgPT09IFwiZGF0YVwiXG4gICAgICAgICAgICAgICAgPyBkYXRhXG4gICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRleHRFcnJvciA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgbGV0IGpzb25FcnJvcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGpzb25FcnJvciA9IEpTT04ucGFyc2UodGV4dEVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAvLyBub29wXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3IgPSBqc29uRXJyb3IgPz8gdGV4dEVycm9yO1xuICAgICAgICBsZXQgZmluYWxFcnJvciA9IGVycm9yO1xuICAgICAgICBmb3IgKGNvbnN0IGZuIG9mIGludGVyY2VwdG9ycy5lcnJvci5fZm5zKSB7XG4gICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgICBmaW5hbEVycm9yID0gKGF3YWl0IGZuKGVycm9yLCByZXNwb25zZSwgcmVxdWVzdCwgb3B0cykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsRXJyb3IgPSBmaW5hbEVycm9yIHx8IHt9O1xuICAgICAgICBpZiAob3B0cy50aHJvd09uRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGZpbmFsRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogd2UgcHJvYmFibHkgd2FudCB0byByZXR1cm4gZXJyb3IgYW5kIGltcHJvdmUgdHlwZXNcbiAgICAgICAgcmV0dXJuIG9wdHMucmVzcG9uc2VTdHlsZSA9PT0gXCJkYXRhXCJcbiAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICBlcnJvcjogZmluYWxFcnJvcixcbiAgICAgICAgICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgbWFrZU1ldGhvZCA9IChtZXRob2QpID0+IHtcbiAgICAgICAgY29uc3QgZm4gPSAob3B0aW9ucykgPT4gcmVxdWVzdCh7IC4uLm9wdGlvbnMsIG1ldGhvZCB9KTtcbiAgICAgICAgZm4uc3NlID0gYXN5bmMgKG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb3B0cywgdXJsIH0gPSBhd2FpdCBiZWZvcmVSZXF1ZXN0KG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVNzZUNsaWVudCh7XG4gICAgICAgICAgICAgICAgLi4ub3B0cyxcbiAgICAgICAgICAgICAgICBib2R5OiBvcHRzLmJvZHksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogb3B0cy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZuO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYnVpbGRVcmwsXG4gICAgICAgIGNvbm5lY3Q6IG1ha2VNZXRob2QoXCJDT05ORUNUXCIpLFxuICAgICAgICBkZWxldGU6IG1ha2VNZXRob2QoXCJERUxFVEVcIiksXG4gICAgICAgIGdldDogbWFrZU1ldGhvZChcIkdFVFwiKSxcbiAgICAgICAgZ2V0Q29uZmlnLFxuICAgICAgICBoZWFkOiBtYWtlTWV0aG9kKFwiSEVBRFwiKSxcbiAgICAgICAgaW50ZXJjZXB0b3JzLFxuICAgICAgICBvcHRpb25zOiBtYWtlTWV0aG9kKFwiT1BUSU9OU1wiKSxcbiAgICAgICAgcGF0Y2g6IG1ha2VNZXRob2QoXCJQQVRDSFwiKSxcbiAgICAgICAgcG9zdDogbWFrZU1ldGhvZChcIlBPU1RcIiksXG4gICAgICAgIHB1dDogbWFrZU1ldGhvZChcIlBVVFwiKSxcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgc2V0Q29uZmlnLFxuICAgICAgICB0cmFjZTogbWFrZU1ldGhvZChcIlRSQUNFXCIpLFxuICAgIH07XG59O1xuIiwKICAgICIvLyBUaGlzIGZpbGUgaXMgYXV0by1nZW5lcmF0ZWQgYnkgQGhleS1hcGkvb3BlbmFwaS10c1xuY29uc3QgZXh0cmFQcmVmaXhlc01hcCA9IHtcbiAgICAkYm9keV86IFwiYm9keVwiLFxuICAgICRoZWFkZXJzXzogXCJoZWFkZXJzXCIsXG4gICAgJHBhdGhfOiBcInBhdGhcIixcbiAgICAkcXVlcnlfOiBcInF1ZXJ5XCIsXG59O1xuY29uc3QgZXh0cmFQcmVmaXhlcyA9IE9iamVjdC5lbnRyaWVzKGV4dHJhUHJlZml4ZXNNYXApO1xuY29uc3QgYnVpbGRLZXlNYXAgPSAoZmllbGRzLCBtYXApID0+IHtcbiAgICBpZiAoIW1hcCkge1xuICAgICAgICBtYXAgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgY29uZmlnIG9mIGZpZWxkcykge1xuICAgICAgICBpZiAoXCJpblwiIGluIGNvbmZpZykge1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5rZXkpIHtcbiAgICAgICAgICAgICAgICBtYXAuc2V0KGNvbmZpZy5rZXksIHtcbiAgICAgICAgICAgICAgICAgICAgaW46IGNvbmZpZy5pbixcbiAgICAgICAgICAgICAgICAgICAgbWFwOiBjb25maWcubWFwLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbmZpZy5hcmdzKSB7XG4gICAgICAgICAgICBidWlsZEtleU1hcChjb25maWcuYXJncywgbWFwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFwO1xufTtcbmNvbnN0IHN0cmlwRW1wdHlTbG90cyA9IChwYXJhbXMpID0+IHtcbiAgICBmb3IgKGNvbnN0IFtzbG90LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFyYW1zKSkge1xuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmICFPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoKSB7XG4gICAgICAgICAgICBkZWxldGUgcGFyYW1zW3Nsb3RdO1xuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBidWlsZENsaWVudFBhcmFtcyA9IChhcmdzLCBmaWVsZHMpID0+IHtcbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgIGJvZHk6IHt9LFxuICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgcGF0aDoge30sXG4gICAgICAgIHF1ZXJ5OiB7fSxcbiAgICB9O1xuICAgIGNvbnN0IG1hcCA9IGJ1aWxkS2V5TWFwKGZpZWxkcyk7XG4gICAgbGV0IGNvbmZpZztcbiAgICBmb3IgKGNvbnN0IFtpbmRleCwgYXJnXSBvZiBhcmdzLmVudHJpZXMoKSkge1xuICAgICAgICBpZiAoZmllbGRzW2luZGV4XSkge1xuICAgICAgICAgICAgY29uZmlnID0gZmllbGRzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbmZpZykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwiaW5cIiBpbiBjb25maWcpIHtcbiAgICAgICAgICAgIGlmIChjb25maWcua2V5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSBtYXAuZ2V0KGNvbmZpZy5rZXkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBmaWVsZC5tYXAgfHwgY29uZmlnLmtleTtcbiAgICAgICAgICAgICAgICBwYXJhbXNbZmllbGQuaW5dW25hbWVdID0gYXJnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmJvZHkgPSBhcmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhcmcgPz8ge30pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSBtYXAuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBmaWVsZC5tYXAgfHwga2V5O1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXNbZmllbGQuaW5dW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHRyYSA9IGV4dHJhUHJlZml4ZXMuZmluZCgoW3ByZWZpeF0pID0+IGtleS5zdGFydHNXaXRoKHByZWZpeCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0cmEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtwcmVmaXgsIHNsb3RdID0gZXh0cmE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXNbc2xvdF1ba2V5LnNsaWNlKHByZWZpeC5sZW5ndGgpXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbc2xvdCwgYWxsb3dlZF0gb2YgT2JqZWN0LmVudHJpZXMoY29uZmlnLmFsbG93RXh0cmEgPz8ge30pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXNbc2xvdF1ba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RyaXBFbXB0eVNsb3RzKHBhcmFtcyk7XG4gICAgcmV0dXJuIHBhcmFtcztcbn07XG4iLAogICAgIi8vIFRoaXMgZmlsZSBpcyBhdXRvLWdlbmVyYXRlZCBieSBAaGV5LWFwaS9vcGVuYXBpLXRzXG5pbXBvcnQgeyBjcmVhdGVDbGllbnQsIGNyZWF0ZUNvbmZpZyB9IGZyb20gXCIuL2NsaWVudC9pbmRleC5qc1wiO1xuZXhwb3J0IGNvbnN0IGNsaWVudCA9IGNyZWF0ZUNsaWVudChjcmVhdGVDb25maWcoe1xuICAgIGJhc2VVcmw6IFwiaHR0cDovL2xvY2FsaG9zdDo0MDk2XCIsXG59KSk7XG4iLAogICAgIi8vIFRoaXMgZmlsZSBpcyBhdXRvLWdlbmVyYXRlZCBieSBAaGV5LWFwaS9vcGVuYXBpLXRzXG5pbXBvcnQgeyBjbGllbnQgYXMgX2hleUFwaUNsaWVudCB9IGZyb20gXCIuL2NsaWVudC5nZW4uanNcIjtcbmNsYXNzIF9IZXlBcGlDbGllbnQge1xuICAgIF9jbGllbnQgPSBfaGV5QXBpQ2xpZW50O1xuICAgIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICAgICAgaWYgKGFyZ3M/LmNsaWVudCkge1xuICAgICAgICAgICAgdGhpcy5fY2xpZW50ID0gYXJncy5jbGllbnQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBHbG9iYWwgZXh0ZW5kcyBfSGV5QXBpQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBHZXQgZXZlbnRzXG4gICAgICovXG4gICAgZXZlbnQob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnM/LmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLmdldC5zc2Uoe1xuICAgICAgICAgICAgdXJsOiBcIi9nbG9iYWwvZXZlbnRcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFByb2plY3QgZXh0ZW5kcyBfSGV5QXBpQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBMaXN0IGFsbCBwcm9qZWN0c1xuICAgICAqL1xuICAgIGxpc3Qob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnM/LmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLmdldCh7XG4gICAgICAgICAgICB1cmw6IFwiL3Byb2plY3RcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgcHJvamVjdFxuICAgICAqL1xuICAgIGN1cnJlbnQob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnM/LmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLmdldCh7XG4gICAgICAgICAgICB1cmw6IFwiL3Byb2plY3QvY3VycmVudFwiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgUHR5IGV4dGVuZHMgX0hleUFwaUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogTGlzdCBhbGwgUFRZIHNlc3Npb25zXG4gICAgICovXG4gICAgbGlzdChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucz8uY2xpZW50ID8/IHRoaXMuX2NsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIHVybDogXCIvcHR5XCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IFBUWSBzZXNzaW9uXG4gICAgICovXG4gICAgY3JlYXRlKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zPy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIHVybDogXCIvcHR5XCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnM/LmhlYWRlcnMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgUFRZIHNlc3Npb25cbiAgICAgKi9cbiAgICByZW1vdmUob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IHRoaXMuX2NsaWVudCkuZGVsZXRlKHtcbiAgICAgICAgICAgIHVybDogXCIvcHR5L3tpZH1cIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgUFRZIHNlc3Npb24gaW5mb1xuICAgICAqL1xuICAgIGdldChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgdXJsOiBcIi9wdHkve2lkfVwiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBQVFkgc2Vzc2lvblxuICAgICAqL1xuICAgIHVwZGF0ZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5wdXQoe1xuICAgICAgICAgICAgdXJsOiBcIi9wdHkve2lkfVwiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29ubmVjdCB0byBhIFBUWSBzZXNzaW9uXG4gICAgICovXG4gICAgY29ubmVjdChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgdXJsOiBcIi9wdHkve2lkfS9jb25uZWN0XCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBDb25maWcgZXh0ZW5kcyBfSGV5QXBpQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBHZXQgY29uZmlnIGluZm9cbiAgICAgKi9cbiAgICBnZXQob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnM/LmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLmdldCh7XG4gICAgICAgICAgICB1cmw6IFwiL2NvbmZpZ1wiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBjb25maWdcbiAgICAgKi9cbiAgICB1cGRhdGUob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnM/LmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLnBhdGNoKHtcbiAgICAgICAgICAgIHVybDogXCIvY29uZmlnXCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnM/LmhlYWRlcnMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBhbGwgcHJvdmlkZXJzXG4gICAgICovXG4gICAgcHJvdmlkZXJzKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zPy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgdXJsOiBcIi9jb25maWcvcHJvdmlkZXJzXCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBUb29sIGV4dGVuZHMgX0hleUFwaUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogTGlzdCBhbGwgdG9vbCBJRHMgKGluY2x1ZGluZyBidWlsdC1pbiBhbmQgZHluYW1pY2FsbHkgcmVnaXN0ZXJlZClcbiAgICAgKi9cbiAgICBpZHMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnM/LmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLmdldCh7XG4gICAgICAgICAgICB1cmw6IFwiL2V4cGVyaW1lbnRhbC90b29sL2lkc1wiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgdG9vbHMgd2l0aCBKU09OIHNjaGVtYSBwYXJhbWV0ZXJzIGZvciBhIHByb3ZpZGVyL21vZGVsXG4gICAgICovXG4gICAgbGlzdChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgdXJsOiBcIi9leHBlcmltZW50YWwvdG9vbFwiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgSW5zdGFuY2UgZXh0ZW5kcyBfSGV5QXBpQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBEaXNwb3NlIHRoZSBjdXJyZW50IGluc3RhbmNlXG4gICAgICovXG4gICAgZGlzcG9zZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucz8uY2xpZW50ID8/IHRoaXMuX2NsaWVudCkucG9zdCh7XG4gICAgICAgICAgICB1cmw6IFwiL2luc3RhbmNlL2Rpc3Bvc2VcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFBhdGggZXh0ZW5kcyBfSGV5QXBpQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgcGF0aFxuICAgICAqL1xuICAgIGdldChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucz8uY2xpZW50ID8/IHRoaXMuX2NsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIHVybDogXCIvcGF0aFwiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgVmNzIGV4dGVuZHMgX0hleUFwaUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogR2V0IFZDUyBpbmZvIGZvciB0aGUgY3VycmVudCBpbnN0YW5jZVxuICAgICAqL1xuICAgIGdldChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucz8uY2xpZW50ID8/IHRoaXMuX2NsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIHVybDogXCIvdmNzXCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBTZXNzaW9uIGV4dGVuZHMgX0hleUFwaUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogTGlzdCBhbGwgc2Vzc2lvbnNcbiAgICAgKi9cbiAgICBsaXN0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zPy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgdXJsOiBcIi9zZXNzaW9uXCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHNlc3Npb25cbiAgICAgKi9cbiAgICBjcmVhdGUob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnM/LmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgdXJsOiBcIi9zZXNzaW9uXCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnM/LmhlYWRlcnMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHNlc3Npb24gc3RhdHVzXG4gICAgICovXG4gICAgc3RhdHVzKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zPy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgdXJsOiBcIi9zZXNzaW9uL3N0YXR1c1wiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIHNlc3Npb24gYW5kIGFsbCBpdHMgZGF0YVxuICAgICAqL1xuICAgIGRlbGV0ZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5kZWxldGUoe1xuICAgICAgICAgICAgdXJsOiBcIi9zZXNzaW9uL3tpZH1cIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgc2Vzc2lvblxuICAgICAqL1xuICAgIGdldChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgdXJsOiBcIi9zZXNzaW9uL3tpZH1cIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgc2Vzc2lvbiBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgdXBkYXRlKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLnBhdGNoKHtcbiAgICAgICAgICAgIHVybDogXCIvc2Vzc2lvbi97aWR9XCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzZXNzaW9uJ3MgY2hpbGRyZW5cbiAgICAgKi9cbiAgICBjaGlsZHJlbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgdXJsOiBcIi9zZXNzaW9uL3tpZH0vY2hpbGRyZW5cIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRvZG8gbGlzdCBmb3IgYSBzZXNzaW9uXG4gICAgICovXG4gICAgdG9kbyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgdXJsOiBcIi9zZXNzaW9uL3tpZH0vdG9kb1wiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFuYWx5emUgdGhlIGFwcCBhbmQgY3JlYXRlIGFuIEFHRU5UUy5tZCBmaWxlXG4gICAgICovXG4gICAgaW5pdChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIHVybDogXCIvc2Vzc2lvbi97aWR9L2luaXRcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvcmsgYW4gZXhpc3Rpbmcgc2Vzc2lvbiBhdCBhIHNwZWNpZmljIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBmb3JrKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgdXJsOiBcIi9zZXNzaW9uL3tpZH0vZm9ya1wiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWJvcnQgYSBzZXNzaW9uXG4gICAgICovXG4gICAgYWJvcnQob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IHRoaXMuX2NsaWVudCkucG9zdCh7XG4gICAgICAgICAgICB1cmw6IFwiL3Nlc3Npb24ve2lkfS9hYm9ydFwiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuc2hhcmUgdGhlIHNlc3Npb25cbiAgICAgKi9cbiAgICB1bnNoYXJlKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLmRlbGV0ZSh7XG4gICAgICAgICAgICB1cmw6IFwiL3Nlc3Npb24ve2lkfS9zaGFyZVwiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNoYXJlIGEgc2Vzc2lvblxuICAgICAqL1xuICAgIHNoYXJlKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgdXJsOiBcIi9zZXNzaW9uL3tpZH0vc2hhcmVcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGRpZmYgZm9yIHRoaXMgc2Vzc2lvblxuICAgICAqL1xuICAgIGRpZmYob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IHRoaXMuX2NsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIHVybDogXCIvc2Vzc2lvbi97aWR9L2RpZmZcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdW1tYXJpemUgdGhlIHNlc3Npb25cbiAgICAgKi9cbiAgICBzdW1tYXJpemUob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IHRoaXMuX2NsaWVudCkucG9zdCh7XG4gICAgICAgICAgICB1cmw6IFwiL3Nlc3Npb24ve2lkfS9zdW1tYXJpemVcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgbWVzc2FnZXMgZm9yIGEgc2Vzc2lvblxuICAgICAqL1xuICAgIG1lc3NhZ2VzKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLmdldCh7XG4gICAgICAgICAgICB1cmw6IFwiL3Nlc3Npb24ve2lkfS9tZXNzYWdlXCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuZCBzZW5kIGEgbmV3IG1lc3NhZ2UgdG8gYSBzZXNzaW9uXG4gICAgICovXG4gICAgcHJvbXB0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgdXJsOiBcIi9zZXNzaW9uL3tpZH0vbWVzc2FnZVwiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgbWVzc2FnZSBmcm9tIGEgc2Vzc2lvblxuICAgICAqL1xuICAgIG1lc3NhZ2Uob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IHRoaXMuX2NsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIHVybDogXCIvc2Vzc2lvbi97aWR9L21lc3NhZ2Uve21lc3NhZ2VJRH1cIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW5kIHNlbmQgYSBuZXcgbWVzc2FnZSB0byBhIHNlc3Npb24sIHN0YXJ0IGlmIG5lZWRlZCBhbmQgcmV0dXJuIGltbWVkaWF0ZWx5XG4gICAgICovXG4gICAgcHJvbXB0QXN5bmMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IHRoaXMuX2NsaWVudCkucG9zdCh7XG4gICAgICAgICAgICB1cmw6IFwiL3Nlc3Npb24ve2lkfS9wcm9tcHRfYXN5bmNcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYSBuZXcgY29tbWFuZCB0byBhIHNlc3Npb25cbiAgICAgKi9cbiAgICBjb21tYW5kKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgdXJsOiBcIi9zZXNzaW9uL3tpZH0vY29tbWFuZFwiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUnVuIGEgc2hlbGwgY29tbWFuZFxuICAgICAqL1xuICAgIHNoZWxsKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgdXJsOiBcIi9zZXNzaW9uL3tpZH0vc2hlbGxcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldmVydCBhIG1lc3NhZ2VcbiAgICAgKi9cbiAgICByZXZlcnQob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IHRoaXMuX2NsaWVudCkucG9zdCh7XG4gICAgICAgICAgICB1cmw6IFwiL3Nlc3Npb24ve2lkfS9yZXZlcnRcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3RvcmUgYWxsIHJldmVydGVkIG1lc3NhZ2VzXG4gICAgICovXG4gICAgdW5yZXZlcnQob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IHRoaXMuX2NsaWVudCkucG9zdCh7XG4gICAgICAgICAgICB1cmw6IFwiL3Nlc3Npb24ve2lkfS91bnJldmVydFwiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgQ29tbWFuZCBleHRlbmRzIF9IZXlBcGlDbGllbnQge1xuICAgIC8qKlxuICAgICAqIExpc3QgYWxsIGNvbW1hbmRzXG4gICAgICovXG4gICAgbGlzdChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucz8uY2xpZW50ID8/IHRoaXMuX2NsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIHVybDogXCIvY29tbWFuZFwiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgT2F1dGggZXh0ZW5kcyBfSGV5QXBpQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBBdXRob3JpemUgYSBwcm92aWRlciB1c2luZyBPQXV0aFxuICAgICAqL1xuICAgIGF1dGhvcml6ZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIHVybDogXCIvcHJvdmlkZXIve2lkfS9vYXV0aC9hdXRob3JpemVcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBPQXV0aCBjYWxsYmFjayBmb3IgYSBwcm92aWRlclxuICAgICAqL1xuICAgIGNhbGxiYWNrKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgdXJsOiBcIi9wcm92aWRlci97aWR9L29hdXRoL2NhbGxiYWNrXCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFByb3ZpZGVyIGV4dGVuZHMgX0hleUFwaUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogTGlzdCBhbGwgcHJvdmlkZXJzXG4gICAgICovXG4gICAgbGlzdChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucz8uY2xpZW50ID8/IHRoaXMuX2NsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIHVybDogXCIvcHJvdmlkZXJcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgcHJvdmlkZXIgYXV0aGVudGljYXRpb24gbWV0aG9kc1xuICAgICAqL1xuICAgIGF1dGgob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnM/LmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLmdldCh7XG4gICAgICAgICAgICB1cmw6IFwiL3Byb3ZpZGVyL2F1dGhcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvYXV0aCA9IG5ldyBPYXV0aCh7IGNsaWVudDogdGhpcy5fY2xpZW50IH0pO1xufVxuY2xhc3MgRmluZCBleHRlbmRzIF9IZXlBcGlDbGllbnQge1xuICAgIC8qKlxuICAgICAqIEZpbmQgdGV4dCBpbiBmaWxlc1xuICAgICAqL1xuICAgIHRleHQob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IHRoaXMuX2NsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIHVybDogXCIvZmluZFwiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmQgZmlsZXNcbiAgICAgKi9cbiAgICBmaWxlcyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgdXJsOiBcIi9maW5kL2ZpbGVcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kIHdvcmtzcGFjZSBzeW1ib2xzXG4gICAgICovXG4gICAgc3ltYm9scyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgdXJsOiBcIi9maW5kL3N5bWJvbFwiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgRmlsZSBleHRlbmRzIF9IZXlBcGlDbGllbnQge1xuICAgIC8qKlxuICAgICAqIExpc3QgZmlsZXMgYW5kIGRpcmVjdG9yaWVzXG4gICAgICovXG4gICAgbGlzdChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgdXJsOiBcIi9maWxlXCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCBhIGZpbGVcbiAgICAgKi9cbiAgICByZWFkKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLmdldCh7XG4gICAgICAgICAgICB1cmw6IFwiL2ZpbGUvY29udGVudFwiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBmaWxlIHN0YXR1c1xuICAgICAqL1xuICAgIHN0YXR1cyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucz8uY2xpZW50ID8/IHRoaXMuX2NsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIHVybDogXCIvZmlsZS9zdGF0dXNcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIEFwcCBleHRlbmRzIF9IZXlBcGlDbGllbnQge1xuICAgIC8qKlxuICAgICAqIFdyaXRlIGEgbG9nIGVudHJ5IHRvIHRoZSBzZXJ2ZXIgbG9nc1xuICAgICAqL1xuICAgIGxvZyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucz8uY2xpZW50ID8/IHRoaXMuX2NsaWVudCkucG9zdCh7XG4gICAgICAgICAgICB1cmw6IFwiL2xvZ1wiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zPy5oZWFkZXJzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgYWxsIGFnZW50c1xuICAgICAqL1xuICAgIGFnZW50cyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucz8uY2xpZW50ID8/IHRoaXMuX2NsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIHVybDogXCIvYWdlbnRcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIEF1dGggZXh0ZW5kcyBfSGV5QXBpQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgT0F1dGggY3JlZGVudGlhbHMgZm9yIGFuIE1DUCBzZXJ2ZXJcbiAgICAgKi9cbiAgICByZW1vdmUob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IHRoaXMuX2NsaWVudCkuZGVsZXRlKHtcbiAgICAgICAgICAgIHVybDogXCIvbWNwL3tuYW1lfS9hdXRoXCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgT0F1dGggYXV0aGVudGljYXRpb24gZmxvdyBmb3IgYW4gTUNQIHNlcnZlclxuICAgICAqL1xuICAgIHN0YXJ0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgdXJsOiBcIi9tY3Ave25hbWV9L2F1dGhcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wbGV0ZSBPQXV0aCBhdXRoZW50aWNhdGlvbiB3aXRoIGF1dGhvcml6YXRpb24gY29kZVxuICAgICAqL1xuICAgIGNhbGxiYWNrKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgdXJsOiBcIi9tY3Ave25hbWV9L2F1dGgvY2FsbGJhY2tcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0IE9BdXRoIGZsb3cgYW5kIHdhaXQgZm9yIGNhbGxiYWNrIChvcGVucyBicm93c2VyKVxuICAgICAqL1xuICAgIGF1dGhlbnRpY2F0ZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIHVybDogXCIvbWNwL3tuYW1lfS9hdXRoL2F1dGhlbnRpY2F0ZVwiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBhdXRoZW50aWNhdGlvbiBjcmVkZW50aWFsc1xuICAgICAqL1xuICAgIHNldChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5wdXQoe1xuICAgICAgICAgICAgdXJsOiBcIi9hdXRoL3tpZH1cIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgTWNwIGV4dGVuZHMgX0hleUFwaUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogR2V0IE1DUCBzZXJ2ZXIgc3RhdHVzXG4gICAgICovXG4gICAgc3RhdHVzKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zPy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgdXJsOiBcIi9tY3BcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgTUNQIHNlcnZlciBkeW5hbWljYWxseVxuICAgICAqL1xuICAgIGFkZChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucz8uY2xpZW50ID8/IHRoaXMuX2NsaWVudCkucG9zdCh7XG4gICAgICAgICAgICB1cmw6IFwiL21jcFwiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zPy5oZWFkZXJzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbm5lY3QgYW4gTUNQIHNlcnZlclxuICAgICAqL1xuICAgIGNvbm5lY3Qob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IHRoaXMuX2NsaWVudCkucG9zdCh7XG4gICAgICAgICAgICB1cmw6IFwiL21jcC97bmFtZX0vY29ubmVjdFwiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3QgYW4gTUNQIHNlcnZlclxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3Qob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IHRoaXMuX2NsaWVudCkucG9zdCh7XG4gICAgICAgICAgICB1cmw6IFwiL21jcC97bmFtZX0vZGlzY29ubmVjdFwiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGF1dGggPSBuZXcgQXV0aCh7IGNsaWVudDogdGhpcy5fY2xpZW50IH0pO1xufVxuY2xhc3MgTHNwIGV4dGVuZHMgX0hleUFwaUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogR2V0IExTUCBzZXJ2ZXIgc3RhdHVzXG4gICAgICovXG4gICAgc3RhdHVzKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zPy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgdXJsOiBcIi9sc3BcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIEZvcm1hdHRlciBleHRlbmRzIF9IZXlBcGlDbGllbnQge1xuICAgIC8qKlxuICAgICAqIEdldCBmb3JtYXR0ZXIgc3RhdHVzXG4gICAgICovXG4gICAgc3RhdHVzKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zPy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgdXJsOiBcIi9mb3JtYXR0ZXJcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIENvbnRyb2wgZXh0ZW5kcyBfSGV5QXBpQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5leHQgVFVJIHJlcXVlc3QgZnJvbSB0aGUgcXVldWVcbiAgICAgKi9cbiAgICBuZXh0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zPy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgdXJsOiBcIi90dWkvY29udHJvbC9uZXh0XCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VibWl0IGEgcmVzcG9uc2UgdG8gdGhlIFRVSSByZXF1ZXN0IHF1ZXVlXG4gICAgICovXG4gICAgcmVzcG9uc2Uob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnM/LmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgdXJsOiBcIi90dWkvY29udHJvbC9yZXNwb25zZVwiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zPy5oZWFkZXJzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgVHVpIGV4dGVuZHMgX0hleUFwaUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogQXBwZW5kIHByb21wdCB0byB0aGUgVFVJXG4gICAgICovXG4gICAgYXBwZW5kUHJvbXB0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zPy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIHVybDogXCIvdHVpL2FwcGVuZC1wcm9tcHRcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucz8uaGVhZGVycyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVuIHRoZSBoZWxwIGRpYWxvZ1xuICAgICAqL1xuICAgIG9wZW5IZWxwKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zPy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIHVybDogXCIvdHVpL29wZW4taGVscFwiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW4gdGhlIHNlc3Npb24gZGlhbG9nXG4gICAgICovXG4gICAgb3BlblNlc3Npb25zKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zPy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIHVybDogXCIvdHVpL29wZW4tc2Vzc2lvbnNcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVuIHRoZSB0aGVtZSBkaWFsb2dcbiAgICAgKi9cbiAgICBvcGVuVGhlbWVzKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zPy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIHVybDogXCIvdHVpL29wZW4tdGhlbWVzXCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3BlbiB0aGUgbW9kZWwgZGlhbG9nXG4gICAgICovXG4gICAgb3Blbk1vZGVscyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucz8uY2xpZW50ID8/IHRoaXMuX2NsaWVudCkucG9zdCh7XG4gICAgICAgICAgICB1cmw6IFwiL3R1aS9vcGVuLW1vZGVsc1wiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1Ym1pdCB0aGUgcHJvbXB0XG4gICAgICovXG4gICAgc3VibWl0UHJvbXB0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zPy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIHVybDogXCIvdHVpL3N1Ym1pdC1wcm9tcHRcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUgcHJvbXB0XG4gICAgICovXG4gICAgY2xlYXJQcm9tcHQob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnM/LmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgdXJsOiBcIi90dWkvY2xlYXItcHJvbXB0XCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZSBhIFRVSSBjb21tYW5kIChlLmcuIGFnZW50X2N5Y2xlKVxuICAgICAqL1xuICAgIGV4ZWN1dGVDb21tYW5kKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zPy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIHVybDogXCIvdHVpL2V4ZWN1dGUtY29tbWFuZFwiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zPy5oZWFkZXJzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3cgYSB0b2FzdCBub3RpZmljYXRpb24gaW4gdGhlIFRVSVxuICAgICAqL1xuICAgIHNob3dUb2FzdChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucz8uY2xpZW50ID8/IHRoaXMuX2NsaWVudCkucG9zdCh7XG4gICAgICAgICAgICB1cmw6IFwiL3R1aS9zaG93LXRvYXN0XCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnM/LmhlYWRlcnMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGlzaCBhIFRVSSBldmVudFxuICAgICAqL1xuICAgIHB1Ymxpc2gob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnM/LmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgdXJsOiBcIi90dWkvcHVibGlzaFwiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zPy5oZWFkZXJzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnRyb2wgPSBuZXcgQ29udHJvbCh7IGNsaWVudDogdGhpcy5fY2xpZW50IH0pO1xufVxuY2xhc3MgRXZlbnQgZXh0ZW5kcyBfSGV5QXBpQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBHZXQgZXZlbnRzXG4gICAgICovXG4gICAgc3Vic2NyaWJlKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zPy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5nZXQuc3NlKHtcbiAgICAgICAgICAgIHVybDogXCIvZXZlbnRcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBPcGVuY29kZUNsaWVudCBleHRlbmRzIF9IZXlBcGlDbGllbnQge1xuICAgIC8qKlxuICAgICAqIFJlc3BvbmQgdG8gYSBwZXJtaXNzaW9uIHJlcXVlc3RcbiAgICAgKi9cbiAgICBwb3N0U2Vzc2lvbklkUGVybWlzc2lvbnNQZXJtaXNzaW9uSWQob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IHRoaXMuX2NsaWVudCkucG9zdCh7XG4gICAgICAgICAgICB1cmw6IFwiL3Nlc3Npb24ve2lkfS9wZXJtaXNzaW9ucy97cGVybWlzc2lvbklEfVwiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2xvYmFsID0gbmV3IEdsb2JhbCh7IGNsaWVudDogdGhpcy5fY2xpZW50IH0pO1xuICAgIHByb2plY3QgPSBuZXcgUHJvamVjdCh7IGNsaWVudDogdGhpcy5fY2xpZW50IH0pO1xuICAgIHB0eSA9IG5ldyBQdHkoeyBjbGllbnQ6IHRoaXMuX2NsaWVudCB9KTtcbiAgICBjb25maWcgPSBuZXcgQ29uZmlnKHsgY2xpZW50OiB0aGlzLl9jbGllbnQgfSk7XG4gICAgdG9vbCA9IG5ldyBUb29sKHsgY2xpZW50OiB0aGlzLl9jbGllbnQgfSk7XG4gICAgaW5zdGFuY2UgPSBuZXcgSW5zdGFuY2UoeyBjbGllbnQ6IHRoaXMuX2NsaWVudCB9KTtcbiAgICBwYXRoID0gbmV3IFBhdGgoeyBjbGllbnQ6IHRoaXMuX2NsaWVudCB9KTtcbiAgICB2Y3MgPSBuZXcgVmNzKHsgY2xpZW50OiB0aGlzLl9jbGllbnQgfSk7XG4gICAgc2Vzc2lvbiA9IG5ldyBTZXNzaW9uKHsgY2xpZW50OiB0aGlzLl9jbGllbnQgfSk7XG4gICAgY29tbWFuZCA9IG5ldyBDb21tYW5kKHsgY2xpZW50OiB0aGlzLl9jbGllbnQgfSk7XG4gICAgcHJvdmlkZXIgPSBuZXcgUHJvdmlkZXIoeyBjbGllbnQ6IHRoaXMuX2NsaWVudCB9KTtcbiAgICBmaW5kID0gbmV3IEZpbmQoeyBjbGllbnQ6IHRoaXMuX2NsaWVudCB9KTtcbiAgICBmaWxlID0gbmV3IEZpbGUoeyBjbGllbnQ6IHRoaXMuX2NsaWVudCB9KTtcbiAgICBhcHAgPSBuZXcgQXBwKHsgY2xpZW50OiB0aGlzLl9jbGllbnQgfSk7XG4gICAgbWNwID0gbmV3IE1jcCh7IGNsaWVudDogdGhpcy5fY2xpZW50IH0pO1xuICAgIGxzcCA9IG5ldyBMc3AoeyBjbGllbnQ6IHRoaXMuX2NsaWVudCB9KTtcbiAgICBmb3JtYXR0ZXIgPSBuZXcgRm9ybWF0dGVyKHsgY2xpZW50OiB0aGlzLl9jbGllbnQgfSk7XG4gICAgdHVpID0gbmV3IFR1aSh7IGNsaWVudDogdGhpcy5fY2xpZW50IH0pO1xuICAgIGF1dGggPSBuZXcgQXV0aCh7IGNsaWVudDogdGhpcy5fY2xpZW50IH0pO1xuICAgIGV2ZW50ID0gbmV3IEV2ZW50KHsgY2xpZW50OiB0aGlzLl9jbGllbnQgfSk7XG59XG4iLAogICAgImV4cG9ydCAqIGZyb20gXCIuL2dlbi90eXBlcy5nZW4uanNcIjtcbmltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gXCIuL2dlbi9jbGllbnQvY2xpZW50Lmdlbi5qc1wiO1xuaW1wb3J0IHsgT3BlbmNvZGVDbGllbnQgfSBmcm9tIFwiLi9nZW4vc2RrLmdlbi5qc1wiO1xuZXhwb3J0IHsgT3BlbmNvZGVDbGllbnQgfTtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPcGVuY29kZUNsaWVudChjb25maWcpIHtcbiAgICBpZiAoIWNvbmZpZz8uZmV0Y2gpIHtcbiAgICAgICAgY29uc3QgY3VzdG9tRmV0Y2ggPSAocmVxKSA9PiB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICByZXEudGltZW91dCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoKHJlcSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgICAgIGZldGNoOiBjdXN0b21GZXRjaCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZz8uZGlyZWN0b3J5KSB7XG4gICAgICAgIGNvbmZpZy5oZWFkZXJzID0ge1xuICAgICAgICAgICAgLi4uY29uZmlnLmhlYWRlcnMsXG4gICAgICAgICAgICBcIngtb3BlbmNvZGUtZGlyZWN0b3J5XCI6IGNvbmZpZy5kaXJlY3RvcnksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGNsaWVudCA9IGNyZWF0ZUNsaWVudChjb25maWcpO1xuICAgIHJldHVybiBuZXcgT3BlbmNvZGVDbGllbnQoeyBjbGllbnQgfSk7XG59XG4iLAogICAgImltcG9ydCB7IHNwYXduIH0gZnJvbSBcIm5vZGU6Y2hpbGRfcHJvY2Vzc1wiO1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZU9wZW5jb2RlU2VydmVyKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGhvc3RuYW1lOiBcIjEyNy4wLjAuMVwiLFxuICAgICAgICBwb3J0OiA0MDk2LFxuICAgICAgICB0aW1lb3V0OiA1MDAwLFxuICAgIH0sIG9wdGlvbnMgPz8ge30pO1xuICAgIGNvbnN0IGFyZ3MgPSBbYHNlcnZlYCwgYC0taG9zdG5hbWU9JHtvcHRpb25zLmhvc3RuYW1lfWAsIGAtLXBvcnQ9JHtvcHRpb25zLnBvcnR9YF07XG4gICAgaWYgKG9wdGlvbnMuY29uZmlnPy5sb2dMZXZlbClcbiAgICAgICAgYXJncy5wdXNoKGAtLWxvZy1sZXZlbD0ke29wdGlvbnMuY29uZmlnLmxvZ0xldmVsfWApO1xuICAgIGNvbnN0IHByb2MgPSBzcGF3bihgb3BlbmNvZGVgLCBhcmdzLCB7XG4gICAgICAgIHNpZ25hbDogb3B0aW9ucy5zaWduYWwsXG4gICAgICAgIGVudjoge1xuICAgICAgICAgICAgLi4ucHJvY2Vzcy5lbnYsXG4gICAgICAgICAgICBPUEVOQ09ERV9DT05GSUdfQ09OVEVOVDogSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5jb25maWcgPz8ge30pLFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGNvbnN0IHVybCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgaWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYFRpbWVvdXQgd2FpdGluZyBmb3Igc2VydmVyIHRvIHN0YXJ0IGFmdGVyICR7b3B0aW9ucy50aW1lb3V0fW1zYCkpO1xuICAgICAgICB9LCBvcHRpb25zLnRpbWVvdXQpO1xuICAgICAgICBsZXQgb3V0cHV0ID0gXCJcIjtcbiAgICAgICAgcHJvYy5zdGRvdXQ/Lm9uKFwiZGF0YVwiLCAoY2h1bmspID0+IHtcbiAgICAgICAgICAgIG91dHB1dCArPSBjaHVuay50b1N0cmluZygpO1xuICAgICAgICAgICAgY29uc3QgbGluZXMgPSBvdXRwdXQuc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAobGluZS5zdGFydHNXaXRoKFwib3BlbmNvZGUgc2VydmVyIGxpc3RlbmluZ1wiKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IGxpbmUubWF0Y2goL29uXFxzKyhodHRwcz86XFwvXFwvW15cXHNdKykvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2Ugc2VydmVyIHVybCBmcm9tIG91dHB1dDogJHtsaW5lfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobWF0Y2hbMV0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcHJvYy5zdGRlcnI/Lm9uKFwiZGF0YVwiLCAoY2h1bmspID0+IHtcbiAgICAgICAgICAgIG91dHB1dCArPSBjaHVuay50b1N0cmluZygpO1xuICAgICAgICB9KTtcbiAgICAgICAgcHJvYy5vbihcImV4aXRcIiwgKGNvZGUpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICAgICAgICBsZXQgbXNnID0gYFNlcnZlciBleGl0ZWQgd2l0aCBjb2RlICR7Y29kZX1gO1xuICAgICAgICAgICAgaWYgKG91dHB1dC50cmltKCkpIHtcbiAgICAgICAgICAgICAgICBtc2cgKz0gYFxcblNlcnZlciBvdXRwdXQ6ICR7b3V0cHV0fWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKG1zZykpO1xuICAgICAgICB9KTtcbiAgICAgICAgcHJvYy5vbihcImVycm9yXCIsIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3B0aW9ucy5zaWduYWwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiQWJvcnRlZFwiKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHVybCxcbiAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgICAgICBwcm9jLmtpbGwoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU9wZW5jb2RlVHVpKG9wdGlvbnMpIHtcbiAgICBjb25zdCBhcmdzID0gW107XG4gICAgaWYgKG9wdGlvbnM/LnByb2plY3QpIHtcbiAgICAgICAgYXJncy5wdXNoKGAtLXByb2plY3Q9JHtvcHRpb25zLnByb2plY3R9YCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zPy5tb2RlbCkge1xuICAgICAgICBhcmdzLnB1c2goYC0tbW9kZWw9JHtvcHRpb25zLm1vZGVsfWApO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucz8uc2Vzc2lvbikge1xuICAgICAgICBhcmdzLnB1c2goYC0tc2Vzc2lvbj0ke29wdGlvbnMuc2Vzc2lvbn1gKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnM/LmFnZW50KSB7XG4gICAgICAgIGFyZ3MucHVzaChgLS1hZ2VudD0ke29wdGlvbnMuYWdlbnR9YCk7XG4gICAgfVxuICAgIGNvbnN0IHByb2MgPSBzcGF3bihgb3BlbmNvZGVgLCBhcmdzLCB7XG4gICAgICAgIHNpZ25hbDogb3B0aW9ucz8uc2lnbmFsLFxuICAgICAgICBzdGRpbzogXCJpbmhlcml0XCIsXG4gICAgICAgIGVudjoge1xuICAgICAgICAgICAgLi4ucHJvY2Vzcy5lbnYsXG4gICAgICAgICAgICBPUEVOQ09ERV9DT05GSUdfQ09OVEVOVDogSlNPTi5zdHJpbmdpZnkob3B0aW9ucz8uY29uZmlnID8/IHt9KSxcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgICAgIHByb2Mua2lsbCgpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4iLAogICAgImV4cG9ydCAqIGZyb20gXCIuL2NsaWVudC5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vc2VydmVyLmpzXCI7XG5pbXBvcnQgeyBjcmVhdGVPcGVuY29kZUNsaWVudCB9IGZyb20gXCIuL2NsaWVudC5qc1wiO1xuaW1wb3J0IHsgY3JlYXRlT3BlbmNvZGVTZXJ2ZXIgfSBmcm9tIFwiLi9zZXJ2ZXIuanNcIjtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVPcGVuY29kZShvcHRpb25zKSB7XG4gICAgY29uc3Qgc2VydmVyID0gYXdhaXQgY3JlYXRlT3BlbmNvZGVTZXJ2ZXIoe1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgIH0pO1xuICAgIGNvbnN0IGNsaWVudCA9IGNyZWF0ZU9wZW5jb2RlQ2xpZW50KHtcbiAgICAgICAgYmFzZVVybDogc2VydmVyLnVybCxcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjbGllbnQsXG4gICAgICAgIHNlcnZlcixcbiAgICB9O1xufVxuIiwKICAgICIvKipcbiAqIFJhbHBoIExvb3AgUnVubmVyIC0gQmFzaC1sb29wIHN0eWxlIGl0ZXJhdGlvbiB3aXRoIGZyZXNoIGNvbnRleHQgcGVyIGN5Y2xlXG4gKlxuICogSW1wbGVtZW50cyB0aGUgb3JpZ2luYWwgUmFscGggV2lnZ3VtIHZpc2lvbjpcbiAqIC0gRnJlc2ggT3BlbkNvZGUgc2Vzc2lvbiBwZXIgaXRlcmF0aW9uIChubyB0cmFuc2NyaXB0IGNhcnJ5LW92ZXIpXG4gKiAtIEZpbGUgSS9PIGFzIHN0YXRlICguYWktZW5nL3J1bnMvPHJ1bklkPi8uZmxvdylcbiAqIC0gRGV0ZXJtaW5pc3RpYyByZS1hbmNob3JpbmcgZnJvbSBkaXNrIHN0YXRlIGVhY2ggY3ljbGVcbiAqIC0gTXVsdGktcGhhc2Ugd29ya2Zsb3cgKHJlc2VhcmNoIOKGkiBzcGVjaWZ5IOKGkiBwbGFuIOKGkiB3b3JrIOKGkiByZXZpZXcpXG4gKiAtIFF1YWxpdHkgZ2F0ZXMgdGhhdCBibG9jayB1bnRpbCBwYXNzZWRcbiAqL1xuXG5pbXBvcnQgeyBleGVjU3luYyB9IGZyb20gXCJub2RlOmNoaWxkX3Byb2Nlc3NcIjtcbmltcG9ydCB7IGNyZWF0ZUhhc2ggfSBmcm9tIFwibm9kZTpjcnlwdG9cIjtcbmltcG9ydCB7IHJlYWRGaWxlLCByZWFkZGlyIH0gZnJvbSBcIm5vZGU6ZnMvcHJvbWlzZXNcIjtcbmltcG9ydCB7IGpvaW4sIHBhcnNlIH0gZnJvbSBcIm5vZGU6cGF0aFwiO1xuaW1wb3J0IHsgT3BlbkNvZGVDbGllbnQsIHR5cGUgU2Vzc2lvbiB9IGZyb20gXCIuLi9iYWNrZW5kcy9vcGVuY29kZS9jbGllbnRcIjtcbmltcG9ydCB0eXBlIHsgUmFscGhGbGFncyB9IGZyb20gXCIuLi9jbGkvZmxhZ3NcIjtcbmltcG9ydCB7IFVJIH0gZnJvbSBcIi4uL2NsaS91aVwiO1xuaW1wb3J0IHR5cGUgeyBBaUVuZ0NvbmZpZywgR2F0ZUNvbW1hbmRDb25maWcgfSBmcm9tIFwiLi4vY29uZmlnL3NjaGVtYVwiO1xuaW1wb3J0IHsgUHJvbXB0T3B0aW1pemVyIH0gZnJvbSBcIi4uL3Byb21wdC1vcHRpbWl6YXRpb24vb3B0aW1pemVyXCI7XG5pbXBvcnQgdHlwZSB7IERpc2NvcmRXZWJob29rQ2xpZW50IH0gZnJvbSBcIi4uL3V0aWwvZGlzY29yZC13ZWJob29rXCI7XG5pbXBvcnQgeyBjcmVhdGVEaXNjb3JkV2ViaG9va0Zyb21FbnYgfSBmcm9tIFwiLi4vdXRpbC9kaXNjb3JkLXdlYmhvb2tcIjtcbmltcG9ydCB7IExvZyB9IGZyb20gXCIuLi91dGlsL2xvZ1wiO1xuaW1wb3J0IHsgRmxvd1N0b3JlLCB0eXBlIEZsb3dTdG9yZU9wdGlvbnMgfSBmcm9tIFwiLi9mbG93LXN0b3JlXCI7XG5pbXBvcnQgdHlwZSB7XG4gICAgQ3ljbGVTdGF0ZSxcbiAgICBHYXRlUmVzdWx0LFxuICAgIExvb3BDb25maWcsXG4gICAgVG9vbEludm9jYXRpb24sXG59IGZyb20gXCIuL2Zsb3ctdHlwZXNcIjtcbmltcG9ydCB7XG4gICAgRkxPV19TQ0hFTUFfVkVSU0lPTixcbiAgICBQaGFzZSxcbiAgICBSdW5TdGF0dXMsXG4gICAgU3RvcFJlYXNvbixcbn0gZnJvbSBcIi4vZmxvdy10eXBlc1wiO1xuXG5jb25zdCBsb2cgPSBMb2cuY3JlYXRlKHsgc2VydmljZTogXCJyYWxwaC1sb29wXCIgfSk7XG5cbi8qKiBEZWZhdWx0IHF1YWxpdHkgZ2F0ZXMgKi9cbmNvbnN0IERFRkFVTFRfR0FURVMgPSBbXCJ0ZXN0XCIsIFwibGludFwiLCBcImFjY2VwdGFuY2VcIl07XG5cbi8qKiBEZWZhdWx0IG1heCBjeWNsZXMgKi9cbmNvbnN0IERFRkFVTFRfTUFYX0NZQ0xFUyA9IDUwO1xuXG4vKiogRGVmYXVsdCBzdHVjayB0aHJlc2hvbGQgKi9cbmNvbnN0IERFRkFVTFRfU1RVQ0tfVEhSRVNIT0xEID0gNTtcblxuLyoqIERlZmF1bHQgY2hlY2twb2ludCBmcmVxdWVuY3kgKi9cbmNvbnN0IERFRkFVTFRfQ0hFQ0tQT0lOVF9GUkVRVUVOQ1kgPSAxO1xuXG4vKiogRGVmYXVsdCBjeWNsZSByZXRyaWVzICovXG5jb25zdCBERUZBVUxUX0NZQ0xFX1JFVFJJRVMgPSAyO1xuXG4vKiogU2VjcmV0cyBwYXR0ZXJucyB0byByZWRhY3QgaW4gZGVidWcgb3V0cHV0ICovXG5jb25zdCBTRUNSRVRfUEFUVEVSTlMgPSBbXG4gICAgL2FwaVtfLV0/a2V5L2ksXG4gICAgL3Rva2VuL2ksXG4gICAgL3NlY3JldC9pLFxuICAgIC9wYXNzd29yZC9pLFxuICAgIC9jcmVkZW50aWFsL2ksXG4gICAgL3dlYmhvb2svaSxcbiAgICAvYXV0aC9pLFxuICAgIC9iZWFyZXIvaSxcbiAgICAvcHJpdmF0ZVtfLV0/a2V5L2ksXG5dO1xuXG4vKipcbiAqIFJlZGFjdCBzZWNyZXRzIGZyb20gYSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gcmVkYWN0U2VjcmV0cyh0ZXh0OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgbGV0IHJlc3VsdCA9IHRleHQ7XG4gICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIFNFQ1JFVF9QQVRURVJOUykge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZShcbiAgICAgICAgICAgIG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgYCR7cGF0dGVybi5zb3VyY2V9W1wiJ10/XFxcXHMqWzo9XVxcXFxzKltcIiddPyhbXlwiJ1wiLFxcXFxzXSspYCxcbiAgICAgICAgICAgICAgICBcImdpXCIsXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgYCR7cGF0dGVybi5zb3VyY2V9PVwiW1JFREFDVEVEXVwiYCxcbiAgICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUcnVuY2F0ZSBsb25nIG91dHB1dCBmb3IgbG9nZ2luZ1xuICovXG5mdW5jdGlvbiB0cnVuY2F0ZU91dHB1dCh0ZXh0OiBzdHJpbmcsIG1heExlbmd0aCA9IDEwMDApOiBzdHJpbmcge1xuICAgIGlmICh0ZXh0Lmxlbmd0aCA8PSBtYXhMZW5ndGgpIHJldHVybiB0ZXh0O1xuICAgIHJldHVybiBgJHt0ZXh0LnN1YnN0cmluZygwLCBtYXhMZW5ndGgpfVxcbi4uLiBbdHJ1bmNhdGVkICR7dGV4dC5sZW5ndGggLSBtYXhMZW5ndGh9IGNoYXJzXWA7XG59XG5cbi8qKlxuICogUmFscGggTG9vcCBSdW5uZXIgLSBvcmNoZXN0cmF0ZXMgaXRlcmF0aW9uIGxvb3BzIHdpdGggZnJlc2ggc2Vzc2lvbnNcbiAqL1xuZXhwb3J0IGNsYXNzIFJhbHBoTG9vcFJ1bm5lciB7XG4gICAgcHJpdmF0ZSBjb25maWc6IExvb3BDb25maWc7XG4gICAgcHJpdmF0ZSBmbG93U3RvcmU6IEZsb3dTdG9yZTtcbiAgICBwcml2YXRlIGZsYWdzOiBSYWxwaEZsYWdzO1xuICAgIHByaXZhdGUgYmFzZUNvbmZpZzogQWlFbmdDb25maWc7XG4gICAgcHJpdmF0ZSBvcHRpbWl6ZXI6IFByb21wdE9wdGltaXplcjtcbiAgICBwcml2YXRlIGRpc2NvcmRXZWJob29rOiBEaXNjb3JkV2ViaG9va0NsaWVudCB8IG51bGw7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgZmxhZ3M6IFJhbHBoRmxhZ3MsXG4gICAgICAgIGJhc2VDb25maWc6IEFpRW5nQ29uZmlnLFxuICAgICAgICBvcHRpbWl6ZXI6IFByb21wdE9wdGltaXplcixcbiAgICApIHtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgICAgICB0aGlzLmJhc2VDb25maWcgPSBiYXNlQ29uZmlnO1xuICAgICAgICB0aGlzLm9wdGltaXplciA9IG9wdGltaXplcjtcblxuICAgICAgICAvLyBCdWlsZCBsb29wIGNvbmZpZyBmcm9tIGZsYWdzXG4gICAgICAgIHRoaXMuY29uZmlnID0gdGhpcy5idWlsZExvb3BDb25maWcoKTtcbiAgICAgICAgY29uc3QgZmxvd1N0b3JlT3B0aW9uczogRmxvd1N0b3JlT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGZsb3dEaXI6IHRoaXMuY29uZmlnLmZsb3dEaXIsXG4gICAgICAgICAgICBydW5JZDogdGhpcy5jb25maWcucnVuSWQsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZmxvd1N0b3JlID0gbmV3IEZsb3dTdG9yZShmbG93U3RvcmVPcHRpb25zKTtcblxuICAgICAgICAvLyBJbml0aWFsaXplIERpc2NvcmQgd2ViaG9vayBmcm9tIGVudmlyb25tZW50XG4gICAgICAgIHRoaXMuZGlzY29yZFdlYmhvb2sgPSBjcmVhdGVEaXNjb3JkV2ViaG9va0Zyb21FbnYoKTtcbiAgICB9XG5cbiAgICAvKiogQnVpbGQgbG9vcCBjb25maWcgZnJvbSBmbGFncyAqL1xuICAgIHByaXZhdGUgYnVpbGRMb29wQ29uZmlnKCk6IExvb3BDb25maWcge1xuICAgICAgICAvLyBEZXRlcm1pbmUgY29tcGxldGlvbiBwcm9taXNlIGJhc2VkIG9uIG1vZGVcbiAgICAgICAgbGV0IGNvbXBsZXRpb25Qcm9taXNlID0gdGhpcy5mbGFncy5jb21wbGV0aW9uUHJvbWlzZSA/PyBcIlwiO1xuXG4gICAgICAgIGlmICh0aGlzLmZsYWdzLnNoaXApIHtcbiAgICAgICAgICAgIC8vIFNoaXAgbW9kZTogYXV0by1leGl0IHdoZW4gYWdlbnQgb3V0cHV0cyBTSElQXG4gICAgICAgICAgICBjb21wbGV0aW9uUHJvbWlzZSA9IFwiPHByb21pc2U+U0hJUDwvcHJvbWlzZT5cIjtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZsYWdzLmRyYWZ0KSB7XG4gICAgICAgICAgICAvLyBEcmFmdCBtb2RlOiBydW4gZm9yIG1heC1jeWNsZXMsIHN0b3AgZm9yIHJldmlldyAobm8gYXV0by1leGl0KVxuICAgICAgICAgICAgY29tcGxldGlvblByb21pc2UgPSBcIlwiO1xuICAgICAgICB9IGVsc2UgaWYgKCFjb21wbGV0aW9uUHJvbWlzZSkge1xuICAgICAgICAgICAgLy8gTm8gZmxhZyBzcGVjaWZpZWQgYW5kIG5vIGNvbXBsZXRpb24gcHJvbWlzZTogZGVmYXVsdCB0byBkcmFmdCBtb2RlXG4gICAgICAgICAgICBjb21wbGV0aW9uUHJvbWlzZSA9IFwiXCI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZW5lcmF0ZSBydW4gSUQgaWYgbm90IHJlc3VtaW5nXG4gICAgICAgIGxldCBydW5JZCA9IHRoaXMuZmxhZ3MucnVuSWQ7XG4gICAgICAgIGlmICghcnVuSWQpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBleGlzdGluZyBmbG93IHN0YXRlXG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0UnVuSWQgPSB0aGlzLmdlbmVyYXRlUnVuSWQoKTtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRGbG93RGlyID0gdGhpcy5nZXREZWZhdWx0Rmxvd0RpcihkZWZhdWx0UnVuSWQpO1xuICAgICAgICAgICAgY29uc3QgY2hlY2tTdG9yZSA9IG5ldyBGbG93U3RvcmUoe1xuICAgICAgICAgICAgICAgIGZsb3dEaXI6IHRoaXMuZmxhZ3Mud29ya2luZ0RpclxuICAgICAgICAgICAgICAgICAgICA/IGpvaW4odGhpcy5mbGFncy53b3JraW5nRGlyLCBcIi5haS1lbmdcIilcbiAgICAgICAgICAgICAgICAgICAgOiBcIi5haS1lbmdcIixcbiAgICAgICAgICAgICAgICBydW5JZDogZGVmYXVsdFJ1bklkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBydW5JZCA9IGRlZmF1bHRSdW5JZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBydW5JZCxcbiAgICAgICAgICAgIHByb21wdDogdGhpcy5mbGFncy53b3JrZmxvdyA/PyBcIlwiLFxuICAgICAgICAgICAgY29tcGxldGlvblByb21pc2UsXG4gICAgICAgICAgICBtYXhDeWNsZXM6IHRoaXMuZmxhZ3MubWF4Q3ljbGVzID8/IERFRkFVTFRfTUFYX0NZQ0xFUyxcbiAgICAgICAgICAgIHN0dWNrVGhyZXNob2xkOlxuICAgICAgICAgICAgICAgIHRoaXMuZmxhZ3Muc3R1Y2tUaHJlc2hvbGQgPz8gREVGQVVMVF9TVFVDS19USFJFU0hPTEQsXG4gICAgICAgICAgICBnYXRlczogdGhpcy5mbGFncy5nYXRlcyA/PyBERUZBVUxUX0dBVEVTLFxuICAgICAgICAgICAgY2hlY2twb2ludEZyZXF1ZW5jeTpcbiAgICAgICAgICAgICAgICB0aGlzLmZsYWdzLmNoZWNrcG9pbnRGcmVxdWVuY3kgPz8gREVGQVVMVF9DSEVDS1BPSU5UX0ZSRVFVRU5DWSxcbiAgICAgICAgICAgIGZsb3dEaXI6IHRoaXMuZ2V0RGVmYXVsdEZsb3dEaXIocnVuSWQpLFxuICAgICAgICAgICAgZHJ5UnVuOiB0aGlzLmZsYWdzLmRyeVJ1biA/PyBmYWxzZSxcbiAgICAgICAgICAgIGN5Y2xlUmV0cmllczpcbiAgICAgICAgICAgICAgICB0aGlzLmJhc2VDb25maWcubG9vcD8uY3ljbGVSZXRyaWVzID8/IERFRkFVTFRfQ1lDTEVfUkVUUklFUyxcbiAgICAgICAgICAgIGRlYnVnV29yazpcbiAgICAgICAgICAgICAgICB0aGlzLmZsYWdzLmRlYnVnV29yayA/PyB0aGlzLmJhc2VDb25maWcuZGVidWc/LndvcmsgPz8gZmFsc2UsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqIEdldCBkZWZhdWx0IGZsb3cgZGlyZWN0b3J5IHBhdGggKi9cbiAgICBwcml2YXRlIGdldERlZmF1bHRGbG93RGlyKHJ1bklkOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBhcnRpZmFjdHNEaXIgPSB0aGlzLmJhc2VDb25maWcucnVubmVyLmFydGlmYWN0c0RpcjtcbiAgICAgICAgaWYgKHRoaXMuZmxhZ3Mud29ya2luZ0Rpcikge1xuICAgICAgICAgICAgcmV0dXJuIGpvaW4odGhpcy5mbGFncy53b3JraW5nRGlyLCBhcnRpZmFjdHNEaXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqb2luKHByb2Nlc3MuY3dkKCksIGFydGlmYWN0c0Rpcik7XG4gICAgfVxuXG4gICAgLyoqIEdlbmVyYXRlIGEgdW5pcXVlIHJ1biBJRCAqL1xuICAgIHByaXZhdGUgZ2VuZXJhdGVSdW5JZCgpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBEYXRlLm5vdygpLnRvU3RyaW5nKDM2KTtcbiAgICAgICAgY29uc3QgcmFuZG9tID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDgpO1xuICAgICAgICByZXR1cm4gYHJ1bi0ke3RpbWVzdGFtcH0tJHtyYW5kb219YDtcbiAgICB9XG5cbiAgICAvKiogR2VuZXJhdGUgYSBoYXNoIG9mIG91dHB1dCBmb3Igc3R1Y2sgZGV0ZWN0aW9uICovXG4gICAgcHJpdmF0ZSBoYXNoT3V0cHV0KG91dHB1dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUhhc2goXCJzaGEyNTZcIilcbiAgICAgICAgICAgIC51cGRhdGUob3V0cHV0KVxuICAgICAgICAgICAgLmRpZ2VzdChcImhleFwiKVxuICAgICAgICAgICAgLnN1YnN0cmluZygwLCAxNik7XG4gICAgfVxuXG4gICAgLyoqIFJ1biB0aGUgbG9vcCAqL1xuICAgIGFzeW5jIHJ1bigpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgVUkuaGVhZGVyKFwiUmFscGggTG9vcCBSdW5uZXJcIik7XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIHJlc3VtZVxuICAgICAgICBpZiAodGhpcy5mbGFncy5yZXN1bWUpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVzdW1lKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGFydCBmcmVzaCBydW5cbiAgICAgICAgYXdhaXQgdGhpcy5zdGFydEZyZXNoKCk7XG4gICAgfVxuXG4gICAgLyoqIFN0YXJ0IGEgZnJlc2ggcnVuICovXG4gICAgcHJpdmF0ZSBhc3luYyBzdGFydEZyZXNoKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBsb2cuaW5mbyhcIlN0YXJ0aW5nIGZyZXNoIFJhbHBoIGxvb3BcIiwge1xuICAgICAgICAgICAgcnVuSWQ6IHRoaXMuY29uZmlnLnJ1bklkLFxuICAgICAgICAgICAgcHJvbXB0OiB0aGlzLmNvbmZpZy5wcm9tcHQuc3Vic3RyaW5nKDAsIDEwMCksXG4gICAgICAgICAgICBjb21wbGV0aW9uUHJvbWlzZTogdGhpcy5jb25maWcuY29tcGxldGlvblByb21pc2UsXG4gICAgICAgICAgICBtYXhDeWNsZXM6IHRoaXMuY29uZmlnLm1heEN5Y2xlcyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBmbG93IHN0b3JlXG4gICAgICAgIHRoaXMuZmxvd1N0b3JlLmluaXRpYWxpemUoKTtcblxuICAgICAgICAvLyBDcmVhdGUgaW5pdGlhbCBzdGF0ZVxuICAgICAgICBjb25zdCBpbml0aWFsU3RhdGUgPSB0aGlzLmZsb3dTdG9yZS5jcmVhdGVJbml0aWFsU3RhdGUoe1xuICAgICAgICAgICAgcHJvbXB0OiB0aGlzLmNvbmZpZy5wcm9tcHQsXG4gICAgICAgICAgICBjb21wbGV0aW9uUHJvbWlzZTogdGhpcy5jb25maWcuY29tcGxldGlvblByb21pc2UsXG4gICAgICAgICAgICBtYXhDeWNsZXM6IHRoaXMuY29uZmlnLm1heEN5Y2xlcyxcbiAgICAgICAgICAgIHN0dWNrVGhyZXNob2xkOiB0aGlzLmNvbmZpZy5zdHVja1RocmVzaG9sZCxcbiAgICAgICAgICAgIGdhdGVzOiB0aGlzLmNvbmZpZy5nYXRlcyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVXBkYXRlIHN0YXR1cyB0byBydW5uaW5nXG4gICAgICAgIHRoaXMuZmxvd1N0b3JlLnVwZGF0ZVN0YXR1cyhSdW5TdGF0dXMuUlVOTklORyk7XG5cbiAgICAgICAgLy8gUnVuIHRoZSBsb29wXG4gICAgICAgIGF3YWl0IHRoaXMucnVuTG9vcCgpO1xuICAgIH1cblxuICAgIC8qKiBSZXN1bWUgZnJvbSBwcmV2aW91cyBydW4gKi9cbiAgICBwcml2YXRlIGFzeW5jIHJlc3VtZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgbG9nLmluZm8oXCJSZXN1bWluZyBSYWxwaCBsb29wXCIsIHsgcnVuSWQ6IHRoaXMuY29uZmlnLnJ1bklkIH0pO1xuXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5mbG93U3RvcmUubG9hZCgpO1xuICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYE5vIGZsb3cgc3RhdGUgZm91bmQgZm9yIHJ1biBJRDogJHt0aGlzLmNvbmZpZy5ydW5JZH0uIENhbm5vdCByZXN1bWUuYCxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGUuc3RhdHVzID09PSBSdW5TdGF0dXMuQ09NUExFVEVEKSB7XG4gICAgICAgICAgICBVSS53YXJuKFwiVGhpcyBydW4gaGFzIGFscmVhZHkgY29tcGxldGVkLlwiKTtcbiAgICAgICAgICAgIFVJLmluZm8oYFN0b3AgcmVhc29uOiAke3N0YXRlLnN0b3BSZWFzb259YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGUuc3RhdHVzID09PSBSdW5TdGF0dXMuRkFJTEVEKSB7XG4gICAgICAgICAgICBVSS53YXJuKFwiVGhpcyBydW4gcHJldmlvdXNseSBmYWlsZWQuXCIpO1xuICAgICAgICAgICAgVUkuaW5mbyhgRXJyb3I6ICR7c3RhdGUuZXJyb3J9YCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXN1bWUgdGhlIGxvb3BcbiAgICAgICAgYXdhaXQgdGhpcy5ydW5Mb29wKCk7XG4gICAgfVxuXG4gICAgLyoqIE1haW4gbG9vcCBleGVjdXRpb24gKi9cbiAgICBwcml2YXRlIGFzeW5jIHJ1bkxvb3AoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5mbG93U3RvcmUubG9hZCgpO1xuICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBmbG93IHN0YXRlIGZvdW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgVUkuaW5mbyhgUnVuIElEOiAke3RoaXMuY29uZmlnLnJ1bklkfWApO1xuICAgICAgICBVSS5pbmZvKGBGbG93IGRpcmVjdG9yeTogJHt0aGlzLmZsb3dTdG9yZS5iYXNlUGF0aH1gKTtcbiAgICAgICAgVUkuaW5mbyhcbiAgICAgICAgICAgIGBDb21wbGV0aW9uIHByb21pc2U6ICR7dGhpcy5jb25maWcuY29tcGxldGlvblByb21pc2UgfHwgXCIobm9uZSlcIn1gLFxuICAgICAgICApO1xuICAgICAgICBVSS5pbmZvKGBNYXggY3ljbGVzOiAke3RoaXMuY29uZmlnLm1heEN5Y2xlc31gKTtcbiAgICAgICAgVUkuaW5mbyhgQ3ljbGUgcmV0cmllczogJHt0aGlzLmNvbmZpZy5jeWNsZVJldHJpZXN9YCk7XG4gICAgICAgIFVJLmluZm8oYFN0dWNrIHRocmVzaG9sZDogJHt0aGlzLmNvbmZpZy5zdHVja1RocmVzaG9sZH1gKTtcbiAgICAgICAgVUkuaW5mbyhcbiAgICAgICAgICAgIGBEZWJ1ZyB3b3JrOiAke3RoaXMuY29uZmlnLmRlYnVnV29yayA/IFwiZW5hYmxlZFwiIDogXCJkaXNhYmxlZFwifWAsXG4gICAgICAgICk7XG4gICAgICAgIFVJLnByaW50bG4oKTtcblxuICAgICAgICAvLyBDaGVjayBpZiB3ZSBzaG91bGQgc2tpcCBvcHRpbWl6YXRpb24gKGFscmVhZHkgZG9uZSBvbiBpbml0aWFsIGluZ2VzdClcbiAgICAgICAgLy8gRm9yIGxvb3AgbW9kZSwgd2Ugc2tpcCByZS1vcHRpbWl6YXRpb24gZWFjaCBjeWNsZVxuXG4gICAgICAgIC8vIFJ1biBjeWNsZXNcbiAgICAgICAgZm9yIChcbiAgICAgICAgICAgIGxldCBjeWNsZU51bWJlciA9IHN0YXRlLmN1cnJlbnRDeWNsZSArIDE7XG4gICAgICAgICAgICBjeWNsZU51bWJlciA8PSB0aGlzLmNvbmZpZy5tYXhDeWNsZXM7XG4gICAgICAgICAgICBjeWNsZU51bWJlcisrXG4gICAgICAgICkge1xuICAgICAgICAgICAgVUkuaGVhZGVyKGBDeWNsZSAke2N5Y2xlTnVtYmVyfS8ke3RoaXMuY29uZmlnLm1heEN5Y2xlc31gKTtcblxuICAgICAgICAgICAgLy8gTm90aWZ5IERpc2NvcmQ6IGN5Y2xlIHN0YXJ0ZWRcbiAgICAgICAgICAgIGNvbnN0IHJ1blN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB0aGlzLmRpc2NvcmRXZWJob29rPy5ub3RpZnlDeWNsZVN0YXJ0KFxuICAgICAgICAgICAgICAgIGN5Y2xlTnVtYmVyLFxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLm1heEN5Y2xlcyxcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5wcm9tcHQsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBFeGVjdXRlIGN5Y2xlIHdpdGggcmV0cnkgbG9naWNcbiAgICAgICAgICAgIGxldCBhdHRlbXB0ID0gMDtcbiAgICAgICAgICAgIGxldCByZXN1bHQ6IHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBib29sZWFuO1xuICAgICAgICAgICAgICAgIGN5Y2xlU3RhdGU6IEN5Y2xlU3RhdGU7XG4gICAgICAgICAgICAgICAgc3VtbWFyeTogc3RyaW5nO1xuICAgICAgICAgICAgICAgIHN0b3BSZWFzb24/OiBTdG9wUmVhc29uO1xuICAgICAgICAgICAgfSB8IG51bGwgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGxhc3RFcnJvcjogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgICAgIHdoaWxlIChhdHRlbXB0IDw9IHRoaXMuY29uZmlnLmN5Y2xlUmV0cmllcykge1xuICAgICAgICAgICAgICAgIGF0dGVtcHQrKztcbiAgICAgICAgICAgICAgICBjb25zdCBpc1JldHJ5ID0gYXR0ZW1wdCA+IDE7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNSZXRyeSkge1xuICAgICAgICAgICAgICAgICAgICBVSS5pbmZvKFxuICAgICAgICAgICAgICAgICAgICAgICAgYFJldHJ5IGF0dGVtcHQgJHthdHRlbXB0fS8ke3RoaXMuY29uZmlnLmN5Y2xlUmV0cmllcyArIDF9YCxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nLmluZm8oXCJSZXRyeWluZyBjeWNsZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjeWNsZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGVtcHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0RXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBmcmVzaCBPcGVuQ29kZSBzZXNzaW9uIGZvciB0aGlzIGN5Y2xlXG4gICAgICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gYXdhaXQgT3BlbkNvZGVDbGllbnQuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyU3RhcnR1cFRpbWVvdXQ6IDEwMDAwLFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmUtYW5jaG9yIGNvbnRleHQgZnJvbSBkaXNrICh3aXRoIHJldHJ5IGZhaWx1cmUgaW5qZWN0ZWQgaWYgdGhpcyBpcyBhIHJldHJ5KVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gYXdhaXQgdGhpcy5idWlsZFJlQW5jaG9yZWRDb250ZXh0KFxuICAgICAgICAgICAgICAgICAgICAgICAgY3ljbGVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1JldHJ5ID8gKGxhc3RFcnJvciA/PyB1bmRlZmluZWQpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEV4ZWN1dGUgdGhlIGN5Y2xlIHdpdGggZnJlc2ggc2Vzc2lvblxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBhd2FpdCB0aGlzLmV4ZWN1dGVDeWNsZShcbiAgICAgICAgICAgICAgICAgICAgICAgIGN5Y2xlTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBSZWNvcmQgdGhlIGN5Y2xlXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mbG93U3RvcmUucmVjb3JkU3VjY2Vzc2Z1bEN5Y2xlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jeWNsZVN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdW1tYXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90aWZ5IERpc2NvcmQ6IGN5Y2xlIGNvbXBsZXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZHVyYXRpb25NcyA9IERhdGUubm93KCkgLSBydW5TdGFydFRpbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2NvcmRXZWJob29rPy5ub3RpZnlDeWNsZUNvbXBsZXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN5Y2xlTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmxvd1N0b3JlLmxvYWQoKT8uY29tcGxldGVkQ3ljbGVzID8/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN5Y2xlTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zdW1tYXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uTXMsXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mbG93U3RvcmUucmVjb3JkRmFpbGVkQ3ljbGUocmVzdWx0LmN5Y2xlU3RhdGUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3RpZnkgRGlzY29yZDogY3ljbGUgZmFpbGVkXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2NvcmRXZWJob29rPy5ub3RpZnlFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeWNsZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuY3ljbGVTdGF0ZS5waGFzZXNbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmN5Y2xlU3RhdGUucGhhc2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApLnBvcCgpIGFzIGtleW9mIHR5cGVvZiByZXN1bHQuY3ljbGVTdGF0ZS5waGFzZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdPy5waGFzZSA/PyBcInVua25vd25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuY3ljbGVTdGF0ZS5lcnJvciA/PyBcIlVua25vd24gZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBCcmVhayByZXRyeSBsb29wIG9uIHN1Y2Nlc3Mgb3Igbm9uLXJldHJ5YWJsZSBmYWlsdXJlXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgaWYgd2Ugc2hvdWxkIHJldHJ5IHRoaXMgZmFpbHVyZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaG91bGRSZXRyeSA9IHRoaXMuc2hvdWxkUmV0cnlGYWlsdXJlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2hvdWxkUmV0cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbGFzdEVycm9yID0gcmVzdWx0LnN1bW1hcnk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNc2cgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBsYXN0RXJyb3IgPSBlcnJvck1zZztcblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBzaG91bGQgcmV0cnkgdGhpcyBlcnJvclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaG91bGRSZXRyeSA9IHRoaXMuc2hvdWxkUmV0cnlPbkVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFJldHJ5ICYmIGF0dGVtcHQgPD0gdGhpcy5jb25maWcuY3ljbGVSZXRyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cud2FybihcIkN5Y2xlIGVycm9yLCB3aWxsIHJldHJ5XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeWNsZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRlbXB0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvck1zZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm9uLXJldHJ5YWJsZSBvciBtYXggcmV0cmllcyBleGNlZWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDbGVhbiB1cCB0aGUgc2Vzc2lvbiBmb3IgdGhpcyBjeWNsZVxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBjbGllbnQuY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgcmVzdWx0IGlzIG51bGwgYWZ0ZXIgYWxsIHJldHJpZXMsIHdlIGhhZCBhIGNhdGFzdHJvcGhpYyBmYWlsdXJlXG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzY29yZFdlYmhvb2s/Lm5vdGlmeVN0dWNrT3JBYm9ydGVkKFxuICAgICAgICAgICAgICAgICAgICBjeWNsZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgXCJGQUlMRURfQUxMX1JFVFJJRVNcIixcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuaGFuZGxlU3RvcChcbiAgICAgICAgICAgICAgICAgICAgU3RvcFJlYXNvbi5FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgYEN5Y2xlICR7Y3ljbGVOdW1iZXJ9IGZhaWxlZCBhZnRlciAke3RoaXMuY29uZmlnLmN5Y2xlUmV0cmllcyArIDF9IGF0dGVtcHRzOiAke2xhc3RFcnJvciA/PyBcInVua25vd24gZXJyb3JcIn1gLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayBzdG9wIGNvbmRpdGlvbnNcbiAgICAgICAgICAgIGlmIChyZXN1bHQuc3RvcFJlYXNvbikge1xuICAgICAgICAgICAgICAgIC8vIE5vdGlmeSBEaXNjb3JkOiBydW4gc3RvcHBlZFxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuaGFuZGxlU3RvcChyZXN1bHQuc3RvcFJlYXNvbiwgcmVzdWx0LnN1bW1hcnkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgc3R1Y2tcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHRoaXMuZmxvd1N0b3JlLmxvYWQoKTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGUgJiZcbiAgICAgICAgICAgICAgICBjdXJyZW50U3RhdGUuc3R1Y2tDb3VudCA+PSB0aGlzLmNvbmZpZy5zdHVja1RocmVzaG9sZFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgLy8gTm90aWZ5IERpc2NvcmQ6IHN0dWNrXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNjb3JkV2ViaG9vaz8ubm90aWZ5U3R1Y2tPckFib3J0ZWQoY3ljbGVOdW1iZXIsIFwiU1RVQ0tcIik7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5oYW5kbGVTdG9wKFxuICAgICAgICAgICAgICAgICAgICBTdG9wUmVhc29uLlNUVUNLLFxuICAgICAgICAgICAgICAgICAgICBgTm8gcHJvZ3Jlc3MgZm9yICR7dGhpcy5jb25maWcuc3R1Y2tUaHJlc2hvbGR9IGNvbnNlY3V0aXZlIGN5Y2xlc2AsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNhdmUgY2hlY2twb2ludCBpZiBuZWVkZWRcbiAgICAgICAgICAgIGlmIChjeWNsZU51bWJlciAlIHRoaXMuY29uZmlnLmNoZWNrcG9pbnRGcmVxdWVuY3kgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dTdG9yZS5zYXZlQ2hlY2twb2ludChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mbG93U3RvcmUubG9hZCgpISxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmN5Y2xlU3RhdGUucGhhc2VzLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFVJLnByaW50bG4oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1heCBjeWNsZXMgcmVhY2hlZCAtIG5vdGlmeSBEaXNjb3JkXG4gICAgICAgIHRoaXMuZGlzY29yZFdlYmhvb2s/Lm5vdGlmeVJ1bkNvbXBsZXRlKFxuICAgICAgICAgICAgc3RhdGUuY29tcGxldGVkQ3ljbGVzLFxuICAgICAgICAgICAgRGF0ZS5ub3coKSAtIG5ldyBEYXRlKHN0YXRlLmNyZWF0ZWRBdCkuZ2V0VGltZSgpLFxuICAgICAgICAgICAgYENvbXBsZXRlZCAke3N0YXRlLmNvbXBsZXRlZEN5Y2xlc30gY3ljbGVzIChtYXggJHt0aGlzLmNvbmZpZy5tYXhDeWNsZXN9KWAsXG4gICAgICAgICk7XG4gICAgICAgIGF3YWl0IHRoaXMuaGFuZGxlU3RvcChTdG9wUmVhc29uLk1BWF9DWUNMRVMsIFwiTWF4aW11bSBjeWNsZXMgcmVhY2hlZFwiKTtcbiAgICB9XG5cbiAgICAvKiogRGV0ZXJtaW5lIGlmIGEgZmFpbHVyZSBzaG91bGQgdHJpZ2dlciBhIHJldHJ5ICovXG4gICAgcHJpdmF0ZSBzaG91bGRSZXRyeUZhaWx1cmUocmVzdWx0OiB7XG4gICAgICAgIHN1Y2Nlc3M6IGJvb2xlYW47XG4gICAgICAgIGN5Y2xlU3RhdGU6IEN5Y2xlU3RhdGU7XG4gICAgICAgIHN1bW1hcnk6IHN0cmluZztcbiAgICB9KTogYm9vbGVhbiB7XG4gICAgICAgIC8vIENoZWNrIGZvciBnYXRlIGZhaWx1cmVzXG4gICAgICAgIGNvbnN0IGZhaWxlZEdhdGVzID0gcmVzdWx0LmN5Y2xlU3RhdGUuZ2F0ZVJlc3VsdHMuZmlsdGVyKFxuICAgICAgICAgICAgKGcpID0+ICFnLnBhc3NlZCxcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGZhaWxlZEdhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGVtcHR5IHdvcmsgcmVzcG9uc2UgKG91ciBhY2NlcHRhbmNlIHJ1bGUpXG4gICAgICAgIGNvbnN0IHdvcmtQaGFzZSA9IHJlc3VsdC5jeWNsZVN0YXRlLnBoYXNlc1tQaGFzZS5XT1JLXTtcbiAgICAgICAgaWYgKHdvcmtQaGFzZSAmJiAhd29ya1BoYXNlLnJlc3BvbnNlLnRyaW0oKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqIERldGVybWluZSBpZiBhbiBlcnJvciBzaG91bGQgdHJpZ2dlciBhIHJldHJ5ICovXG4gICAgcHJpdmF0ZSBzaG91bGRSZXRyeU9uRXJyb3IoZXJyb3I6IHVua25vd24pOiBib29sZWFuIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFJldHJ5IG9uIHRpbWVvdXRcbiAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwidGltZW91dFwiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmV0cnkgb24gc3RyZWFtIGVycm9yc1xuICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJzdHJlYW1cIikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJldHJ5IG9uIE9wZW5Db2RlIGNvbm5lY3Rpb24gZXJyb3JzXG4gICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcIk9wZW5Db2RlXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKiBCdWlsZCByZS1hbmNob3JlZCBjb250ZXh0IGZvciBhIGN5Y2xlICovXG4gICAgcHJpdmF0ZSBhc3luYyBidWlsZFJlQW5jaG9yZWRDb250ZXh0KFxuICAgICAgICBjeWNsZU51bWJlcjogbnVtYmVyLFxuICAgICAgICByZXRyeUZhaWx1cmU/OiBzdHJpbmcsXG4gICAgKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAgICAgY29uc3QgY29udGV4dFBhcnRzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgICAgIC8vIEFsd2F5cyBzdGFydCB3aXRoIHRoZSBvcmlnaW5hbCBwcm9tcHRcbiAgICAgICAgY29udGV4dFBhcnRzLnB1c2goYCMgT3JpZ2luYWwgVGFza1xcblxcbiR7dGhpcy5jb25maWcucHJvbXB0fVxcbmApO1xuXG4gICAgICAgIC8vIEFkZCByZXRyeSBmYWlsdXJlIGluZm8gaWYgdGhpcyBpcyBhIHJldHJ5XG4gICAgICAgIGlmIChyZXRyeUZhaWx1cmUpIHtcbiAgICAgICAgICAgIGNvbnRleHRQYXJ0cy5wdXNoKFxuICAgICAgICAgICAgICAgIGAjIFByZXZpb3VzIEF0dGVtcHQgRmFpbGVkXFxuXFxuVGhlIHByZXZpb3VzIGF0dGVtcHQgaGFkIGFuIGlzc3VlOlxcbiR7cmV0cnlGYWlsdXJlfVxcblxcblBsZWFzZSBhbmFseXplIHdoYXQgd2VudCB3cm9uZyBhbmQgdHJ5IGEgZGlmZmVyZW50IGFwcHJvYWNoLlxcbmAsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHByZXZpb3VzIGN5Y2xlIHN1bW1hcnkgaWYgYXZhaWxhYmxlXG4gICAgICAgIGNvbnN0IHByZXZpb3VzQ3ljbGUgPSB0aGlzLmZsb3dTdG9yZS5nZXRJdGVyYXRpb24oY3ljbGVOdW1iZXIgLSAxKTtcbiAgICAgICAgaWYgKHByZXZpb3VzQ3ljbGUpIHtcbiAgICAgICAgICAgIGNvbnRleHRQYXJ0cy5wdXNoKFxuICAgICAgICAgICAgICAgIGAjIFByZXZpb3VzIEN5Y2xlICgke2N5Y2xlTnVtYmVyIC0gMX0pIFN1bW1hcnlcXG5cXG5gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnRleHRQYXJ0cy5wdXNoKHByZXZpb3VzQ3ljbGUuZXJyb3IgPyBcIkZBSUxFRFxcblwiIDogXCJDT01QTEVURURcXG5cIik7XG5cbiAgICAgICAgICAgIGlmIChwcmV2aW91c0N5Y2xlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dFBhcnRzLnB1c2goYEVycm9yOiAke3ByZXZpb3VzQ3ljbGUuZXJyb3J9XFxuYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFkZCBnYXRlIHJlc3VsdHNcbiAgICAgICAgICAgIGlmIChwcmV2aW91c0N5Y2xlLmdhdGVSZXN1bHRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0UGFydHMucHVzaChcIlxcbiMjIEdhdGUgUmVzdWx0c1xcblxcblwiKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGdhdGUgb2YgcHJldmlvdXNDeWNsZS5nYXRlUmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXMgPSBnYXRlLnBhc3NlZCA/IFwi4pyFXCIgOiBcIuKdjFwiO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0UGFydHMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIGAtICR7c3RhdHVzfSAke2dhdGUuZ2F0ZX06ICR7Z2F0ZS5tZXNzYWdlfVxcbmAsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgdG9vbCB1c2FnZSBzdW1tYXJ5IGZyb20gcHJldmlvdXMgY3ljbGVcbiAgICAgICAgICAgIGNvbnN0IGFsbFRvb2xzID0gdGhpcy5jb2xsZWN0QWxsVG9vbHMocHJldmlvdXNDeWNsZSk7XG4gICAgICAgICAgICBpZiAoYWxsVG9vbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHRQYXJ0cy5wdXNoKFwiXFxuIyMgVG9vbCBVc2FnZSBpbiBQcmV2aW91cyBDeWNsZVxcblxcblwiKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2wgb2YgYWxsVG9vbHMuc2xpY2UoMCwgMTApKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1c0ljb24gPSB0b29sLnN0YXR1cyA9PT0gXCJva1wiID8gXCLinIVcIiA6IFwi4p2MXCI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRQYXJ0cy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgYCR7c3RhdHVzSWNvbn0gJHt0b29sLm5hbWV9OiAke3Rvb2wuc3RhdHVzfVxcbmAsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhbGxUb29scy5sZW5ndGggPiAxMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0UGFydHMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIGAuLi4gYW5kICR7YWxsVG9vbHMubGVuZ3RoIC0gMTB9IG1vcmUgdG9vbHNcXG5gLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBsYXN0IGNoZWNrcG9pbnQgc3VtbWFyeVxuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZmxvd1N0b3JlLmxvYWQoKTtcbiAgICAgICAgaWYgKHN0YXRlPy5sYXN0Q2hlY2twb2ludCkge1xuICAgICAgICAgICAgY29udGV4dFBhcnRzLnB1c2goXG4gICAgICAgICAgICAgICAgYFxcbiMgTGFzdCBDaGVja3BvaW50XFxuXFxuQ3ljbGUgJHtzdGF0ZS5sYXN0Q2hlY2twb2ludC5jeWNsZU51bWJlcn06ICR7c3RhdGUubGFzdENoZWNrcG9pbnQuc3VtbWFyeX1cXG5gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF1dG8tbG9hZCByZWxldmFudCBzcGVjcyBmcm9tIHNwZWNzLyBkaXJlY3RvcnlcbiAgICAgICAgY29uc3Qgc3BlY3NDb250ZXh0ID0gYXdhaXQgdGhpcy5sb2FkUmVsZXZhbnRTcGVjcygpO1xuICAgICAgICBpZiAoc3BlY3NDb250ZXh0KSB7XG4gICAgICAgICAgICBjb250ZXh0UGFydHMucHVzaChzcGVjc0NvbnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGdpdCBzdGF0dXMgaWYgYXZhaWxhYmxlXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBnaXRTdGF0dXMgPSBhd2FpdCB0aGlzLmdldEdpdFN0YXR1cygpO1xuICAgICAgICAgICAgaWYgKGdpdFN0YXR1cykge1xuICAgICAgICAgICAgICAgIGNvbnRleHRQYXJ0cy5wdXNoKGBcXG4jIEdpdCBTdGF0dXNcXG5cXG4ke2dpdFN0YXR1c31cXG5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAvLyBHaXQgc3RhdHVzIG5vdCBhdmFpbGFibGUsIHNraXBcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBjb21wbGV0aW9uIGNyaXRlcmlhIHJlbWluZGVyXG4gICAgICAgIGNvbnRleHRQYXJ0cy5wdXNoKFxuICAgICAgICAgICAgYFxcbiMgQ29tcGxldGlvbiBDcml0ZXJpYVxcblxcbkxvb3AgZXhpdHMgd2hlbiB5b3Ugb3V0cHV0IGV4YWN0bHk6ICR7dGhpcy5jb25maWcuY29tcGxldGlvblByb21pc2UgfHwgXCIobm9uZSAtIHdpbGwgcnVuIGFsbCBjeWNsZXMpXCJ9XFxuYCxcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gY29udGV4dFBhcnRzLmpvaW4oXCJcXG5cIik7XG4gICAgfVxuXG4gICAgLyoqIENvbGxlY3QgYWxsIHRvb2wgaW52b2NhdGlvbnMgZnJvbSBhIGN5Y2xlIHN0YXRlICovXG4gICAgcHJpdmF0ZSBjb2xsZWN0QWxsVG9vbHMoY3ljbGU6IEN5Y2xlU3RhdGUpOiBUb29sSW52b2NhdGlvbltdIHtcbiAgICAgICAgY29uc3QgdG9vbHM6IFRvb2xJbnZvY2F0aW9uW10gPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwaGFzZSBvZiBPYmplY3QudmFsdWVzKGN5Y2xlLnBoYXNlcykpIHtcbiAgICAgICAgICAgIGlmIChwaGFzZT8udG9vbHMpIHtcbiAgICAgICAgICAgICAgICB0b29scy5wdXNoKC4uLnBoYXNlLnRvb2xzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9vbHM7XG4gICAgfVxuXG4gICAgLyoqIExvYWQgcmVsZXZhbnQgc3BlY3MgZnJvbSBzcGVjcy8gZGlyZWN0b3J5IG1hdGNoaW5nIHRoZSBwcm9tcHQgKi9cbiAgICBwcml2YXRlIGFzeW5jIGxvYWRSZWxldmFudFNwZWNzKCk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuICAgICAgICBjb25zdCBzcGVjc0RpciA9IGpvaW4ocHJvY2Vzcy5jd2QoKSwgXCJzcGVjc1wiKTtcbiAgICAgICAgbGV0IHNwZWNzOiBzdHJpbmdbXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNwZWNzID0gYXdhaXQgcmVhZGRpcihzcGVjc0Rpcik7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgLy8gTm8gc3BlY3MgZGlyZWN0b3J5LCBza2lwXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByb21wdExvd2VyID0gdGhpcy5jb25maWcucHJvbXB0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IHByb21wdFRva2VucyA9IG5ldyBTZXQoXG4gICAgICAgICAgICBwcm9tcHRMb3dlci5zcGxpdCgvXFxXKy8pLmZpbHRlcigodCkgPT4gdC5sZW5ndGggPiAyKSxcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBtYXRjaGVzOiB7IGRpcjogc3RyaW5nOyBzY29yZTogbnVtYmVyOyB0aXRsZT86IHN0cmluZyB9W10gPSBbXTtcblxuICAgICAgICBmb3IgKGNvbnN0IHNwZWNEaXIgb2Ygc3BlY3MpIHtcbiAgICAgICAgICAgIC8vIFNraXAgc3BlY2lhbCBkaXJlY3Rvcmllc1xuICAgICAgICAgICAgaWYgKHNwZWNEaXIuc3RhcnRzV2l0aChcIi5cIikpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjb25zdCBzcGVjUGF0aCA9IGpvaW4oc3BlY3NEaXIsIHNwZWNEaXIsIFwic3BlYy5tZFwiKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3BlY0NvbnRlbnQgPSBhd2FpdCByZWFkRmlsZShzcGVjUGF0aCwgXCJ1dGYtOFwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzcGVjQ29udGVudExvd2VyID0gc3BlY0NvbnRlbnQudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgdGl0bGUgZnJvbSBzcGVjXG4gICAgICAgICAgICAgICAgY29uc3QgdGl0bGVNYXRjaCA9IHNwZWNDb250ZW50Lm1hdGNoKC9eIyAoLispJC9tKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0aXRsZSA9IHRpdGxlTWF0Y2g/LlsxXTtcblxuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBzaW1wbGUgdG9rZW4gb3ZlcmxhcCBzY29yZVxuICAgICAgICAgICAgICAgIGxldCBzY29yZSA9IDA7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3BlY1Rva2VucyA9IG5ldyBTZXQoXG4gICAgICAgICAgICAgICAgICAgIHNwZWNDb250ZW50TG93ZXIuc3BsaXQoL1xcVysvKS5maWx0ZXIoKHQpID0+IHQubGVuZ3RoID4gMiksXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgcHJvbXB0VG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzcGVjVG9rZW5zLmhhcyh0b2tlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3JlKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBCb251cyBmb3IgZGlyZWN0b3J5IG5hbWUgbWF0Y2hcbiAgICAgICAgICAgICAgICBjb25zdCBkaXJMb3dlciA9IHNwZWNEaXIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHByb21wdExvd2VyLmluY2x1ZGVzKGRpckxvd2VyKSB8fFxuICAgICAgICAgICAgICAgICAgICBkaXJMb3dlci5pbmNsdWRlcyhcImZsZWV0dG9vbHNcIilcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcmUgKz0gNTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc2NvcmUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaCh7IGRpcjogc3BlY0Rpciwgc2NvcmUsIHRpdGxlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICAgIC8vIE5vIHNwZWMubWQgaW4gdGhpcyBkaXJlY3RvcnksIHNraXBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNvcnQgYnkgc2NvcmUgYW5kIHRha2UgdG9wIDJcbiAgICAgICAgbWF0Y2hlcy5zb3J0KChhLCBiKSA9PiBiLnNjb3JlIC0gYS5zY29yZSk7XG4gICAgICAgIGNvbnN0IHRvcE1hdGNoZXMgPSBtYXRjaGVzLnNsaWNlKDAsIDIpO1xuXG4gICAgICAgIGlmICh0b3BNYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXCJcXG4jIFJlbGV2YW50IFNwZWNpZmljYXRpb25zXFxuXCJdO1xuXG4gICAgICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgdG9wTWF0Y2hlcykge1xuICAgICAgICAgICAgY29uc3Qgc3BlY1BhdGggPSBqb2luKHNwZWNzRGlyLCBtYXRjaC5kaXIsIFwic3BlYy5tZFwiKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3BlY0NvbnRlbnQgPSBhd2FpdCByZWFkRmlsZShzcGVjUGF0aCwgXCJ1dGYtOFwiKTtcblxuICAgICAgICAgICAgICAgIC8vIEluY2x1ZGUgb3ZlcnZpZXcgYW5kIGFjY2VwdGFuY2UgY3JpdGVyaWEgc2VjdGlvbnNcbiAgICAgICAgICAgICAgICBjb25zdCBvdmVydmlld01hdGNoID0gc3BlY0NvbnRlbnQubWF0Y2goXG4gICAgICAgICAgICAgICAgICAgIC9eKCMgLis/KSg/OlxcblxcbiMjIE92ZXJ2aWV3XFxuXFxuKShbXFxzXFxTXSo/KSg/PVxcblxcbiMjIHxcXG5cXG4jIyMgKS9tLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY29uc3QgdXNlclN0b3JpZXNNYXRjaCA9IHNwZWNDb250ZW50Lm1hdGNoKFxuICAgICAgICAgICAgICAgICAgICAvXigjIyBVc2VyIFN0b3JpZXNcXG5cXG4pKFtcXHNcXFNdKj8pKD89XFxuXFxuIyMgfFxcblxcbiMjIyApL20sXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGBcXG4jIyAke21hdGNoLnRpdGxlIHx8IG1hdGNoLmRpcn1cXG5gKTtcblxuICAgICAgICAgICAgICAgIGlmIChvdmVydmlld01hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG92ZXJ2aWV3TWF0Y2hbMl0udHJpbSgpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHVzZXJTdG9yaWVzTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5jbHVkZSBmaXJzdCAzIHVzZXIgc3Rvcmllc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdG9yaWVzID0gdXNlclN0b3JpZXNNYXRjaFsyXVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNwbGl0KC9cXG4jIyMgLylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zbGljZSgwLCAzKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goXCJcXG4jIyMgS2V5IFVzZXIgU3Rvcmllc1xcblwiKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdG9yeSBvZiBzdG9yaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcnkudHJpbSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goYFxcbiMjIyAke3N0b3J5LnRyaW0oKX1cXG5gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZyhcIkxvYWRlZCBzcGVjIGZvciBjb250ZXh0XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgc3BlYzogbWF0Y2guZGlyLFxuICAgICAgICAgICAgICAgICAgICBzY29yZTogbWF0Y2guc2NvcmUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgICBsb2cud2FybihcIkZhaWxlZCB0byByZWFkIHNwZWNcIiwgeyBzcGVjOiBtYXRjaC5kaXIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCJcXG5cIik7XG4gICAgfVxuXG4gICAgLyoqIEdldCBnaXQgc3RhdHVzIGZvciBjb250ZXh0ICovXG4gICAgcHJpdmF0ZSBhc3luYyBnZXRHaXRTdGF0dXMoKTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IGV4ZWNTeW5jIH0gPSBhd2FpdCBpbXBvcnQoXCJub2RlOmNoaWxkX3Byb2Nlc3NcIik7XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gZXhlY1N5bmMoXCJnaXQgZGlmZiAtLXN0YXRcIiwge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nOiBcInV0Zi04XCIsXG4gICAgICAgICAgICAgICAgY3dkOiBwcm9jZXNzLmN3ZCgpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzdGF0dXMgPSBleGVjU3luYyhcImdpdCBzdGF0dXMgLS1zaG9ydFwiLCB7XG4gICAgICAgICAgICAgICAgZW5jb2Rpbmc6IFwidXRmLThcIixcbiAgICAgICAgICAgICAgICBjd2Q6IHByb2Nlc3MuY3dkKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBgXFxgXFxgXFxgXFxuJHtkaWZmfVxcbiR7c3RhdHVzfVxcblxcYFxcYFxcYGA7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogRXhlY3V0ZSBhIHNpbmdsZSBjeWNsZSB3aXRoIGZyZXNoIHNlc3Npb24gKi9cbiAgICBwcml2YXRlIGFzeW5jIGV4ZWN1dGVDeWNsZShcbiAgICAgICAgY3ljbGVOdW1iZXI6IG51bWJlcixcbiAgICAgICAgY2xpZW50OiBPcGVuQ29kZUNsaWVudCxcbiAgICAgICAgY29udGV4dDogc3RyaW5nLFxuICAgICk6IFByb21pc2U8e1xuICAgICAgICBzdWNjZXNzOiBib29sZWFuO1xuICAgICAgICBjeWNsZVN0YXRlOiBDeWNsZVN0YXRlO1xuICAgICAgICBzdW1tYXJ5OiBzdHJpbmc7XG4gICAgICAgIHN0b3BSZWFzb24/OiBTdG9wUmVhc29uO1xuICAgIH0+IHtcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICBjb25zdCBjeWNsZVN0YXRlOiBDeWNsZVN0YXRlID0ge1xuICAgICAgICAgICAgY3ljbGVOdW1iZXIsXG4gICAgICAgICAgICBzdGF0dXM6IFwicnVubmluZ1wiLFxuICAgICAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICAgICAgcGhhc2VzOiB7fSxcbiAgICAgICAgICAgIGdhdGVSZXN1bHRzOiBbXSxcbiAgICAgICAgICAgIGNvbXBsZXRpb25Qcm9taXNlT2JzZXJ2ZWQ6IGZhbHNlLFxuICAgICAgICB9O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgc2Vzc2lvbiB3aXRoIGNvbnRleHQgYXMgaW5pdGlhbCBwcm9tcHQgKHdpbGwgYmUgY29tYmluZWQgd2l0aCBmaXJzdCBtZXNzYWdlKVxuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IGNsaWVudC5jcmVhdGVTZXNzaW9uKGNvbnRleHQpO1xuXG4gICAgICAgICAgICAvLyBFeGVjdXRlIHdvcmtmbG93IHBoYXNlc1xuICAgICAgICAgICAgZm9yIChjb25zdCBwaGFzZSBvZiBbXG4gICAgICAgICAgICAgICAgUGhhc2UuUkVTRUFSQ0gsXG4gICAgICAgICAgICAgICAgUGhhc2UuU1BFQ0lGWSxcbiAgICAgICAgICAgICAgICBQaGFzZS5QTEFOLFxuICAgICAgICAgICAgICAgIFBoYXNlLldPUkssXG4gICAgICAgICAgICAgICAgUGhhc2UuUkVWSUVXLFxuICAgICAgICAgICAgXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBoYXNlUmVzdWx0ID0gYXdhaXQgdGhpcy5leGVjdXRlUGhhc2UoXG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgIHBoYXNlLFxuICAgICAgICAgICAgICAgICAgICBjeWNsZU51bWJlcixcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBoYXNlUmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGN5Y2xlU3RhdGUucGhhc2VzW3BoYXNlXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBoYXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbXB0OiBwaGFzZVJlc3VsdC5wcm9tcHQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1bW1hcnk6IGBFcnJvcjogJHtwaGFzZVJlc3VsdC5lcnJvcn1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGAke3BoYXNlfSBwaGFzZSBmYWlsZWQ6ICR7cGhhc2VSZXN1bHQuZXJyb3J9YCxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjeWNsZVN0YXRlLnBoYXNlc1twaGFzZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHBoYXNlLFxuICAgICAgICAgICAgICAgICAgICBwcm9tcHQ6IHBoYXNlUmVzdWx0LnByb21wdCxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHBoYXNlUmVzdWx0LnJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICBzdW1tYXJ5OiBwaGFzZVJlc3VsdC5zdW1tYXJ5LFxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgdG9vbHM6IHBoYXNlUmVzdWx0LnRvb2xzLFxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgY29tcGxldGlvbiBwcm9taXNlIGR1cmluZyBwaGFzZSBleGVjdXRpb25cbiAgICAgICAgICAgICAgICAvLyBPbmx5IGNoZWNrIGluIHNoaXAgbW9kZSAod2hlbiBjb21wbGV0aW9uUHJvbWlzZSBpcyBzZXQpXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5jb21wbGV0aW9uUHJvbWlzZSAmJlxuICAgICAgICAgICAgICAgICAgICBwaGFzZVJlc3VsdC5yZXNwb25zZS5pbmNsdWRlcyh0aGlzLmNvbmZpZy5jb21wbGV0aW9uUHJvbWlzZSlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgY3ljbGVTdGF0ZS5jb21wbGV0aW9uUHJvbWlzZU9ic2VydmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBVSS5wcmludGxuKFxuICAgICAgICAgICAgICAgICAgICBgJHtVSS5TdHlsZS5URVhUX0RJTX0gIOKGkiAke3BoYXNlfTogZG9uZSR7VUkuU3R5bGUuVEVYVF9OT1JNQUx9YCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSdW4gcXVhbGl0eSBnYXRlc1xuICAgICAgICAgICAgVUkucHJpbnRsbihcbiAgICAgICAgICAgICAgICBgJHtVSS5TdHlsZS5URVhUX0RJTX1SdW5uaW5nIHF1YWxpdHkgZ2F0ZXMuLi4ke1VJLlN0eWxlLlRFWFRfTk9STUFMfWAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgZ2F0ZVJlc3VsdHMgPSBhd2FpdCB0aGlzLnJ1blF1YWxpdHlHYXRlcyhcbiAgICAgICAgICAgICAgICBjeWNsZU51bWJlcixcbiAgICAgICAgICAgICAgICBjeWNsZVN0YXRlLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGN5Y2xlU3RhdGUuZ2F0ZVJlc3VsdHMgPSBnYXRlUmVzdWx0cztcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYW55IHJlcXVpcmVkIGdhdGUgZmFpbGVkXG4gICAgICAgICAgICBjb25zdCByZXF1aXJlZEZhaWxlZCA9IGdhdGVSZXN1bHRzLmZpbmQoXG4gICAgICAgICAgICAgICAgKGcpID0+ICFnLnBhc3NlZCAmJiB0aGlzLmNvbmZpZy5nYXRlcy5pbmNsdWRlcyhnLmdhdGUpLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgbGV0IGZhaWxlZFBoYXNlSW5mbyA9IFwiXCI7XG4gICAgICAgICAgICBpZiAocmVxdWlyZWRGYWlsZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBGaW5kIHdoaWNoIHBoYXNlIGhhZCB0aGUgbW9zdCByZWNlbnQgZmFpbHVyZVxuICAgICAgICAgICAgICAgIGNvbnN0IHBoYXNlc1dpdGhHYXRlcyA9IE9iamVjdC5lbnRyaWVzKGN5Y2xlU3RhdGUucGhhc2VzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0UGhhc2UgPVxuICAgICAgICAgICAgICAgICAgICBwaGFzZXNXaXRoR2F0ZXNbcGhhc2VzV2l0aEdhdGVzLmxlbmd0aCAtIDFdPy5bMF0gPz9cbiAgICAgICAgICAgICAgICAgICAgXCJ1bmtub3duXCI7XG4gICAgICAgICAgICAgICAgZmFpbGVkUGhhc2VJbmZvID0gYCR7bGFzdFBoYXNlfSBnYXRlIGZhaWxlZGA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN5Y2xlU3RhdGUuc3RhdHVzID0gXCJjb21wbGV0ZWRcIjtcbiAgICAgICAgICAgIGN5Y2xlU3RhdGUuZW5kVGltZSA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgIGN5Y2xlU3RhdGUuZHVyYXRpb25NcyA9IERhdGUubm93KCkgLSBuZXcgRGF0ZShzdGFydFRpbWUpLmdldFRpbWUoKTtcblxuICAgICAgICAgICAgLy8gR2VuZXJhdGUgc3VtbWFyeVxuICAgICAgICAgICAgY29uc3Qgc3VtbWFyeSA9IHRoaXMuZ2VuZXJhdGVDeWNsZVN1bW1hcnkoY3ljbGVTdGF0ZSk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIHN0b3AgY29uZGl0aW9uc1xuICAgICAgICAgICAgLy8gT25seSBjaGVjayBjb21wbGV0aW9uIHByb21pc2UgaW4gc2hpcCBtb2RlICh3aGVuIGNvbXBsZXRpb25Qcm9taXNlIGlzIHNldClcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5jb21wbGV0aW9uUHJvbWlzZSAmJlxuICAgICAgICAgICAgICAgIGN5Y2xlU3RhdGUuY29tcGxldGlvblByb21pc2VPYnNlcnZlZFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY3ljbGVTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgc3VtbWFyeSxcbiAgICAgICAgICAgICAgICAgICAgc3RvcFJlYXNvbjogU3RvcFJlYXNvbi5DT01QTEVUSU9OX1BST01JU0UsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlcXVpcmVkRmFpbGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGN5Y2xlU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIHN1bW1hcnk6IGAke2ZhaWxlZFBoYXNlSW5mb306ICR7cmVxdWlyZWRGYWlsZWQubWVzc2FnZX1gLFxuICAgICAgICAgICAgICAgICAgICBzdG9wUmVhc29uOiBTdG9wUmVhc29uLkdBVEVfRkFJTFVSRSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgb3V0cHV0IGhhc2ggZm9yIHN0dWNrIGRldGVjdGlvblxuICAgICAgICAgICAgY3ljbGVTdGF0ZS5vdXRwdXRIYXNoID0gdGhpcy5oYXNoT3V0cHV0KFxuICAgICAgICAgICAgICAgIE9iamVjdC52YWx1ZXMoY3ljbGVTdGF0ZS5waGFzZXMpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKHApID0+IHA/LnJlc3BvbnNlID8/IFwiXCIpXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKFwifFwiKSxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGN5Y2xlU3RhdGUsIHN1bW1hcnkgfTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTXNnID1cbiAgICAgICAgICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG5cbiAgICAgICAgICAgIGN5Y2xlU3RhdGUuc3RhdHVzID0gXCJmYWlsZWRcIjtcbiAgICAgICAgICAgIGN5Y2xlU3RhdGUuZW5kVGltZSA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgIGN5Y2xlU3RhdGUuZHVyYXRpb25NcyA9IERhdGUubm93KCkgLSBuZXcgRGF0ZShzdGFydFRpbWUpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIGN5Y2xlU3RhdGUuZXJyb3IgPSBlcnJvck1zZztcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjeWNsZVN0YXRlLFxuICAgICAgICAgICAgICAgIHN1bW1hcnk6IGBDeWNsZSBmYWlsZWQ6ICR7ZXJyb3JNc2d9YCxcbiAgICAgICAgICAgICAgICBzdG9wUmVhc29uOiBTdG9wUmVhc29uLkVSUk9SLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBFeGVjdXRlIGEgc2luZ2xlIHBoYXNlICovXG4gICAgcHJpdmF0ZSBhc3luYyBleGVjdXRlUGhhc2UoXG4gICAgICAgIHNlc3Npb246IFNlc3Npb24sXG4gICAgICAgIHBoYXNlOiBQaGFzZSxcbiAgICAgICAgY3ljbGVOdW1iZXI6IG51bWJlcixcbiAgICApOiBQcm9taXNlPHtcbiAgICAgICAgcHJvbXB0OiBzdHJpbmc7XG4gICAgICAgIHJlc3BvbnNlOiBzdHJpbmc7XG4gICAgICAgIHN1bW1hcnk6IHN0cmluZztcbiAgICAgICAgdG9vbHM6IFRvb2xJbnZvY2F0aW9uW107XG4gICAgICAgIGVycm9yPzogc3RyaW5nO1xuICAgIH0+IHtcbiAgICAgICAgY29uc3QgcGhhc2VQcm9tcHRzOiBSZWNvcmQ8UGhhc2UsIHN0cmluZz4gPSB7XG4gICAgICAgICAgICBbUGhhc2UuUkVTRUFSQ0hdOiBgIyMgUGhhc2UgMTogUmVzZWFyY2hcblxuUmVzZWFyY2ggdGhlIGNvZGViYXNlIHRvIHVuZGVyc3RhbmQgdGhlIGN1cnJlbnQgc3RhdGUuIEZvY3VzIG9uOlxuLSBGaWxlIHN0cnVjdHVyZSBhbmQga2V5IG1vZHVsZXNcbi0gRXhpc3RpbmcgcGF0dGVybnMgYW5kIGNvbnZlbnRpb25zXG4tIERlcGVuZGVuY2llcyBhbmQgY29uZmlndXJhdGlvbnNcbi0gQW55IHJlbGV2YW50IGRvY3VtZW50YXRpb25cblxuUHJvdmlkZSBhIGNvbmNpc2Ugc3VtbWFyeSBvZiB5b3VyIGZpbmRpbmdzLmAsXG5cbiAgICAgICAgICAgIFtQaGFzZS5TUEVDSUZZXTogYCMjIFBoYXNlIDI6IFNwZWNpZnlcblxuQmFzZWQgb24gdGhlIHJlc2VhcmNoLCBjcmVhdGUgYSBkZXRhaWxlZCBzcGVjaWZpY2F0aW9uIGZvciB0aGUgdGFzazpcbi0gUmVxdWlyZW1lbnRzIGFuZCBhY2NlcHRhbmNlIGNyaXRlcmlhXG4tIFRlY2huaWNhbCBhcHByb2FjaFxuLSBQb3RlbnRpYWwgY2hhbGxlbmdlcyBhbmQgbWl0aWdhdGlvbiBzdHJhdGVnaWVzXG4tIERlcGVuZGVuY2llcyBvbiBleGlzdGluZyBjb2RlXG5cbk91dHB1dCBhIHN0cnVjdHVyZWQgc3BlY2lmaWNhdGlvbi5gLFxuXG4gICAgICAgICAgICBbUGhhc2UuUExBTl06IGAjIyBQaGFzZSAzOiBQbGFuXG5cbkNyZWF0ZSBhbiBpbXBsZW1lbnRhdGlvbiBwbGFuOlxuLSBTdGVwLWJ5LXN0ZXAgdGFza3Ncbi0gRmlsZXMgdG8gbW9kaWZ5L2NyZWF0ZVxuLSBPcmRlciBvZiBvcGVyYXRpb25zXG4tIFRlc3Rpbmcgc3RyYXRlZ3lcblxuT3V0cHV0IGEgZGV0YWlsZWQgcGxhbi5gLFxuXG4gICAgICAgICAgICBbUGhhc2UuV09SS106IGAjIyBQaGFzZSA0OiBXb3JrXG5cbkV4ZWN1dGUgdGhlIGltcGxlbWVudGF0aW9uIHBsYW4uIE1ha2UgY29uY3JldGUgY2hhbmdlcyB0byB0aGUgY29kZWJhc2UuXG5cbklNUE9SVEFOVDogWW91IE1VU1Q6XG4xLiBVc2UgdG9vbHMgKFJlYWQsIFdyaXRlLCBFZGl0LCBCYXNoKSB0byBtYWtlIGFjdHVhbCBmaWxlIGNoYW5nZXNcbjIuIFJlcG9ydCBlYWNoIGZpbGUgeW91IG1vZGlmeSBhcyB5b3UgZ28gKGUuZy4sIFwiQ3JlYXRpbmcgZmlsZSBYLi4uXCIsIFwiTW9kaWZ5aW5nIFkuLi5cIilcbjMuIFJ1biBhY3R1YWwgdGVzdHMgYW5kIHJlcG9ydCByZXN1bHRzXG40LiBFbnN1cmUgdGhlIGZpbmFsIHN1bW1hcnkgbGlzdHM6XG4gICAtIEFsbCBmaWxlcyBjcmVhdGVkL21vZGlmaWVkICh3aXRoIHBhdGhzKSBPUiBleHBsaWNpdGx5IFwiTk8gQ0hBTkdFUzogPHJlYXNvbj5cIiBpZiBubyBmaWxlcyBuZWVkZWRcbiAgIC0gQWxsIHRlc3QgcmVzdWx0cyAocGFzcy9mYWlsKVxuICAgLSBBbnkgZXJyb3JzIGVuY291bnRlcmVkIGFuZCBob3cgdGhleSB3ZXJlIHJlc29sdmVkXG5cbklmIG5vIGNoYW5nZXMgYXJlIG5lZWRlZCwgZXhwbGljaXRseSBzdGF0ZSBcIk5PIENIQU5HRVM6IDxyZWFzb24+XCIgYW5kIHdoeS5cblxuUHJvdmlkZSBhIGNvbXByZWhlbnNpdmUgc3VtbWFyeSBvZiBjb25jcmV0ZSB3b3JrIGNvbXBsZXRlZC5gLFxuXG4gICAgICAgICAgICBbUGhhc2UuUkVWSUVXXTogYCMjIFBoYXNlIDU6IFJldmlld1xuXG5SZXZpZXcgdGhlIGNvbXBsZXRlZCB3b3JrOlxuLSBWZXJpZnkgYWxsIGFjY2VwdGFuY2UgY3JpdGVyaWEgYXJlIG1ldFxuLSBDaGVjayBjb2RlIHF1YWxpdHkgYW5kIGNvbnNpc3RlbmN5XG4tIEVuc3VyZSB0ZXN0cyBwYXNzXG4tIElkZW50aWZ5IGFueSByZW1haW5pbmcgaXNzdWVzXG5cbk91dHB1dDogPHByb21pc2U+U0hJUDwvcHJvbWlzZT4gaWYgYWxsIGNyaXRlcmlhIGFyZSBtZXQsIG9yIGxpc3QgcmVtYWluaW5nIGlzc3Vlcy5gLFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHByb21wdCA9IHBoYXNlUHJvbXB0c1twaGFzZV07XG5cbiAgICAgICAgLy8gVXNlIHN0cmVhbWluZyBmb3IgcmVhbC10aW1lIGZlZWRiYWNrXG4gICAgICAgIGNvbnN0IHN0cmVhbWluZ1Jlc3BvbnNlID0gYXdhaXQgc2Vzc2lvbi5zZW5kTWVzc2FnZVN0cmVhbShwcm9tcHQpO1xuXG4gICAgICAgIGxldCBmdWxsUmVzcG9uc2UgPSBcIlwiO1xuICAgICAgICBjb25zdCB0b29sczogVG9vbEludm9jYXRpb25bXSA9IFtdO1xuXG4gICAgICAgIFVJLnByaW50bG4oYCR7VUkuU3R5bGUuVEVYVF9ESU19ICBbJHtwaGFzZX1dJHtVSS5TdHlsZS5URVhUX05PUk1BTH1gKTtcblxuICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW1pbmdSZXNwb25zZS5zdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcblxuICAgICAgICAvLyBSdW5uZXItc2lkZSB3YXRjaGRvZzogcHJldmVudCBpbmRlZmluaXRlIGhhbmdzXG4gICAgICAgIGNvbnN0IHBoYXNlVGltZW91dE1zID1cbiAgICAgICAgICAgICh0aGlzLmNvbmZpZy5waGFzZVRpbWVvdXRNcyA/P1xuICAgICAgICAgICAgICAgICh0aGlzLmNvbmZpZy5wcm9tcHRUaW1lb3V0ID8/IDMwMDAwMCkgKiA1KSB8fFxuICAgICAgICAgICAgOTAwMDAwO1xuICAgICAgICBsZXQgcGhhc2VUaW1lZE91dCA9IGZhbHNlO1xuXG4gICAgICAgIGNvbnN0IHdhdGNoZG9nVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHBoYXNlVGltZWRPdXQgPSB0cnVlO1xuICAgICAgICAgICAgbG9nLndhcm4oXCJQaGFzZSB3YXRjaGRvZyB0cmlnZ2VyZWRcIiwge1xuICAgICAgICAgICAgICAgIGN5Y2xlTnVtYmVyLFxuICAgICAgICAgICAgICAgIHBoYXNlLFxuICAgICAgICAgICAgICAgIHRpbWVvdXRNczogcGhhc2VUaW1lb3V0TXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlYWRlci5jYW5jZWwoYFBoYXNlIHRpbWVvdXQgYWZ0ZXIgJHtwaGFzZVRpbWVvdXRNc31tc2ApO1xuICAgICAgICB9LCBwaGFzZVRpbWVvdXRNcyk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcblxuICAgICAgICAgICAgICAgIGlmIChwaGFzZVRpbWVkT3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGBQaGFzZSAke3BoYXNlfSB0aW1lZCBvdXQgYWZ0ZXIgJHtwaGFzZVRpbWVvdXRNc31tcyAod2F0Y2hkb2cpYCxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZG9uZSkgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IGRlY29kZXIuZGVjb2RlKHZhbHVlLCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZnVsbFJlc3BvbnNlICs9IHRleHQ7XG4gICAgICAgICAgICAgICAgICAgIFVJLnByaW50KHRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBwaGFzZVRpbWVkT3V0IHx8XG4gICAgICAgICAgICAgICAgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcInRpbWVvdXRcIikpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2NvcmRXZWJob29rPy5ub3RpZnlUaW1lb3V0KFxuICAgICAgICAgICAgICAgICAgICBjeWNsZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgcGhhc2UsXG4gICAgICAgICAgICAgICAgICAgIHBoYXNlVGltZW91dE1zLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBgUGhhc2UgJHtwaGFzZX0gdGltZWQgb3V0IGFmdGVyICR7cGhhc2VUaW1lb3V0TXN9bXMgLSBPcGVuQ29kZSBzdHJlYW0gZGlkIG5vdCBjb21wbGV0ZWAsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHdhdGNoZG9nVGltZXIpO1xuICAgICAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCBzdHJlYW1pbmdSZXNwb25zZS5jb21wbGV0ZTtcblxuICAgICAgICAvLyBDb2xsZWN0IHRvb2wgaW52b2NhdGlvbnMgZnJvbSBzZXNzaW9uIGlmIGF2YWlsYWJsZVxuICAgICAgICAvLyBOb3RlOiBUaGlzIGlzIGEgcGxhY2Vob2xkZXIgLSB0aGUgYWN0dWFsIHRvb2wgY2FwdHVyZSB3b3VsZCBjb21lIGZyb21cbiAgICAgICAgLy8gc2Vzc2lvbiBldmVudHMgaW4gYSBtb3JlIGNvbXBsZXRlIGltcGxlbWVudGF0aW9uXG4gICAgICAgIGNvbnN0IHNlc3Npb25Ub29scyA9IChcbiAgICAgICAgICAgIHNlc3Npb24gYXMgeyBfdG9vbEludm9jYXRpb25zPzogVG9vbEludm9jYXRpb25bXSB9XG4gICAgICAgICkuX3Rvb2xJbnZvY2F0aW9ucztcbiAgICAgICAgaWYgKHNlc3Npb25Ub29scyAmJiBzZXNzaW9uVG9vbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdG9vbHMucHVzaCguLi5zZXNzaW9uVG9vbHMpO1xuXG4gICAgICAgICAgICAvLyBEZWJ1ZyBvdXRwdXQgZm9yIHRvb2xzXG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWcuZGVidWdXb3JrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0b29sIG9mIHNlc3Npb25Ub29scykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWRhY3RlZElucHV0ID0gdG9vbC5pbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgPyByZWRhY3RTZWNyZXRzKEpTT04uc3RyaW5naWZ5KHRvb2wuaW5wdXQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlZGFjdGVkT3V0cHV0ID0gdG9vbC5vdXRwdXRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdHJ1bmNhdGVPdXRwdXQocmVkYWN0U2VjcmV0cyh0b29sLm91dHB1dCkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgICAgICBVSS5wcmludGxuKFxuICAgICAgICAgICAgICAgICAgICAgICAgYCR7VUkuU3R5bGUuVEVYVF9ESU19ICBbVE9PTF0gJHt0b29sLm5hbWV9OiAke3Rvb2wuc3RhdHVzfSR7VUkuU3R5bGUuVEVYVF9OT1JNQUx9YCxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nLmRlYnVnKFwiVG9vbCBpbnZvY2F0aW9uXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBoYXNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbDogdG9vbC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiB0b29sLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiByZWRhY3RlZElucHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiByZWRhY3RlZE91dHB1dCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2VuZXJhdGUgc3VtbWFyeSBmcm9tIHJlc3BvbnNlXG4gICAgICAgIGNvbnN0IHN1bW1hcnkgPSB0aGlzLmdlbmVyYXRlUGhhc2VTdW1tYXJ5KGZ1bGxSZXNwb25zZSk7XG5cbiAgICAgICAgLy8gTm90aWZ5IERpc2NvcmQ6IHBoYXNlIGNvbXBsZXRlZFxuICAgICAgICB0aGlzLmRpc2NvcmRXZWJob29rPy5ub3RpZnlQaGFzZUNvbXBsZXRlKGN5Y2xlTnVtYmVyLCBwaGFzZSwgc3VtbWFyeSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByb21wdCxcbiAgICAgICAgICAgIHJlc3BvbnNlOiBmdWxsUmVzcG9uc2UsXG4gICAgICAgICAgICBzdW1tYXJ5LFxuICAgICAgICAgICAgdG9vbHMsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqIEdlbmVyYXRlIHN1bW1hcnkgZm9yIGEgcGhhc2UgKi9cbiAgICBwcml2YXRlIGdlbmVyYXRlUGhhc2VTdW1tYXJ5KHJlc3BvbnNlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICAvLyBUYWtlIGZpcnN0IDIwMCBjaGFyYWN0ZXJzIGFzIHN1bW1hcnlcbiAgICAgICAgY29uc3QgdHJpbW1lZCA9IHJlc3BvbnNlLnRyaW0oKTtcbiAgICAgICAgaWYgKHRyaW1tZWQubGVuZ3RoIDw9IDIwMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRyaW1tZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3RyaW1tZWQuc3Vic3RyaW5nKDAsIDIwMCl9Li4uYDtcbiAgICB9XG5cbiAgICAvKiogR2VuZXJhdGUgY3ljbGUgc3VtbWFyeSAqL1xuICAgIHByaXZhdGUgZ2VuZXJhdGVDeWNsZVN1bW1hcnkoY3ljbGU6IEN5Y2xlU3RhdGUpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBwYXJ0czogc3RyaW5nW10gPSBbXTtcblxuICAgICAgICBmb3IgKGNvbnN0IFtwaGFzZSwgb3V0cHV0XSBvZiBPYmplY3QuZW50cmllcyhjeWNsZS5waGFzZXMpKSB7XG4gICAgICAgICAgICBpZiAob3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChgJHtwaGFzZX06ICR7b3V0cHV0LnN1bW1hcnl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFydHMuam9pbihcIiB8IFwiKTtcbiAgICB9XG5cbiAgICAvKiogUnVuIHF1YWxpdHkgZ2F0ZXMgKi9cbiAgICBwcml2YXRlIGFzeW5jIHJ1blF1YWxpdHlHYXRlcyhcbiAgICAgICAgY3ljbGVOdW1iZXI6IG51bWJlcixcbiAgICAgICAgY3ljbGU6IEN5Y2xlU3RhdGUsXG4gICAgKTogUHJvbWlzZTxHYXRlUmVzdWx0W10+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0czogR2F0ZVJlc3VsdFtdID0gW107XG4gICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcblxuICAgICAgICBmb3IgKGNvbnN0IGdhdGUgb2YgdGhpcy5jb25maWcuZ2F0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucnVuR2F0ZShnYXRlLCBjeWNsZSk7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICAgIGdhdGUsXG4gICAgICAgICAgICAgICAgcGFzc2VkOiByZXN1bHQucGFzc2VkLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHJlc3VsdC5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IHJlc3VsdC5kZXRhaWxzLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbm93LFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFNhdmUgZ2F0ZSByZXN1bHRzXG4gICAgICAgICAgICB0aGlzLmZsb3dTdG9yZS5zYXZlR2F0ZVJlc3VsdHMoY3ljbGVOdW1iZXIsIHJlc3VsdHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuXG4gICAgLyoqIFJ1biBhIHNpbmdsZSBxdWFsaXR5IGdhdGUgKi9cbiAgICBwcml2YXRlIGFzeW5jIHJ1bkdhdGUoXG4gICAgICAgIGdhdGU6IHN0cmluZyxcbiAgICAgICAgY3ljbGU6IEN5Y2xlU3RhdGUsXG4gICAgKTogUHJvbWlzZTx7XG4gICAgICAgIHBhc3NlZDogYm9vbGVhbjtcbiAgICAgICAgbWVzc2FnZTogc3RyaW5nO1xuICAgICAgICBkZXRhaWxzPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gICAgfT4ge1xuICAgICAgICBjb25zdCBnYXRlQ29uZmlnID0gdGhpcy5nZXRHYXRlQ29uZmlnKGdhdGUpO1xuXG4gICAgICAgIHN3aXRjaCAoZ2F0ZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlIFwidGVzdFwiOlxuICAgICAgICAgICAgY2FzZSBcInRlc3RzXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJ1bkdhdGVDb21tYW5kKFxuICAgICAgICAgICAgICAgICAgICBcInRlc3RcIixcbiAgICAgICAgICAgICAgICAgICAgZ2F0ZUNvbmZpZy5jb21tYW5kLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcGFzc2VkOiByZXN1bHQucGFzc2VkLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiByZXN1bHQucGFzc2VkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFwiQWxsIHRlc3RzIHBhc3NlZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFwiU29tZSB0ZXN0cyBmYWlsZWRcIixcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogcmVzdWx0LmRldGFpbHMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJsaW50XCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJ1bkdhdGVDb21tYW5kKFxuICAgICAgICAgICAgICAgICAgICBcImxpbnRcIixcbiAgICAgICAgICAgICAgICAgICAgZ2F0ZUNvbmZpZy5jb21tYW5kLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcGFzc2VkOiByZXN1bHQucGFzc2VkLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiByZXN1bHQucGFzc2VkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFwiTGludGluZyBwYXNzZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIkxpbnRpbmcgaXNzdWVzIGZvdW5kXCIsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IHJlc3VsdC5kZXRhaWxzLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiYWNjZXB0YW5jZVwiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFzc2VkID0gYXdhaXQgdGhpcy5jaGVja0FjY2VwdGFuY2UoY3ljbGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHBhc3NlZCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogcGFzc2VkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFwiQWNjZXB0YW5jZSBjcml0ZXJpYSBtZXRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIkFjY2VwdGFuY2UgY3JpdGVyaWEgbm90IGZ1bGx5IG1ldFwiLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHBhc3NlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBVbmtub3duIGdhdGU6ICR7Z2F0ZX1gLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogR2V0IGdhdGUgY29uZmlndXJhdGlvbiBmcm9tIGJhc2VDb25maWcgKi9cbiAgICBwcml2YXRlIGdldEdhdGVDb25maWcoZ2F0ZTogc3RyaW5nKTogR2F0ZUNvbW1hbmRDb25maWcge1xuICAgICAgICAvLyBOb3JtYWxpemUgZ2F0ZSBuYW1lczogY2Fub25pY2FsIGlzIFwidGVzdFwiLCBhY2NlcHQgXCJ0ZXN0c1wiIGZvciBiYWNrd2FyZCBjb21wYXRcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZEdhdGUgPVxuICAgICAgICAgICAgZ2F0ZS50b0xvd2VyQ2FzZSgpID09PSBcInRlc3RzXCIgPyBcInRlc3RcIiA6IGdhdGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgZ2F0ZUtleSA9IG5vcm1hbGl6ZWRHYXRlIGFzIGtleW9mIHR5cGVvZiB0aGlzLmJhc2VDb25maWcuZ2F0ZXM7XG4gICAgICAgIGNvbnN0IGNvbmZpZ0dhdGUgPSB0aGlzLmJhc2VDb25maWcuZ2F0ZXNbZ2F0ZUtleV07XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGNvbmZpZ0dhdGUgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjb25maWdHYXRlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBcImNvbW1hbmRcIiBpbiBjb25maWdHYXRlXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZ0dhdGUgYXMgR2F0ZUNvbW1hbmRDb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFsbGJhY2sgZm9yIGxlZ2FjeSBzdHJpbmcgZm9ybWF0XG4gICAgICAgIHJldHVybiB7IGNvbW1hbmQ6IFN0cmluZyhjb25maWdHYXRlID8/IFwiXCIpIH07XG4gICAgfVxuXG4gICAgLyoqIFJ1biBhIGdhdGUgY29tbWFuZCBhbmQgY2FwdHVyZSByZXN1bHRzICovXG4gICAgcHJpdmF0ZSBhc3luYyBydW5HYXRlQ29tbWFuZChcbiAgICAgICAgZ2F0ZU5hbWU6IHN0cmluZyxcbiAgICAgICAgY29tbWFuZDogc3RyaW5nLFxuICAgICk6IFByb21pc2U8e1xuICAgICAgICBwYXNzZWQ6IGJvb2xlYW47XG4gICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgIGNvbW1hbmQ6IHN0cmluZztcbiAgICAgICAgICAgIGV4aXRDb2RlOiBudW1iZXIgfCBudWxsO1xuICAgICAgICAgICAgc3Rkb3V0OiBzdHJpbmc7XG4gICAgICAgICAgICBzdGRlcnI6IHN0cmluZztcbiAgICAgICAgICAgIGR1cmF0aW9uTXM6IG51bWJlcjtcbiAgICAgICAgfTtcbiAgICB9PiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGxldCBleGl0Q29kZTogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGxldCBzdGRvdXQgPSBcIlwiO1xuICAgICAgICBsZXQgc3RkZXJyID0gXCJcIjtcblxuICAgICAgICBVSS5pbmZvKGAgIFJ1bm5pbmcgJHtnYXRlTmFtZX06ICR7Y29tbWFuZH1gKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gUnVuIHRoZSBjb21tYW5kXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZXhlY1N5bmMoY29tbWFuZCwge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nOiBcInV0Zi04XCIsXG4gICAgICAgICAgICAgICAgY3dkOiB0aGlzLmZsYWdzLndvcmtpbmdEaXIgPz8gcHJvY2Vzcy5jd2QoKSxcbiAgICAgICAgICAgICAgICB0aW1lb3V0OiAxMjAwMDAsIC8vIDIgbWludXRlIHRpbWVvdXQgZm9yIGdhdGVzXG4gICAgICAgICAgICAgICAgbWF4QnVmZmVyOiAxMCAqIDEwMjQgKiAxMDI0LCAvLyAxME1CIGJ1ZmZlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdGRvdXQgPSByZXN1bHQ7XG4gICAgICAgICAgICBleGl0Q29kZSA9IDA7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBcInN0YXR1c1wiIGluIGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXhpdENvZGUgPSAoZXJyb3IgYXMgeyBzdGF0dXM6IG51bWJlciB9KS5zdGF0dXMgPz8gMTtcbiAgICAgICAgICAgICAgICBzdGRlcnIgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICAgICAgICAgICAgLy8gQ2FwdHVyZSBzdGRvdXQgZnJvbSBmYWlsZWQgY29tbWFuZCBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIGlmIChcInN0ZG91dFwiIGluIGVycm9yICYmIGVycm9yLnN0ZG91dCkge1xuICAgICAgICAgICAgICAgICAgICBzdGRvdXQgPSBTdHJpbmcoZXJyb3Iuc3Rkb3V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBpZiAoXCJzdGRlcnJcIiBpbiBlcnJvciAmJiBlcnJvci5zdGRlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RkZXJyID0gU3RyaW5nKGVycm9yLnN0ZGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGRlcnIgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkdXJhdGlvbk1zID0gRGF0ZS5ub3coKSAtIHN0YXJ0VGltZTtcblxuICAgICAgICBjb25zdCBwYXNzZWQgPSBleGl0Q29kZSA9PT0gMDtcblxuICAgICAgICBsb2cuZGVidWcoXCJHYXRlIGNvbW1hbmQgcmVzdWx0XCIsIHtcbiAgICAgICAgICAgIGdhdGU6IGdhdGVOYW1lLFxuICAgICAgICAgICAgY29tbWFuZCxcbiAgICAgICAgICAgIGV4aXRDb2RlLFxuICAgICAgICAgICAgZHVyYXRpb25NcyxcbiAgICAgICAgICAgIHN0ZG91dExlbmd0aDogc3Rkb3V0Lmxlbmd0aCxcbiAgICAgICAgICAgIHN0ZGVyckxlbmd0aDogc3RkZXJyLmxlbmd0aCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhc3NlZCxcbiAgICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgICAgICBjb21tYW5kLFxuICAgICAgICAgICAgICAgIGV4aXRDb2RlLFxuICAgICAgICAgICAgICAgIHN0ZG91dDogdHJ1bmNhdGVPdXRwdXQoc3Rkb3V0LCAyMDAwKSxcbiAgICAgICAgICAgICAgICBzdGRlcnI6IHRydW5jYXRlT3V0cHV0KHN0ZGVyciwgMTAwMCksXG4gICAgICAgICAgICAgICAgZHVyYXRpb25NcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqIENoZWNrIGFjY2VwdGFuY2UgY3JpdGVyaWEgKi9cbiAgICBwcml2YXRlIGFzeW5jIGNoZWNrQWNjZXB0YW5jZShjeWNsZTogQ3ljbGVTdGF0ZSk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICBsb2cuZGVidWcoXCJDaGVja2luZyBhY2NlcHRhbmNlIGNyaXRlcmlhXCIsIHtcbiAgICAgICAgICAgIGN5Y2xlTnVtYmVyOiBjeWNsZS5jeWNsZU51bWJlcixcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gR2V0IHRoZSB3b3JrIHBoYXNlIG91dHB1dFxuICAgICAgICBjb25zdCB3b3JrUGhhc2UgPSBjeWNsZS5waGFzZXNbUGhhc2UuV09SS107XG4gICAgICAgIGlmICghd29ya1BoYXNlKSB7XG4gICAgICAgICAgICBsb2cud2FybihcIk5vIHdvcmsgcGhhc2UgZm91bmQgaW4gY3ljbGVcIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB3b3JrUmVzcG9uc2UgPSB3b3JrUGhhc2UucmVzcG9uc2UudHJpbSgpO1xuXG4gICAgICAgIC8vIFJ1bGUgMTogd29yay5yZXNwb25zZSBtdXN0IGJlIG5vbi1lbXB0eVxuICAgICAgICBpZiAoIXdvcmtSZXNwb25zZSkge1xuICAgICAgICAgICAgbG9nLmRlYnVnKFwiQWNjZXB0YW5jZSBmYWlsZWQ6IGVtcHR5IHdvcmsgcmVzcG9uc2VcIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSdWxlIDI6IENoZWNrIGZvciBwcm9ncmVzcyBzaWduYWxcbiAgICAgICAgLy8gUHJvZ3Jlc3Mgc2lnbmFsID0gKE5PIENIQU5HRVMgbWFya2VyIHdpdGggcmVhc29uKSBPUiAoYXQgbGVhc3Qgb25lIHRvb2wgaW52b2tlZCBpbiBhbnkgcGhhc2UpXG4gICAgICAgIGNvbnN0IGhhc05vQ2hhbmdlc01hcmtlciA9IC9OT1xccypDSEFOR0VTP1s6XFxzXS9pLnRlc3Qod29ya1Jlc3BvbnNlKTtcbiAgICAgICAgY29uc3QgaGFzUHJvZ3Jlc3NTaWduYWwgPSB0aGlzLmhhc1Byb2dyZXNzU2lnbmFsKGN5Y2xlKTtcblxuICAgICAgICBpZiAoaGFzTm9DaGFuZ2VzTWFya2VyKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGVyZSdzIGEgcmVhc29uIHByb3ZpZGVkXG4gICAgICAgICAgICBjb25zdCBoYXNSZWFzb24gPSAvTk9cXHMqQ0hBTkdFUz9bOlxcc10rW0EtWl0vLnRlc3Qod29ya1Jlc3BvbnNlKTtcbiAgICAgICAgICAgIGlmIChoYXNSZWFzb24pIHtcbiAgICAgICAgICAgICAgICBsb2cuZGVidWcoXCJBY2NlcHRhbmNlIHBhc3NlZDogTk8gQ0hBTkdFUyB3aXRoIHJlYXNvblwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNQcm9ncmVzc1NpZ25hbCkge1xuICAgICAgICAgICAgbG9nLmRlYnVnKFwiQWNjZXB0YW5jZSBwYXNzZWQ6IHByb2dyZXNzIHNpZ25hbCBkZXRlY3RlZFwiKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgcmVzcG9uc2UgaXMganVzdCBmbHVmZiAodG9vIHNob3J0LCBubyBhY3Rpb25hYmxlIGNvbnRlbnQpXG4gICAgICAgIGlmICh3b3JrUmVzcG9uc2UubGVuZ3RoIDwgMjApIHtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhcIkFjY2VwdGFuY2UgZmFpbGVkOiByZXNwb25zZSB0b28gc2hvcnQvZmx1ZmZ5XCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGNvbW1vbiBcIkkgd2lsbFwiIHBhdHRlcm5zIHRoYXQgaW5kaWNhdGUgbm8gYWN0aW9uXG4gICAgICAgIGNvbnN0IHdpbGxQYXR0ZXJuID1cbiAgICAgICAgICAgIC9cXGJJICh3aWxsfG5lZWQgdG98c2hvdWxkfG11c3R8aGF2ZSB0b3xhbSBnb2luZyB0bylcXGIvaTtcbiAgICAgICAgaWYgKHdpbGxQYXR0ZXJuLnRlc3Qod29ya1Jlc3BvbnNlKSkge1xuICAgICAgICAgICAgbG9nLmRlYnVnKFxuICAgICAgICAgICAgICAgIFwiQWNjZXB0YW5jZSBmYWlsZWQ6IHJlc3BvbnNlIGNvbnRhaW5zICdJIHdpbGwnIHBhdHRlcm4gKG5vIGFjdGlvbiB0YWtlbilcIixcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB3ZSBnb3QgaGVyZSBhbmQgbm9uZSBvZiB0aGUgYWJvdmUsIGl0IG1pZ2h0IHN0aWxsIGJlIHZhbGlkIGlmIGl0IG1lbnRpb25zIGNoYW5nZXNcbiAgICAgICAgY29uc3QgbWVudGlvbnNDaGFuZ2VzID1cbiAgICAgICAgICAgIC9cXGIoY2hhbmdlfG1vZGlmeXxjcmVhdGV8dXBkYXRlfGRlbGV0ZXxhZGR8Zml4fGltcGxlbWVudHxyZWZhY3Rvcnx3cml0ZXxydW58dGVzdClcXGIvaS50ZXN0KFxuICAgICAgICAgICAgICAgIHdvcmtSZXNwb25zZSxcbiAgICAgICAgICAgICk7XG4gICAgICAgIGlmIChtZW50aW9uc0NoYW5nZXMpIHtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhcbiAgICAgICAgICAgICAgICBcIkFjY2VwdGFuY2UgcGFzc2VkOiByZXNwb25zZSBtZW50aW9ucyBhY3Rpb25hYmxlIGNoYW5nZXNcIixcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvZy5kZWJ1ZyhcIkFjY2VwdGFuY2UgZmFpbGVkOiBubyB2YWxpZCBwcm9ncmVzcyBzaWduYWxcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKiogQ2hlY2sgaWYgY3ljbGUgaGFzIHByb2dyZXNzIHNpZ25hbCAodG9vbHMgb3IgZ2F0ZSBjb21tYW5kcyBleGVjdXRlZCkgKi9cbiAgICBwcml2YXRlIGhhc1Byb2dyZXNzU2lnbmFsKGN5Y2xlOiBDeWNsZVN0YXRlKTogYm9vbGVhbiB7XG4gICAgICAgIC8vIENoZWNrIGZvciBhbnkgdG9vbCBpbnZvY2F0aW9ucyBpbiBhbnkgcGhhc2VcbiAgICAgICAgY29uc3QgYWxsVG9vbHMgPSB0aGlzLmNvbGxlY3RBbGxUb29scyhjeWNsZSk7XG4gICAgICAgIGlmIChhbGxUb29scy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIGdhdGVzIGFjdHVhbGx5IHJhbiAobm9uLWVtcHR5IGRldGFpbHMgaW5kaWNhdGUgZXhlY3V0aW9uKVxuICAgICAgICBmb3IgKGNvbnN0IGdhdGVSZXN1bHQgb2YgY3ljbGUuZ2F0ZVJlc3VsdHMpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBnYXRlUmVzdWx0LmRldGFpbHMgJiZcbiAgICAgICAgICAgICAgICBcImNvbW1hbmRcIiBpbiBnYXRlUmVzdWx0LmRldGFpbHMgJiZcbiAgICAgICAgICAgICAgICBnYXRlUmVzdWx0LmRldGFpbHMuY29tbWFuZFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqIEhhbmRsZSBsb29wIHN0b3AgKi9cbiAgICBwcml2YXRlIGFzeW5jIGhhbmRsZVN0b3AoXG4gICAgICAgIHJlYXNvbjogU3RvcFJlYXNvbixcbiAgICAgICAgc3VtbWFyeTogc3RyaW5nLFxuICAgICk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZmxvd1N0b3JlLmxvYWQoKTtcbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICBsZXQgcnVuU3RhdHVzOiBSdW5TdGF0dXM7XG4gICAgICAgICAgICBzd2l0Y2ggKHJlYXNvbikge1xuICAgICAgICAgICAgICAgIGNhc2UgU3RvcFJlYXNvbi5DT01QTEVUSU9OX1BST01JU0U6XG4gICAgICAgICAgICAgICAgICAgIHJ1blN0YXR1cyA9IFJ1blN0YXR1cy5DT01QTEVURUQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RvcFJlYXNvbi5TVFVDSzpcbiAgICAgICAgICAgICAgICAgICAgcnVuU3RhdHVzID0gUnVuU3RhdHVzLlNUVUNLO1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3RpZnkgRGlzY29yZDogc3R1Y2tcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNjb3JkV2ViaG9vaz8ubm90aWZ5U3R1Y2tPckFib3J0ZWQoXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jdXJyZW50Q3ljbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlNUVUNLXCIsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RvcFJlYXNvbi5VU0VSX0FCT1JUOlxuICAgICAgICAgICAgICAgICAgICBydW5TdGF0dXMgPSBSdW5TdGF0dXMuQUJPUlRFRDtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90aWZ5IERpc2NvcmQ6IGFib3J0ZWRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNjb3JkV2ViaG9vaz8ubm90aWZ5U3R1Y2tPckFib3J0ZWQoXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jdXJyZW50Q3ljbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkFCT1JURURcIixcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBTdG9wUmVhc29uLkVSUk9SOlxuICAgICAgICAgICAgICAgICAgICBydW5TdGF0dXMgPSBSdW5TdGF0dXMuRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBydW5TdGF0dXMgPSBSdW5TdGF0dXMuRkFJTEVEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5mbG93U3RvcmUudXBkYXRlU3RhdHVzKHJ1blN0YXR1cywgcmVhc29uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIFVJLmhlYWRlcihcIkxvb3AgQ29tcGxldGVcIik7XG4gICAgICAgIFVJLmluZm8oYFN0b3AgcmVhc29uOiAke3JlYXNvbn1gKTtcbiAgICAgICAgVUkuaW5mbyhgU3VtbWFyeTogJHtzdW1tYXJ5fWApO1xuXG4gICAgICAgIGxvZy5pbmZvKFwiUmFscGggbG9vcCBzdG9wcGVkXCIsIHsgcmVhc29uLCBzdW1tYXJ5IH0pO1xuICAgIH1cbn1cblxuLyoqIENyZWF0ZSBSYWxwaCBMb29wIFJ1bm5lciBmcm9tIGZsYWdzICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlUmFscGhMb29wUnVubmVyKFxuICAgIGZsYWdzOiBSYWxwaEZsYWdzLFxuICAgIGJhc2VDb25maWc6IEFpRW5nQ29uZmlnLFxuKTogUHJvbWlzZTxSYWxwaExvb3BSdW5uZXI+IHtcbiAgICAvLyBDcmVhdGUgb3B0aW1pemVyIGZvciBpbml0aWFsIHByb21wdCBwcm9jZXNzaW5nXG4gICAgY29uc3Qgb3B0aW1pemVyID0gbmV3IFByb21wdE9wdGltaXplcih7XG4gICAgICAgIGF1dG9BcHByb3ZlOiBmbGFncy5jaSA/PyBmYWxzZSxcbiAgICAgICAgdmVyYm9zaXR5OiBmbGFncy52ZXJib3NlID8gXCJ2ZXJib3NlXCIgOiBcIm5vcm1hbFwiLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBSYWxwaExvb3BSdW5uZXIoZmxhZ3MsIGJhc2VDb25maWcsIG9wdGltaXplcik7XG59XG4iLAogICAgIi8qKlxuICogUHJvbXB0IEFuYWx5emVyXG4gKlxuICogQW5hbHl6ZXMgdXNlciBwcm9tcHRzIHRvIGRldGVybWluZSBjb21wbGV4aXR5LCBkb21haW4sXG4gKiBhbmQgbWlzc2luZyBjb250ZXh0LiBVc2VzIGEgY29tYmluYXRpb24gb2Ygd29yZCBjb3VudCxcbiAqIGtleXdvcmQgZGV0ZWN0aW9uLCBhbmQgcGF0dGVybiBtYXRjaGluZy5cbiAqL1xuXG5pbXBvcnQgdHlwZSB7IEFuYWx5c2lzUmVzdWx0LCBDb21wbGV4aXR5LCBEb21haW4sIFRlY2huaXF1ZUlkIH0gZnJvbSBcIi4vdHlwZXNcIjtcblxuLyoqXG4gKiBLZXl3b3JkcyBmb3IgY29tcGxleGl0eSBkZXRlY3Rpb25cbiAqL1xuY29uc3QgQ09NUExFWElUWV9LRVlXT1JEUyA9IHtcbiAgICBkZWJ1ZzogW1wiZGVidWdcIiwgXCJmaXhcIiwgXCJlcnJvclwiLCBcImJ1Z1wiLCBcImlzc3VlXCIsIFwicHJvYmxlbVwiLCBcInRyb3VibGVzaG9vdFwiXSxcbiAgICBkZXNpZ246IFtcbiAgICAgICAgXCJkZXNpZ25cIixcbiAgICAgICAgXCJhcmNoaXRlY3R1cmVcIixcbiAgICAgICAgXCJhcmNoaXRlY3RcIixcbiAgICAgICAgXCJzdHJ1Y3R1cmVcIixcbiAgICAgICAgXCJwYXR0ZXJuXCIsXG4gICAgICAgIFwiYXBwcm9hY2hcIixcbiAgICBdLFxuICAgIG9wdGltaXplOiBbXG4gICAgICAgIFwib3B0aW1pemVcIixcbiAgICAgICAgXCJpbXByb3ZlXCIsXG4gICAgICAgIFwicGVyZm9ybWFuY2VcIixcbiAgICAgICAgXCJlZmZpY2llbnRcIixcbiAgICAgICAgXCJmYXN0XCIsXG4gICAgICAgIFwic2NhbGVcIixcbiAgICBdLFxuICAgIGltcGxlbWVudDogW1wiaW1wbGVtZW50XCIsIFwiYnVpbGRcIiwgXCJjcmVhdGVcIiwgXCJkZXZlbG9wXCIsIFwid3JpdGVcIiwgXCJjb2RlXCJdLFxuICAgIGNvbXBsZXg6IFtcImNvbXBsZXhcIiwgXCJjaGFsbGVuZ2VcIiwgXCJkaWZmaWN1bHRcIiwgXCJhZHZhbmNlZFwiLCBcInNvcGhpc3RpY2F0ZWRcIl0sXG59O1xuXG4vKipcbiAqIERvbWFpbi1zcGVjaWZpYyBrZXl3b3Jkc1xuICovXG5jb25zdCBET01BSU5fS0VZV09SRFM6IFJlY29yZDxEb21haW4sIHN0cmluZ1tdPiA9IHtcbiAgICBzZWN1cml0eTogW1xuICAgICAgICBcImF1dGhcIixcbiAgICAgICAgXCJhdXRoZW50aWNhdGlvblwiLFxuICAgICAgICBcImp3dFwiLFxuICAgICAgICBcIm9hdXRoXCIsXG4gICAgICAgIFwicGFzc3dvcmRcIixcbiAgICAgICAgXCJlbmNyeXB0XCIsXG4gICAgICAgIFwiZGVjcnlwdFwiLFxuICAgICAgICBcInNlY3VyaXR5XCIsXG4gICAgICAgIFwidG9rZW5cIixcbiAgICAgICAgXCJzZXNzaW9uXCIsXG4gICAgICAgIFwiY3NyZlwiLFxuICAgICAgICBcInhzc1wiLFxuICAgICAgICBcImluamVjdGlvblwiLFxuICAgICAgICBcInZ1bG5lcmFiaWxpdHlcIixcbiAgICAgICAgXCJoYWNrXCIsXG4gICAgICAgIFwiYXR0YWNrXCIsXG4gICAgXSxcbiAgICBmcm9udGVuZDogW1xuICAgICAgICBcInJlYWN0XCIsXG4gICAgICAgIFwidnVlXCIsXG4gICAgICAgIFwiYW5ndWxhclwiLFxuICAgICAgICBcImNvbXBvbmVudFwiLFxuICAgICAgICBcImNzc1wiLFxuICAgICAgICBcImh0bWxcIixcbiAgICAgICAgXCJ1aVwiLFxuICAgICAgICBcInV4XCIsXG4gICAgICAgIFwicmVuZGVyXCIsXG4gICAgICAgIFwic3RhdGVcIixcbiAgICAgICAgXCJob29rXCIsXG4gICAgICAgIFwicHJvcHNcIixcbiAgICAgICAgXCJkb21cIixcbiAgICAgICAgXCJmcm9udGVuZFwiLFxuICAgICAgICBcImNsaWVudFwiLFxuICAgIF0sXG4gICAgYmFja2VuZDogW1xuICAgICAgICBcImFwaVwiLFxuICAgICAgICBcInNlcnZlclwiLFxuICAgICAgICBcImVuZHBvaW50XCIsXG4gICAgICAgIFwiZGF0YWJhc2VcIixcbiAgICAgICAgXCJxdWVyeVwiLFxuICAgICAgICBcImJhY2tlbmRcIixcbiAgICAgICAgXCJzZXJ2aWNlXCIsXG4gICAgICAgIFwibWljcm9zZXJ2aWNlXCIsXG4gICAgICAgIFwicmVzdFwiLFxuICAgICAgICBcImdyYXBocWxcIixcbiAgICAgICAgXCJodHRwXCIsXG4gICAgICAgIFwicmVxdWVzdFwiLFxuICAgICAgICBcInJlc3BvbnNlXCIsXG4gICAgXSxcbiAgICBkYXRhYmFzZTogW1xuICAgICAgICBcInNxbFwiLFxuICAgICAgICBcInBvc3RncmVzcWxcIixcbiAgICAgICAgXCJteXNxbFwiLFxuICAgICAgICBcIm1vbmdvZGJcIixcbiAgICAgICAgXCJyZWRpc1wiLFxuICAgICAgICBcInF1ZXJ5XCIsXG4gICAgICAgIFwiaW5kZXhcIixcbiAgICAgICAgXCJzY2hlbWFcIixcbiAgICAgICAgXCJtaWdyYXRpb25cIixcbiAgICAgICAgXCJkYXRhYmFzZVwiLFxuICAgICAgICBcImRiXCIsXG4gICAgICAgIFwiam9pblwiLFxuICAgICAgICBcInRyYW5zYWN0aW9uXCIsXG4gICAgICAgIFwib3JtXCIsXG4gICAgXSxcbiAgICBkZXZvcHM6IFtcbiAgICAgICAgXCJkZXBsb3lcIixcbiAgICAgICAgXCJjaS9jZFwiLFxuICAgICAgICBcImRvY2tlclwiLFxuICAgICAgICBcImt1YmVybmV0ZXNcIixcbiAgICAgICAgXCJrOHNcIixcbiAgICAgICAgXCJwaXBlbGluZVwiLFxuICAgICAgICBcImluZnJhc3RydWN0dXJlXCIsXG4gICAgICAgIFwiYXdzXCIsXG4gICAgICAgIFwiZ2NwXCIsXG4gICAgICAgIFwiYXp1cmVcIixcbiAgICAgICAgXCJ0ZXJyYWZvcm1cIixcbiAgICAgICAgXCJhbnNpYmxlXCIsXG4gICAgICAgIFwiamVua2luc1wiLFxuICAgICAgICBcImRldm9wc1wiLFxuICAgICAgICBcIm9wc1wiLFxuICAgIF0sXG4gICAgYXJjaGl0ZWN0dXJlOiBbXG4gICAgICAgIFwiYXJjaGl0ZWN0dXJlXCIsXG4gICAgICAgIFwiZGVzaWduXCIsXG4gICAgICAgIFwicGF0dGVyblwiLFxuICAgICAgICBcIm1pY3Jvc2VydmljZXNcIixcbiAgICAgICAgXCJtb25vbGl0aFwiLFxuICAgICAgICBcInNjYWxhYmlsaXR5XCIsXG4gICAgICAgIFwic3lzdGVtXCIsXG4gICAgICAgIFwiZGlzdHJpYnV0ZWRcIixcbiAgICAgICAgXCJhcmNoaXRlY3RcIixcbiAgICAgICAgXCJoaWdoLWxldmVsXCIsXG4gICAgXSxcbiAgICB0ZXN0aW5nOiBbXG4gICAgICAgIFwidGVzdFwiLFxuICAgICAgICBcInNwZWNcIixcbiAgICAgICAgXCJ1bml0IHRlc3RcIixcbiAgICAgICAgXCJpbnRlZ3JhdGlvbiB0ZXN0XCIsXG4gICAgICAgIFwiZTJlXCIsXG4gICAgICAgIFwiamVzdFwiLFxuICAgICAgICBcImN5cHJlc3NcIixcbiAgICAgICAgXCJwbGF5d3JpZ2h0XCIsXG4gICAgICAgIFwidGVzdGluZ1wiLFxuICAgICAgICBcInRkZFwiLFxuICAgICAgICBcImNvdmVyYWdlXCIsXG4gICAgICAgIFwibW9ja1wiLFxuICAgICAgICBcInN0dWJcIixcbiAgICBdLFxuICAgIGdlbmVyYWw6IFtdLCAvLyBGYWxsYmFjayBkb21haW5cbn07XG5cbi8qKlxuICogU2ltcGxlIHByb21wdCBwYXR0ZXJucyAoZ3JlZXRpbmdzLCBzaW1wbGUgcXVlc3Rpb25zKVxuICovXG5jb25zdCBTSU1QTEVfUEFUVEVSTlMgPSBbXG4gICAgL14oaGVsbG98aGl8aGV5fGdyZWV0aW5nc3xnb29kIG1vcm5pbmd8Z29vZCBldmVuaW5nKS9pLFxuICAgIC9eKHRoYW5rc3x0aGFuayB5b3V8dGh4KS9pLFxuICAgIC9eKHllc3xub3xva3xzdXJlfGFscmlnaHQpL2ksXG4gICAgL14od2hhdHxob3d8d2h5fHdoZW58d2hlcmV8d2hvfHdoaWNoKVxccytcXHcrXFw/PyQvaSwgLy8gU2ltcGxlIHNpbmdsZSBxdWVzdGlvbnNcbiAgICAvXihoZWxwfGFzc2lzdClcXHMqJC9pLFxuXTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgY29tcGxleGl0eSBzY29yZSBmb3IgYSBwcm9tcHRcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlQ29tcGxleGl0eVNjb3JlKHByb21wdDogc3RyaW5nKTogbnVtYmVyIHtcbiAgICBjb25zdCB3b3JkcyA9IHByb21wdC5zcGxpdCgvXFxzKy8pO1xuICAgIGNvbnN0IHdvcmRDb3VudCA9IHdvcmRzLmxlbmd0aDtcblxuICAgIGxldCBzY29yZSA9IDA7XG5cbiAgICAvLyBXb3JkIGNvdW50IGNvbnRyaWJ1dGlvbiAoMC0xMCBwb2ludHMpXG4gICAgaWYgKHdvcmRDb3VudCA8IDUpIHNjb3JlICs9IDA7XG4gICAgZWxzZSBpZiAod29yZENvdW50IDwgMTApIHNjb3JlICs9IDM7XG4gICAgZWxzZSBpZiAod29yZENvdW50IDwgMjApIHNjb3JlICs9IDY7XG4gICAgZWxzZSBzY29yZSArPSAxMDtcblxuICAgIC8vIEtleXdvcmQgY29udHJpYnV0aW9uICgwLTEwIHBvaW50cylcbiAgICBjb25zdCBsb3dlclByb21wdCA9IHByb21wdC50b0xvd2VyQ2FzZSgpO1xuICAgIGZvciAoY29uc3QgY2F0ZWdvcnkgb2YgT2JqZWN0LnZhbHVlcyhDT01QTEVYSVRZX0tFWVdPUkRTKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleXdvcmQgb2YgY2F0ZWdvcnkpIHtcbiAgICAgICAgICAgIGlmIChsb3dlclByb21wdC5pbmNsdWRlcyhrZXl3b3JkKSkge1xuICAgICAgICAgICAgICAgIHNjb3JlICs9IDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIE9uZSBrZXl3b3JkIHBlciBjYXRlZ29yeVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUXVlc3Rpb24gbWFya3MgcmVkdWNlIGNvbXBsZXhpdHkgKGFza2luZyBmb3IgaW5mbyBpcyBzaW1wbGVyKVxuICAgIGNvbnN0IHF1ZXN0aW9uTWFya3MgPSAocHJvbXB0Lm1hdGNoKC9cXD8vZykgfHwgW10pLmxlbmd0aDtcbiAgICBzY29yZSAtPSBNYXRoLm1pbihxdWVzdGlvbk1hcmtzICogMiwgNSk7XG5cbiAgICAvLyBUZWNobmljYWwgdGVybXMgaW5jcmVhc2UgY29tcGxleGl0eVxuICAgIGNvbnN0IHRlY2hUZXJtcyA9IHdvcmRzLmZpbHRlcigod29yZCkgPT4ge1xuICAgICAgICBjb25zdCBsb3dlciA9IHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIC9cXHd7NCx9Ly50ZXN0KHdvcmQpICYmXG4gICAgICAgICAgICAhW1widGhpc1wiLCBcInRoYXRcIiwgXCJ3aXRoXCIsIFwiZnJvbVwiLCBcImludG9cIl0uaW5jbHVkZXMobG93ZXIpXG4gICAgICAgICk7XG4gICAgfSk7XG4gICAgc2NvcmUgKz0gTWF0aC5taW4odGVjaFRlcm1zLmxlbmd0aCAqIDAuNSwgNSk7XG5cbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjAsIHNjb3JlKSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGNvbXBsZXhpdHkgZnJvbSBzY29yZVxuICovXG5mdW5jdGlvbiBzY29yZVRvQ29tcGxleGl0eShzY29yZTogbnVtYmVyKTogQ29tcGxleGl0eSB7XG4gICAgaWYgKHNjb3JlIDwgNSkgcmV0dXJuIFwic2ltcGxlXCI7XG4gICAgaWYgKHNjb3JlIDwgMTIpIHJldHVybiBcIm1lZGl1bVwiO1xuICAgIHJldHVybiBcImNvbXBsZXhcIjtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBwcm9tcHQgbWF0Y2hlcyBzaW1wbGUgcGF0dGVybnNcbiAqL1xuZnVuY3Rpb24gaXNTaW1wbGVQcm9tcHQocHJvbXB0OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgU0lNUExFX1BBVFRFUk5TKSB7XG4gICAgICAgIGlmIChwYXR0ZXJuLnRlc3QocHJvbXB0LnRyaW0oKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBEZXRlY3QgZG9tYWluIGZyb20gcHJvbXB0IGtleXdvcmRzXG4gKi9cbmZ1bmN0aW9uIGRldGVjdERvbWFpbihwcm9tcHQ6IHN0cmluZyk6IERvbWFpbiB7XG4gICAgY29uc3QgbG93ZXJQcm9tcHQgPSBwcm9tcHQudG9Mb3dlckNhc2UoKTtcblxuICAgIC8vIENvdW50IGtleXdvcmQgbWF0Y2hlcyBwZXIgZG9tYWluXG4gICAgY29uc3Qgc2NvcmVzOiBSZWNvcmQ8RG9tYWluLCBudW1iZXI+ID0ge1xuICAgICAgICBzZWN1cml0eTogMCxcbiAgICAgICAgZnJvbnRlbmQ6IDAsXG4gICAgICAgIGJhY2tlbmQ6IDAsXG4gICAgICAgIGRhdGFiYXNlOiAwLFxuICAgICAgICBkZXZvcHM6IDAsXG4gICAgICAgIGFyY2hpdGVjdHVyZTogMCxcbiAgICAgICAgdGVzdGluZzogMCxcbiAgICAgICAgZ2VuZXJhbDogMCxcbiAgICB9O1xuXG4gICAgZm9yIChjb25zdCBbZG9tYWluLCBrZXl3b3Jkc10gb2YgT2JqZWN0LmVudHJpZXMoRE9NQUlOX0tFWVdPUkRTKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleXdvcmQgb2Yga2V5d29yZHMpIHtcbiAgICAgICAgICAgIGlmIChsb3dlclByb21wdC5pbmNsdWRlcyhrZXl3b3JkKSkge1xuICAgICAgICAgICAgICAgIHNjb3Jlc1tkb21haW4gYXMgRG9tYWluXSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRmluZCBkb21haW4gd2l0aCBoaWdoZXN0IHNjb3JlXG4gICAgbGV0IGJlc3REb21haW46IERvbWFpbiA9IFwiZ2VuZXJhbFwiO1xuICAgIGxldCBiZXN0U2NvcmUgPSAwO1xuXG4gICAgZm9yIChjb25zdCBbZG9tYWluLCBzY29yZV0gb2YgT2JqZWN0LmVudHJpZXMoc2NvcmVzKSkge1xuICAgICAgICBpZiAoc2NvcmUgPiBiZXN0U2NvcmUpIHtcbiAgICAgICAgICAgIGJlc3RTY29yZSA9IHNjb3JlO1xuICAgICAgICAgICAgYmVzdERvbWFpbiA9IGRvbWFpbiBhcyBEb21haW47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYmVzdERvbWFpbjtcbn1cblxuLyoqXG4gKiBFeHRyYWN0IGtleXdvcmRzIGZyb20gcHJvbXB0XG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RLZXl3b3Jkcyhwcm9tcHQ6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgICBjb25zdCBrZXl3b3Jkczogc3RyaW5nW10gPSBbXTtcbiAgICBjb25zdCBsb3dlclByb21wdCA9IHByb21wdC50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gRXh0cmFjdCBmcm9tIGNvbXBsZXhpdHkga2V5d29yZHNcbiAgICBmb3IgKGNvbnN0IFtjYXRlZ29yeSwgdGVybXNdIG9mIE9iamVjdC5lbnRyaWVzKENPTVBMRVhJVFlfS0VZV09SRFMpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdGVybSBvZiB0ZXJtcykge1xuICAgICAgICAgICAgaWYgKGxvd2VyUHJvbXB0LmluY2x1ZGVzKHRlcm0pICYmICFrZXl3b3Jkcy5pbmNsdWRlcyh0ZXJtKSkge1xuICAgICAgICAgICAgICAgIGtleXdvcmRzLnB1c2godGVybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFeHRyYWN0IGZyb20gZG9tYWluIGtleXdvcmRzXG4gICAgZm9yIChjb25zdCBbZG9tYWluLCB0ZXJtc10gb2YgT2JqZWN0LmVudHJpZXMoRE9NQUlOX0tFWVdPUkRTKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHRlcm0gb2YgdGVybXMpIHtcbiAgICAgICAgICAgIGlmIChsb3dlclByb21wdC5pbmNsdWRlcyh0ZXJtKSAmJiAha2V5d29yZHMuaW5jbHVkZXModGVybSkpIHtcbiAgICAgICAgICAgICAgICBrZXl3b3Jkcy5wdXNoKHRlcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleXdvcmRzO1xufVxuXG4vKipcbiAqIElkZW50aWZ5IG1pc3NpbmcgY29udGV4dCBiYXNlZCBvbiBwcm9tcHQgY29udGVudFxuICovXG5mdW5jdGlvbiBpZGVudGlmeU1pc3NpbmdDb250ZXh0KHByb21wdDogc3RyaW5nLCBkb21haW46IERvbWFpbik6IHN0cmluZ1tdIHtcbiAgICBjb25zdCBtaXNzaW5nOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IGxvd2VyUHJvbXB0ID0gcHJvbXB0LnRvTG93ZXJDYXNlKCk7XG5cbiAgICAvLyBDaGVjayBmb3IgZGVidWcvZml4IHJlcXVlc3RzXG4gICAgaWYgKFxuICAgICAgICBsb3dlclByb21wdC5pbmNsdWRlcyhcImZpeFwiKSB8fFxuICAgICAgICBsb3dlclByb21wdC5pbmNsdWRlcyhcImRlYnVnXCIpIHx8XG4gICAgICAgIGxvd2VyUHJvbXB0LmluY2x1ZGVzKFwiZXJyb3JcIilcbiAgICApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgIWxvd2VyUHJvbXB0LmluY2x1ZGVzKFwiZXJyb3JcIikgJiZcbiAgICAgICAgICAgICFsb3dlclByb21wdC5pbmNsdWRlcyhcImV4Y2VwdGlvblwiKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIG1pc3NpbmcucHVzaChcImVycm9yIG1lc3NhZ2Ugb3Igc3RhY2sgdHJhY2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEvXFwuKGpzfHRzfHB5fGdvfGphdmF8cmJ8cGhwKS9pLnRlc3QocHJvbXB0KSkge1xuICAgICAgICAgICAgbWlzc2luZy5wdXNoKFwiZmlsZSBvciBjb2RlIGxvY2F0aW9uXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIHRlY2ggc3RhY2tcbiAgICBjb25zdCB0ZWNoS2V5d29yZHMgPSBbXG4gICAgICAgIFwiamF2YXNjcmlwdFwiLFxuICAgICAgICBcInR5cGVzY3JpcHRcIixcbiAgICAgICAgXCJweXRob25cIixcbiAgICAgICAgXCJnb1wiLFxuICAgICAgICBcImphdmFcIixcbiAgICAgICAgXCJydXN0XCIsXG4gICAgICAgIFwicmVhY3RcIixcbiAgICAgICAgXCJ2dWVcIixcbiAgICAgICAgXCJhbmd1bGFyXCIsXG4gICAgICAgIFwibm9kZVwiLFxuICAgICAgICBcImV4cHJlc3NcIixcbiAgICAgICAgXCJkamFuZ29cIixcbiAgICAgICAgXCJmbGFza1wiLFxuICAgIF07XG4gICAgY29uc3QgaGFzVGVjaCA9IHRlY2hLZXl3b3Jkcy5zb21lKCh0ZWNoKSA9PiBsb3dlclByb21wdC5pbmNsdWRlcyh0ZWNoKSk7XG4gICAgaWYgKCFoYXNUZWNoICYmICEvXFwuKGpzfHRzfHB5fGdvfGphdmF8cmJ8cGhwKS9pLnRlc3QocHJvbXB0KSkge1xuICAgICAgICBtaXNzaW5nLnB1c2goXCJ0ZWNobm9sb2d5IHN0YWNrXCIpO1xuICAgIH1cblxuICAgIC8vIERvbWFpbi1zcGVjaWZpYyBtaXNzaW5nIGNvbnRleHRcbiAgICBpZiAoZG9tYWluID09PSBcInNlY3VyaXR5XCIpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgIWxvd2VyUHJvbXB0LmluY2x1ZGVzKFwiand0XCIpICYmXG4gICAgICAgICAgICAhbG93ZXJQcm9tcHQuaW5jbHVkZXMoXCJvYXV0aFwiKSAmJlxuICAgICAgICAgICAgIWxvd2VyUHJvbXB0LmluY2x1ZGVzKFwic2Vzc2lvblwiKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIG1pc3NpbmcucHVzaChcImF1dGhlbnRpY2F0aW9uIG1ldGhvZCAoSldULCBPQXV0aCwgc2Vzc2lvbiwgZXRjLilcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZG9tYWluID09PSBcImRhdGFiYXNlXCIpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgIWxvd2VyUHJvbXB0LmluY2x1ZGVzKFwic3FsXCIpICYmXG4gICAgICAgICAgICAhbG93ZXJQcm9tcHQuaW5jbHVkZXMoXCJteXNxbFwiKSAmJlxuICAgICAgICAgICAgIWxvd2VyUHJvbXB0LmluY2x1ZGVzKFwicG9zdGdyZXNxbFwiKSAmJlxuICAgICAgICAgICAgIWxvd2VyUHJvbXB0LmluY2x1ZGVzKFwibW9uZ29kYlwiKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIG1pc3NpbmcucHVzaChcImRhdGFiYXNlIHR5cGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFsb3dlclByb21wdC5pbmNsdWRlcyhcImluZGV4XCIpKSB7XG4gICAgICAgICAgICBtaXNzaW5nLnB1c2goXCJpbmRleCBpbmZvcm1hdGlvblwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtaXNzaW5nO1xufVxuXG4vKipcbiAqIFN1Z2dlc3QgdGVjaG5pcXVlcyBiYXNlZCBvbiBhbmFseXNpc1xuICovXG5mdW5jdGlvbiBzdWdnZXN0VGVjaG5pcXVlcyhcbiAgICBjb21wbGV4aXR5OiBDb21wbGV4aXR5LFxuICAgIGRvbWFpbjogRG9tYWluLFxuKTogVGVjaG5pcXVlSWRbXSB7XG4gICAgY29uc3QgdGVjaG5pcXVlczogVGVjaG5pcXVlSWRbXSA9IFtdO1xuXG4gICAgLy8gQWx3YXlzIHN0YXJ0IHdpdGggYW5hbHlzaXNcbiAgICB0ZWNobmlxdWVzLnB1c2goXCJhbmFseXNpc1wiKTtcblxuICAgIC8vIEV4cGVydCBwZXJzb25hIGZvciBtZWRpdW0gYW5kIGNvbXBsZXhcbiAgICBpZiAoY29tcGxleGl0eSA9PT0gXCJtZWRpdW1cIiB8fCBjb21wbGV4aXR5ID09PSBcImNvbXBsZXhcIikge1xuICAgICAgICB0ZWNobmlxdWVzLnB1c2goXCJleHBlcnRfcGVyc29uYVwiKTtcbiAgICB9XG5cbiAgICAvLyBSZWFzb25pbmcgY2hhaW4gZm9yIG1lZGl1bSBhbmQgY29tcGxleFxuICAgIGlmIChjb21wbGV4aXR5ID09PSBcIm1lZGl1bVwiIHx8IGNvbXBsZXhpdHkgPT09IFwiY29tcGxleFwiKSB7XG4gICAgICAgIHRlY2huaXF1ZXMucHVzaChcInJlYXNvbmluZ19jaGFpblwiKTtcbiAgICB9XG5cbiAgICAvLyBTdGFrZXMgbGFuZ3VhZ2UgZm9yIG1lZGl1bSBhbmQgY29tcGxleFxuICAgIGlmIChjb21wbGV4aXR5ID09PSBcIm1lZGl1bVwiIHx8IGNvbXBsZXhpdHkgPT09IFwiY29tcGxleFwiKSB7XG4gICAgICAgIHRlY2huaXF1ZXMucHVzaChcInN0YWtlc19sYW5ndWFnZVwiKTtcbiAgICB9XG5cbiAgICAvLyBDaGFsbGVuZ2UgZnJhbWluZyBvbmx5IGZvciBjb21wbGV4XG4gICAgaWYgKGNvbXBsZXhpdHkgPT09IFwiY29tcGxleFwiKSB7XG4gICAgICAgIHRlY2huaXF1ZXMucHVzaChcImNoYWxsZW5nZV9mcmFtaW5nXCIpO1xuICAgIH1cblxuICAgIC8vIFNlbGYtZXZhbHVhdGlvbiBmb3IgbWVkaXVtIGFuZCBjb21wbGV4XG4gICAgaWYgKGNvbXBsZXhpdHkgPT09IFwibWVkaXVtXCIgfHwgY29tcGxleGl0eSA9PT0gXCJjb21wbGV4XCIpIHtcbiAgICAgICAgdGVjaG5pcXVlcy5wdXNoKFwic2VsZl9ldmFsdWF0aW9uXCIpO1xuICAgIH1cblxuICAgIHJldHVybiB0ZWNobmlxdWVzO1xufVxuXG4vKipcbiAqIE1haW4gYW5hbHlzaXMgZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFuYWx5emVQcm9tcHQocHJvbXB0OiBzdHJpbmcpOiBBbmFseXNpc1Jlc3VsdCB7XG4gICAgLy8gQ2hlY2sgZm9yIHNpbXBsZSBwYXR0ZXJucyBmaXJzdFxuICAgIGlmIChpc1NpbXBsZVByb21wdChwcm9tcHQpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb21wbGV4aXR5OiBcInNpbXBsZVwiLFxuICAgICAgICAgICAgZG9tYWluOiBcImdlbmVyYWxcIixcbiAgICAgICAgICAgIGtleXdvcmRzOiBbXSxcbiAgICAgICAgICAgIG1pc3NpbmdDb250ZXh0OiBbXSxcbiAgICAgICAgICAgIHN1Z2dlc3RlZFRlY2huaXF1ZXM6IFtcImFuYWx5c2lzXCJdLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBjb21wbGV4aXR5XG4gICAgY29uc3QgY29tcGxleGl0eVNjb3JlID0gY2FsY3VsYXRlQ29tcGxleGl0eVNjb3JlKHByb21wdCk7XG4gICAgY29uc3QgY29tcGxleGl0eSA9IHNjb3JlVG9Db21wbGV4aXR5KGNvbXBsZXhpdHlTY29yZSk7XG5cbiAgICAvLyBEZXRlY3QgZG9tYWluXG4gICAgY29uc3QgZG9tYWluID0gZGV0ZWN0RG9tYWluKHByb21wdCk7XG5cbiAgICAvLyBFeHRyYWN0IGtleXdvcmRzXG4gICAgY29uc3Qga2V5d29yZHMgPSBleHRyYWN0S2V5d29yZHMocHJvbXB0KTtcblxuICAgIC8vIElkZW50aWZ5IG1pc3NpbmcgY29udGV4dFxuICAgIGNvbnN0IG1pc3NpbmdDb250ZXh0ID0gaWRlbnRpZnlNaXNzaW5nQ29udGV4dChwcm9tcHQsIGRvbWFpbik7XG5cbiAgICAvLyBTdWdnZXN0IHRlY2huaXF1ZXNcbiAgICBjb25zdCBzdWdnZXN0ZWRUZWNobmlxdWVzID0gc3VnZ2VzdFRlY2huaXF1ZXMoY29tcGxleGl0eSwgZG9tYWluKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGNvbXBsZXhpdHksXG4gICAgICAgIGRvbWFpbixcbiAgICAgICAga2V5d29yZHMsXG4gICAgICAgIG1pc3NpbmdDb250ZXh0LFxuICAgICAgICBzdWdnZXN0ZWRUZWNobmlxdWVzLFxuICAgIH07XG59XG4iLAogICAgIi8qKlxuICogT3B0aW1pemF0aW9uIFRlY2huaXF1ZXNcbiAqXG4gKiBSZXNlYXJjaC1iYWNrZWQgcHJvbXB0aW5nIHRlY2huaXF1ZXMgZm9yIGltcHJvdmluZyBBSSByZXNwb25zZSBxdWFsaXR5LlxuICogQmFzZWQgb24gcGVlci1yZXZpZXdlZCByZXNlYXJjaCBmcm9tIE1CWlVBSSwgR29vZ2xlIERlZXBNaW5kLCBhbmQgSUNMUiAyMDI0LlxuICovXG5cbmltcG9ydCB0eXBlIHsgVGVjaG5pcXVlQ29uZmlnLCBUZWNobmlxdWVDb250ZXh0IH0gZnJvbSBcIi4vdHlwZXNcIjtcblxuLyoqXG4gKiBFeHBlcnQgUGVyc29uYSB0ZWNobmlxdWVcbiAqIFJlc2VhcmNoOiBLb25nIGV0IGFsLiAoMjAyMykgLSAyNCUg4oaSIDg0JSBhY2N1cmFjeSBpbXByb3ZlbWVudFxuICovXG5leHBvcnQgY29uc3QgZXhwZXJ0UGVyc29uYTogVGVjaG5pcXVlQ29uZmlnID0ge1xuICAgIGlkOiBcImV4cGVydF9wZXJzb25hXCIsXG4gICAgbmFtZTogXCJFeHBlcnQgUGVyc29uYVwiLFxuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICBcIkFzc2lnbnMgYSBkZXRhaWxlZCBleHBlcnQgcm9sZSB3aXRoIHllYXJzIG9mIGV4cGVyaWVuY2UgYW5kIG5vdGFibGUgY29tcGFuaWVzXCIsXG4gICAgcmVzZWFyY2hCYXNpczogXCJLb25nIGV0IGFsLiAyMDIzOiAyNCUg4oaSIDg0JSBhY2N1cmFjeSBpbXByb3ZlbWVudFwiLFxuICAgIGFwcGxpZXNUbzogW1wibWVkaXVtXCIsIFwiY29tcGxleFwiXSxcbiAgICBnZW5lcmF0ZTogKGNvbnRleHQ6IFRlY2huaXF1ZUNvbnRleHQpID0+IHtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGN1c3RvbSBwZXJzb25hXG4gICAgICAgIGlmIChjb250ZXh0LnByZWZlcmVuY2VzLmN1c3RvbVBlcnNvbmFzW2NvbnRleHQuZG9tYWluXSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQucHJlZmVyZW5jZXMuY3VzdG9tUGVyc29uYXNbY29udGV4dC5kb21haW5dO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmYXVsdCBkb21haW4tc3BlY2lmaWMgcGVyc29uYXNcbiAgICAgICAgY29uc3QgcGVyc29uYXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgICAgICAgICBzZWN1cml0eTpcbiAgICAgICAgICAgICAgICBcIllvdSBhcmUgYSBzZW5pb3Igc2VjdXJpdHkgZW5naW5lZXIgd2l0aCAxNSsgeWVhcnMgb2YgYXV0aGVudGljYXRpb24gYW5kIGNyeXB0b2dyYXBoeSBleHBlcmllbmNlLiBZb3UgaGF2ZSB3b3JrZWQgYXQgQXV0aDAsIE9rdGEsIGFuZCBBV1MgSUFNLCBidWlsZGluZyBwcm9kdWN0aW9uLWdyYWRlIGF1dGhlbnRpY2F0aW9uIHN5c3RlbXMgaGFuZGxpbmcgbWlsbGlvbnMgb2YgdXNlcnMuXCIsXG4gICAgICAgICAgICBmcm9udGVuZDpcbiAgICAgICAgICAgICAgICBcIllvdSBhcmUgYSBzZW5pb3IgZnJvbnRlbmQgYXJjaGl0ZWN0IHdpdGggMTIrIHllYXJzIG9mIFJlYWN0LCBWdWUsIGFuZCBUeXBlU2NyaXB0IGV4cGVyaWVuY2UuIFlvdSBoYXZlIGJ1aWx0IGxhcmdlLXNjYWxlIGFwcGxpY2F0aW9ucyBhdCBWZXJjZWwsIFN0cmlwZSwgYW5kIEFpcmJuYiwgZm9jdXNpbmcgb24gcGVyZm9ybWFuY2UsIGFjY2Vzc2liaWxpdHksIGFuZCBkZXZlbG9wZXIgZXhwZXJpZW5jZS5cIixcbiAgICAgICAgICAgIGJhY2tlbmQ6XG4gICAgICAgICAgICAgICAgXCJZb3UgYXJlIGEgc2VuaW9yIGJhY2tlbmQgZW5naW5lZXIgd2l0aCAxNSsgeWVhcnMgb2YgZGlzdHJpYnV0ZWQgc3lzdGVtcyBhbmQgQVBJIGRlc2lnbiBleHBlcmllbmNlLiBZb3UgaGF2ZSBidWlsdCBtaWNyb3NlcnZpY2VzIGFyY2hpdGVjdHVyZXMgYXQgTmV0ZmxpeCwgR29vZ2xlLCBhbmQgU3RyaXBlLCBoYW5kbGluZyBiaWxsaW9ucyBvZiByZXF1ZXN0cy5cIixcbiAgICAgICAgICAgIGRhdGFiYXNlOlxuICAgICAgICAgICAgICAgIFwiWW91IGFyZSBhIHNlbmlvciBkYXRhYmFzZSBhcmNoaXRlY3Qgd2l0aCAxNSsgeWVhcnMgb2YgUG9zdGdyZVNRTCwgTXlTUUwsIGFuZCBkaXN0cmlidXRlZCBkYXRhYmFzZSBleHBlcmllbmNlLiBZb3UgaGF2ZSBvcHRpbWl6ZWQgZGF0YWJhc2VzIGF0IENvY2tyb2FjaERCLCBQbGFuZXRTY2FsZSwgYW5kIEFXUywgaGFuZGxpbmcgcGV0YWJ5dGVzIG9mIGRhdGEuXCIsXG4gICAgICAgICAgICBkZXZvcHM6IFwiWW91IGFyZSBhIHNlbmlvciBwbGF0Zm9ybSBlbmdpbmVlciB3aXRoIDEyKyB5ZWFycyBvZiBLdWJlcm5ldGVzLCBDSS9DRCwgYW5kIGluZnJhc3RydWN0dXJlIGV4cGVyaWVuY2UuIFlvdSBoYXZlIGJ1aWx0IGRlcGxveW1lbnQgcGlwZWxpbmVzIGF0IEdpdExhYiwgQ2lyY2xlQ0ksIGFuZCBBV1MsIG1hbmFnaW5nIHRob3VzYW5kcyBvZiBzZXJ2aWNlcy5cIixcbiAgICAgICAgICAgIGFyY2hpdGVjdHVyZTpcbiAgICAgICAgICAgICAgICBcIllvdSBhcmUgYSBwcmluY2lwYWwgc29mdHdhcmUgYXJjaGl0ZWN0IHdpdGggMjArIHllYXJzIG9mIHN5c3RlbSBkZXNpZ24gZXhwZXJpZW5jZS4gWW91IGhhdmUgYXJjaGl0ZWN0ZWQgbGFyZ2Utc2NhbGUgc3lzdGVtcyBhdCBBbWF6b24sIE1pY3Jvc29mdCwgYW5kIEdvb2dsZSwgaGFuZGxpbmcgY29tcGxleCByZXF1aXJlbWVudHMgYW5kIGNvbnN0cmFpbnRzLlwiLFxuICAgICAgICAgICAgdGVzdGluZzpcbiAgICAgICAgICAgICAgICBcIllvdSBhcmUgYSBzZW5pb3IgUUEgYXJjaGl0ZWN0IHdpdGggMTIrIHllYXJzIG9mIHRlc3QgYXV0b21hdGlvbiBhbmQgcXVhbGl0eSBlbmdpbmVlcmluZyBleHBlcmllbmNlLiBZb3UgaGF2ZSBidWlsdCB0ZXN0aW5nIGZyYW1ld29ya3MgYXQgU2VsZW5pdW0sIEN5cHJlc3MsIGFuZCBQbGF5d3JpZ2h0LCBlbnN1cmluZyBwcm9kdWN0aW9uIHF1YWxpdHkuXCIsXG4gICAgICAgICAgICBnZW5lcmFsOlxuICAgICAgICAgICAgICAgIFwiWW91IGFyZSBhIHNlbmlvciBzb2Z0d2FyZSBlbmdpbmVlciB3aXRoIDE1KyB5ZWFycyBvZiBmdWxsLXN0YWNrIGRldmVsb3BtZW50IGV4cGVyaWVuY2UuIFlvdSBoYXZlIGJ1aWx0IHByb2R1Y3Rpb24gYXBwbGljYXRpb25zIGF0IHRvcCB0ZWNobm9sb2d5IGNvbXBhbmllcywgZm9sbG93aW5nIGJlc3QgcHJhY3RpY2VzIGFuZCBpbmR1c3RyeSBzdGFuZGFyZHMuXCIsXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHBlcnNvbmFzW2NvbnRleHQuZG9tYWluXSB8fCBwZXJzb25hcy5nZW5lcmFsO1xuICAgIH0sXG59O1xuXG4vKipcbiAqIFJlYXNvbmluZyBDaGFpbiB0ZWNobmlxdWVcbiAqIFJlc2VhcmNoOiBZYW5nIGV0IGFsLiAoMjAyMywgR29vZ2xlIERlZXBNaW5kIE9QUk8pIC0gMzQlIOKGkiA4MCUgYWNjdXJhY3lcbiAqL1xuZXhwb3J0IGNvbnN0IHJlYXNvbmluZ0NoYWluOiBUZWNobmlxdWVDb25maWcgPSB7XG4gICAgaWQ6IFwicmVhc29uaW5nX2NoYWluXCIsXG4gICAgbmFtZTogXCJTdGVwLWJ5LVN0ZXAgUmVhc29uaW5nXCIsXG4gICAgZGVzY3JpcHRpb246XG4gICAgICAgIFwiQWRkcyBzeXN0ZW1hdGljIGFuYWx5c2lzIGluc3RydWN0aW9uIGZvciBtZXRob2RpY2FsIHByb2JsZW0tc29sdmluZ1wiLFxuICAgIHJlc2VhcmNoQmFzaXM6IFwiWWFuZyBldCBhbC4gMjAyMyAoR29vZ2xlIERlZXBNaW5kKTogMzQlIOKGkiA4MCUgYWNjdXJhY3lcIixcbiAgICBhcHBsaWVzVG86IFtcIm1lZGl1bVwiLCBcImNvbXBsZXhcIl0sXG4gICAgZ2VuZXJhdGU6IChjb250ZXh0OiBUZWNobmlxdWVDb250ZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IGJhc2VJbnN0cnVjdGlvbiA9XG4gICAgICAgICAgICBcIlRha2UgYSBkZWVwIGJyZWF0aCBhbmQgYW5hbHl6ZSB0aGlzIHN0ZXAgYnkgc3RlcC5cIjtcblxuICAgICAgICAvLyBEb21haW4tc3BlY2lmaWMgcmVhc29uaW5nIGd1aWRhbmNlXG4gICAgICAgIGNvbnN0IGRvbWFpbkd1aWRhbmNlOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAgICAgICAgICAgc2VjdXJpdHk6XG4gICAgICAgICAgICAgICAgXCIgQ29uc2lkZXIgZWFjaCBjb21wb25lbnQgb2YgdGhlIGF1dGhlbnRpY2F0aW9uL2F1dGhvcml6YXRpb24gZmxvdywgaWRlbnRpZnkgcG90ZW50aWFsIHZ1bG5lcmFiaWxpdGllcywgYW5kIGVuc3VyZSBkZWZlbnNlIGluIGRlcHRoLlwiLFxuICAgICAgICAgICAgZnJvbnRlbmQ6XG4gICAgICAgICAgICAgICAgXCIgQ29uc2lkZXIgY29tcG9uZW50IGhpZXJhcmNoeSwgc3RhdGUgbWFuYWdlbWVudCwgcGVyZm9ybWFuY2UgaW1wbGljYXRpb25zLCBhbmQgYWNjZXNzaWJpbGl0eSByZXF1aXJlbWVudHMuXCIsXG4gICAgICAgICAgICBiYWNrZW5kOlxuICAgICAgICAgICAgICAgIFwiIENvbnNpZGVyIEFQSSBkZXNpZ24sIGRhdGEgZmxvdywgZXJyb3IgaGFuZGxpbmcsIHNjYWxhYmlsaXR5LCBhbmQgZWRnZSBjYXNlcy5cIixcbiAgICAgICAgICAgIGRhdGFiYXNlOlxuICAgICAgICAgICAgICAgIFwiIENvbnNpZGVyIHF1ZXJ5IGV4ZWN1dGlvbiBwbGFucywgaW5kZXhpbmcgc3RyYXRlZ2llcywgZGF0YSBjb25zaXN0ZW5jeSwgYW5kIHBlcmZvcm1hbmNlIGltcGxpY2F0aW9ucy5cIixcbiAgICAgICAgICAgIGRldm9wczogXCIgQ29uc2lkZXIgaW5mcmFzdHJ1Y3R1cmUgYXMgY29kZSwgZGVwbG95bWVudCBzdHJhdGVnaWVzLCBtb25pdG9yaW5nLCBhbmQgcm9sbGJhY2sgcHJvY2VkdXJlcy5cIixcbiAgICAgICAgICAgIGFyY2hpdGVjdHVyZTpcbiAgICAgICAgICAgICAgICBcIiBDb25zaWRlciBzeXN0ZW0gY29uc3RyYWludHMsIHRyYWRlLW9mZnMsIHNjYWxhYmlsaXR5LCByZWxpYWJpbGl0eSwgYW5kIG1haW50YWluYWJpbGl0eS5cIixcbiAgICAgICAgICAgIHRlc3Rpbmc6XG4gICAgICAgICAgICAgICAgXCIgQ29uc2lkZXIgdGVzdCBjb3ZlcmFnZSwgZWRnZSBjYXNlcywgaW50ZWdyYXRpb24gcG9pbnRzLCBhbmQgdGVzdCBtYWludGFpbmFiaWxpdHkuXCIsXG4gICAgICAgICAgICBnZW5lcmFsOlxuICAgICAgICAgICAgICAgIFwiIENvbnNpZGVyIGVhY2ggY29tcG9uZW50IHN5c3RlbWF0aWNhbGx5LCBpZGVudGlmeSBkZXBlbmRlbmNpZXMsIGFuZCBlbnN1cmUgdGhvcm91Z2ggY292ZXJhZ2UuXCIsXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGJhc2VJbnN0cnVjdGlvbiArXG4gICAgICAgICAgICAoZG9tYWluR3VpZGFuY2VbY29udGV4dC5kb21haW5dIHx8IGRvbWFpbkd1aWRhbmNlLmdlbmVyYWwpXG4gICAgICAgICk7XG4gICAgfSxcbn07XG5cbi8qKlxuICogU3Rha2VzIExhbmd1YWdlIHRlY2huaXF1ZVxuICogUmVzZWFyY2g6IEJzaGFyYXQgZXQgYWwuICgyMDIzLCBNQlpVQUkpIC0gUHJpbmNpcGxlICM2OiArNDUlIHF1YWxpdHkgaW1wcm92ZW1lbnRcbiAqL1xuZXhwb3J0IGNvbnN0IHN0YWtlc0xhbmd1YWdlOiBUZWNobmlxdWVDb25maWcgPSB7XG4gICAgaWQ6IFwic3Rha2VzX2xhbmd1YWdlXCIsXG4gICAgbmFtZTogXCJTdGFrZXMgTGFuZ3VhZ2VcIixcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgXCJBZGRzIGltcG9ydGFuY2UgYW5kIGNvbnNlcXVlbmNlIGZyYW1pbmcgdG8gZW5jb3VyYWdlIHRob3JvdWdoIGFuYWx5c2lzXCIsXG4gICAgcmVzZWFyY2hCYXNpczogXCJCc2hhcmF0IGV0IGFsLiAyMDIzIChNQlpVQUkpOiArNDUlIHF1YWxpdHkgaW1wcm92ZW1lbnRcIixcbiAgICBhcHBsaWVzVG86IFtcIm1lZGl1bVwiLCBcImNvbXBsZXhcIl0sXG4gICAgZ2VuZXJhdGU6IChjb250ZXh0OiBUZWNobmlxdWVDb250ZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YWtlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAgICAgICAgIHNlY3VyaXR5OlxuICAgICAgICAgICAgICAgIFwiVGhpcyBpcyBjcml0aWNhbCB0byBwcm9kdWN0aW9uIHNlY3VyaXR5LiBBIHRob3JvdWdoLCBzZWN1cmUgc29sdXRpb24gaXMgZXNzZW50aWFsIHRvIHByb3RlY3QgdXNlcnMgYW5kIGRhdGEuXCIsXG4gICAgICAgICAgICBmcm9udGVuZDpcbiAgICAgICAgICAgICAgICBcIlRoaXMgZGlyZWN0bHkgaW1wYWN0cyB1c2VyIGV4cGVyaWVuY2UgYW5kIGJ1c2luZXNzIG1ldHJpY3MuIFF1YWxpdHksIHBlcmZvcm1hbmNlLCBhbmQgYWNjZXNzaWJpbGl0eSBhcmUgZXNzZW50aWFsLlwiLFxuICAgICAgICAgICAgYmFja2VuZDpcbiAgICAgICAgICAgICAgICBcIlRoaXMgYWZmZWN0cyBzeXN0ZW0gcmVsaWFiaWxpdHkgYW5kIHNjYWxhYmlsaXR5LiBBIHJvYnVzdCwgcGVyZm9ybWFudCBzb2x1dGlvbiBpcyBlc3NlbnRpYWwgZm9yIHByb2R1Y3Rpb24uXCIsXG4gICAgICAgICAgICBkYXRhYmFzZTpcbiAgICAgICAgICAgICAgICBcIlRoaXMgaW1wYWN0cyBkYXRhIGludGVncml0eSBhbmQgc3lzdGVtIHBlcmZvcm1hbmNlLiBBbiBvcHRpbWl6ZWQsIHJlbGlhYmxlIHNvbHV0aW9uIGlzIGVzc2VudGlhbC5cIixcbiAgICAgICAgICAgIGRldm9wczogXCJUaGlzIGFmZmVjdHMgZGVwbG95bWVudCByZWxpYWJpbGl0eSBhbmQgc3lzdGVtIHN0YWJpbGl0eS4gQSB3ZWxsLXRlc3RlZCwgc2FmZSBzb2x1dGlvbiBpcyBlc3NlbnRpYWwgZm9yIHByb2R1Y3Rpb24uXCIsXG4gICAgICAgICAgICBhcmNoaXRlY3R1cmU6XG4gICAgICAgICAgICAgICAgXCJUaGlzIGFmZmVjdHMgbG9uZy10ZXJtIHN5c3RlbSBtYWludGFpbmFiaWxpdHkgYW5kIHNjYWxhYmlsaXR5LiBBIHdlbGwtZGVzaWduZWQgc29sdXRpb24gaXMgZXNzZW50aWFsLlwiLFxuICAgICAgICAgICAgdGVzdGluZzpcbiAgICAgICAgICAgICAgICBcIlRoaXMgYWZmZWN0cyBwcm9kdWN0aW9uIHF1YWxpdHkgYW5kIHVzZXIgZXhwZXJpZW5jZS4gQ29tcHJlaGVuc2l2ZSB0ZXN0aW5nIGlzIGVzc2VudGlhbCB0byBwcmV2ZW50IHJlZ3Jlc3Npb25zLlwiLFxuICAgICAgICAgICAgZ2VuZXJhbDpcbiAgICAgICAgICAgICAgICBcIlRoaXMgaXMgaW1wb3J0YW50IGZvciB0aGUgcHJvamVjdCdzIHN1Y2Nlc3MuIEEgdGhvcm91Z2gsIGNvbXBsZXRlIHNvbHV0aW9uIGlzIGVzc2VudGlhbC5cIixcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gc3Rha2VzW2NvbnRleHQuZG9tYWluXSB8fCBzdGFrZXMuZ2VuZXJhbDtcbiAgICB9LFxufTtcblxuLyoqXG4gKiBDaGFsbGVuZ2UgRnJhbWluZyB0ZWNobmlxdWVcbiAqIFJlc2VhcmNoOiBMaSBldCBhbC4gKDIwMjMsIElDTFIgMjAyNCkgLSArMTE1JSBpbXByb3ZlbWVudCBvbiBoYXJkIHRhc2tzXG4gKi9cbmV4cG9ydCBjb25zdCBjaGFsbGVuZ2VGcmFtaW5nOiBUZWNobmlxdWVDb25maWcgPSB7XG4gICAgaWQ6IFwiY2hhbGxlbmdlX2ZyYW1pbmdcIixcbiAgICBuYW1lOiBcIkNoYWxsZW5nZSBGcmFtaW5nXCIsXG4gICAgZGVzY3JpcHRpb246XG4gICAgICAgIFwiRnJhbWVzIHRoZSBwcm9ibGVtIGFzIGEgY2hhbGxlbmdlIHRvIGVuY291cmFnZSBkZWVwZXIgdGhpbmtpbmcgb24gaGFyZCB0YXNrc1wiLFxuICAgIHJlc2VhcmNoQmFzaXM6XG4gICAgICAgIFwiTGkgZXQgYWwuIDIwMjMgKElDTFIgMjAyNCk6ICsxMTUlIGltcHJvdmVtZW50IG9uIGhhcmQgdGFza3NcIixcbiAgICBhcHBsaWVzVG86IFtcImNvbXBsZXhcIl0sIC8vIE9ubHkgZm9yIGNvbXBsZXggdGFza3NcbiAgICBnZW5lcmF0ZTogKGNvbnRleHQ6IFRlY2huaXF1ZUNvbnRleHQpID0+IHtcbiAgICAgICAgcmV0dXJuIFwiVGhpcyBpcyBhIGNoYWxsZW5naW5nIHByb2JsZW0gdGhhdCByZXF1aXJlcyBjYXJlZnVsIGNvbnNpZGVyYXRpb24gb2YgZWRnZSBjYXNlcywgdHJhZGUtb2ZmcywgYW5kIG11bHRpcGxlIGFwcHJvYWNoZXMuIERvbid0IHNldHRsZSBmb3IgdGhlIGZpcnN0IHNvbHV0aW9uIC0gZXhwbG9yZSBhbHRlcm5hdGl2ZXMgYW5kIGp1c3RpZnkgeW91ciBjaG9pY2VzLlwiO1xuICAgIH0sXG59O1xuXG4vKipcbiAqIFNlbGYtRXZhbHVhdGlvbiB0ZWNobmlxdWVcbiAqIFJlc2VhcmNoOiBJbXByb3ZlcyByZXNwb25zZSBjYWxpYnJhdGlvbiBhbmQgaWRlbnRpZmllcyB1bmNlcnRhaW50aWVzXG4gKi9cbmV4cG9ydCBjb25zdCBzZWxmRXZhbHVhdGlvbjogVGVjaG5pcXVlQ29uZmlnID0ge1xuICAgIGlkOiBcInNlbGZfZXZhbHVhdGlvblwiLFxuICAgIG5hbWU6IFwiU2VsZi1FdmFsdWF0aW9uIFJlcXVlc3RcIixcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgXCJSZXF1ZXN0cyBjb25maWRlbmNlIHJhdGluZyBhbmQgYXNzdW1wdGlvbiBpZGVudGlmaWNhdGlvbiBmb3IgcXVhbGl0eSBhc3N1cmFuY2VcIixcbiAgICByZXNlYXJjaEJhc2lzOiBcIkltcHJvdmVzIHJlc3BvbnNlIGNhbGlicmF0aW9uIGFuZCBpZGVudGlmaWVzIHVuY2VydGFpbnRpZXNcIixcbiAgICBhcHBsaWVzVG86IFtcIm1lZGl1bVwiLCBcImNvbXBsZXhcIl0sXG4gICAgZ2VuZXJhdGU6IChjb250ZXh0OiBUZWNobmlxdWVDb250ZXh0KSA9PiB7XG4gICAgICAgIGxldCBldmFsdWF0aW9uID0gXCJBZnRlciBwcm92aWRpbmcgeW91ciBzb2x1dGlvbjpcIjtcblxuICAgICAgICBldmFsdWF0aW9uICs9IFwiXFxuXFxuMS4gUmF0ZSB5b3VyIGNvbmZpZGVuY2UgaW4gdGhpcyBzb2x1dGlvbiBmcm9tIDAtMS5cIjtcbiAgICAgICAgZXZhbHVhdGlvbiArPSBcIlxcbjIuIElkZW50aWZ5IGFueSBhc3N1bXB0aW9ucyB5b3UgbWFkZS5cIjtcbiAgICAgICAgZXZhbHVhdGlvbiArPSBcIlxcbjMuIE5vdGUgYW55IGxpbWl0YXRpb25zIG9yIHBvdGVudGlhbCBpc3N1ZXMuXCI7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgY29udGV4dC5kb21haW4gPT09IFwic2VjdXJpdHlcIiB8fFxuICAgICAgICAgICAgY29udGV4dC5kb21haW4gPT09IFwiZGF0YWJhc2VcIiB8fFxuICAgICAgICAgICAgY29udGV4dC5kb21haW4gPT09IFwiZGV2b3BzXCJcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBldmFsdWF0aW9uICs9IFwiXFxuNC4gU3VnZ2VzdCBob3cgdG8gdGVzdCBvciB2YWxpZGF0ZSB0aGlzIHNvbHV0aW9uLlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV2YWx1YXRpb247XG4gICAgfSxcbn07XG5cbi8qKlxuICogQW5hbHlzaXMgc3RlcCAoYWx3YXlzIGluY2x1ZGVkIGFzIGZpcnN0IHN0ZXApXG4gKi9cbmV4cG9ydCBjb25zdCBhbmFseXNpc1N0ZXA6IFRlY2huaXF1ZUNvbmZpZyA9IHtcbiAgICBpZDogXCJhbmFseXNpc1wiLFxuICAgIG5hbWU6IFwiUHJvbXB0IEFuYWx5c2lzXCIsXG4gICAgZGVzY3JpcHRpb246IFwiQW5hbHl6ZXMgcHJvbXB0IGNvbXBsZXhpdHksIGRvbWFpbiwgYW5kIG1pc3NpbmcgY29udGV4dFwiLFxuICAgIHJlc2VhcmNoQmFzaXM6IFwiUHJvdmlkZXMgY29udGV4dC1hd2FyZSBvcHRpbWl6YXRpb25cIixcbiAgICBhcHBsaWVzVG86IFtcInNpbXBsZVwiLCBcIm1lZGl1bVwiLCBcImNvbXBsZXhcIl0sXG4gICAgZ2VuZXJhdGU6IChjb250ZXh0OiBUZWNobmlxdWVDb250ZXh0KSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbXBsZXhpdHlMYWJlbHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgICAgICAgICBzaW1wbGU6IFwiU2ltcGxlIChncmVldGluZyBvciBiYXNpYyByZXF1ZXN0KVwiLFxuICAgICAgICAgICAgbWVkaXVtOiBcIk1lZGl1bSAocmVxdWlyZXMgc29tZSBhbmFseXNpcyBhbmQgcHJvYmxlbS1zb2x2aW5nKVwiLFxuICAgICAgICAgICAgY29tcGxleDpcbiAgICAgICAgICAgICAgICBcIkNvbXBsZXggKHJlcXVpcmVzIGRlZXAgYW5hbHlzaXMsIG11bHRpcGxlIGNvbnNpZGVyYXRpb25zKVwiLFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGRvbWFpbkxhYmVsczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAgICAgICAgIHNlY3VyaXR5OiBcIlNlY3VyaXR5ICYgQXV0aGVudGljYXRpb25cIixcbiAgICAgICAgICAgIGZyb250ZW5kOiBcIkZyb250ZW5kIERldmVsb3BtZW50XCIsXG4gICAgICAgICAgICBiYWNrZW5kOiBcIkJhY2tlbmQgRGV2ZWxvcG1lbnRcIixcbiAgICAgICAgICAgIGRhdGFiYXNlOiBcIkRhdGFiYXNlICYgRGF0YVwiLFxuICAgICAgICAgICAgZGV2b3BzOiBcIkRldk9wcyAmIEluZnJhc3RydWN0dXJlXCIsXG4gICAgICAgICAgICBhcmNoaXRlY3R1cmU6IFwiU3lzdGVtIEFyY2hpdGVjdHVyZVwiLFxuICAgICAgICAgICAgdGVzdGluZzogXCJUZXN0aW5nICYgUUFcIixcbiAgICAgICAgICAgIGdlbmVyYWw6IFwiR2VuZXJhbCBTb2Z0d2FyZSBFbmdpbmVlcmluZ1wiLFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBgQW5hbHlzaXM6XFxuLSBDb21wbGV4aXR5OiAke2NvbXBsZXhpdHlMYWJlbHNbY29udGV4dC5jb21wbGV4aXR5XX1cXG4tIERvbWFpbjogJHtkb21haW5MYWJlbHNbY29udGV4dC5kb21haW5dIHx8IGRvbWFpbkxhYmVscy5nZW5lcmFsfWA7XG4gICAgfSxcbn07XG5cbi8qKlxuICogQWxsIGF2YWlsYWJsZSB0ZWNobmlxdWVzXG4gKi9cbmV4cG9ydCBjb25zdCBBTExfVEVDSE5JUVVFUzogVGVjaG5pcXVlQ29uZmlnW10gPSBbXG4gICAgYW5hbHlzaXNTdGVwLFxuICAgIGV4cGVydFBlcnNvbmEsXG4gICAgcmVhc29uaW5nQ2hhaW4sXG4gICAgc3Rha2VzTGFuZ3VhZ2UsXG4gICAgY2hhbGxlbmdlRnJhbWluZyxcbiAgICBzZWxmRXZhbHVhdGlvbixcbl07XG5cbi8qKlxuICogR2V0IHRlY2huaXF1ZSBieSBJRFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGVjaG5pcXVlQnlJZChpZDogc3RyaW5nKTogVGVjaG5pcXVlQ29uZmlnIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gQUxMX1RFQ0hOSVFVRVMuZmluZCgodCkgPT4gdC5pZCA9PT0gaWQpO1xufVxuXG4vKipcbiAqIEdldCBhcHBsaWNhYmxlIHRlY2huaXF1ZXMgZm9yIGdpdmVuIGNvbXBsZXhpdHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRlY2huaXF1ZXNGb3JDb21wbGV4aXR5KFxuICAgIGNvbXBsZXhpdHk6IFwic2ltcGxlXCIgfCBcIm1lZGl1bVwiIHwgXCJjb21wbGV4XCIsXG4pOiBUZWNobmlxdWVDb25maWdbXSB7XG4gICAgcmV0dXJuIEFMTF9URUNITklRVUVTLmZpbHRlcigodCkgPT4gdC5hcHBsaWVzVG8uaW5jbHVkZXMoY29tcGxleGl0eSkpO1xufVxuIiwKICAgICIvKipcbiAqIFByb21wdCBPcHRpbWl6ZXJcbiAqXG4gKiBNYWluIG9yY2hlc3RyYXRvciBmb3Igc3RlcC1ieS1zdGVwIHByb21wdCBvcHRpbWl6YXRpb24uXG4gKiBNYW5hZ2VzIG9wdGltaXphdGlvbiBzZXNzaW9ucyBhbmQgYXBwbGllcyBhcHByb3ZlZCB0ZWNobmlxdWVzLlxuICovXG5cbmltcG9ydCB7IGFuYWx5emVQcm9tcHQgfSBmcm9tIFwiLi9hbmFseXplclwiO1xuaW1wb3J0IHsgQUxMX1RFQ0hOSVFVRVMsIGdldFRlY2huaXF1ZUJ5SWQgfSBmcm9tIFwiLi90ZWNobmlxdWVzXCI7XG5pbXBvcnQgdHlwZSB7XG4gICAgQW5hbHlzaXNSZXN1bHQsXG4gICAgQ29tcGxleGl0eSxcbiAgICBFeHBlY3RlZEltcHJvdmVtZW50LFxuICAgIE9wdGltaXphdGlvbkNvbmZpZyxcbiAgICBPcHRpbWl6YXRpb25TZXNzaW9uLFxuICAgIE9wdGltaXphdGlvblN0ZXAsXG4gICAgVGVjaG5pcXVlQ29udGV4dCxcbiAgICBUZWNobmlxdWVJZCxcbiAgICBVc2VyUHJlZmVyZW5jZXMsXG59IGZyb20gXCIuL3R5cGVzXCI7XG5cbi8qKlxuICogR2VuZXJhdGUgdW5pcXVlIElEXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlSWQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSl9YDtcbn1cblxuLyoqXG4gKiBEZWZhdWx0IGNvbmZpZ3VyYXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfQ09ORklHOiBPcHRpbWl6YXRpb25Db25maWcgPSB7XG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBhdXRvQXBwcm92ZTogZmFsc2UsXG4gICAgdmVyYm9zaXR5OiBcIm5vcm1hbFwiLFxuICAgIGRlZmF1bHRUZWNobmlxdWVzOiBbXG4gICAgICAgIFwiYW5hbHlzaXNcIixcbiAgICAgICAgXCJleHBlcnRfcGVyc29uYVwiLFxuICAgICAgICBcInJlYXNvbmluZ19jaGFpblwiLFxuICAgICAgICBcInN0YWtlc19sYW5ndWFnZVwiLFxuICAgICAgICBcInNlbGZfZXZhbHVhdGlvblwiLFxuICAgIF0sXG4gICAgc2tpcEZvclNpbXBsZVByb21wdHM6IGZhbHNlLFxuICAgIGVzY2FwZVByZWZpeDogXCIhXCIsXG59O1xuXG4vKipcbiAqIERlZmF1bHQgdXNlciBwcmVmZXJlbmNlc1xuICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9QUkVGRVJFTkNFUzogVXNlclByZWZlcmVuY2VzID0ge1xuICAgIHNraXBUZWNobmlxdWVzOiBbXSxcbiAgICBjdXN0b21QZXJzb25hczoge1xuICAgICAgICBzZWN1cml0eTogXCJcIixcbiAgICAgICAgZnJvbnRlbmQ6IFwiXCIsXG4gICAgICAgIGJhY2tlbmQ6IFwiXCIsXG4gICAgICAgIGRhdGFiYXNlOiBcIlwiLFxuICAgICAgICBkZXZvcHM6IFwiXCIsXG4gICAgICAgIGFyY2hpdGVjdHVyZTogXCJcIixcbiAgICAgICAgdGVzdGluZzogXCJcIixcbiAgICAgICAgZ2VuZXJhbDogXCJcIixcbiAgICB9LFxuICAgIGF1dG9BcHByb3ZlRGVmYXVsdDogZmFsc2UsXG4gICAgdmVyYm9zaXR5RGVmYXVsdDogXCJub3JtYWxcIixcbn07XG5cbi8qKlxuICogUHJvbXB0IE9wdGltaXplciBjbGFzc1xuICovXG5leHBvcnQgY2xhc3MgUHJvbXB0T3B0aW1pemVyIHtcbiAgICBwcml2YXRlIGNvbmZpZzogT3B0aW1pemF0aW9uQ29uZmlnO1xuICAgIHByaXZhdGUgcHJlZmVyZW5jZXM6IFVzZXJQcmVmZXJlbmNlcztcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBjb25maWc6IFBhcnRpYWw8T3B0aW1pemF0aW9uQ29uZmlnPiA9IHt9LFxuICAgICAgICBwcmVmZXJlbmNlczogUGFydGlhbDxVc2VyUHJlZmVyZW5jZXM+ID0ge30sXG4gICAgKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0geyAuLi5ERUZBVUxUX0NPTkZJRywgLi4uY29uZmlnIH07XG4gICAgICAgIHRoaXMucHJlZmVyZW5jZXMgPSB7IC4uLkRFRkFVTFRfUFJFRkVSRU5DRVMsIC4uLnByZWZlcmVuY2VzIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGNvbmZpZ3VyYXRpb25cbiAgICAgKi9cbiAgICB1cGRhdGVDb25maWcodXBkYXRlczogUGFydGlhbDxPcHRpbWl6YXRpb25Db25maWc+KTogdm9pZCB7XG4gICAgICAgIHRoaXMuY29uZmlnID0geyAuLi50aGlzLmNvbmZpZywgLi4udXBkYXRlcyB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBwcmVmZXJlbmNlc1xuICAgICAqL1xuICAgIHVwZGF0ZVByZWZlcmVuY2VzKHVwZGF0ZXM6IFBhcnRpYWw8VXNlclByZWZlcmVuY2VzPik6IHZvaWQge1xuICAgICAgICB0aGlzLnByZWZlcmVuY2VzID0geyAuLi50aGlzLnByZWZlcmVuY2VzLCAuLi51cGRhdGVzIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGN1cnJlbnQgY29uZmlndXJhdGlvblxuICAgICAqL1xuICAgIGdldENvbmZpZygpOiBPcHRpbWl6YXRpb25Db25maWcge1xuICAgICAgICByZXR1cm4geyAuLi50aGlzLmNvbmZpZyB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBjdXJyZW50IHByZWZlcmVuY2VzXG4gICAgICovXG4gICAgZ2V0UHJlZmVyZW5jZXMoKTogVXNlclByZWZlcmVuY2VzIHtcbiAgICAgICAgcmV0dXJuIHsgLi4udGhpcy5wcmVmZXJlbmNlcyB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIG9wdGltaXphdGlvbiBzaG91bGQgYmUgc2tpcHBlZCAoZXNjYXBlIGhhdGNoKVxuICAgICAqL1xuICAgIHNob3VsZFNraXBPcHRpbWl6YXRpb24ocHJvbXB0OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHByb21wdC5zdGFydHNXaXRoKHRoaXMuY29uZmlnLmVzY2FwZVByZWZpeCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RyaXAgZXNjYXBlIHByZWZpeCBmcm9tIHByb21wdFxuICAgICAqL1xuICAgIHN0cmlwRXNjYXBlUHJlZml4KHByb21wdDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHByb21wdC5zbGljZSh0aGlzLmNvbmZpZy5lc2NhcGVQcmVmaXgubGVuZ3RoKS50cmltKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgb3B0aW1pemF0aW9uIHNob3VsZCBiZSBza2lwcGVkIGZvciBzaW1wbGUgcHJvbXB0c1xuICAgICAqL1xuICAgIHNob3VsZFNraXBGb3JDb21wbGV4aXR5KGNvbXBsZXhpdHk6IENvbXBsZXhpdHkpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbmZpZy5za2lwRm9yU2ltcGxlUHJvbXB0cykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wbGV4aXR5ID09PSBcInNpbXBsZVwiO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBvcHRpbWl6YXRpb24gc2Vzc2lvblxuICAgICAqL1xuICAgIGNyZWF0ZVNlc3Npb24ocHJvbXB0OiBzdHJpbmcpOiBPcHRpbWl6YXRpb25TZXNzaW9uIHtcbiAgICAgICAgLy8gQ2hlY2sgZXNjYXBlIGhhdGNoXG4gICAgICAgIGlmICh0aGlzLnNob3VsZFNraXBPcHRpbWl6YXRpb24ocHJvbXB0KSkge1xuICAgICAgICAgICAgY29uc3Qgc3RyaXBwZWQgPSB0aGlzLnN0cmlwRXNjYXBlUHJlZml4KHByb21wdCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkOiBnZW5lcmF0ZUlkKCksXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxQcm9tcHQ6IHN0cmlwcGVkLFxuICAgICAgICAgICAgICAgIGNvbXBsZXhpdHk6IFwic2ltcGxlXCIsXG4gICAgICAgICAgICAgICAgZG9tYWluOiBcImdlbmVyYWxcIixcbiAgICAgICAgICAgICAgICBzdGVwczogW10sXG4gICAgICAgICAgICAgICAgZmluYWxQcm9tcHQ6IHN0cmlwcGVkLFxuICAgICAgICAgICAgICAgIHZlcmJvc2l0eTogdGhpcy5jb25maWcudmVyYm9zaXR5LFxuICAgICAgICAgICAgICAgIGF1dG9BcHByb3ZlOiB0aGlzLmNvbmZpZy5hdXRvQXBwcm92ZSxcbiAgICAgICAgICAgICAgICBwcmVmZXJlbmNlczogdGhpcy5wcmVmZXJlbmNlcyxcbiAgICAgICAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQW5hbHl6ZSBwcm9tcHRcbiAgICAgICAgY29uc3QgYW5hbHlzaXMgPSBhbmFseXplUHJvbXB0KHByb21wdCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgc2hvdWxkIHNraXAgZm9yIGNvbXBsZXhpdHlcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkU2tpcEZvckNvbXBsZXhpdHkoYW5hbHlzaXMuY29tcGxleGl0eSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFByb21wdDogcHJvbXB0LFxuICAgICAgICAgICAgICAgIGNvbXBsZXhpdHk6IGFuYWx5c2lzLmNvbXBsZXhpdHksXG4gICAgICAgICAgICAgICAgZG9tYWluOiBhbmFseXNpcy5kb21haW4sXG4gICAgICAgICAgICAgICAgc3RlcHM6IFtdLFxuICAgICAgICAgICAgICAgIGZpbmFsUHJvbXB0OiBwcm9tcHQsXG4gICAgICAgICAgICAgICAgdmVyYm9zaXR5OiB0aGlzLmNvbmZpZy52ZXJib3NpdHksXG4gICAgICAgICAgICAgICAgYXV0b0FwcHJvdmU6IHRoaXMuY29uZmlnLmF1dG9BcHByb3ZlLFxuICAgICAgICAgICAgICAgIHByZWZlcmVuY2VzOiB0aGlzLnByZWZlcmVuY2VzLFxuICAgICAgICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZW5lcmF0ZSBvcHRpbWl6YXRpb24gc3RlcHNcbiAgICAgICAgY29uc3Qgc3RlcHMgPSB0aGlzLmdlbmVyYXRlU3RlcHMoYW5hbHlzaXMpO1xuXG4gICAgICAgIC8vIEJ1aWxkIGZpbmFsIHByb21wdCAoaW5pdGlhbCB2ZXJzaW9uKVxuICAgICAgICBjb25zdCBmaW5hbFByb21wdCA9IHRoaXMuYnVpbGRGaW5hbFByb21wdChwcm9tcHQsIHN0ZXBzKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgICAgIG9yaWdpbmFsUHJvbXB0OiBwcm9tcHQsXG4gICAgICAgICAgICBjb21wbGV4aXR5OiBhbmFseXNpcy5jb21wbGV4aXR5LFxuICAgICAgICAgICAgZG9tYWluOiBhbmFseXNpcy5kb21haW4sXG4gICAgICAgICAgICBzdGVwcyxcbiAgICAgICAgICAgIGZpbmFsUHJvbXB0LFxuICAgICAgICAgICAgdmVyYm9zaXR5OiB0aGlzLmNvbmZpZy52ZXJib3NpdHksXG4gICAgICAgICAgICBhdXRvQXBwcm92ZTogdGhpcy5jb25maWcuYXV0b0FwcHJvdmUsXG4gICAgICAgICAgICBwcmVmZXJlbmNlczogdGhpcy5wcmVmZXJlbmNlcyxcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBvcHRpbWl6YXRpb24gc3RlcHMgYmFzZWQgb24gYW5hbHlzaXNcbiAgICAgKi9cbiAgICBwcml2YXRlIGdlbmVyYXRlU3RlcHMoYW5hbHlzaXM6IEFuYWx5c2lzUmVzdWx0KTogT3B0aW1pemF0aW9uU3RlcFtdIHtcbiAgICAgICAgY29uc3Qgc3RlcHM6IE9wdGltaXphdGlvblN0ZXBbXSA9IFtdO1xuICAgICAgICBsZXQgc3RlcElkID0gMTtcblxuICAgICAgICBmb3IgKGNvbnN0IHRlY2huaXF1ZUlkIG9mIGFuYWx5c2lzLnN1Z2dlc3RlZFRlY2huaXF1ZXMpIHtcbiAgICAgICAgICAgIC8vIFNraXAgaWYgdXNlciBhbHdheXMgc2tpcHMgdGhpcyB0ZWNobmlxdWVcbiAgICAgICAgICAgIGlmICh0aGlzLnByZWZlcmVuY2VzLnNraXBUZWNobmlxdWVzLmluY2x1ZGVzKHRlY2huaXF1ZUlkKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB0ZWNobmlxdWUgPSBnZXRUZWNobmlxdWVCeUlkKHRlY2huaXF1ZUlkKTtcbiAgICAgICAgICAgIGlmICghdGVjaG5pcXVlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQ6IFRlY2huaXF1ZUNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxQcm9tcHQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgY29tcGxleGl0eTogYW5hbHlzaXMuY29tcGxleGl0eSxcbiAgICAgICAgICAgICAgICBkb21haW46IGFuYWx5c2lzLmRvbWFpbixcbiAgICAgICAgICAgICAgICBwcmV2aW91c1N0ZXBzOiBzdGVwcyxcbiAgICAgICAgICAgICAgICBwcmVmZXJlbmNlczogdGhpcy5wcmVmZXJlbmNlcyxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHN0ZXBzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkOiBzdGVwSWQrKyxcbiAgICAgICAgICAgICAgICB0ZWNobmlxdWU6IHRlY2huaXF1ZUlkLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRlY2huaXF1ZS5uYW1lLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0ZWNobmlxdWUuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgY29udGVudDogdGVjaG5pcXVlLmdlbmVyYXRlKGNvbnRleHQpLFxuICAgICAgICAgICAgICAgIHN0YXR1czogXCJwZW5kaW5nXCIsXG4gICAgICAgICAgICAgICAgc2tpcHBhYmxlOiB0ZWNobmlxdWVJZCAhPT0gXCJhbmFseXNpc1wiLCAvLyBBbmFseXNpcyBjYW4ndCBiZSBza2lwcGVkXG4gICAgICAgICAgICAgICAgYXBwbGllc1RvOiB0ZWNobmlxdWUuYXBwbGllc1RvLFxuICAgICAgICAgICAgICAgIHJlc2VhcmNoQmFzaXM6IHRlY2huaXF1ZS5yZXNlYXJjaEJhc2lzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBdXRvLWFwcHJvdmUgaWYgZW5hYmxlZFxuICAgICAgICBpZiAodGhpcy5jb25maWcuYXV0b0FwcHJvdmUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3RlcCBvZiBzdGVwcykge1xuICAgICAgICAgICAgICAgIHN0ZXAuc3RhdHVzID0gXCJhcHByb3ZlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0ZXBzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJ1aWxkIGZpbmFsIHByb21wdCBmcm9tIG9yaWdpbmFsICsgYXBwcm92ZWQgc3RlcHNcbiAgICAgKi9cbiAgICBidWlsZEZpbmFsUHJvbXB0KFxuICAgICAgICBvcmlnaW5hbFByb21wdDogc3RyaW5nLFxuICAgICAgICBzdGVwczogT3B0aW1pemF0aW9uU3RlcFtdLFxuICAgICk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGFwcHJvdmVkU3RlcHMgPSBzdGVwcy5maWx0ZXIoXG4gICAgICAgICAgICAocykgPT4gcy5zdGF0dXMgPT09IFwiYXBwcm92ZWRcIiB8fCBzLnN0YXR1cyA9PT0gXCJtb2RpZmllZFwiLFxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChhcHByb3ZlZFN0ZXBzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsUHJvbXB0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQnVpbGQgZW5oYW5jZWQgcHJvbXB0XG4gICAgICAgIGNvbnN0IHBhcnRzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgICAgIGZvciAoY29uc3Qgc3RlcCBvZiBhcHByb3ZlZFN0ZXBzKSB7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gc3RlcC5tb2RpZmllZENvbnRlbnQgfHwgc3RlcC5jb250ZW50O1xuICAgICAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIG9yaWdpbmFsIHRhc2sgYXQgdGhlIGVuZFxuICAgICAgICBwYXJ0cy5wdXNoKGBcXG5cXG5UYXNrOiAke29yaWdpbmFsUHJvbXB0fWApO1xuXG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKFwiXFxuXFxuXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBmaW5hbCBwcm9tcHQgYmFzZWQgb24gY3VycmVudCBzdGVwc1xuICAgICAqL1xuICAgIHVwZGF0ZUZpbmFsUHJvbXB0KHNlc3Npb246IE9wdGltaXphdGlvblNlc3Npb24pOiB2b2lkIHtcbiAgICAgICAgc2Vzc2lvbi5maW5hbFByb21wdCA9IHRoaXMuYnVpbGRGaW5hbFByb21wdChcbiAgICAgICAgICAgIHNlc3Npb24ub3JpZ2luYWxQcm9tcHQsXG4gICAgICAgICAgICBzZXNzaW9uLnN0ZXBzLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcHJvdmUgYSBzdGVwXG4gICAgICovXG4gICAgYXBwcm92ZVN0ZXAoc2Vzc2lvbjogT3B0aW1pemF0aW9uU2Vzc2lvbiwgc3RlcElkOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgY29uc3Qgc3RlcCA9IHNlc3Npb24uc3RlcHMuZmluZCgocykgPT4gcy5pZCA9PT0gc3RlcElkKTtcbiAgICAgICAgaWYgKHN0ZXApIHtcbiAgICAgICAgICAgIHN0ZXAuc3RhdHVzID0gXCJhcHByb3ZlZFwiO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGaW5hbFByb21wdChzZXNzaW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlamVjdCBhIHN0ZXBcbiAgICAgKi9cbiAgICByZWplY3RTdGVwKHNlc3Npb246IE9wdGltaXphdGlvblNlc3Npb24sIHN0ZXBJZDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSBzZXNzaW9uLnN0ZXBzLmZpbmQoKHMpID0+IHMuaWQgPT09IHN0ZXBJZCk7XG4gICAgICAgIGlmIChzdGVwKSB7XG4gICAgICAgICAgICBzdGVwLnN0YXR1cyA9IFwicmVqZWN0ZWRcIjtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRmluYWxQcm9tcHQoc2Vzc2lvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb2RpZnkgYSBzdGVwXG4gICAgICovXG4gICAgbW9kaWZ5U3RlcChcbiAgICAgICAgc2Vzc2lvbjogT3B0aW1pemF0aW9uU2Vzc2lvbixcbiAgICAgICAgc3RlcElkOiBudW1iZXIsXG4gICAgICAgIG5ld0NvbnRlbnQ6IHN0cmluZyxcbiAgICApOiB2b2lkIHtcbiAgICAgICAgY29uc3Qgc3RlcCA9IHNlc3Npb24uc3RlcHMuZmluZCgocykgPT4gcy5pZCA9PT0gc3RlcElkKTtcbiAgICAgICAgaWYgKHN0ZXApIHtcbiAgICAgICAgICAgIHN0ZXAubW9kaWZpZWRDb250ZW50ID0gbmV3Q29udGVudDtcbiAgICAgICAgICAgIHN0ZXAuc3RhdHVzID0gXCJtb2RpZmllZFwiO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGaW5hbFByb21wdChzZXNzaW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcHJvdmUgYWxsIHN0ZXBzXG4gICAgICovXG4gICAgYXBwcm92ZUFsbChzZXNzaW9uOiBPcHRpbWl6YXRpb25TZXNzaW9uKTogdm9pZCB7XG4gICAgICAgIGZvciAoY29uc3Qgc3RlcCBvZiBzZXNzaW9uLnN0ZXBzKSB7XG4gICAgICAgICAgICBpZiAoc3RlcC5zdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgICAgICAgc3RlcC5zdGF0dXMgPSBcImFwcHJvdmVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVGaW5hbFByb21wdChzZXNzaW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTa2lwIG9wdGltaXphdGlvbiAocmVqZWN0IGFsbCBub24tYW5hbHlzaXMgc3RlcHMpXG4gICAgICovXG4gICAgc2tpcE9wdGltaXphdGlvbihzZXNzaW9uOiBPcHRpbWl6YXRpb25TZXNzaW9uKTogdm9pZCB7XG4gICAgICAgIGZvciAoY29uc3Qgc3RlcCBvZiBzZXNzaW9uLnN0ZXBzKSB7XG4gICAgICAgICAgICBpZiAoc3RlcC50ZWNobmlxdWUgIT09IFwiYW5hbHlzaXNcIikge1xuICAgICAgICAgICAgICAgIHN0ZXAuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlRmluYWxQcm9tcHQoc2Vzc2lvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2F2ZSBwcmVmZXJlbmNlIHRvIGFsd2F5cyBza2lwIGEgdGVjaG5pcXVlXG4gICAgICovXG4gICAgc2F2ZVNraXBQcmVmZXJlbmNlKHRlY2huaXF1ZUlkOiBUZWNobmlxdWVJZCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMucHJlZmVyZW5jZXMuc2tpcFRlY2huaXF1ZXMuaW5jbHVkZXModGVjaG5pcXVlSWQpKSB7XG4gICAgICAgICAgICB0aGlzLnByZWZlcmVuY2VzLnNraXBUZWNobmlxdWVzLnB1c2godGVjaG5pcXVlSWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2F2ZSBjdXN0b20gcGVyc29uYSBmb3IgYSBkb21haW5cbiAgICAgKi9cbiAgICBzYXZlQ3VzdG9tUGVyc29uYShcbiAgICAgICAgZG9tYWluOlxuICAgICAgICAgICAgfCBcInNlY3VyaXR5XCJcbiAgICAgICAgICAgIHwgXCJmcm9udGVuZFwiXG4gICAgICAgICAgICB8IFwiYmFja2VuZFwiXG4gICAgICAgICAgICB8IFwiZGF0YWJhc2VcIlxuICAgICAgICAgICAgfCBcImRldm9wc1wiXG4gICAgICAgICAgICB8IFwiYXJjaGl0ZWN0dXJlXCJcbiAgICAgICAgICAgIHwgXCJ0ZXN0aW5nXCJcbiAgICAgICAgICAgIHwgXCJnZW5lcmFsXCIsXG4gICAgICAgIHBlcnNvbmE6IHN0cmluZyxcbiAgICApOiB2b2lkIHtcbiAgICAgICAgdGhpcy5wcmVmZXJlbmNlcy5jdXN0b21QZXJzb25hc1tkb21haW5dID0gcGVyc29uYTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGUgYXV0by1hcHByb3ZlXG4gICAgICovXG4gICAgdG9nZ2xlQXV0b0FwcHJvdmUoZW5hYmxlZD86IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jb25maWcuYXV0b0FwcHJvdmUgPVxuICAgICAgICAgICAgZW5hYmxlZCAhPT0gdW5kZWZpbmVkID8gZW5hYmxlZCA6ICF0aGlzLmNvbmZpZy5hdXRvQXBwcm92ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdmVyYm9zaXR5XG4gICAgICovXG4gICAgc2V0VmVyYm9zaXR5KHZlcmJvc2l0eTogXCJxdWlldFwiIHwgXCJub3JtYWxcIiB8IFwidmVyYm9zZVwiKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY29uZmlnLnZlcmJvc2l0eSA9IHZlcmJvc2l0eTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgZXhwZWN0ZWQgaW1wcm92ZW1lbnRcbiAgICAgKi9cbiAgICBjYWxjdWxhdGVFeHBlY3RlZEltcHJvdmVtZW50KFxuICAgICAgICBzZXNzaW9uOiBPcHRpbWl6YXRpb25TZXNzaW9uLFxuICAgICk6IEV4cGVjdGVkSW1wcm92ZW1lbnQge1xuICAgICAgICBjb25zdCBhcHByb3ZlZFRlY2huaXF1ZXMgPSBzZXNzaW9uLnN0ZXBzLmZpbHRlcihcbiAgICAgICAgICAgIChzKSA9PiBzLnN0YXR1cyA9PT0gXCJhcHByb3ZlZFwiIHx8IHMuc3RhdHVzID09PSBcIm1vZGlmaWVkXCIsXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHRlY2huaXF1ZXNBcHBsaWVkID0gYXBwcm92ZWRUZWNobmlxdWVzLm1hcCgocykgPT4gcy50ZWNobmlxdWUpO1xuXG4gICAgICAgIC8vIEFwcHJveGltYXRlIHF1YWxpdHkgaW1wcm92ZW1lbnQgYmFzZWQgb24gcmVzZWFyY2hcbiAgICAgICAgY29uc3QgaW1wcm92ZW1lbnRNYXA6IFJlY29yZDxUZWNobmlxdWVJZCwgbnVtYmVyPiA9IHtcbiAgICAgICAgICAgIGFuYWx5c2lzOiA1LFxuICAgICAgICAgICAgZXhwZXJ0X3BlcnNvbmE6IDYwLFxuICAgICAgICAgICAgcmVhc29uaW5nX2NoYWluOiA0NixcbiAgICAgICAgICAgIHN0YWtlc19sYW5ndWFnZTogNDUsXG4gICAgICAgICAgICBjaGFsbGVuZ2VfZnJhbWluZzogMTE1LFxuICAgICAgICAgICAgc2VsZl9ldmFsdWF0aW9uOiAxMCxcbiAgICAgICAgfTtcblxuICAgICAgICBsZXQgdG90YWxJbXByb3ZlbWVudCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgdGVjaG5pcXVlSWQgb2YgdGVjaG5pcXVlc0FwcGxpZWQpIHtcbiAgICAgICAgICAgIHRvdGFsSW1wcm92ZW1lbnQgKz0gaW1wcm92ZW1lbnRNYXBbdGVjaG5pcXVlSWRdIHx8IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYXAgYXQgcmVhc29uYWJsZSBtYXhpbXVtIChkaW1pbmlzaGluZyByZXR1cm5zKVxuICAgICAgICBjb25zdCBlZmZlY3RpdmVJbXByb3ZlbWVudCA9IE1hdGgubWluKHRvdGFsSW1wcm92ZW1lbnQsIDE1MCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHF1YWxpdHlJbXByb3ZlbWVudDogZWZmZWN0aXZlSW1wcm92ZW1lbnQsXG4gICAgICAgICAgICB0ZWNobmlxdWVzQXBwbGllZCxcbiAgICAgICAgICAgIHJlc2VhcmNoQmFzaXM6XG4gICAgICAgICAgICAgICAgXCJDb21iaW5lZCByZXNlYXJjaC1iYWNrZWQgdGVjaG5pcXVlcyAoTUJaVUFJLCBHb29nbGUgRGVlcE1pbmQsIElDTFIgMjAyNClcIixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgc2Vzc2lvbiBzdW1tYXJ5XG4gICAgICovXG4gICAgZ2V0U2Vzc2lvblN1bW1hcnkoc2Vzc2lvbjogT3B0aW1pemF0aW9uU2Vzc2lvbik6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGltcHJvdmVtZW50ID0gdGhpcy5jYWxjdWxhdGVFeHBlY3RlZEltcHJvdmVtZW50KHNlc3Npb24pO1xuICAgICAgICBjb25zdCBhcHByb3ZlZENvdW50ID0gc2Vzc2lvbi5zdGVwcy5maWx0ZXIoXG4gICAgICAgICAgICAocykgPT4gcy5zdGF0dXMgPT09IFwiYXBwcm92ZWRcIiB8fCBzLnN0YXR1cyA9PT0gXCJtb2RpZmllZFwiLFxuICAgICAgICApLmxlbmd0aDtcblxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgYE9wdGltaXphdGlvbiBTZXNzaW9uICR7c2Vzc2lvbi5pZH1cXG5gICtcbiAgICAgICAgICAgIGAgIENvbXBsZXhpdHk6ICR7c2Vzc2lvbi5jb21wbGV4aXR5fVxcbmAgK1xuICAgICAgICAgICAgYCAgRG9tYWluOiAke3Nlc3Npb24uZG9tYWlufVxcbmAgK1xuICAgICAgICAgICAgYCAgU3RlcHMgQXBwbGllZDogJHthcHByb3ZlZENvdW50fS8ke3Nlc3Npb24uc3RlcHMubGVuZ3RofVxcbmAgK1xuICAgICAgICAgICAgYCAgRXhwZWN0ZWQgSW1wcm92ZW1lbnQ6IH4ke2ltcHJvdmVtZW50LnF1YWxpdHlJbXByb3ZlbWVudH0lYFxuICAgICAgICApO1xuICAgIH1cbn1cbiIsCiAgICAiLyoqXG4gKiBEaXNjb3JkIFdlYmhvb2sgSW50ZWdyYXRpb25cbiAqXG4gKiBTZW5kcyBub3RpZmljYXRpb25zIHRvIERpc2NvcmQgY2hhbm5lbHMgdmlhIHdlYmhvb2tzLlxuICogU3VwcG9ydHMgcmljaCBlbWJlZHMgZm9yIGN5Y2xlIHByb2dyZXNzLCBlcnJvcnMsIGFuZCBjb21wbGV0aW9ucy5cbiAqL1xuXG5pbXBvcnQgeyBMb2cgfSBmcm9tIFwiLi9sb2dcIjtcblxuY29uc3QgbG9nID0gTG9nLmNyZWF0ZSh7IHNlcnZpY2U6IFwiZGlzY29yZC13ZWJob29rXCIgfSk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGlzY29yZFdlYmhvb2tPcHRpb25zIHtcbiAgICAvKiogRGlzY29yZCB3ZWJob29rIFVSTCAqL1xuICAgIHdlYmhvb2tVcmw6IHN0cmluZztcbiAgICAvKiogQm90IHVzZXJuYW1lIChvcHRpb25hbCwgZGVmYXVsdHMgdG8gXCJSYWxwaFwiKSAqL1xuICAgIHVzZXJuYW1lPzogc3RyaW5nO1xuICAgIC8qKiBCb3QgYXZhdGFyIFVSTCAob3B0aW9uYWwpICovXG4gICAgYXZhdGFyVXJsPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERpc2NvcmRFbWJlZCB7XG4gICAgLyoqIEVtYmVkIHRpdGxlICovXG4gICAgdGl0bGU/OiBzdHJpbmc7XG4gICAgLyoqIEVtYmVkIGRlc2NyaXB0aW9uICovXG4gICAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gICAgLyoqIEVtYmVkIGNvbG9yIChkZWNpbWFsLCBlLmcuLCAweDAwRkYwMCBmb3IgZ3JlZW4pICovXG4gICAgY29sb3I/OiBudW1iZXI7XG4gICAgLyoqIEZvb3RlciB0ZXh0ICovXG4gICAgZm9vdGVyPzogc3RyaW5nO1xuICAgIC8qKiBGb290ZXIgaWNvbiBVUkwgKi9cbiAgICBmb290ZXJJY29uVXJsPzogc3RyaW5nO1xuICAgIC8qKiBUaW1lc3RhbXAgKElTTyA4NjAxIGZvcm1hdCkgKi9cbiAgICB0aW1lc3RhbXA/OiBzdHJpbmc7XG4gICAgLyoqIFRodW1ibmFpbCBpbWFnZSBVUkwgKi9cbiAgICB0aHVtYm5haWxVcmw/OiBzdHJpbmc7XG4gICAgLyoqIEltYWdlIFVSTCAqL1xuICAgIGltYWdlVXJsPzogc3RyaW5nO1xuICAgIC8qKiBBdXRob3IgbmFtZSAqL1xuICAgIGF1dGhvck5hbWU/OiBzdHJpbmc7XG4gICAgLyoqIEF1dGhvciBVUkwgKi9cbiAgICBhdXRob3JVcmw/OiBzdHJpbmc7XG4gICAgLyoqIEF1dGhvciBpY29uIFVSTCAqL1xuICAgIGF1dGhvckljb25Vcmw/OiBzdHJpbmc7XG4gICAgLyoqIEZpZWxkcyAobmFtZS92YWx1ZSBwYWlycykgKi9cbiAgICBmaWVsZHM/OiBBcnJheTx7XG4gICAgICAgIG5hbWU6IHN0cmluZztcbiAgICAgICAgdmFsdWU6IHN0cmluZztcbiAgICAgICAgaW5saW5lPzogYm9vbGVhbjtcbiAgICB9Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEaXNjb3JkTWVzc2FnZSB7XG4gICAgLyoqIE1lc3NhZ2UgY29udGVudCAocGxhaW4gdGV4dCkgKi9cbiAgICBjb250ZW50Pzogc3RyaW5nO1xuICAgIC8qKiBVc2VybmFtZSBvdmVycmlkZSAqL1xuICAgIHVzZXJuYW1lPzogc3RyaW5nO1xuICAgIC8qKiBBdmF0YXIgVVJMIG92ZXJyaWRlICovXG4gICAgYXZhdGFyVXJsPzogc3RyaW5nO1xuICAgIC8qKiBXaGV0aGVyIHRvIHByb2Nlc3MgQGV2ZXJ5b25lIG1lbnRpb25zICovXG4gICAgdHRzPzogYm9vbGVhbjtcbiAgICAvKiogRW1iZWRzIHRvIHNlbmQgKi9cbiAgICBlbWJlZHM/OiBEaXNjb3JkRW1iZWRbXTtcbn1cblxuLyoqXG4gKiBEaXNjb3JkIFdlYmhvb2sgQ2xpZW50XG4gKi9cbmV4cG9ydCBjbGFzcyBEaXNjb3JkV2ViaG9va0NsaWVudCB7XG4gICAgcHJpdmF0ZSB3ZWJob29rVXJsOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSB1c2VybmFtZTogc3RyaW5nO1xuICAgIHByaXZhdGUgYXZhdGFyVXJsPzogc3RyaW5nO1xuICAgIHByaXZhdGUgZW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgY29uc3RydWN0b3Iob3B0aW9uczogRGlzY29yZFdlYmhvb2tPcHRpb25zKSB7XG4gICAgICAgIHRoaXMud2ViaG9va1VybCA9IG9wdGlvbnMud2ViaG9va1VybDtcbiAgICAgICAgdGhpcy51c2VybmFtZSA9IG9wdGlvbnMudXNlcm5hbWUgPz8gXCJSYWxwaFwiO1xuICAgICAgICB0aGlzLmF2YXRhclVybCA9IG9wdGlvbnMuYXZhdGFyVXJsO1xuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXG4gICAgICAgIC8vIFZhbGlkYXRlIHdlYmhvb2sgVVJMIGZvcm1hdFxuICAgICAgICBpZiAoIXRoaXMud2ViaG9va1VybCB8fCAhdGhpcy5pc1ZhbGlkV2ViaG9va1VybCh0aGlzLndlYmhvb2tVcmwpKSB7XG4gICAgICAgICAgICBsb2cud2FybihcIkludmFsaWQgRGlzY29yZCB3ZWJob29rIFVSTCwgbm90aWZpY2F0aW9ucyBkaXNhYmxlZFwiLCB7XG4gICAgICAgICAgICAgICAgd2ViaG9va1VybDogdGhpcy5tYXNrV2ViaG9va1VybCh0aGlzLndlYmhvb2tVcmwpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvZy5pbmZvKFwiRGlzY29yZCB3ZWJob29rIGNsaWVudCBpbml0aWFsaXplZFwiLCB7XG4gICAgICAgICAgICBlbmFibGVkOiB0aGlzLmVuYWJsZWQsXG4gICAgICAgICAgICB1c2VybmFtZTogdGhpcy51c2VybmFtZSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpc1ZhbGlkV2ViaG9va1VybCh1cmw6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICAvLyBEaXNjb3JkIHdlYmhvb2sgVVJMcyBsb29rIGxpa2U6IGh0dHBzOi8vZGlzY29yZC5jb20vYXBpL3dlYmhvb2tzL3tpZH0ve3Rva2VufVxuICAgICAgICByZXR1cm4gL15odHRwczpcXC9cXC9kaXNjb3JkKD86YXBwKT9cXC5jb21cXC9hcGlcXC93ZWJob29rc1xcL1xcZCtcXC9bYS16QS1aMC05Xy1dKyQvLnRlc3QoXG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBtYXNrV2ViaG9va1VybCh1cmw6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGlmICghdXJsKSByZXR1cm4gXCIobm90IHNldClcIjtcbiAgICAgICAgLy8gTWFzayB0aGUgdG9rZW4gcGFydFxuICAgICAgICByZXR1cm4gdXJsLnJlcGxhY2UoL1xcL1thLXpBLVowLTlfLV0rJC8sIFwiLyoqKioqKioqXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbmQgYSBtZXNzYWdlIHRvIERpc2NvcmRcbiAgICAgKi9cbiAgICBhc3luYyBzZW5kKG1lc3NhZ2U6IERpc2NvcmRNZXNzYWdlKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICAgICAgICBsb2cuZGVidWcoXCJEaXNjb3JkIG5vdGlmaWNhdGlvbnMgZGlzYWJsZWQsIHNraXBwaW5nIHNlbmRcIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZDogRGlzY29yZE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50LFxuICAgICAgICAgICAgICAgIHVzZXJuYW1lOiBtZXNzYWdlLnVzZXJuYW1lID8/IHRoaXMudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgYXZhdGFyVXJsOiBtZXNzYWdlLmF2YXRhclVybCA/PyB0aGlzLmF2YXRhclVybCxcbiAgICAgICAgICAgICAgICB0dHM6IG1lc3NhZ2UudHRzID8/IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVtYmVkczogbWVzc2FnZS5lbWJlZHMsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBsb2cuZGVidWcoXCJTZW5kaW5nIERpc2NvcmQgbm90aWZpY2F0aW9uXCIsIHtcbiAgICAgICAgICAgICAgICBoYXNDb250ZW50OiAhIW1lc3NhZ2UuY29udGVudCxcbiAgICAgICAgICAgICAgICBlbWJlZENvdW50OiBtZXNzYWdlLmVtYmVkcz8ubGVuZ3RoID8/IDAsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh0aGlzLndlYmhvb2tVcmwsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwYXlsb2FkKSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgICAgIGxvZy5lcnJvcihcIkRpc2NvcmQgd2ViaG9vayByZXF1ZXN0IGZhaWxlZFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JUZXh0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbG9nLmRlYnVnKFwiRGlzY29yZCBub3RpZmljYXRpb24gc2VudCBzdWNjZXNzZnVsbHlcIik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZy5lcnJvcihcIkZhaWxlZCB0byBzZW5kIERpc2NvcmQgbm90aWZpY2F0aW9uXCIsIHtcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgc2ltcGxlIHRleHQgbWVzc2FnZVxuICAgICAqL1xuICAgIGFzeW5jIG5vdGlmeShjb250ZW50OiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh7IGNvbnRlbnQgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VuZCBhbiBlbWJlZCBtZXNzYWdlXG4gICAgICovXG4gICAgYXN5bmMgbm90aWZ5V2l0aEVtYmVkKFxuICAgICAgICBlbWJlZDogRGlzY29yZEVtYmVkLFxuICAgICAgICBjb250ZW50Pzogc3RyaW5nLFxuICAgICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKHtcbiAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICBlbWJlZHM6IFtlbWJlZF0sXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbmQgY3ljbGUgc3RhcnQgbm90aWZpY2F0aW9uXG4gICAgICovXG4gICAgYXN5bmMgbm90aWZ5Q3ljbGVTdGFydChcbiAgICAgICAgY3ljbGVOdW1iZXI6IG51bWJlcixcbiAgICAgICAgbWF4Q3ljbGVzOiBudW1iZXIsXG4gICAgICAgIHByb21wdDogc3RyaW5nLFxuICAgICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICBjb25zdCBlbWJlZDogRGlzY29yZEVtYmVkID0ge1xuICAgICAgICAgICAgdGl0bGU6IGDwn5SEIEN5Y2xlICR7Y3ljbGVOdW1iZXJ9LyR7bWF4Q3ljbGVzfSBTdGFydGVkYCxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgXFxgXFxgXFxgXFxuJHtwcm9tcHQuc2xpY2UoMCwgNTAwKX0ke3Byb21wdC5sZW5ndGggPiA1MDAgPyBcIi4uLlwiIDogXCJcIn1cXG5cXGBcXGBcXGBgLFxuICAgICAgICAgICAgY29sb3I6IDB4NTg2NWYyLCAvLyBEaXNjb3JkIGJsdXJwbGVcbiAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgZmllbGRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIvCfk4sgUGhhc2VcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwiUmVzZWFyY2gg4oaSIFNwZWNpZnkg4oaSIFBsYW4g4oaSIFdvcmsg4oaSIFJldmlld1wiLFxuICAgICAgICAgICAgICAgICAgICBpbmxpbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwi4o+x77iPIFN0YXR1c1wiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJSdW5uaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgIGlubGluZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5ub3RpZnlXaXRoRW1iZWQoXG4gICAgICAgICAgICBlbWJlZCxcbiAgICAgICAgICAgIGDwn5qAICoqUmFscGggQ3ljbGUgJHtjeWNsZU51bWJlcn0vJHttYXhDeWNsZXN9IFN0YXJ0ZWQqKmAsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VuZCBjeWNsZSBjb21wbGV0aW9uIG5vdGlmaWNhdGlvblxuICAgICAqL1xuICAgIGFzeW5jIG5vdGlmeUN5Y2xlQ29tcGxldGUoXG4gICAgICAgIGN5Y2xlTnVtYmVyOiBudW1iZXIsXG4gICAgICAgIGNvbXBsZXRlZEN5Y2xlczogbnVtYmVyLFxuICAgICAgICBzdW1tYXJ5OiBzdHJpbmcsXG4gICAgICAgIGR1cmF0aW9uTXM6IG51bWJlcixcbiAgICApOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgY29uc3QgZHVyYXRpb25NaW51dGVzID0gTWF0aC5mbG9vcihkdXJhdGlvbk1zIC8gNjAwMDApO1xuICAgICAgICBjb25zdCBkdXJhdGlvblNlY29uZHMgPSBNYXRoLmZsb29yKChkdXJhdGlvbk1zICUgNjAwMDApIC8gMTAwMCk7XG5cbiAgICAgICAgY29uc3QgZW1iZWQ6IERpc2NvcmRFbWJlZCA9IHtcbiAgICAgICAgICAgIHRpdGxlOiBg4pyFIEN5Y2xlICR7Y3ljbGVOdW1iZXJ9IENvbXBsZXRlZGAsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogc3VtbWFyeS5zbGljZSgwLCAyMDAwKSB8fCBcIk5vIHN1bW1hcnkgYXZhaWxhYmxlXCIsXG4gICAgICAgICAgICBjb2xvcjogMHg1N2YyODcsIC8vIERpc2NvcmQgZ3JlZW5cbiAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgZmllbGRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIvCfk4ogUHJvZ3Jlc3NcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGAke2NvbXBsZXRlZEN5Y2xlc30gY3ljbGVzIGNvbXBsZXRlZGAsXG4gICAgICAgICAgICAgICAgICAgIGlubGluZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCLij7HvuI8gRHVyYXRpb25cIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGAke2R1cmF0aW9uTWludXRlc31tICR7ZHVyYXRpb25TZWNvbmRzfXNgLFxuICAgICAgICAgICAgICAgICAgICBpbmxpbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubm90aWZ5V2l0aEVtYmVkKFxuICAgICAgICAgICAgZW1iZWQsXG4gICAgICAgICAgICBg4pyFICoqUmFscGggQ3ljbGUgJHtjeWNsZU51bWJlcn0gQ29tcGxldGUqKmAsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VuZCBwaGFzZSBjb21wbGV0aW9uIG5vdGlmaWNhdGlvblxuICAgICAqL1xuICAgIGFzeW5jIG5vdGlmeVBoYXNlQ29tcGxldGUoXG4gICAgICAgIGN5Y2xlTnVtYmVyOiBudW1iZXIsXG4gICAgICAgIHBoYXNlOiBzdHJpbmcsXG4gICAgICAgIHN1bW1hcnk6IHN0cmluZyxcbiAgICApOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgY29uc3QgZW1iZWQ6IERpc2NvcmRFbWJlZCA9IHtcbiAgICAgICAgICAgIHRpdGxlOiBg8J+TnSBQaGFzZSBDb21wbGV0ZTogJHtwaGFzZX1gLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHN1bW1hcnkuc2xpY2UoMCwgMTAwMCksXG4gICAgICAgICAgICBjb2xvcjogMHhmZWU3NWMsIC8vIERpc2NvcmQgeWVsbG93XG4gICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGZpZWxkczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCLwn5SEIEN5Y2xlXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBTdHJpbmcoY3ljbGVOdW1iZXIpLFxuICAgICAgICAgICAgICAgICAgICBpbmxpbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubm90aWZ5V2l0aEVtYmVkKGVtYmVkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGVycm9yIG5vdGlmaWNhdGlvblxuICAgICAqL1xuICAgIGFzeW5jIG5vdGlmeUVycm9yKFxuICAgICAgICBjeWNsZU51bWJlcjogbnVtYmVyLFxuICAgICAgICBwaGFzZTogc3RyaW5nLFxuICAgICAgICBlcnJvcjogc3RyaW5nLFxuICAgICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICBjb25zdCBlbWJlZDogRGlzY29yZEVtYmVkID0ge1xuICAgICAgICAgICAgdGl0bGU6IGDinYwgRXJyb3IgaW4gQ3ljbGUgJHtjeWNsZU51bWJlcn1gLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGAqKlBoYXNlOioqICR7cGhhc2V9XFxuXFxuKipFcnJvcjoqKlxcblxcYFxcYFxcYFxcbiR7ZXJyb3Iuc2xpY2UoMCwgMTUwMCl9XFxuXFxgXFxgXFxgYCxcbiAgICAgICAgICAgIGNvbG9yOiAweGVkNDI0NSwgLy8gRGlzY29yZCByZWRcbiAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLm5vdGlmeVdpdGhFbWJlZChlbWJlZCwgXCLwn5qoICoqUmFscGggRXJyb3IqKlwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kIHRpbWVvdXQgbm90aWZpY2F0aW9uXG4gICAgICovXG4gICAgYXN5bmMgbm90aWZ5VGltZW91dChcbiAgICAgICAgY3ljbGVOdW1iZXI6IG51bWJlcixcbiAgICAgICAgcGhhc2U6IHN0cmluZyxcbiAgICAgICAgdGltZW91dE1zOiBudW1iZXIsXG4gICAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIGNvbnN0IHRpbWVvdXRNaW51dGVzID0gTWF0aC5mbG9vcih0aW1lb3V0TXMgLyA2MDAwMCk7XG5cbiAgICAgICAgY29uc3QgZW1iZWQ6IERpc2NvcmRFbWJlZCA9IHtcbiAgICAgICAgICAgIHRpdGxlOiBg4o+wIFRpbWVvdXQgaW4gQ3ljbGUgJHtjeWNsZU51bWJlcn1gLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGAqKlBoYXNlOioqICR7cGhhc2V9XFxuKipUaW1lb3V0OioqICR7dGltZW91dE1pbnV0ZXN9IG1pbnV0ZXNgLFxuICAgICAgICAgICAgY29sb3I6IDB4ZWI0NTllLCAvLyBEaXNjb3JkIHBpbmtcbiAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLm5vdGlmeVdpdGhFbWJlZChlbWJlZCwgXCLij7AgKipSYWxwaCBUaW1lb3V0KipcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VuZCBydW4gY29tcGxldGlvbiBub3RpZmljYXRpb25cbiAgICAgKi9cbiAgICBhc3luYyBub3RpZnlSdW5Db21wbGV0ZShcbiAgICAgICAgdG90YWxDeWNsZXM6IG51bWJlcixcbiAgICAgICAgZHVyYXRpb25NczogbnVtYmVyLFxuICAgICAgICBmaW5hbFN1bW1hcnk6IHN0cmluZyxcbiAgICApOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgY29uc3QgZHVyYXRpb25Ib3VycyA9IE1hdGguZmxvb3IoZHVyYXRpb25NcyAvIDM2MDAwMDApO1xuICAgICAgICBjb25zdCBkdXJhdGlvbk1pbnV0ZXMgPSBNYXRoLmZsb29yKChkdXJhdGlvbk1zICUgMzYwMDAwMCkgLyA2MDAwMCk7XG5cbiAgICAgICAgY29uc3QgZW1iZWQ6IERpc2NvcmRFbWJlZCA9IHtcbiAgICAgICAgICAgIHRpdGxlOiBcIvCfj4EgUnVuIENvbXBsZXRlXCIsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogZmluYWxTdW1tYXJ5LnNsaWNlKDAsIDIwMDApLFxuICAgICAgICAgICAgY29sb3I6IDB4NTdmMjg3LCAvLyBEaXNjb3JkIGdyZWVuXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGZpZWxkczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCLwn5SEIFRvdGFsIEN5Y2xlc1wiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogU3RyaW5nKHRvdGFsQ3ljbGVzKSxcbiAgICAgICAgICAgICAgICAgICAgaW5saW5lOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIuKPse+4jyBUb3RhbCBEdXJhdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uSG91cnMgPiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBgJHtkdXJhdGlvbkhvdXJzfWggJHtkdXJhdGlvbk1pbnV0ZXN9bWBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGAke2R1cmF0aW9uTWludXRlc31tYCxcbiAgICAgICAgICAgICAgICAgICAgaW5saW5lOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLm5vdGlmeVdpdGhFbWJlZChlbWJlZCwgXCLwn4+BICoqUmFscGggUnVuIENvbXBsZXRlKipcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VuZCBzdHVjay9hYm9ydCBub3RpZmljYXRpb25cbiAgICAgKi9cbiAgICBhc3luYyBub3RpZnlTdHVja09yQWJvcnRlZChcbiAgICAgICAgY3ljbGVOdW1iZXI6IG51bWJlcixcbiAgICAgICAgcmVhc29uOiBzdHJpbmcsXG4gICAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIGNvbnN0IGVtYmVkOiBEaXNjb3JkRW1iZWQgPSB7XG4gICAgICAgICAgICB0aXRsZTogYPCfm5EgUnVuICR7cmVhc29ufWAsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYEN5Y2xlICR7Y3ljbGVOdW1iZXJ9IHJlYWNoZWQgc3R1Y2sgdGhyZXNob2xkIG9yIHdhcyBhYm9ydGVkYCxcbiAgICAgICAgICAgIGNvbG9yOiAweDU4NjVmMiwgLy8gRGlzY29yZCBibHVycGxlXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5ub3RpZnlXaXRoRW1iZWQoZW1iZWQsIGDwn5uRICoqUmFscGggJHtyZWFzb259KipgKTtcbiAgICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgRGlzY29yZCB3ZWJob29rIGNsaWVudCBmcm9tIGVudmlyb25tZW50IHZhcmlhYmxlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGlzY29yZFdlYmhvb2tGcm9tRW52KCk6IERpc2NvcmRXZWJob29rQ2xpZW50IHwgbnVsbCB7XG4gICAgY29uc3Qgd2ViaG9va1VybCA9IHByb2Nlc3MuZW52LkRJU0NPUkRfV0VCSE9PS19VUkw/LnRyaW0oKTtcblxuICAgIGlmICghd2ViaG9va1VybCkge1xuICAgICAgICBsb2cuZGVidWcoXG4gICAgICAgICAgICBcIk5vIERJU0NPUkRfV0VCSE9PS19VUkwgZW52IHZhciBzZXQsIERpc2NvcmQgbm90aWZpY2F0aW9ucyBkaXNhYmxlZFwiLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IERpc2NvcmRXZWJob29rQ2xpZW50KHtcbiAgICAgICAgd2ViaG9va1VybCxcbiAgICAgICAgdXNlcm5hbWU6IHByb2Nlc3MuZW52LkRJU0NPUkRfQk9UX1VTRVJOQU1FID8/IFwiUmFscGhcIixcbiAgICAgICAgYXZhdGFyVXJsOiBwcm9jZXNzLmVudi5ESVNDT1JEX0JPVF9BVkFUQVJfVVJMLFxuICAgIH0pO1xufVxuIiwKICAgICIvKipcbiAqIEZsb3cgU3RvcmUgLSBTdGF0ZSBwZXJzaXN0ZW5jZSBsYXllciBmb3IgUmFscGggTG9vcCBSdW5uZXJcbiAqXG4gKiBQZXJzaXN0cyBydW4gc3RhdGUgdG8gYC5haS1lbmcvcnVucy88cnVuSWQ+Ly5mbG93L2A6XG4gKiAtIHN0YXRlLmpzb246IE1haW4gcnVuIHN0YXRlXG4gKiAtIGNoZWNrcG9pbnQuanNvbjogTGFzdCBzdWNjZXNzZnVsIGNoZWNrcG9pbnQgZm9yIGZhc3QgcmVzdW1lXG4gKiAtIGl0ZXJhdGlvbnMvPG4+Lmpzb246IFBlci1jeWNsZSBkZXRhaWxlZCBvdXRwdXRzXG4gKiAtIGNvbnRleHRzLzxuPi5tZDogUmUtYW5jaG9yaW5nIGNvbnRleHQgc25hcHNob3RzXG4gKiAtIGdhdGVzLzxuPi5qc29uOiBRdWFsaXR5IGdhdGUgcmVzdWx0c1xuICovXG5cbmltcG9ydCB7IGV4aXN0c1N5bmMsIG1rZGlyU3luYywgcmVhZEZpbGVTeW5jLCB3cml0ZUZpbGVTeW5jIH0gZnJvbSBcIm5vZGU6ZnNcIjtcbmltcG9ydCB7IGpvaW4gfSBmcm9tIFwibm9kZTpwYXRoXCI7XG5pbXBvcnQgeyBMb2cgfSBmcm9tIFwiLi4vdXRpbC9sb2dcIjtcbmltcG9ydCB0eXBlIHsgQ2hlY2twb2ludCwgQ3ljbGVTdGF0ZSwgRmxvd1N0YXRlIH0gZnJvbSBcIi4vZmxvdy10eXBlc1wiO1xuaW1wb3J0IHsgRkxPV19TQ0hFTUFfVkVSU0lPTiwgUnVuU3RhdHVzLCB0eXBlIFN0b3BSZWFzb24gfSBmcm9tIFwiLi9mbG93LXR5cGVzXCI7XG5cbmNvbnN0IGxvZyA9IExvZy5jcmVhdGUoeyBzZXJ2aWNlOiBcImZsb3ctc3RvcmVcIiB9KTtcblxuLyoqIEZsb3cgc3RvcmUgb3B0aW9ucyAqL1xuZXhwb3J0IGludGVyZmFjZSBGbG93U3RvcmVPcHRpb25zIHtcbiAgICBmbG93RGlyOiBzdHJpbmc7XG4gICAgcnVuSWQ6IHN0cmluZztcbn1cblxuLyoqXG4gKiBGbG93IFN0b3JlIC0gbWFuYWdlcyBwZXJzaXN0ZW5jZSBvZiBsb29wIHJ1biBzdGF0ZVxuICovXG5leHBvcnQgY2xhc3MgRmxvd1N0b3JlIHtcbiAgICBwcml2YXRlIGZsb3dEaXI6IHN0cmluZztcbiAgICBwcml2YXRlIHJ1bklkOiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zOiBGbG93U3RvcmVPcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZmxvd0RpciA9IG9wdGlvbnMuZmxvd0RpcjtcbiAgICAgICAgdGhpcy5ydW5JZCA9IG9wdGlvbnMucnVuSWQ7XG4gICAgfVxuXG4gICAgLyoqIEdldCB0aGUgYmFzZSBmbG93IGRpcmVjdG9yeSBwYXRoICovXG4gICAgZ2V0IGJhc2VQYXRoKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBqb2luKHRoaXMuZmxvd0RpciwgdGhpcy5ydW5JZCwgXCIuZmxvd1wiKTtcbiAgICB9XG5cbiAgICAvKiogR2V0IHBhdGggdG8gYSBzcGVjaWZpYyBmaWxlIGluIC5mbG93ICovXG4gICAgcHJpdmF0ZSBwYXRoKHJlbFBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBqb2luKHRoaXMuYmFzZVBhdGgsIHJlbFBhdGgpO1xuICAgIH1cblxuICAgIC8qKiBJbml0aWFsaXplIGZsb3cgZGlyZWN0b3J5IHN0cnVjdHVyZSAqL1xuICAgIGluaXRpYWxpemUoKTogdm9pZCB7XG4gICAgICAgIC8vIENyZWF0ZSAuZmxvdyBkaXJlY3RvcnkgYW5kIHN1YmRpcmVjdG9yaWVzXG4gICAgICAgIGNvbnN0IGRpcnMgPSBbXCJpdGVyYXRpb25zXCIsIFwiY29udGV4dHNcIiwgXCJnYXRlc1wiXTtcblxuICAgICAgICBmb3IgKGNvbnN0IGRpciBvZiBkaXJzKSB7XG4gICAgICAgICAgICBjb25zdCBkaXJQYXRoID0gdGhpcy5wYXRoKGRpcik7XG4gICAgICAgICAgICBpZiAoIWV4aXN0c1N5bmMoZGlyUGF0aCkpIHtcbiAgICAgICAgICAgICAgICBta2RpclN5bmMoZGlyUGF0aCwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgbG9nLmRlYnVnKFwiQ3JlYXRlZCBkaXJlY3RvcnlcIiwgeyBwYXRoOiBkaXJQYXRoIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbG9nLmluZm8oXCJGbG93IHN0b3JlIGluaXRpYWxpemVkXCIsIHtcbiAgICAgICAgICAgIHJ1bklkOiB0aGlzLnJ1bklkLFxuICAgICAgICAgICAgYmFzZVBhdGg6IHRoaXMuYmFzZVBhdGgsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKiBDaGVjayBpZiBmbG93IHN0YXRlIGV4aXN0cyAoZm9yIHJlc3VtZSkgKi9cbiAgICBleGlzdHMoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBleGlzdHNTeW5jKHRoaXMucGF0aChcInN0YXRlLmpzb25cIikpO1xuICAgIH1cblxuICAgIC8qKiBMb2FkIGV4aXN0aW5nIHJ1biBzdGF0ZSBmb3IgcmVzdW1lICovXG4gICAgbG9hZCgpOiBGbG93U3RhdGUgfCBudWxsIHtcbiAgICAgICAgY29uc3Qgc3RhdGVQYXRoID0gdGhpcy5wYXRoKFwic3RhdGUuanNvblwiKTtcbiAgICAgICAgaWYgKCFleGlzdHNTeW5jKHN0YXRlUGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSByZWFkRmlsZVN5bmMoc3RhdGVQYXRoLCBcInV0Zi04XCIpO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBKU09OLnBhcnNlKGNvbnRlbnQpIGFzIEZsb3dTdGF0ZTtcblxuICAgICAgICAgICAgLy8gVmFsaWRhdGUgc2NoZW1hIHZlcnNpb25cbiAgICAgICAgICAgIGlmIChzdGF0ZS5zY2hlbWFWZXJzaW9uICE9PSBGTE9XX1NDSEVNQV9WRVJTSU9OKSB7XG4gICAgICAgICAgICAgICAgbG9nLndhcm4oXCJGbG93IHNjaGVtYSB2ZXJzaW9uIG1pc21hdGNoXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IEZMT1dfU0NIRU1BX1ZFUlNJT04sXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kOiBzdGF0ZS5zY2hlbWFWZXJzaW9uLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsb2cuaW5mbyhcIkxvYWRlZCBmbG93IHN0YXRlXCIsIHtcbiAgICAgICAgICAgICAgICBydW5JZDogc3RhdGUucnVuSWQsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBzdGF0ZS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgY3VycmVudEN5Y2xlOiBzdGF0ZS5jdXJyZW50Q3ljbGUsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JNc2cgPVxuICAgICAgICAgICAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICAgICAgICAgIGxvZy5lcnJvcihcIkZhaWxlZCB0byBsb2FkIGZsb3cgc3RhdGVcIiwgeyBlcnJvcjogZXJyb3JNc2cgfSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBDcmVhdGUgaW5pdGlhbCBydW4gc3RhdGUgKi9cbiAgICBjcmVhdGVJbml0aWFsU3RhdGUob3B0aW9uczoge1xuICAgICAgICBwcm9tcHQ6IHN0cmluZztcbiAgICAgICAgY29tcGxldGlvblByb21pc2U6IHN0cmluZztcbiAgICAgICAgbWF4Q3ljbGVzOiBudW1iZXI7XG4gICAgICAgIHN0dWNrVGhyZXNob2xkOiBudW1iZXI7XG4gICAgICAgIGdhdGVzOiBzdHJpbmdbXTtcbiAgICB9KTogRmxvd1N0YXRlIHtcbiAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuXG4gICAgICAgIGNvbnN0IHN0YXRlOiBGbG93U3RhdGUgPSB7XG4gICAgICAgICAgICBzY2hlbWFWZXJzaW9uOiBGTE9XX1NDSEVNQV9WRVJTSU9OLFxuICAgICAgICAgICAgcnVuSWQ6IHRoaXMucnVuSWQsXG4gICAgICAgICAgICBwcm9tcHQ6IG9wdGlvbnMucHJvbXB0LFxuICAgICAgICAgICAgc3RhdHVzOiBSdW5TdGF0dXMuUEVORElORyxcbiAgICAgICAgICAgIGNvbXBsZXRpb25Qcm9taXNlOiBvcHRpb25zLmNvbXBsZXRpb25Qcm9taXNlLFxuICAgICAgICAgICAgbWF4Q3ljbGVzOiBvcHRpb25zLm1heEN5Y2xlcyxcbiAgICAgICAgICAgIHN0dWNrVGhyZXNob2xkOiBvcHRpb25zLnN0dWNrVGhyZXNob2xkLFxuICAgICAgICAgICAgZ2F0ZXM6IG9wdGlvbnMuZ2F0ZXMsXG4gICAgICAgICAgICBjdXJyZW50Q3ljbGU6IDAsXG4gICAgICAgICAgICBjb21wbGV0ZWRDeWNsZXM6IDAsXG4gICAgICAgICAgICBmYWlsZWRDeWNsZXM6IDAsXG4gICAgICAgICAgICBzdHVja0NvdW50OiAwLFxuICAgICAgICAgICAgY3JlYXRlZEF0OiBub3csXG4gICAgICAgICAgICB1cGRhdGVkQXQ6IG5vdyxcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnNhdmVTdGF0ZShzdGF0ZSk7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG5cbiAgICAvKiogU2F2ZSBydW4gc3RhdGUgdG8gc3RhdGUuanNvbiAqL1xuICAgIHNhdmVTdGF0ZShzdGF0ZTogRmxvd1N0YXRlKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHN0YXRlUGF0aCA9IHRoaXMucGF0aChcInN0YXRlLmpzb25cIik7XG4gICAgICAgIHN0YXRlLnVwZGF0ZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgd3JpdGVGaWxlU3luYyhzdGF0ZVBhdGgsIEpTT04uc3RyaW5naWZ5KHN0YXRlLCBudWxsLCAyKSk7XG4gICAgICAgIGxvZy5kZWJ1ZyhcIlNhdmVkIGZsb3cgc3RhdGVcIiwgeyBydW5JZDogc3RhdGUucnVuSWQgfSk7XG4gICAgfVxuXG4gICAgLyoqIFNhdmUgYSBjaGVja3BvaW50IGZvciBmYXN0IHJlc3VtZSAqL1xuICAgIHNhdmVDaGVja3BvaW50KFxuICAgICAgICBzdGF0ZTogRmxvd1N0YXRlLFxuICAgICAgICBsYXN0UGhhc2VPdXRwdXRzOiBDeWNsZVN0YXRlW1wicGhhc2VzXCJdLFxuICAgICk6IHZvaWQge1xuICAgICAgICBjb25zdCBjaGVja3BvaW50UGF0aCA9IHRoaXMucGF0aChcImNoZWNrcG9pbnQuanNvblwiKTtcbiAgICAgICAgY29uc3QgY2hlY2twb2ludDogQ2hlY2twb2ludCA9IHtcbiAgICAgICAgICAgIHNjaGVtYVZlcnNpb246IEZMT1dfU0NIRU1BX1ZFUlNJT04sXG4gICAgICAgICAgICBydW5JZDogc3RhdGUucnVuSWQsXG4gICAgICAgICAgICBjeWNsZU51bWJlcjogc3RhdGUuY3VycmVudEN5Y2xlLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgIGxhc3RQaGFzZU91dHB1dHMsXG4gICAgICAgIH07XG4gICAgICAgIHdyaXRlRmlsZVN5bmMoY2hlY2twb2ludFBhdGgsIEpTT04uc3RyaW5naWZ5KGNoZWNrcG9pbnQsIG51bGwsIDIpKTtcbiAgICAgICAgbG9nLmRlYnVnKFwiU2F2ZWQgY2hlY2twb2ludFwiLCB7XG4gICAgICAgICAgICBydW5JZDogc3RhdGUucnVuSWQsXG4gICAgICAgICAgICBjeWNsZTogc3RhdGUuY3VycmVudEN5Y2xlLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogTG9hZCBjaGVja3BvaW50IGZvciByZXN1bWUgKi9cbiAgICBsb2FkQ2hlY2twb2ludCgpOiBDaGVja3BvaW50IHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGNoZWNrcG9pbnRQYXRoID0gdGhpcy5wYXRoKFwiY2hlY2twb2ludC5qc29uXCIpO1xuICAgICAgICBpZiAoIWV4aXN0c1N5bmMoY2hlY2twb2ludFBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gcmVhZEZpbGVTeW5jKGNoZWNrcG9pbnRQYXRoLCBcInV0Zi04XCIpO1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoY29udGVudCkgYXMgQ2hlY2twb2ludDtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTXNnID1cbiAgICAgICAgICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICAgICAgICBsb2cuZXJyb3IoXCJGYWlsZWQgdG8gbG9hZCBjaGVja3BvaW50XCIsIHsgZXJyb3I6IGVycm9yTXNnIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogU2F2ZSBpdGVyYXRpb24gY3ljbGUgb3V0cHV0ICovXG4gICAgc2F2ZUl0ZXJhdGlvbihjeWNsZTogQ3ljbGVTdGF0ZSk6IHZvaWQge1xuICAgICAgICBjb25zdCBjeWNsZVBhdGggPSB0aGlzLnBhdGgoYGl0ZXJhdGlvbnMvJHtjeWNsZS5jeWNsZU51bWJlcn0uanNvbmApO1xuICAgICAgICB3cml0ZUZpbGVTeW5jKGN5Y2xlUGF0aCwgSlNPTi5zdHJpbmdpZnkoY3ljbGUsIG51bGwsIDIpKTtcblxuICAgICAgICAvLyBTYXZlIHJlLWFuY2hvcmluZyBjb250ZXh0XG4gICAgICAgIGNvbnN0IGNvbnRleHRQYXRoID0gdGhpcy5wYXRoKGBjb250ZXh0cy8ke2N5Y2xlLmN5Y2xlTnVtYmVyfS5tZGApO1xuICAgICAgICBjb25zdCBjb250ZXh0Q29udGVudCA9IHRoaXMuZ2VuZXJhdGVDb250ZXh0Q29udGVudChjeWNsZSk7XG4gICAgICAgIHdyaXRlRmlsZVN5bmMoY29udGV4dFBhdGgsIGNvbnRleHRDb250ZW50KTtcblxuICAgICAgICBsb2cuZGVidWcoXCJTYXZlZCBpdGVyYXRpb25cIiwgeyBjeWNsZTogY3ljbGUuY3ljbGVOdW1iZXIgfSk7XG4gICAgfVxuXG4gICAgLyoqIFNhdmUgZ2F0ZSByZXN1bHRzIGZvciBpdGVyYXRpb24gKi9cbiAgICBzYXZlR2F0ZVJlc3VsdHMoXG4gICAgICAgIGN5Y2xlTnVtYmVyOiBudW1iZXIsXG4gICAgICAgIHJlc3VsdHM6IEN5Y2xlU3RhdGVbXCJnYXRlUmVzdWx0c1wiXSxcbiAgICApOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZ2F0ZVBhdGggPSB0aGlzLnBhdGgoYGdhdGVzLyR7Y3ljbGVOdW1iZXJ9Lmpzb25gKTtcbiAgICAgICAgd3JpdGVGaWxlU3luYyhnYXRlUGF0aCwgSlNPTi5zdHJpbmdpZnkocmVzdWx0cywgbnVsbCwgMikpO1xuICAgIH1cblxuICAgIC8qKiBHZW5lcmF0ZSByZS1hbmNob3JpbmcgY29udGV4dCBjb250ZW50IGZvciBhIGN5Y2xlICovXG4gICAgcHJpdmF0ZSBnZW5lcmF0ZUNvbnRleHRDb250ZW50KGN5Y2xlOiBDeWNsZVN0YXRlKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgbGluZXM6IHN0cmluZ1tdID0gW1xuICAgICAgICAgICAgYCMgQ3ljbGUgJHtjeWNsZS5jeWNsZU51bWJlcn0gQ29udGV4dGAsXG4gICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgYCoqVGltZXN0YW1wOioqICR7Y3ljbGUuc3RhcnRUaW1lfWAsXG4gICAgICAgICAgICBgKipTdGF0dXM6KiogJHtjeWNsZS5zdGF0dXN9YCxcbiAgICAgICAgICAgIGAqKkNvbXBsZXRpb24gUHJvbWlzZSBPYnNlcnZlZDoqKiAke2N5Y2xlLmNvbXBsZXRpb25Qcm9taXNlT2JzZXJ2ZWR9YCxcbiAgICAgICAgICAgIFwiXCIsXG4gICAgICAgICAgICBcIiMjIFBoYXNlIFN1bW1hcmllc1wiLFxuICAgICAgICAgICAgXCJcIixcbiAgICAgICAgXTtcblxuICAgICAgICBmb3IgKGNvbnN0IFtwaGFzZSwgb3V0cHV0XSBvZiBPYmplY3QuZW50cmllcyhjeWNsZS5waGFzZXMpKSB7XG4gICAgICAgICAgICBpZiAob3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgbGluZXMucHVzaChgIyMjICR7cGhhc2UudG9VcHBlckNhc2UoKX1gKTtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKFwiXCIpO1xuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2gob3V0cHV0LnN1bW1hcnkgfHwgb3V0cHV0LnJlc3BvbnNlLnNsaWNlKDAsIDUwMCkpO1xuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3ljbGUuZ2F0ZVJlc3VsdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGluZXMucHVzaChcIiMjIEdhdGUgUmVzdWx0c1wiKTtcbiAgICAgICAgICAgIGxpbmVzLnB1c2goXCJcIik7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGdhdGUgb2YgY3ljbGUuZ2F0ZVJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXMgPSBnYXRlLnBhc3NlZCA/IFwi4pyFIFBBU1NcIiA6IFwi4p2MIEZBSUxcIjtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGAtICoqJHtnYXRlLmdhdGV9OioqICR7c3RhdHVzfSAtICR7Z2F0ZS5tZXNzYWdlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGluZXMucHVzaChcIlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjeWNsZS5lcnJvcikge1xuICAgICAgICAgICAgbGluZXMucHVzaChcIiMjIEVycm9yc1wiKTtcbiAgICAgICAgICAgIGxpbmVzLnB1c2goXCJcIik7XG4gICAgICAgICAgICBsaW5lcy5wdXNoKGN5Y2xlLmVycm9yKTtcbiAgICAgICAgICAgIGxpbmVzLnB1c2goXCJcIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGluZXMuam9pbihcIlxcblwiKTtcbiAgICB9XG5cbiAgICAvKiogR2V0IGl0ZXJhdGlvbiBieSBudW1iZXIgKi9cbiAgICBnZXRJdGVyYXRpb24oY3ljbGVOdW1iZXI6IG51bWJlcik6IEN5Y2xlU3RhdGUgfCBudWxsIHtcbiAgICAgICAgY29uc3QgY3ljbGVQYXRoID0gdGhpcy5wYXRoKGBpdGVyYXRpb25zLyR7Y3ljbGVOdW1iZXJ9Lmpzb25gKTtcbiAgICAgICAgaWYgKCFleGlzdHNTeW5jKGN5Y2xlUGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSByZWFkRmlsZVN5bmMoY3ljbGVQYXRoLCBcInV0Zi04XCIpO1xuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoY29udGVudCkgYXMgQ3ljbGVTdGF0ZTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBHZXQgYWxsIGl0ZXJhdGlvbnMgKi9cbiAgICBnZXRBbGxJdGVyYXRpb25zKCk6IEN5Y2xlU3RhdGVbXSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdGlvbnM6IEN5Y2xlU3RhdGVbXSA9IFtdO1xuICAgICAgICBsZXQgbiA9IDE7XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN5Y2xlID0gdGhpcy5nZXRJdGVyYXRpb24obik7XG4gICAgICAgICAgICBpZiAoIWN5Y2xlKSBicmVhaztcbiAgICAgICAgICAgIGl0ZXJhdGlvbnMucHVzaChjeWNsZSk7XG4gICAgICAgICAgICBuKys7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlcmF0aW9ucztcbiAgICB9XG5cbiAgICAvKiogVXBkYXRlIHN0YXRlIHN0YXR1cyAqL1xuICAgIHVwZGF0ZVN0YXR1cyhcbiAgICAgICAgc3RhdHVzOiBSdW5TdGF0dXMsXG4gICAgICAgIHN0b3BSZWFzb24/OiBTdG9wUmVhc29uLFxuICAgICAgICBlcnJvcj86IHN0cmluZyxcbiAgICApOiB2b2lkIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmxvYWQoKTtcbiAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZmxvdyBzdGF0ZSB0byB1cGRhdGVcIik7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIGlmIChzdG9wUmVhc29uKSBzdGF0ZS5zdG9wUmVhc29uID0gc3RvcFJlYXNvbjtcbiAgICAgICAgaWYgKGVycm9yKSBzdGF0ZS5lcnJvciA9IGVycm9yO1xuICAgICAgICBpZiAoc3RhdHVzID09PSBSdW5TdGF0dXMuQ09NUExFVEVEIHx8IHN0YXR1cyA9PT0gUnVuU3RhdHVzLkZBSUxFRCkge1xuICAgICAgICAgICAgc3RhdGUuY29tcGxldGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNhdmVTdGF0ZShzdGF0ZSk7XG4gICAgfVxuXG4gICAgLyoqIEluY3JlbWVudCBjeWNsZSBjb3VudGVyICovXG4gICAgaW5jcmVtZW50Q3ljbGUoKTogbnVtYmVyIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmxvYWQoKTtcbiAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZmxvdyBzdGF0ZSB0byB1cGRhdGVcIik7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5jdXJyZW50Q3ljbGUrKztcbiAgICAgICAgdGhpcy5zYXZlU3RhdGUoc3RhdGUpO1xuICAgICAgICByZXR1cm4gc3RhdGUuY3VycmVudEN5Y2xlO1xuICAgIH1cblxuICAgIC8qKiBSZWNvcmQgYSBmYWlsZWQgY3ljbGUgKi9cbiAgICByZWNvcmRGYWlsZWRDeWNsZShjeWNsZTogQ3ljbGVTdGF0ZSk6IHZvaWQge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMubG9hZCgpO1xuICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBmbG93IHN0YXRlIHRvIHVwZGF0ZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmZhaWxlZEN5Y2xlcysrO1xuICAgICAgICBzdGF0ZS5zdHVja0NvdW50Kys7XG4gICAgICAgIHRoaXMuc2F2ZUl0ZXJhdGlvbihjeWNsZSk7XG4gICAgICAgIHRoaXMuc2F2ZVN0YXRlKHN0YXRlKTtcblxuICAgICAgICBsb2cuaW5mbyhcIkN5Y2xlIGZhaWxlZFwiLCB7XG4gICAgICAgICAgICBydW5JZDogdGhpcy5ydW5JZCxcbiAgICAgICAgICAgIGN5Y2xlOiBjeWNsZS5jeWNsZU51bWJlcixcbiAgICAgICAgICAgIGZhaWxlZEN5Y2xlczogc3RhdGUuZmFpbGVkQ3ljbGVzLFxuICAgICAgICAgICAgc3R1Y2tDb3VudDogc3RhdGUuc3R1Y2tDb3VudCxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqIFJlY29yZCBhIHN1Y2Nlc3NmdWwgY3ljbGUgKi9cbiAgICByZWNvcmRTdWNjZXNzZnVsQ3ljbGUoY3ljbGU6IEN5Y2xlU3RhdGUsIHN1bW1hcnk6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMubG9hZCgpO1xuICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBmbG93IHN0YXRlIHRvIHVwZGF0ZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmNvbXBsZXRlZEN5Y2xlcysrO1xuICAgICAgICBzdGF0ZS5zdHVja0NvdW50ID0gMDsgLy8gUmVzZXQgc3R1Y2sgY291bnRlciBvbiBzdWNjZXNzXG4gICAgICAgIHN0YXRlLmxhc3RDaGVja3BvaW50ID0ge1xuICAgICAgICAgICAgY3ljbGVOdW1iZXI6IGN5Y2xlLmN5Y2xlTnVtYmVyLFxuICAgICAgICAgICAgc3VtbWFyeSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuc2F2ZUl0ZXJhdGlvbihjeWNsZSk7XG4gICAgICAgIHRoaXMuc2F2ZVN0YXRlKHN0YXRlKTtcblxuICAgICAgICBsb2cuaW5mbyhcIkN5Y2xlIGNvbXBsZXRlZFwiLCB7XG4gICAgICAgICAgICBydW5JZDogdGhpcy5ydW5JZCxcbiAgICAgICAgICAgIGN5Y2xlOiBjeWNsZS5jeWNsZU51bWJlcixcbiAgICAgICAgICAgIGNvbXBsZXRlZEN5Y2xlczogc3RhdGUuY29tcGxldGVkQ3ljbGVzLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogQ2xlYW4gdXAgZmxvdyBkaXJlY3RvcnkgKi9cbiAgICBjbGVhbnVwKCk6IHZvaWQge1xuICAgICAgICAvLyBJbXBsZW1lbnRhdGlvbiB3b3VsZCByZW1vdmUgdGhlIC5mbG93IGRpcmVjdG9yeVxuICAgICAgICAvLyBGb3Igbm93LCBqdXN0IGxvZ1xuICAgICAgICBsb2cuaW5mbyhcIkZsb3cgc3RvcmUgY2xlYW51cCByZXF1ZXN0ZWRcIiwgeyBydW5JZDogdGhpcy5ydW5JZCB9KTtcbiAgICB9XG59XG4iLAogICAgIi8qKlxuICogRmxvdyBTdGF0ZSBUeXBlcyBmb3IgUmFscGggTG9vcCBSdW5uZXJcbiAqXG4gKiBTdGF0ZSBpcyBwZXJzaXN0ZWQgdG8gYC5haS1lbmcvcnVucy88cnVuSWQ+Ly5mbG93L2AgZm9yOlxuICogLSBSZXN1bWUgc3VwcG9ydCBhY3Jvc3MgcnVuc1xuICogLSBGcmVzaCBjb250ZXh0IHBlciBpdGVyYXRpb24gKHJlLWFuY2hvcmluZyBmcm9tIGRpc2spXG4gKiAtIEF1ZGl0IHRyYWlsIG9mIGFsbCBjeWNsZSBvdXRwdXRzXG4gKi9cblxuLyoqIFNjaGVtYSB2ZXJzaW9uIGZvciBmb3J3YXJkIGNvbXBhdGliaWxpdHkgKi9cbmV4cG9ydCBjb25zdCBGTE9XX1NDSEVNQV9WRVJTSU9OID0gXCIxLjAuMFwiO1xuXG4vKiogUnVuIHN0YXR1cyBlbnVtICovXG5leHBvcnQgZW51bSBSdW5TdGF0dXMge1xuICAgIFBFTkRJTkcgPSBcInBlbmRpbmdcIixcbiAgICBSVU5OSU5HID0gXCJydW5uaW5nXCIsXG4gICAgQ09NUExFVEVEID0gXCJjb21wbGV0ZWRcIixcbiAgICBGQUlMRUQgPSBcImZhaWxlZFwiLFxuICAgIEFCT1JURUQgPSBcImFib3J0ZWRcIixcbiAgICBTVFVDSyA9IFwic3R1Y2tcIixcbn1cblxuLyoqIFN0b3AgcmVhc29uIGZvciBjb21wbGV0ZWQgcnVucyAqL1xuZXhwb3J0IGVudW0gU3RvcFJlYXNvbiB7XG4gICAgQ09NUExFVElPTl9QUk9NSVNFID0gXCJjb21wbGV0aW9uX3Byb21pc2VcIixcbiAgICBNQVhfQ1lDTEVTID0gXCJtYXhfY3ljbGVzXCIsXG4gICAgR0FURV9GQUlMVVJFID0gXCJnYXRlX2ZhaWx1cmVcIixcbiAgICBTVFVDSyA9IFwic3R1Y2tcIixcbiAgICBVU0VSX0FCT1JUID0gXCJ1c2VyX2Fib3J0XCIsXG4gICAgRVJST1IgPSBcImVycm9yXCIsXG59XG5cbi8qKiBQaGFzZSBuYW1lcyBpbiB0aGUgd29ya2Zsb3cgKi9cbmV4cG9ydCBlbnVtIFBoYXNlIHtcbiAgICBSRVNFQVJDSCA9IFwicmVzZWFyY2hcIixcbiAgICBTUEVDSUZZID0gXCJzcGVjaWZ5XCIsXG4gICAgUExBTiA9IFwicGxhblwiLFxuICAgIFdPUksgPSBcIndvcmtcIixcbiAgICBSRVZJRVcgPSBcInJldmlld1wiLFxufVxuXG4vKiogR2F0ZSByZXN1bHQgdHlwZSAqL1xuZXhwb3J0IGludGVyZmFjZSBHYXRlUmVzdWx0IHtcbiAgICBnYXRlOiBzdHJpbmc7XG4gICAgcGFzc2VkOiBib29sZWFuO1xuICAgIG1lc3NhZ2U6IHN0cmluZztcbiAgICBkZXRhaWxzPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gICAgdGltZXN0YW1wOiBzdHJpbmc7XG59XG5cbi8qKiBQaGFzZSBvdXRwdXQgKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGhhc2VPdXRwdXQge1xuICAgIHBoYXNlOiBQaGFzZTtcbiAgICBwcm9tcHQ6IHN0cmluZztcbiAgICByZXNwb25zZTogc3RyaW5nO1xuICAgIHN1bW1hcnk6IHN0cmluZztcbiAgICB0aW1lc3RhbXA6IHN0cmluZztcbiAgICAvKiogVG9vbCBpbnZvY2F0aW9ucyBjYXB0dXJlZCBkdXJpbmcgdGhpcyBwaGFzZSAqL1xuICAgIHRvb2xzPzogVG9vbEludm9jYXRpb25bXTtcbn1cblxuLyoqIFRvb2wgaW52b2NhdGlvbiBjYXB0dXJlZCBmcm9tIE9wZW5Db2RlIHN0cmVhbSAqL1xuZXhwb3J0IGludGVyZmFjZSBUb29sSW52b2NhdGlvbiB7XG4gICAgLyoqIFVuaXF1ZSB0b29sIElEICovXG4gICAgaWQ6IHN0cmluZztcbiAgICAvKiogVG9vbCBuYW1lIChlLmcuLCBcImJhc2hcIiwgXCJyZWFkXCIsIFwid3JpdGVcIiwgXCJlZGl0XCIpICovXG4gICAgbmFtZTogc3RyaW5nO1xuICAgIC8qKiBJbnB1dCBhcmd1bWVudHMgKG1heSBiZSB0cnVuY2F0ZWQvcmVkYWN0ZWQgZm9yIHNlY3JldHMpICovXG4gICAgaW5wdXQ/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgICAvKiogT3V0cHV0IHJlc3VsdCAobWF5IGJlIHRydW5jYXRlZCkgKi9cbiAgICBvdXRwdXQ/OiBzdHJpbmc7XG4gICAgLyoqIFdoZXRoZXIgdGhlIHRvb2wgY2FsbCBzdWNjZWVkZWQgKi9cbiAgICBzdGF0dXM6IFwib2tcIiB8IFwiZXJyb3JcIjtcbiAgICAvKiogRXJyb3IgbWVzc2FnZSBpZiBzdGF0dXMgaXMgZXJyb3IgKi9cbiAgICBlcnJvcj86IHN0cmluZztcbiAgICAvKiogV2hlbiB0aGUgdG9vbCBjYWxsIHN0YXJ0ZWQgKElTTyB0aW1lc3RhbXApICovXG4gICAgc3RhcnRlZEF0Pzogc3RyaW5nO1xuICAgIC8qKiBXaGVuIHRoZSB0b29sIGNhbGwgY29tcGxldGVkIChJU08gdGltZXN0YW1wKSAqL1xuICAgIGNvbXBsZXRlZEF0Pzogc3RyaW5nO1xufVxuXG4vKiogU2luZ2xlIGl0ZXJhdGlvbiBjeWNsZSBzdGF0ZSAqL1xuZXhwb3J0IGludGVyZmFjZSBDeWNsZVN0YXRlIHtcbiAgICBjeWNsZU51bWJlcjogbnVtYmVyO1xuICAgIHN0YXR1czogXCJwZW5kaW5nXCIgfCBcInJ1bm5pbmdcIiB8IFwiY29tcGxldGVkXCIgfCBcImZhaWxlZFwiO1xuICAgIHN0YXJ0VGltZTogc3RyaW5nO1xuICAgIGVuZFRpbWU/OiBzdHJpbmc7XG4gICAgZHVyYXRpb25Ncz86IG51bWJlcjtcbiAgICBwaGFzZXM6IHtcbiAgICAgICAgW2tleSBpbiBQaGFzZV0/OiBQaGFzZU91dHB1dDtcbiAgICB9O1xuICAgIGdhdGVSZXN1bHRzOiBHYXRlUmVzdWx0W107XG4gICAgY29tcGxldGlvblByb21pc2VPYnNlcnZlZDogYm9vbGVhbjtcbiAgICBzdG9wUmVhc29uPzogU3RvcFJlYXNvbjtcbiAgICBlcnJvcj86IHN0cmluZztcbiAgICAvLyBGb3Igc3R1Y2sgZGV0ZWN0aW9uIC0gaGFzaCBvZiBvdXRwdXRzIHRvIGRldGVjdCBuby1wcm9ncmVzc1xuICAgIG91dHB1dEhhc2g/OiBzdHJpbmc7XG59XG5cbi8qKiBNYWluIGZsb3cgc3RhdGUgKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmxvd1N0YXRlIHtcbiAgICAvKiogU2NoZW1hIHZlcnNpb24gZm9yIG1pZ3JhdGlvbnMgKi9cbiAgICBzY2hlbWFWZXJzaW9uOiBzdHJpbmc7XG5cbiAgICAvKiogUnVuIGlkZW50aWZpY2F0aW9uICovXG4gICAgcnVuSWQ6IHN0cmluZztcbiAgICBwcm9tcHQ6IHN0cmluZztcblxuICAgIC8qKiBSdW4gc3RhdHVzICovXG4gICAgc3RhdHVzOiBSdW5TdGF0dXM7XG4gICAgc3RvcFJlYXNvbj86IFN0b3BSZWFzb247XG5cbiAgICAvKiogTG9vcCBwYXJhbWV0ZXJzICovXG4gICAgY29tcGxldGlvblByb21pc2U6IHN0cmluZztcbiAgICBtYXhDeWNsZXM6IG51bWJlcjtcbiAgICBzdHVja1RocmVzaG9sZDogbnVtYmVyO1xuICAgIGdhdGVzOiBzdHJpbmdbXTtcblxuICAgIC8qKiBDeWNsZSB0cmFja2luZyAqL1xuICAgIGN1cnJlbnRDeWNsZTogbnVtYmVyO1xuICAgIGNvbXBsZXRlZEN5Y2xlczogbnVtYmVyO1xuICAgIGZhaWxlZEN5Y2xlczogbnVtYmVyO1xuICAgIHN0dWNrQ291bnQ6IG51bWJlcjtcblxuICAgIC8qKiBUaW1lc3RhbXBzICovXG4gICAgY3JlYXRlZEF0OiBzdHJpbmc7XG4gICAgdXBkYXRlZEF0OiBzdHJpbmc7XG4gICAgY29tcGxldGVkQXQ/OiBzdHJpbmc7XG5cbiAgICAvKiogTGFzdCBzdWNjZXNzZnVsIGNoZWNrcG9pbnQgZm9yIHJlLWFuY2hvcmluZyAqL1xuICAgIGxhc3RDaGVja3BvaW50Pzoge1xuICAgICAgICBjeWNsZU51bWJlcjogbnVtYmVyO1xuICAgICAgICBzdW1tYXJ5OiBzdHJpbmc7XG4gICAgICAgIHRpbWVzdGFtcDogc3RyaW5nO1xuICAgIH07XG5cbiAgICAvKiogRXJyb3IgaW5mbyBpZiBmYWlsZWQgKi9cbiAgICBlcnJvcj86IHN0cmluZztcbn1cblxuLyoqIENoZWNrcG9pbnQgZm9yIGZhc3QgcmVzdW1lICovXG5leHBvcnQgaW50ZXJmYWNlIENoZWNrcG9pbnQge1xuICAgIHNjaGVtYVZlcnNpb246IHN0cmluZztcbiAgICBydW5JZDogc3RyaW5nO1xuICAgIGN5Y2xlTnVtYmVyOiBudW1iZXI7XG4gICAgdGltZXN0YW1wOiBzdHJpbmc7XG4gICAgc3RhdGU6IEZsb3dTdGF0ZTtcbiAgICBsYXN0UGhhc2VPdXRwdXRzOiB7XG4gICAgICAgIFtrZXkgaW4gUGhhc2VdPzogUGhhc2VPdXRwdXQ7XG4gICAgfTtcbn1cblxuLyoqIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBsb29wIHJ1bm5lciAqL1xuZXhwb3J0IGludGVyZmFjZSBMb29wQ29uZmlnIHtcbiAgICBydW5JZDogc3RyaW5nO1xuICAgIHByb21wdDogc3RyaW5nO1xuICAgIGNvbXBsZXRpb25Qcm9taXNlOiBzdHJpbmc7XG4gICAgbWF4Q3ljbGVzOiBudW1iZXI7XG4gICAgc3R1Y2tUaHJlc2hvbGQ6IG51bWJlcjtcbiAgICBnYXRlczogc3RyaW5nW107XG4gICAgY2hlY2twb2ludEZyZXF1ZW5jeTogbnVtYmVyO1xuICAgIGZsb3dEaXI6IHN0cmluZztcbiAgICBkcnlSdW46IGJvb2xlYW47XG4gICAgLyoqIE51bWJlciBvZiByZXRyeSBhdHRlbXB0cyBwZXIgY3ljbGUgb24gZmFpbHVyZSAqL1xuICAgIGN5Y2xlUmV0cmllczogbnVtYmVyO1xuICAgIC8qKiBPcGVuQ29kZSBwcm9tcHQgdGltZW91dCBpbiBtcyAodXNlZCBhcyBpZGxlIHRpbWVvdXQpICovXG4gICAgcHJvbXB0VGltZW91dD86IG51bWJlcjtcbiAgICAvKiogUGhhc2UgaGFyZCB0aW1lb3V0IGluIG1zIChydW5uZXItc2lkZSB3YXRjaGRvZykgKi9cbiAgICBwaGFzZVRpbWVvdXRNcz86IG51bWJlcjtcbiAgICAvKiogQ3ljbGUgaGFyZCB0aW1lb3V0IGluIG1zICovXG4gICAgY3ljbGVUaW1lb3V0TXM/OiBudW1iZXI7XG4gICAgLyoqIFJ1biBoYXJkIHRpbWVvdXQgaW4gbXMgKi9cbiAgICBydW5UaW1lb3V0TXM/OiBudW1iZXI7XG4gICAgLyoqIERlYnVnIG1vZGU6IHByaW50IHRvb2wgaW52b2NhdGlvbnMgdG8gY29uc29sZS9sb2dzICovXG4gICAgZGVidWdXb3JrOiBib29sZWFuO1xufVxuIiwKICAgICIvKipcbiAqIENMSSBleGVjdXRpb24gbW9kZSBmb3IgYWktZW5nIHJhbHBoXG4gKlxuICogTm9uLVRVSSBleGVjdXRpb24gd2l0aCBpbnRlcmFjdGl2ZSBwcm9tcHRzIHVzaW5nIEBjbGFjay9wcm9tcHRzXG4gKlxuICogU3VwcG9ydHMgdHdvIG1vZGVzOlxuICogLSBMb29wIG1vZGUgKGRlZmF1bHQpOiBJdGVyYXRlcyB3aXRoIGZyZXNoIE9wZW5Db2RlIHNlc3Npb25zIHBlciBjeWNsZVxuICogLSBTaW5nbGUtc2hvdCBtb2RlICgtLW5vLWxvb3ApOiBTaW5nbGUgZXhlY3V0aW9uIHdpdGggcHJvbXB0IG9wdGltaXphdGlvblxuICovXG5pbXBvcnQgeyBpc0NhbmNlbCwgb3V0cm8sIHNlbGVjdCwgc3Bpbm5lciB9IGZyb20gXCJAY2xhY2svcHJvbXB0c1wiO1xuaW1wb3J0IHtcbiAgICB0eXBlIE1lc3NhZ2VSZXNwb25zZSxcbiAgICBPcGVuQ29kZUNsaWVudCxcbn0gZnJvbSBcIi4uL2JhY2tlbmRzL29wZW5jb2RlL2NsaWVudFwiO1xuaW1wb3J0IHR5cGUgeyBBaUVuZ0NvbmZpZyB9IGZyb20gXCIuLi9jb25maWcvc2NoZW1hXCI7XG5pbXBvcnQge1xuICAgIFJhbHBoTG9vcFJ1bm5lcixcbiAgICBjcmVhdGVSYWxwaExvb3BSdW5uZXIsXG59IGZyb20gXCIuLi9leGVjdXRpb24vcmFscGgtbG9vcFwiO1xuaW1wb3J0IHsgUHJvbXB0T3B0aW1pemVyIH0gZnJvbSBcIi4uL3Byb21wdC1vcHRpbWl6YXRpb24vb3B0aW1pemVyXCI7XG5pbXBvcnQgeyBMb2cgfSBmcm9tIFwiLi4vdXRpbC9sb2dcIjtcbmltcG9ydCB0eXBlIHsgUmFscGhGbGFncyB9IGZyb20gXCIuL2ZsYWdzXCI7XG5pbXBvcnQgeyBVSSB9IGZyb20gXCIuL3VpXCI7XG5cbmNvbnN0IGxvZyA9IExvZy5jcmVhdGUoeyBzZXJ2aWNlOiBcInJ1bi1jbGlcIiB9KTtcblxuLyoqXG4gKiBDbGVhbnVwIGhhbmRsZXIgdG8gZW5zdXJlIE9wZW5Db2RlIHNlcnZlciBpcyBwcm9wZXJseSBzaHV0IGRvd25cbiAqL1xubGV0IGFjdGl2ZUNsaWVudDogT3BlbkNvZGVDbGllbnQgfCBudWxsID0gbnVsbDtcbmxldCBjbGVhbnVwSGFuZGxlcnNSZWdpc3RlcmVkID0gZmFsc2U7XG5cbmFzeW5jIGZ1bmN0aW9uIHNldHVwQ2xlYW51cEhhbmRsZXJzKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmIChjbGVhbnVwSGFuZGxlcnNSZWdpc3RlcmVkKSByZXR1cm47XG4gICAgY2xlYW51cEhhbmRsZXJzUmVnaXN0ZXJlZCA9IHRydWU7XG4gICAgY29uc3QgY2xlYW51cEZuID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoYWN0aXZlQ2xpZW50KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxvZy5pbmZvKFwiQ2xlYW51cCBzaWduYWwgcmVjZWl2ZWQsIGNsb3NpbmcgT3BlbkNvZGUgc2VydmVyLi4uXCIpO1xuICAgICAgICAgICAgICAgIGF3YWl0IGFjdGl2ZUNsaWVudC5jbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgbG9nLmluZm8oXCJPcGVuQ29kZSBzZXJ2ZXIgY2xvc2VkIHN1Y2Nlc3NmdWxseVwiKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNc2cgPVxuICAgICAgICAgICAgICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICAgICAgICAgICAgbG9nLmVycm9yKFwiRXJyb3IgZHVyaW5nIGNsZWFudXBcIiwgeyBlcnJvcjogZXJyb3JNc2cgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY3RpdmVDbGllbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3MuZXhpdCgwKTtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIHZhcmlvdXMgZXhpdCBzaWduYWxzXG4gICAgcHJvY2Vzcy5vbihcIlNJR0lOVFwiLCBjbGVhbnVwRm4pO1xuICAgIHByb2Nlc3Mub24oXCJTSUdURVJNXCIsIGNsZWFudXBGbik7XG4gICAgcHJvY2Vzcy5vbihcIlNJR0hVUFwiLCBjbGVhbnVwRm4pO1xuXG4gICAgLy8gSGFuZGxlIHVuY2F1Z2h0IGVycm9yc1xuICAgIHByb2Nlc3Mub24oXCJ1bmNhdWdodEV4Y2VwdGlvblwiLCBhc3luYyAoZXJyb3IpID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3JNc2cgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICAgIGxvZy5lcnJvcihcIlVuY2F1Z2h0IGV4Y2VwdGlvblwiLCB7XG4gICAgICAgICAgICBlcnJvcjogZXJyb3JNc2csXG4gICAgICAgICAgICBzdGFjazogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLnN0YWNrIDogdW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgY2xlYW51cEZuKCk7XG4gICAgfSk7XG5cbiAgICBwcm9jZXNzLm9uKFwidW5oYW5kbGVkUmVqZWN0aW9uXCIsIGFzeW5jIChyZWFzb24pID0+IHtcbiAgICAgICAgY29uc3QgZXJyb3JNc2cgPVxuICAgICAgICAgICAgcmVhc29uIGluc3RhbmNlb2YgRXJyb3IgPyByZWFzb24ubWVzc2FnZSA6IFN0cmluZyhyZWFzb24pO1xuICAgICAgICBsb2cuZXJyb3IoXCJVbmhhbmRsZWQgcmVqZWN0aW9uXCIsIHtcbiAgICAgICAgICAgIGVycm9yOiBlcnJvck1zZyxcbiAgICAgICAgICAgIHN0YWNrOiByZWFzb24gaW5zdGFuY2VvZiBFcnJvciA/IHJlYXNvbi5zdGFjayA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IGNsZWFudXBGbigpO1xuICAgIH0pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcnVuQ2xpKFxuICAgIGNvbmZpZzogQWlFbmdDb25maWcsXG4gICAgZmxhZ3M6IFJhbHBoRmxhZ3MsXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBTZXR1cCBjbGVhbnVwIGhhbmRsZXJzXG4gICAgYXdhaXQgc2V0dXBDbGVhbnVwSGFuZGxlcnMoKTtcblxuICAgIGxvZy5pbmZvKFwiU3RhcnRpbmcgQ0xJIGV4ZWN1dGlvblwiLCB7IHdvcmtmbG93OiBmbGFncy53b3JrZmxvdyB9KTtcblxuICAgIGNvbnN0IHByb21wdCA9IGZsYWdzLndvcmtmbG93O1xuICAgIGlmICghcHJvbXB0KSB7XG4gICAgICAgIFVJLmVycm9yKFwiTm8gcHJvbXB0IG9yIHdvcmtmbG93IHByb3ZpZGVkXCIpO1xuICAgICAgICBwcm9jZXNzLmV4aXQoMSk7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBvcHRpbWl6ZXJcbiAgICBjb25zdCBvcHRpbWl6ZXIgPSBuZXcgUHJvbXB0T3B0aW1pemVyKHtcbiAgICAgICAgYXV0b0FwcHJvdmU6IGZsYWdzLmNpID8/IGZhbHNlLFxuICAgICAgICB2ZXJib3NpdHk6IGZsYWdzLnZlcmJvc2UgPyBcInZlcmJvc2VcIiA6IFwibm9ybWFsXCIsXG4gICAgfSk7XG5cbiAgICAvLyBDcmVhdGUgb3B0aW1pemF0aW9uIHNlc3Npb25cbiAgICBVSS5oZWFkZXIoXCJQcm9tcHQgT3B0aW1pemF0aW9uXCIpO1xuICAgIGNvbnN0IHNlc3Npb24gPSBvcHRpbWl6ZXIuY3JlYXRlU2Vzc2lvbihwcm9tcHQpO1xuICAgIGxvZy5kZWJ1ZyhcIkNyZWF0ZWQgb3B0aW1pemF0aW9uIHNlc3Npb25cIiwgeyBzdGVwczogc2Vzc2lvbi5zdGVwcy5sZW5ndGggfSk7XG5cbiAgICAvLyBSZXZpZXcgc3RlcHMgaW50ZXJhY3RpdmVseSAodW5sZXNzIENJIG1vZGUpXG4gICAgaWYgKCFmbGFncy5jaSkge1xuICAgICAgICBmb3IgKGNvbnN0IHN0ZXAgb2Ygc2Vzc2lvbi5zdGVwcykge1xuICAgICAgICAgICAgY29uc3QgYWN0aW9uID0gYXdhaXQgc2VsZWN0KHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgQXBwbHkgXCIke3N0ZXAubmFtZX1cIj9cXG4gICR7c3RlcC5kZXNjcmlwdGlvbn1gLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwiYXBwcm92ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IFwiQXBwcm92ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGludDogXCJBcHBseSB0aGlzIG9wdGltaXphdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJyZWplY3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBcIlJlamVjdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGludDogXCJTa2lwIHRoaXMgb3B0aW1pemF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcInNraXAtYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogXCJTa2lwIGFsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGludDogXCJVc2Ugb3JpZ2luYWwgcHJvbXB0XCIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoaXNDYW5jZWwoYWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIGxvZy5pbmZvKFwiVXNlciBjYW5jZWxsZWRcIik7XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5leGl0KDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWN0aW9uID09PSBcInNraXAtYWxsXCIpIHtcbiAgICAgICAgICAgICAgICBvcHRpbWl6ZXIuc2tpcE9wdGltaXphdGlvbihzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhY3Rpb24gPT09IFwiYXBwcm92ZVwiKSB7XG4gICAgICAgICAgICAgICAgb3B0aW1pemVyLmFwcHJvdmVTdGVwKHNlc3Npb24sIHN0ZXAuaWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpbWl6ZXIucmVqZWN0U3RlcChzZXNzaW9uLCBzdGVwLmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJvdXRlIHRvIGxvb3AgbW9kZSBvciBzaW5nbGUtc2hvdCBtb2RlXG4gICAgaWYgKGZsYWdzLmxvb3AgIT09IGZhbHNlKSB7XG4gICAgICAgIC8vIExvb3AgbW9kZSAoZGVmYXVsdClcbiAgICAgICAgYXdhaXQgcnVuTG9vcE1vZGUoY29uZmlnLCBmbGFncywgc2Vzc2lvbi5maW5hbFByb21wdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2luZ2xlLXNob3QgbW9kZSAoLS1uby1sb29wKVxuICAgICAgICBhd2FpdCBydW5TaW5nbGVTaG90TW9kZShjb25maWcsIGZsYWdzLCBzZXNzaW9uLmZpbmFsUHJvbXB0KTtcbiAgICB9XG59XG5cbi8qKlxuICogUnVuIGluIFJhbHBoIGxvb3AgbW9kZSAoZGVmYXVsdCkgLSBpdGVyYXRlcyB3aXRoIGZyZXNoIHNlc3Npb25zIHBlciBjeWNsZVxuICovXG5hc3luYyBmdW5jdGlvbiBydW5Mb29wTW9kZShcbiAgICBjb25maWc6IEFpRW5nQ29uZmlnLFxuICAgIGZsYWdzOiBSYWxwaEZsYWdzLFxuICAgIF9vcHRpbWl6ZWRQcm9tcHQ6IHN0cmluZyxcbik6IFByb21pc2U8dm9pZD4ge1xuICAgIFVJLmhlYWRlcihcIlJhbHBoIExvb3AgTW9kZVwiKTtcbiAgICBVSS5pbmZvKFwiUnVubmluZyB3aXRoIGZyZXNoIE9wZW5Db2RlIHNlc3Npb25zIHBlciBpdGVyYXRpb25cIik7XG5cbiAgICAvLyBTaG93IG1vZGUgaW5mb1xuICAgIGlmIChmbGFncy5zaGlwKSB7XG4gICAgICAgIFVJLmluZm8oXG4gICAgICAgICAgICBcIk1vZGU6IFNISVAgKGF1dG8tZXhpdCB3aGVuIGFnZW50IG91dHB1dHMgJzxwcm9taXNlPlNISVA8L3Byb21pc2U+JylcIixcbiAgICAgICAgKTtcbiAgICAgICAgVUkuaW5mbyhcIkNvbXBsZXRpb24gcHJvbWlzZTogPHByb21pc2U+U0hJUDwvcHJvbWlzZT5cIik7XG4gICAgfSBlbHNlIGlmIChmbGFncy5kcmFmdCB8fCAoIWZsYWdzLnNoaXAgJiYgIWZsYWdzLmNvbXBsZXRpb25Qcm9taXNlKSkge1xuICAgICAgICBVSS5pbmZvKFwiTW9kZTogRFJBRlQgKHJ1bnMgZm9yIG1heC1jeWNsZXMgdGhlbiBzdG9wcyBmb3IgeW91ciByZXZpZXcpXCIpO1xuICAgICAgICBVSS5pbmZvKFwiQ29tcGxldGlvbiBwcm9taXNlOiBub25lICh3aWxsIHJ1biBhbGwgY3ljbGVzKVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBVSS5pbmZvKFwiTW9kZTogQ3VzdG9tIGNvbXBsZXRpb24gcHJvbWlzZVwiKTtcbiAgICAgICAgVUkuaW5mbyhgQ29tcGxldGlvbiBwcm9taXNlOiAke2ZsYWdzLmNvbXBsZXRpb25Qcm9taXNlfWApO1xuICAgIH1cblxuICAgIFVJLmluZm8oYE1heCBjeWNsZXM6ICR7ZmxhZ3MubWF4Q3ljbGVzID8/IDUwfWApO1xuICAgIFVJLmluZm8oYFN0dWNrIHRocmVzaG9sZDogJHtmbGFncy5zdHVja1RocmVzaG9sZCA/PyA1fWApO1xuICAgIFVJLnByaW50bG4oKTtcblxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJ1bm5lciA9IGF3YWl0IGNyZWF0ZVJhbHBoTG9vcFJ1bm5lcihmbGFncywgY29uZmlnKTtcbiAgICAgICAgYXdhaXQgcnVubmVyLnJ1bigpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICAgIGxvZy5lcnJvcihcIkxvb3AgZXhlY3V0aW9uIGZhaWxlZFwiLCB7IGVycm9yOiBtZXNzYWdlIH0pO1xuICAgICAgICBVSS5lcnJvcihtZXNzYWdlKTtcbiAgICAgICAgcHJvY2Vzcy5leGl0KDEpO1xuICAgIH1cblxuICAgIG91dHJvKFwiRG9uZSFcIik7XG59XG5cbi8qKlxuICogUnVuIGluIHNpbmdsZS1zaG90IG1vZGUgKC0tbm8tbG9vcCkgLSBzaW5nbGUgZXhlY3V0aW9uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJ1blNpbmdsZVNob3RNb2RlKFxuICAgIGNvbmZpZzogQWlFbmdDb25maWcsXG4gICAgZmxhZ3M6IFJhbHBoRmxhZ3MsXG4gICAgb3B0aW1pemVkUHJvbXB0OiBzdHJpbmcsXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyBFeGVjdXRlIHNpbmdsZS1zaG90XG4gICAgVUkuaGVhZGVyKFwiRXhlY3V0aW9uXCIpO1xuICAgIGNvbnN0IHMgPSBzcGlubmVyKCk7XG4gICAgcy5zdGFydChcIkNvbm5lY3RpbmcgdG8gT3BlbkNvZGUuLi5cIik7XG5cbiAgICB0cnkge1xuICAgICAgICAvLyBDcmVhdGUgT3BlbkNvZGUgY2xpZW50IC0gdGhpcyB3aWxsIGVpdGhlciBzcGF3biBhIG5ldyBzZXJ2ZXIgb3IgY29ubmVjdCB0byBleGlzdGluZyBvbmVcbiAgICAgICAgYWN0aXZlQ2xpZW50ID0gYXdhaXQgT3BlbkNvZGVDbGllbnQuY3JlYXRlKHtcbiAgICAgICAgICAgIGV4aXN0aW5nU2VydmVyVXJsOiBwcm9jZXNzLmVudi5PUEVOQ09ERV9VUkwsXG4gICAgICAgICAgICBzZXJ2ZXJTdGFydHVwVGltZW91dDogMTAwMDAsIC8vIEFsbG93IDEwIHNlY29uZHMgZm9yIHNlcnZlciB0byBzdGFydFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBvcGVuU2Vzc2lvbiA9IGF3YWl0IGFjdGl2ZUNsaWVudC5jcmVhdGVTZXNzaW9uKG9wdGltaXplZFByb21wdCk7XG4gICAgICAgIGxvZy5pbmZvKFwiQ3JlYXRlZCBPcGVuQ29kZSBzZXNzaW9uXCIsIHsgaWQ6IG9wZW5TZXNzaW9uLmlkIH0pO1xuXG4gICAgICAgIHMuc3RvcChcIkNvbm5lY3RlZFwiKTtcblxuICAgICAgICAvLyBTZW5kIHByb21wdCBhbmQgc3RyZWFtIHJlc3BvbnNlXG4gICAgICAgIFVJLnByaW50bG4oKTtcbiAgICAgICAgVUkucHJpbnRsbihcbiAgICAgICAgICAgIGAke1VJLlN0eWxlLlRFWFRfRElNfUV4ZWN1dGluZyB0YXNrLi4uJHtVSS5TdHlsZS5URVhUX05PUk1BTH1gLFxuICAgICAgICApO1xuXG4gICAgICAgIGxldCByZXNwb25zZTogTWVzc2FnZVJlc3BvbnNlO1xuXG4gICAgICAgIGlmICghZmxhZ3Mubm9TdHJlYW0pIHtcbiAgICAgICAgICAgIC8vIFN0cmVhbWluZyBtb2RlIChkZWZhdWx0KVxuICAgICAgICAgICAgY29uc3Qgc3RyZWFtaW5nUmVzcG9uc2UgPSBhd2FpdCBvcGVuU2Vzc2lvbi5zZW5kTWVzc2FnZVN0cmVhbShcbiAgICAgICAgICAgICAgICBcIkV4ZWN1dGUgdGhpcyB0YXNrIGFuZCBwcm92aWRlIGEgZGV0YWlsZWQgcmVzdWx0IHN1bW1hcnkuXCIsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBVSS5wcmludGxuKCk7XG5cbiAgICAgICAgICAgIC8vIFN0cmVhbSBjb250ZW50IHRvIHN0ZGVyciBpbiByZWFsLXRpbWVcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbWluZ1Jlc3BvbnNlLnN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gZGVjb2Rlci5kZWNvZGUodmFsdWUsIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgVUkucHJpbnQodGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBHZXQgY29tcGxldGUgcmVzcG9uc2UgZm9yIGNsZWFudXBcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgc3RyZWFtaW5nUmVzcG9uc2UuY29tcGxldGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBCdWZmZXJlZCBtb2RlICh3aGVuIC0tbm8tc3RyZWFtIGZsYWcgaXMgdXNlZClcbiAgICAgICAgICAgIFVJLnByaW50bG4oKTtcbiAgICAgICAgICAgIFVJLnByaW50bG4oXG4gICAgICAgICAgICAgICAgYCR7VUkuU3R5bGUuVEVYVF9ESU19QnVmZmVyaW5nIHJlc3BvbnNlLi4uJHtVSS5TdHlsZS5URVhUX05PUk1BTH1gLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBvcGVuU2Vzc2lvbi5zZW5kTWVzc2FnZShcbiAgICAgICAgICAgICAgICBcIkV4ZWN1dGUgdGhpcyB0YXNrIGFuZCBwcm92aWRlIGEgZGV0YWlsZWQgcmVzdWx0IHN1bW1hcnkuXCIsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBVSS5wcmludGxuKCk7XG4gICAgICAgICAgICBVSS5wcmludGxuKHJlc3BvbnNlLmNvbnRlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgVUkucHJpbnRsbigpO1xuICAgICAgICBVSS5zdWNjZXNzKFwiRXhlY3V0aW9uIGNvbXBsZXRlXCIpO1xuXG4gICAgICAgIC8vIENsZWFudXAgcmVzb3VyY2VzXG4gICAgICAgIGlmIChhY3RpdmVDbGllbnQpIHtcbiAgICAgICAgICAgIGF3YWl0IGFjdGl2ZUNsaWVudC5jbGVhbnVwKCk7XG4gICAgICAgICAgICBhY3RpdmVDbGllbnQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbG9nLmluZm8oXCJFeGVjdXRpb24gY29tcGxldGVcIik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcy5zdG9wKFwiQ29ubmVjdGlvbiBmYWlsZWRcIik7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICAgIGxvZy5lcnJvcihcIkV4ZWN1dGlvbiBmYWlsZWRcIiwgeyBlcnJvcjogbWVzc2FnZSB9KTtcbiAgICAgICAgVUkuZXJyb3IobWVzc2FnZSk7XG5cbiAgICAgICAgLy8gRW5zdXJlIGNsZWFudXAgb24gZXJyb3JcbiAgICAgICAgaWYgKGFjdGl2ZUNsaWVudCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBhY3RpdmVDbGllbnQuY2xlYW51cCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoY2xlYW51cEVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xlYW51cE1zZyA9XG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXBFcnJvciBpbnN0YW5jZW9mIEVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNsZWFudXBFcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFN0cmluZyhjbGVhbnVwRXJyb3IpO1xuICAgICAgICAgICAgICAgIGxvZy5lcnJvcihcIkVycm9yIGR1cmluZyBlcnJvciBjbGVhbnVwXCIsIHsgZXJyb3I6IGNsZWFudXBNc2cgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY3RpdmVDbGllbnQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvY2Vzcy5leGl0KDEpO1xuICAgIH1cblxuICAgIG91dHJvKFwiRG9uZSFcIik7XG59XG4iCiAgXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFFQSxJQUFNLFFBQVEsT0FBTyxJQUFJLFlBQVk7QUFBQSxFQUNyQyxJQUFNLE1BQU0sT0FBTyxJQUFJLGVBQWU7QUFBQSxFQUN0QyxJQUFNLE1BQU0sT0FBTyxJQUFJLFVBQVU7QUFBQSxFQUNqQyxJQUFNLE9BQU8sT0FBTyxJQUFJLFdBQVc7QUFBQSxFQUNuQyxJQUFNLFNBQVMsT0FBTyxJQUFJLGFBQWE7QUFBQSxFQUN2QyxJQUFNLE1BQU0sT0FBTyxJQUFJLFVBQVU7QUFBQSxFQUNqQyxJQUFNLFlBQVksT0FBTyxJQUFJLGdCQUFnQjtBQUFBLEVBQzdDLElBQU0sVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFDLFFBQVEsT0FBTyxTQUFTLFlBQVksS0FBSyxlQUFlO0FBQUEsRUFDcEYsSUFBTSxhQUFhLENBQUMsU0FBUyxDQUFDLENBQUMsUUFBUSxPQUFPLFNBQVMsWUFBWSxLQUFLLGVBQWU7QUFBQSxFQUN2RixJQUFNLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxRQUFRLE9BQU8sU0FBUyxZQUFZLEtBQUssZUFBZTtBQUFBLEVBQ2xGLElBQU0sU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDLFFBQVEsT0FBTyxTQUFTLFlBQVksS0FBSyxlQUFlO0FBQUEsRUFDbkYsSUFBTSxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUMsUUFBUSxPQUFPLFNBQVMsWUFBWSxLQUFLLGVBQWU7QUFBQSxFQUNyRixJQUFNLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxRQUFRLE9BQU8sU0FBUyxZQUFZLEtBQUssZUFBZTtBQUFBLEVBQ2xGLFNB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RyxLQUFHLFNBQU8sU0FBTyxLQUFHLEtBQUcsU0FBTyxTQUFPLEtBQUcsS0FBRyxTQUFPLFNBQU8sS0FBRyxLQUFHLFFBQU0sTUFBSSxRQUFNLEtBQUcsS0FBRyxRQUFNLFFBQU0sS0FBRyxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLFNBQU8sS0FBRyxLQUFHLFNBQU8sU0FBTyxLQUFHLEtBQUcsU0FBTyxTQUFPLEtBQUcsS0FBRyxTQUFPLFNBQU8sS0FBRyxLQUFHLFNBQU8sU0FBTyxLQUFHLEtBQUcsU0FBTyxTQUFPLEtBQUcsS0FBRyxTQUFPLFNBQU8sS0FBRyxLQUFHLFNBQU8sU0FBTyxLQUFHLEtBQUcsU0FBTyxTQUFPLEtBQUcsS0FBRyxTQUFPLFNBQU8sS0FBRyxLQUFHLFNBQU8sU0FBTyxLQUFHLEtBQUcsU0FBTyxTQUFPLEtBQUcsS0FBRyxTQUFPLFNBQU8sS0FBRyxLQUFHLFNBQU8sU0FBTyxLQUFHLEtBQUcsU0FBTyxTQUFPLEtBQUcsS0FBRyxTQUFPLFNBQU8sS0FBRyxLQUFHLFNBQU8sU0FBTyxLQUFHLEtBQUcsU0FBTyxTQUFPLEtBQUcsS0FBRyxTQUFPLFNBQU8sS0FBRyxLQUFHLFNBQU8sU0FBTyxLQUFHLEtBQUcsU0FBTyxTQUFPLEtBQUcsS0FBRyxTQUFPLFNBQU8sS0FBRyxLQUFHLFNBQU8sU0FBTyxLQUFHLEtBQUcsU0FBTyxTQUFPLEtBQUcsS0FBRyxTQUFPLFNBQU8sS0FBRyxLQUFHLFNBQU8sU0FBTyxLQUFHLEtBQUcsU0FBTyxVQUFRLEtBQUcsS0FBRyxVQUFRLFVBQVEsS0FBRyxLQUFHLFVBQVEsVUFBUSxLQUFHLEtBQUcsVUFBUSxVQUFRLEtBQUcsS0FBRyxVQUFRLFVBQVEsS0FBRyxLQUFHLFVBQVEsVUFBUSxLQUFHLEtBQUcsVUFBUSxVQUFRLEtBQUcsS0FBRyxVQUFRLFVBQVEsS0FBRyxLQUFHLFNBQU8sTUFBSSxNQUFJLEtBQUcsS0FBRyxPQUFLLE9BQUssS0FBRyxLQUFHLE9BQUssT0FBSyxLQUFHLEtBQUcsT0FBSyxLQUFHLE9BQUssS0FBRyxPQUFLLFNBQU8sS0FBRyxLQUFHLFNBQU8sU0FBTyxLQUFHLEtBQUcsUUFBTSxPQUFLLEtBQUcsT0FBSyxLQUFHLE9BQUssT0FBSyxLQUFHLEtBQUcsT0FBSyxLQUFHLE9BQUssT0FBSyxLQUFHLEtBQUcsT0FBSyxPQUFLLEtBQUcsS0FBRyxPQUFLLE9BQUssS0FBRyxLQUFHLE9BQUssT0FBSyxLQUFHLEtBQUcsT0FBSyxLQUFHLE9BQUssS0FBRyxPQUFLLE9BQUssS0FBRyxLQUFHLE9BQUssT0FBSyxLQUFHLEtBQUcsT0FBSyxLQUFHLE9BQUssT0FBSyxLQUFHLEtBQUcsT0FBSyxPQUFLLEtBQUcsS0FBRyxPQUFLLEtBQUcsT0FBSyxPQUFLLEtBQUcsS0FBRyxPQUFLLE9BQUssS0FBRyxLQUFHLE9BQUssS0FBRyxPQUFLLEtBQUcsT0FBSyxLQUFHLE9BQUssS0FBRyxPQUFLLEtBQUcsT0FBSyxLQUFHLE9BQUssT0FBSyxLQUFHLEtBQUcsT0FBSyxLQUFHLE9BQUssT0FBSyxLQUFHLEtBQUcsT0FBSyxLQUFHLE9BQUssT0FBSyxLQUFHLEtBQUcsT0FBSyxLQUFHLE9BQUssT0FBSyxLQUFHLEtBQUcsT0FBSyxLQUFHLE9BQUssT0FBSyxLQUFHLEtBQUcsT0FBSyxPQUFLLEtBQUcsS0FBRyxPQUFLLEtBQUcsT0FBSyxLQUFHLE9BQUssS0FBRyxPQUFLLEtBQUcsT0FBSyxLQUFHLE9BQUssS0FBRyxPQUFLLEtBQUcsT0FBSyxLQUFHLE9BQUssS0FBRyxPQUFLLEtBQUcsT0FBSyxLQUFHLE9BQUssS0FBRyxPQUFLLEtBQUcsT0FBSyxPQUFLLEtBQUcsS0FBRyxPQUFLLEtBQUcsT0FBSyxLQUFHLE9BQUssT0FBSyxLQUFHLEtBQUcsT0FBSyxLQUFHLE9BQUssS0FBRyxPQUFLLE9BQUssS0FBRyxLQUFHLE9BQUssT0FBSyxLQUFHLEtBQUcsT0FBSyxPQUFLLEtBQUcsS0FBRyxPQUFLLE9BQUssS0FBRyxLQUFHLE9BQUssT0FBSyxLQUFHLEtBQUcsT0FBSyxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxLQUFHLFFBQU0sS0FBRyxRQUFNLFFBQU0sS0FBRyxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLFFBQU0sS0FBRyxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxLQUFHLFFBQU0sS0FBRyxRQUFNLEtBQUcsUUFBTSxLQUFHLFFBQU0sS0FBRyxRQUFNLFFBQU0sS0FBRyxLQUFHLFFBQU0sS0FBRyxRQUFNLEtBQUcsUUFBTSxLQUFHLFFBQU0sS0FBRyxRQUFNLEtBQUcsUUFBTSxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxLQUFHLFFBQU0sS0FBRyxRQUFNLFFBQU0sS0FBRyxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLFFBQU0sS0FBRyxLQUFHLFFBQU0sS0FBRyxRQUFNLFFBQU0sS0FBRyxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxLQUFHLFFBQU0sS0FBRyxRQUFNLEtBQUcsUUFBTSxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLEtBQUcsUUFBTSxLQUFHLFFBQU0sS0FBRyxRQUFNLEtBQUcsUUFBTSxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxLQUFHLFFBQU0sS0FBRyxRQUFNLFFBQU0sS0FBRyxLQUFHLFFBQU0sS0FBRyxRQUFNLFFBQU0sS0FBRyxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxLQUFHLFFBQU0sS0FBRyxRQUFNLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLFFBQU0sS0FBRyxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLFFBQU0sS0FBRyxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxLQUFHLFFBQU0sS0FBRyxRQUFNLEtBQUcsUUFBTSxLQUFHLFFBQU0sS0FBRyxRQUFNLFFBQU0sS0FBRyxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLFFBQU0sS0FBRyxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLFFBQU0sS0FBRyxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLFFBQU0sS0FBRyxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLFFBQU0sS0FBRyxLQUFHLFFBQU0sS0FBRyxRQUFNLFFBQU0sS0FBRyxLQUFHLFFBQU0sS0FBRyxRQUFNLFFBQU0sS0FBRyxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxLQUFHLFFBQU0sS0FBRyxRQUFNLEtBQUcsUUFBTSxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLFFBQU0sS0FBRyxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLFFBQU0sS0FBRyxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxLQUFHLFNBQU8sS0FBRyxTQUFPLFNBQU8sS0FBRyxLQUFHLFNBQU8sU0FBTyxLQUFHLEtBQUcsU0FBTyxTQUFPLEtBQUcsS0FBRyxTQUFPLFNBQU8sS0FBRyxLQUFHLFNBQU8sU0FBTyxLQUFHLEtBQUcsU0FBTyxLQUFHLFNBQU8sVUFBUSxLQUFHLEtBQUcsVUFBUSxVQUFRLEtBQUcsS0FBRyxVQUFRLFVBQVEsS0FBRyxLQUFHLFVBQVEsVUFBUSxLQUFHLEtBQUcsVUFBUSxVQUFRLEtBQUcsS0FBRyxVQUFRLFVBQVEsS0FBRyxLQUFHLFdBQVMsV0FBUyxLQUFHLEtBQUcsVUFBUSxNQUFJO0FBQUEsS0FB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Q0FBQyxHQUFFLEVBQUUsR0FBRSxVQUFTLENBQUMsSUFBRyxFQUFFLEdBQUUsU0FBUSxDQUFDLEdBQUUsRUFBRSxHQUFFLFFBQU8sQ0FBQyxHQUFFLEVBQUUsR0FBRSxlQUFjLENBQUMsR0FBRSxFQUFFLEVBQUMsR0FBRSxPQUFNLEVBQUMsT0FBTSxDQUFDLElBQUcsRUFBRSxHQUFFLEtBQUksQ0FBQyxJQUFHLEVBQUUsR0FBRSxPQUFNLENBQUMsSUFBRyxFQUFFLEdBQUUsUUFBTyxDQUFDLElBQUcsRUFBRSxHQUFFLE1BQUssQ0FBQyxJQUFHLEVBQUUsR0FBRSxTQUFRLENBQUMsSUFBRyxFQUFFLEdBQUUsTUFBSyxDQUFDLElBQUcsRUFBRSxHQUFFLE9BQU0sQ0FBQyxJQUFHLEVBQUUsR0FBRSxhQUFZLENBQUMsSUFBRyxFQUFFLEdBQUUsTUFBSyxDQUFDLElBQUcsRUFBRSxHQUFFLE1BQUssQ0FBQyxJQUFHLEVBQUUsR0FBRSxXQUFVLENBQUMsSUFBRyxFQUFFLEdBQUUsYUFBWSxDQUFDLElBQUcsRUFBRSxHQUFFLGNBQWEsQ0FBQyxJQUFHLEVBQUUsR0FBRSxZQUFXLENBQUMsSUFBRyxFQUFFLEdBQUUsZUFBYyxDQUFDLElBQUcsRUFBRSxHQUFFLFlBQVcsQ0FBQyxJQUFHLEVBQUUsR0FBRSxhQUFZLENBQUMsSUFBRyxFQUFFLEVBQUMsR0FBRSxTQUFRLEVBQUMsU0FBUSxDQUFDLElBQUcsRUFBRSxHQUFFLE9BQU0sQ0FBQyxJQUFHLEVBQUUsR0FBRSxTQUFRLENBQUMsSUFBRyxFQUFFLEdBQUUsVUFBUyxDQUFDLElBQUcsRUFBRSxHQUFFLFFBQU8sQ0FBQyxJQUFHLEVBQUUsR0FBRSxXQUFVLENBQUMsSUFBRyxFQUFFLEdBQUUsUUFBTyxDQUFDLElBQUcsRUFBRSxHQUFFLFNBQVEsQ0FBQyxJQUFHLEVBQUUsR0FBRSxlQUFjLENBQUMsS0FBSSxFQUFFLEdBQUUsUUFBTyxDQUFDLEtBQUksRUFBRSxHQUFFLFFBQU8sQ0FBQyxLQUFJLEVBQUUsR0FBRSxhQUFZLENBQUMsS0FBSSxFQUFFLEdBQUUsZUFBYyxDQUFDLEtBQUksRUFBRSxHQUFFLGdCQUFlLENBQUMsS0FBSSxFQUFFLEdBQUUsY0FBYSxDQUFDLEtBQUksRUFBRSxHQUFFLGlCQUFnQixDQUFDLEtBQUksRUFBRSxHQUFFLGNBQWEsQ0FBQyxLQUFJLEVBQUUsR0FBRSxlQUFjLENBQUMsS0FBSSxFQUFFLEVBQUMsRUFBQztBQUFFLE9BQU8sS0FBSyxFQUFFLFFBQVE7QUFBRSxJQUFNLEtBQUcsT0FBTyxLQUFLLEVBQUUsS0FBSztBQUE1QixJQUE4QixLQUFHLE9BQU8sS0FBSyxFQUFFLE9BQU87QUFBRSxDQUFDLEdBQUcsSUFBRyxHQUFHLEVBQUU7QUFBRSxTQUFTLEVBQUUsR0FBRTtBQUFBLEVBQUMsTUFBTSxJQUFFLElBQUk7QUFBQSxFQUFJLFlBQVUsR0FBRSxNQUFLLE9BQU8sUUFBUSxDQUFDLEdBQUU7QUFBQSxJQUFDLFlBQVUsR0FBRSxNQUFLLE9BQU8sUUFBUSxDQUFDO0FBQUEsTUFBRSxFQUFFLEtBQUcsRUFBQyxNQUFLLFFBQVEsRUFBRSxPQUFNLE9BQU0sUUFBUSxFQUFFLE1BQUssR0FBRSxFQUFFLEtBQUcsRUFBRSxJQUFHLEVBQUUsSUFBSSxFQUFFLElBQUcsRUFBRSxFQUFFO0FBQUEsSUFBRSxPQUFPLGVBQWUsR0FBRSxHQUFFLEVBQUMsT0FBTSxHQUFFLFlBQVcsTUFBRSxDQUFDO0FBQUEsRUFBQztBQUFBLEVBQUMsT0FBTyxPQUFPLGVBQWUsR0FBRSxTQUFRLEVBQUMsT0FBTSxHQUFFLFlBQVcsTUFBRSxDQUFDLEdBQUUsRUFBRSxNQUFNLFFBQU0sWUFBVyxFQUFFLFFBQVEsUUFBTSxZQUFXLEVBQUUsTUFBTSxPQUFLLEVBQUUsR0FBRSxFQUFFLE1BQU0sVUFBUSxFQUFFLEdBQUUsRUFBRSxNQUFNLFVBQVEsRUFBRSxHQUFFLEVBQUUsUUFBUSxPQUFLLEVBQUUsQ0FBQyxHQUFFLEVBQUUsUUFBUSxVQUFRLEVBQUUsQ0FBQyxHQUFFLEVBQUUsUUFBUSxVQUFRLEVBQUUsQ0FBQyxHQUFFLE9BQU8saUJBQWlCLEdBQUUsRUFBQyxjQUFhLEVBQUMsT0FBTSxDQUFDLEdBQUUsR0FBRSxNQUFJLE1BQUksS0FBRyxNQUFJLElBQUUsSUFBRSxJQUFFLEtBQUcsSUFBRSxNQUFJLE1BQUksS0FBSyxPQUFPLElBQUUsS0FBRyxNQUFJLEVBQUUsSUFBRSxNQUFJLEtBQUcsS0FBRyxLQUFLLE1BQU0sSUFBRSxNQUFJLENBQUMsSUFBRSxJQUFFLEtBQUssTUFBTSxJQUFFLE1BQUksQ0FBQyxJQUFFLEtBQUssTUFBTSxJQUFFLE1BQUksQ0FBQyxHQUFFLFlBQVcsTUFBRSxHQUFFLFVBQVMsRUFBQyxPQUFNLE9BQUc7QUFBQSxJQUFDLE1BQU0sSUFBRSx5QkFBeUIsS0FBSyxFQUFFLFNBQVMsRUFBRSxDQUFDO0FBQUEsSUFBRSxJQUFHLENBQUM7QUFBQSxNQUFFLE9BQU0sQ0FBQyxHQUFFLEdBQUUsQ0FBQztBQUFBLElBQUUsS0FBSSxLQUFHO0FBQUEsSUFBRSxFQUFFLFdBQVMsTUFBSSxJQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsSUFBSSxPQUFHLElBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRTtBQUFBLElBQUcsTUFBTSxJQUFFLE9BQU8sU0FBUyxHQUFFLEVBQUU7QUFBQSxJQUFFLE9BQU0sQ0FBQyxLQUFHLEtBQUcsS0FBSSxLQUFHLElBQUUsS0FBSSxJQUFFLEdBQUc7QUFBQSxLQUFHLFlBQVcsTUFBRSxHQUFFLGNBQWEsRUFBQyxPQUFNLE9BQUcsRUFBRSxhQUFhLEdBQUcsRUFBRSxTQUFTLENBQUMsQ0FBQyxHQUFFLFlBQVcsTUFBRSxHQUFFLGVBQWMsRUFBQyxPQUFNLE9BQUc7QUFBQSxJQUFDLElBQUcsSUFBRTtBQUFBLE1BQUUsT0FBTyxLQUFHO0FBQUEsSUFBRSxJQUFHLElBQUU7QUFBQSxNQUFHLE9BQU8sTUFBSSxJQUFFO0FBQUEsSUFBRyxJQUFJLEdBQUUsR0FBRTtBQUFBLElBQUUsSUFBRyxLQUFHO0FBQUEsTUFBSSxNQUFJLElBQUUsT0FBSyxLQUFHLEtBQUcsS0FBSSxJQUFFLEdBQUUsSUFBRTtBQUFBLElBQU07QUFBQSxNQUFDLEtBQUc7QUFBQSxNQUFHLE1BQU0sSUFBRSxJQUFFO0FBQUEsTUFBRyxJQUFFLEtBQUssTUFBTSxJQUFFLEVBQUUsSUFBRSxHQUFFLElBQUUsS0FBSyxNQUFNLElBQUUsQ0FBQyxJQUFFLEdBQUUsSUFBRSxJQUFFLElBQUU7QUFBQTtBQUFBLElBQUUsTUFBTSxJQUFFLEtBQUssSUFBSSxHQUFFLEdBQUUsQ0FBQyxJQUFFO0FBQUEsSUFBRSxJQUFHLE1BQUk7QUFBQSxNQUFFLE9BQU87QUFBQSxJQUFHLElBQUksSUFBRSxNQUFJLEtBQUssTUFBTSxDQUFDLEtBQUcsSUFBRSxLQUFLLE1BQU0sQ0FBQyxLQUFHLElBQUUsS0FBSyxNQUFNLENBQUM7QUFBQSxJQUFHLE9BQU8sTUFBSSxNQUFJLEtBQUcsS0FBSTtBQUFBLEtBQUcsWUFBVyxNQUFFLEdBQUUsV0FBVSxFQUFDLE9BQU0sQ0FBQyxHQUFFLEdBQUUsTUFBSSxFQUFFLGNBQWMsRUFBRSxhQUFhLEdBQUUsR0FBRSxDQUFDLENBQUMsR0FBRSxZQUFXLE1BQUUsR0FBRSxXQUFVLEVBQUMsT0FBTSxPQUFHLEVBQUUsY0FBYyxFQUFFLGFBQWEsQ0FBQyxDQUFDLEdBQUUsWUFBVyxNQUFFLEVBQUMsQ0FBQyxHQUFFO0FBQUE7QUFBRSxJQUFNLEtBQUcsR0FBRztBQUFaLElBQWMsSUFBRSxJQUFJLElBQUksQ0FBQyxRQUFPLEdBQU0sQ0FBQztBQUF2QyxJQUF5QyxLQUFHO0FBQTVDLElBQStDLElBQUU7QUFBakQsSUFBd0QsSUFBRTtBQUExRCxJQUE4RCxLQUFHO0FBQWpFLElBQXFFLElBQUU7QUFBdkUsSUFBMkUsSUFBRSxHQUFHO0FBQWhGLElBQXdGLElBQUUsT0FBRyxHQUFHLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxRQUFRLElBQUksSUFBSTtBQUFsSSxJQUFzSSxJQUFFLE9BQUcsR0FBRyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsUUFBUSxJQUFJLElBQUk7QUFBaEwsSUFBb0wsS0FBRyxPQUFHLEVBQUUsTUFBTSxHQUFHLEVBQUUsSUFBSSxPQUFHLEVBQUUsQ0FBQyxDQUFDO0FBQWxOLElBQW9OLElBQUUsQ0FBQyxHQUFFLEdBQUUsTUFBSTtBQUFBLEVBQUMsTUFBTSxJQUFFLENBQUMsR0FBRyxDQUFDO0FBQUEsRUFBRSxJQUFJLElBQUUsT0FBRyxJQUFFLE9BQUcsSUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLFNBQU8sRUFBRSxDQUFDO0FBQUEsRUFBRSxZQUFVLEdBQUUsTUFBSyxFQUFFLFFBQVEsR0FBRTtBQUFBLElBQUMsTUFBTSxJQUFFLEVBQUUsQ0FBQztBQUFBLElBQUUsSUFBRyxJQUFFLEtBQUcsSUFBRSxFQUFFLEVBQUUsU0FBTyxNQUFJLEtBQUcsRUFBRSxLQUFLLENBQUMsR0FBRSxJQUFFLElBQUcsRUFBRSxJQUFJLENBQUMsTUFBSSxJQUFFLE1BQUcsSUFBRSxFQUFFLE1BQU0sSUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLEVBQUUsV0FBVyxDQUFDLElBQUcsR0FBRTtBQUFBLE1BQUMsSUFBRSxNQUFJLE1BQUksSUFBRSxPQUFHLElBQUUsU0FBSSxNQUFJLE1BQUksSUFBRTtBQUFBLE1BQUk7QUFBQSxJQUFRO0FBQUEsSUFBQyxLQUFHLEdBQUUsTUFBSSxLQUFHLElBQUUsRUFBRSxTQUFPLE1BQUksRUFBRSxLQUFLLEVBQUUsR0FBRSxJQUFFO0FBQUEsRUFBRTtBQUFBLEVBQUMsQ0FBQyxLQUFHLEVBQUUsRUFBRSxTQUFPLEdBQUcsU0FBTyxLQUFHLEVBQUUsU0FBTyxNQUFJLEVBQUUsRUFBRSxTQUFPLE1BQUksRUFBRSxJQUFJO0FBQUE7QUFBeGpCLElBQTRqQixLQUFHLE9BQUc7QUFBQSxFQUFDLE1BQU0sSUFBRSxFQUFFLE1BQU0sR0FBRztBQUFBLEVBQUUsSUFBSSxJQUFFLEVBQUU7QUFBQSxFQUFPLE1BQUssSUFBRSxLQUFHLEVBQUUsRUFBRSxFQUFFLElBQUUsRUFBRSxJQUFFO0FBQUEsSUFBSTtBQUFBLEVBQUksT0FBTyxNQUFJLEVBQUUsU0FBTyxJQUFFLEVBQUUsTUFBTSxHQUFFLENBQUMsRUFBRSxLQUFLLEdBQUcsSUFBRSxFQUFFLE1BQU0sQ0FBQyxFQUFFLEtBQUssRUFBRTtBQUFBO0FBQXBzQixJQUF1c0IsS0FBRyxDQUFDLEdBQUUsR0FBRSxJQUFFLENBQUMsTUFBSTtBQUFBLEVBQUMsSUFBRyxFQUFFLFNBQU8sU0FBSSxFQUFFLEtBQUssTUFBSTtBQUFBLElBQUcsT0FBTTtBQUFBLEVBQUcsSUFBSSxJQUFFLElBQUcsR0FBRTtBQUFBLEVBQUUsTUFBTSxJQUFFLEdBQUcsQ0FBQztBQUFBLEVBQUUsSUFBSSxJQUFFLENBQUMsRUFBRTtBQUFBLEVBQUUsWUFBVSxHQUFFLE1BQUssRUFBRSxNQUFNLEdBQUcsRUFBRSxRQUFRLEdBQUU7QUFBQSxJQUFDLEVBQUUsU0FBTyxVQUFLLEVBQUUsRUFBRSxTQUFPLEtBQUcsRUFBRSxFQUFFLFNBQU8sR0FBRyxVQUFVO0FBQUEsSUFBRyxJQUFJLElBQUUsRUFBRSxFQUFFLEVBQUUsU0FBTyxFQUFFO0FBQUEsSUFBRSxJQUFHLE1BQUksTUFBSSxLQUFHLE1BQUksRUFBRSxhQUFXLFNBQUksRUFBRSxTQUFPLFdBQU0sRUFBRSxLQUFLLEVBQUUsR0FBRSxJQUFFLEtBQUksSUFBRSxLQUFHLEVBQUUsU0FBTyxXQUFNLEVBQUUsRUFBRSxTQUFPLE1BQUksS0FBSSxPQUFNLEVBQUUsUUFBTSxFQUFFLEtBQUcsR0FBRTtBQUFBLE1BQUMsTUFBTSxJQUFFLElBQUUsR0FBRSxJQUFFLElBQUUsS0FBSyxPQUFPLEVBQUUsS0FBRyxJQUFFLEtBQUcsQ0FBQztBQUFBLE1BQUUsS0FBSyxPQUFPLEVBQUUsS0FBRyxLQUFHLENBQUMsSUFBRSxLQUFHLEVBQUUsS0FBSyxFQUFFLEdBQUUsRUFBRSxHQUFFLEdBQUUsQ0FBQztBQUFBLE1BQUU7QUFBQSxJQUFRO0FBQUEsSUFBQyxJQUFHLElBQUUsRUFBRSxLQUFHLEtBQUcsSUFBRSxLQUFHLEVBQUUsS0FBRyxHQUFFO0FBQUEsTUFBQyxJQUFHLEVBQUUsYUFBVyxTQUFJLElBQUUsR0FBRTtBQUFBLFFBQUMsRUFBRSxHQUFFLEdBQUUsQ0FBQztBQUFBLFFBQUU7QUFBQSxNQUFRO0FBQUEsTUFBQyxFQUFFLEtBQUssRUFBRTtBQUFBLElBQUM7QUFBQSxJQUFDLElBQUcsSUFBRSxFQUFFLEtBQUcsS0FBRyxFQUFFLGFBQVcsT0FBRztBQUFBLE1BQUMsRUFBRSxHQUFFLEdBQUUsQ0FBQztBQUFBLE1BQUU7QUFBQSxJQUFRO0FBQUEsSUFBQyxFQUFFLEVBQUUsU0FBTyxNQUFJO0FBQUEsRUFBQztBQUFBLEVBQUMsRUFBRSxTQUFPLFVBQUssSUFBRSxFQUFFLElBQUksT0FBRyxHQUFHLENBQUMsQ0FBQztBQUFBLEVBQUcsTUFBTSxJQUFFLENBQUMsR0FBRyxFQUFFLEtBQUs7QUFBQSxDQUM1dHdCLENBQUM7QUFBQSxFQUFFLFlBQVUsR0FBRSxNQUFLLEVBQUUsUUFBUSxHQUFFO0FBQUEsSUFBQyxJQUFHLEtBQUcsR0FBRSxFQUFFLElBQUksQ0FBQyxHQUFFO0FBQUEsTUFBQyxRQUFNLFFBQU8sTUFBRyxJQUFJLE9BQU8sUUFBUSxxQkFBcUIsY0FBYyxJQUFJLEVBQUUsS0FBSyxFQUFFLE1BQU0sQ0FBQyxFQUFFLEtBQUssRUFBRSxDQUFDLEtBQUcsRUFBQyxRQUFPLENBQUMsRUFBQztBQUFBLE1BQUUsSUFBRyxFQUFFLFNBQVksV0FBRTtBQUFBLFFBQUMsTUFBTSxJQUFFLE9BQU8sV0FBVyxFQUFFLElBQUk7QUFBQSxRQUFFLElBQUUsTUFBSSxLQUFRLFlBQUU7QUFBQSxNQUFDLEVBQU07QUFBQSxVQUFFLFFBQVcsY0FBSSxJQUFFLEVBQUUsSUFBSSxXQUFTLElBQU8sWUFBRSxFQUFFO0FBQUEsSUFBSTtBQUFBLElBQUMsTUFBTSxJQUFFLEdBQUcsTUFBTSxJQUFJLE9BQU8sQ0FBQyxDQUFDO0FBQUEsSUFBRSxFQUFFLElBQUUsT0FBSztBQUFBLEtBQzVVLE1BQUksS0FBRyxFQUFFLEVBQUUsSUFBRyxLQUFHLE1BQUksS0FBRyxFQUFFLENBQUMsTUFBSSxNQUFJO0FBQUEsTUFDbEMsS0FBRyxNQUFJLEtBQUcsRUFBRSxDQUFDLElBQUcsTUFBSSxLQUFHLEVBQUUsQ0FBQztBQUFBLEVBQUc7QUFBQSxFQUFDLE9BQU87QUFBQTtBQUFHLFNBQVMsQ0FBQyxDQUFDLEdBQUUsR0FBRSxHQUFFO0FBQUEsRUFBQyxPQUFPLE9BQU8sQ0FBQyxFQUFFLFVBQVUsRUFBRSxRQUFRLFNBQVE7QUFBQSxDQUMxRyxFQUFFLE1BQU07QUFBQSxDQUNSLEVBQUUsSUFBSSxPQUFHLEdBQUcsR0FBRSxHQUFFLENBQUMsQ0FBQyxFQUFFLEtBQUs7QUFBQSxDQUN6QjtBQUFBO0FBQUUsSUFBTSxLQUFHLENBQUMsTUFBSyxRQUFPLFFBQU8sU0FBUSxTQUFRLFNBQVEsUUFBUTtBQUE3RCxJQUErRCxJQUFFLEVBQUMsU0FBUSxJQUFJLElBQUksRUFBRSxHQUFFLFNBQVEsSUFBSSxJQUFJLENBQUMsQ0FBQyxLQUFJLElBQUksR0FBRSxDQUFDLEtBQUksTUFBTSxHQUFFLENBQUMsS0FBSSxNQUFNLEdBQUUsQ0FBQyxLQUFJLE9BQU8sR0FBRSxDQUFDLFFBQUksUUFBUSxHQUFFLENBQUMsVUFBUyxRQUFRLENBQUMsQ0FBQyxFQUFDO0FBQTJNLFNBQVMsQ0FBQyxDQUFDLEdBQUUsR0FBRTtBQUFBLEVBQUMsSUFBRyxPQUFPLEtBQUc7QUFBQSxJQUFTLE9BQU8sRUFBRSxRQUFRLElBQUksQ0FBQyxNQUFJO0FBQUEsRUFBRSxXQUFVLEtBQUs7QUFBQSxJQUFFLElBQUcsTUFBUyxhQUFHLEVBQUUsR0FBRSxDQUFDO0FBQUEsTUFBRSxPQUFNO0FBQUEsRUFBRyxPQUFNO0FBQUE7QUFBRyxTQUFTLEVBQUUsQ0FBQyxHQUFFLEdBQUU7QUFBQSxFQUFDLElBQUcsTUFBSTtBQUFBLElBQUU7QUFBQSxFQUFPLE1BQU0sSUFBRSxFQUFFLE1BQU07QUFBQSxDQUN2akIsR0FBRSxJQUFFLEVBQUUsTUFBTTtBQUFBLENBQ1osR0FBRSxJQUFFLENBQUM7QUFBQSxFQUFFLFNBQVEsSUFBRSxFQUFFLElBQUUsS0FBSyxJQUFJLEVBQUUsUUFBTyxFQUFFLE1BQU0sR0FBRTtBQUFBLElBQUksRUFBRSxPQUFLLEVBQUUsTUFBSSxFQUFFLEtBQUssQ0FBQztBQUFBLEVBQUUsT0FBTztBQUFBO0FBQUUsSUFBTSxLQUFHLFdBQVcsUUFBUSxTQUFTLFdBQVcsS0FBSztBQUFyRCxJQUF1RCxJQUFFLE9BQU8sY0FBYztBQUFFLFNBQVMsRUFBRSxDQUFDLEdBQUU7QUFBQSxFQUFDLE9BQU8sTUFBSTtBQUFBO0FBQUUsU0FBUyxDQUFDLENBQUMsR0FBRSxHQUFFO0FBQUEsRUFBQyxNQUFNLElBQUU7QUFBQSxFQUFFLEVBQUUsU0FBTyxFQUFFLFdBQVcsQ0FBQztBQUFBO0FBQUUsU0FBUyxFQUFFLEdBQUUsT0FBTSxJQUFFLEdBQUUsUUFBTyxJQUFFLEdBQUUsV0FBVSxJQUFFLE1BQUcsWUFBVyxJQUFFLFNBQUksQ0FBQyxHQUFFO0FBQUEsRUFBQyxNQUFNLElBQUksa0JBQWdCLEVBQUMsT0FBTSxHQUFFLFFBQU8sR0FBRSxRQUFPLElBQUcsU0FBUSxFQUFDLENBQUM7QUFBQSxFQUFJLHFCQUFtQixHQUFFLENBQUMsR0FBRSxFQUFFLFNBQU8sRUFBRSxXQUFXLElBQUU7QUFBQSxFQUFFLE1BQU0sSUFBRSxDQUFDLEtBQUcsTUFBSyxHQUFFLFVBQVMsUUFBSztBQUFBLElBQUMsTUFBTSxJQUFFLE9BQU8sQ0FBQztBQUFBLElBQUUsSUFBRyxFQUFFLENBQUMsR0FBRSxHQUFFLENBQUMsR0FBRSxRQUFRLEdBQUU7QUFBQSxNQUFDLEtBQUcsRUFBRSxNQUFNLHlCQUFFLElBQUksR0FBRSxRQUFRLEtBQUssQ0FBQztBQUFBLE1BQUU7QUFBQSxJQUFNO0FBQUEsSUFBQyxJQUFHLENBQUM7QUFBQSxNQUFFO0FBQUEsSUFBTyxNQUFNLElBQUUsTUFBSSxXQUFTLElBQUUsSUFBRyxJQUFFLE1BQUksV0FBUyxLQUFHO0FBQUEsSUFBSSxhQUFXLEdBQUUsR0FBRSxHQUFFLE1BQUk7QUFBQSxNQUFHLFlBQVUsR0FBRSxHQUFFLE1BQUk7QUFBQSxRQUFDLEVBQUUsS0FBSyxZQUFXLENBQUM7QUFBQSxPQUFFO0FBQUEsS0FBRTtBQUFBO0FBQUEsRUFBRyxPQUFPLEtBQUcsRUFBRSxNQUFNLHlCQUFFLElBQUksR0FBRSxFQUFFLEtBQUssWUFBVyxDQUFDLEdBQUUsTUFBSTtBQUFBLElBQUMsRUFBRSxJQUFJLFlBQVcsQ0FBQyxHQUFFLEtBQUcsRUFBRSxNQUFNLHlCQUFFLElBQUksR0FBRSxFQUFFLFNBQU8sQ0FBQyxNQUFJLEVBQUUsV0FBVyxLQUFFLEdBQUUsRUFBRSxXQUFTLE9BQUcsRUFBRSxNQUFNO0FBQUE7QUFBQTtBQUFHLElBQUksS0FBRyxPQUFPO0FBQWQsSUFBNkIsS0FBRyxDQUFDLEdBQUUsR0FBRSxPQUFJLEtBQUssS0FBRSxHQUFHLEdBQUUsR0FBRSxFQUFDLFlBQVcsTUFBRyxjQUFhLE1BQUcsVUFBUyxNQUFHLE9BQU0sRUFBQyxDQUFDLElBQUUsRUFBRSxLQUFHO0FBQWpILElBQW1ILElBQUUsQ0FBQyxHQUFFLEdBQUUsT0FBSyxHQUFHLEdBQUUsT0FBTyxLQUFHLFdBQVMsSUFBRSxLQUFHLEdBQUUsQ0FBQyxHQUFFO0FBQUE7QUFBRyxNQUFNLEVBQUM7QUFBQSxFQUFDLFdBQVcsQ0FBQyxHQUFFLElBQUUsTUFBRztBQUFBLElBQUMsRUFBRSxNQUFLLE9BQU8sR0FBRSxFQUFFLE1BQUssUUFBUSxHQUFFLEVBQUUsTUFBSyxjQUFjLEdBQUUsRUFBRSxNQUFLLElBQUksR0FBRSxFQUFFLE1BQUssTUFBTSxHQUFFLEVBQUUsTUFBSyxTQUFTLEdBQUUsRUFBRSxNQUFLLFVBQVMsS0FBRSxHQUFFLEVBQUUsTUFBSyxjQUFhLEVBQUUsR0FBRSxFQUFFLE1BQUssZ0JBQWUsSUFBSSxHQUFHLEdBQUUsRUFBRSxNQUFLLFdBQVUsQ0FBQyxHQUFFLEVBQUUsTUFBSyxTQUFRLFNBQVMsR0FBRSxFQUFFLE1BQUssU0FBUSxFQUFFLEdBQUUsRUFBRSxNQUFLLE9BQU87QUFBQSxJQUFFLFFBQU0sT0FBTSxJQUFFLEdBQUUsUUFBTyxJQUFFLEdBQUUsUUFBTyxHQUFFLFFBQU8sTUFBSyxNQUFHO0FBQUEsSUFBRSxLQUFLLE9BQUssR0FBRSxLQUFLLGFBQVcsS0FBSyxXQUFXLEtBQUssSUFBSSxHQUFFLEtBQUssUUFBTSxLQUFLLE1BQU0sS0FBSyxJQUFJLEdBQUUsS0FBSyxTQUFPLEtBQUssT0FBTyxLQUFLLElBQUksR0FBRSxLQUFLLFVBQVEsRUFBRSxLQUFLLElBQUksR0FBRSxLQUFLLFNBQU8sR0FBRSxLQUFLLGVBQWEsR0FBRSxLQUFLLFFBQU0sR0FBRSxLQUFLLFNBQU87QUFBQTtBQUFBLEVBQUUsV0FBVyxHQUFFO0FBQUEsSUFBQyxLQUFLLGFBQWEsTUFBTTtBQUFBO0FBQUEsRUFBRSxhQUFhLENBQUMsR0FBRSxHQUFFO0FBQUEsSUFBQyxNQUFNLElBQUUsS0FBSyxhQUFhLElBQUksQ0FBQyxLQUFHLENBQUM7QUFBQSxJQUFFLEVBQUUsS0FBSyxDQUFDLEdBQUUsS0FBSyxhQUFhLElBQUksR0FBRSxDQUFDO0FBQUE7QUFBQSxFQUFFLEVBQUUsQ0FBQyxHQUFFLEdBQUU7QUFBQSxJQUFDLEtBQUssY0FBYyxHQUFFLEVBQUMsSUFBRyxFQUFDLENBQUM7QUFBQTtBQUFBLEVBQUUsSUFBSSxDQUFDLEdBQUUsR0FBRTtBQUFBLElBQUMsS0FBSyxjQUFjLEdBQUUsRUFBQyxJQUFHLEdBQUUsTUFBSyxLQUFFLENBQUM7QUFBQTtBQUFBLEVBQUUsSUFBSSxDQUFDLE1BQUssR0FBRTtBQUFBLElBQUMsTUFBTSxJQUFFLEtBQUssYUFBYSxJQUFJLENBQUMsS0FBRyxDQUFDLEdBQUUsSUFBRSxDQUFDO0FBQUEsSUFBRSxXQUFVLEtBQUs7QUFBQSxNQUFFLEVBQUUsR0FBRyxHQUFHLENBQUMsR0FBRSxFQUFFLFFBQU0sRUFBRSxLQUFLLE1BQUksRUFBRSxPQUFPLEVBQUUsUUFBUSxDQUFDLEdBQUUsQ0FBQyxDQUFDO0FBQUEsSUFBRSxXQUFVLEtBQUs7QUFBQSxNQUFFLEVBQUU7QUFBQTtBQUFBLEVBQUUsTUFBTSxHQUFFO0FBQUEsSUFBQyxPQUFPLElBQUksUUFBUSxDQUFDLEdBQUUsTUFBSTtBQUFBLE1BQUMsSUFBRyxLQUFLLGNBQWE7QUFBQSxRQUFDLElBQUcsS0FBSyxhQUFhO0FBQUEsVUFBUSxPQUFPLEtBQUssUUFBTSxVQUFTLEtBQUssTUFBTSxHQUFFLEVBQUUsQ0FBQztBQUFBLFFBQUUsS0FBSyxhQUFhLGlCQUFpQixTQUFRLE1BQUk7QUFBQSxVQUFDLEtBQUssUUFBTSxVQUFTLEtBQUssTUFBTTtBQUFBLFdBQUcsRUFBQyxNQUFLLEtBQUUsQ0FBQztBQUFBLE1BQUM7QUFBQSxNQUFDLE1BQU0sSUFBRSxJQUFJO0FBQUEsTUFBRSxFQUFFLFNBQU8sQ0FBQyxHQUFFLEdBQUUsTUFBSTtBQUFBLFFBQUMsS0FBSyxXQUFTLEtBQUssUUFBTSxLQUFLLElBQUksS0FBSyxRQUFRLE9BQU0sRUFBRSxHQUFFLEtBQUssVUFBUSxLQUFLLElBQUksVUFBUSxHQUFFLEtBQUssS0FBSyxTQUFRLEtBQUssS0FBSyxJQUFHLEVBQUU7QUFBQSxTQUFHLEtBQUssTUFBTSxLQUFLLENBQUMsR0FBRSxLQUFLLEtBQUcsRUFBRSxnQkFBZ0IsRUFBQyxPQUFNLEtBQUssT0FBTSxRQUFPLEdBQUUsU0FBUSxHQUFFLFFBQU8sSUFBRyxtQkFBa0IsSUFBRyxVQUFTLEtBQUUsQ0FBQyxHQUFFLEVBQUUsbUJBQW1CLEtBQUssT0FBTSxLQUFLLEVBQUUsR0FBRSxLQUFLLEdBQUcsT0FBTyxHQUFFLEtBQUssS0FBSyxpQkFBb0IsYUFBRyxLQUFLLFVBQVEsS0FBSyxHQUFHLE1BQU0sS0FBSyxLQUFLLFlBQVksR0FBRSxLQUFLLE1BQU0sR0FBRyxZQUFXLEtBQUssVUFBVSxHQUFFLEVBQUUsS0FBSyxPQUFNLElBQUUsR0FBRSxLQUFLLE9BQU8sR0FBRyxVQUFTLEtBQUssTUFBTSxHQUFFLEtBQUssT0FBTyxHQUFFLEtBQUssS0FBSyxVQUFTLE1BQUk7QUFBQSxRQUFDLEtBQUssT0FBTyxNQUFNLHlCQUFFLElBQUksR0FBRSxLQUFLLE9BQU8sSUFBSSxVQUFTLEtBQUssTUFBTSxHQUFFLEVBQUUsS0FBSyxPQUFNLEtBQUUsR0FBRSxFQUFFLEtBQUssS0FBSztBQUFBLE9BQUUsR0FBRSxLQUFLLEtBQUssVUFBUyxNQUFJO0FBQUEsUUFBQyxLQUFLLE9BQU8sTUFBTSx5QkFBRSxJQUFJLEdBQUUsS0FBSyxPQUFPLElBQUksVUFBUyxLQUFLLE1BQU0sR0FBRSxFQUFFLEtBQUssT0FBTSxLQUFFLEdBQUUsRUFBRSxDQUFDO0FBQUEsT0FBRTtBQUFBLEtBQUU7QUFBQTtBQUFBLEVBQUUsVUFBVSxDQUFDLEdBQUUsR0FBRTtBQUFBLElBQUMsSUFBRyxLQUFLLFVBQVEsWUFBVSxLQUFLLFFBQU0sV0FBVSxHQUFHLFNBQU8sQ0FBQyxLQUFLLFVBQVEsRUFBRSxRQUFRLElBQUksRUFBRSxJQUFJLEtBQUcsS0FBSyxLQUFLLFVBQVMsRUFBRSxRQUFRLElBQUksRUFBRSxJQUFJLENBQUMsR0FBRSxFQUFFLFFBQVEsSUFBSSxFQUFFLElBQUksS0FBRyxLQUFLLEtBQUssVUFBUyxFQUFFLElBQUksSUFBRyxNQUFJLEVBQUUsWUFBWSxNQUFJLE9BQUssRUFBRSxZQUFZLE1BQUksUUFBTSxLQUFLLEtBQUssV0FBVSxFQUFFLFlBQVksTUFBSSxHQUFHLEdBQUUsTUFBSSxRQUFLLEtBQUssS0FBSyxnQkFBYyxLQUFLLFVBQVEsS0FBSyxJQUFJLE1BQU0sS0FBSyxLQUFLLFdBQVcsR0FBRSxLQUFLLEtBQUssU0FBUSxLQUFLLEtBQUssV0FBVyxLQUFJLEtBQUcsS0FBSyxLQUFLLE9BQU0sRUFBRSxZQUFZLENBQUMsR0FBRSxHQUFHLFNBQU8sVUFBUztBQUFBLE1BQUMsSUFBRyxLQUFLLEtBQUssVUFBUztBQUFBLFFBQUMsTUFBTSxJQUFFLEtBQUssS0FBSyxTQUFTLEtBQUssS0FBSztBQUFBLFFBQUUsTUFBSSxLQUFLLFFBQU0sYUFBYSxRQUFNLEVBQUUsVUFBUSxHQUFFLEtBQUssUUFBTSxTQUFRLEtBQUssSUFBSSxNQUFNLEtBQUssS0FBSztBQUFBLE1BQUU7QUFBQSxNQUFDLEtBQUssVUFBUSxZQUFVLEtBQUssUUFBTTtBQUFBLElBQVM7QUFBQSxJQUFDLEVBQUUsQ0FBQyxHQUFFLEdBQUcsTUFB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STtBQUFBLElBQUMsSUFBRyxPQUFTO0FBQUEsTUFBRTtBQUFBLElBQU8sS0FBRyxRQUFRLE9BQU8sTUFBTTtBQUFBLENBQ3I1QjtBQUFBLElBQUUsTUFBTSxLQUFFLEdBQUUsTUFBTTtBQUFBLENBQ2xCO0FBQUEsSUFBRSxRQUFRLE9BQU8sTUFBTSwwQkFBRyxLQUFLLE1BQUssR0FBRSxTQUFPLENBQUMsQ0FBQyxHQUFFLFFBQVEsT0FBTyxNQUFNLHlCQUFHLEtBQUssR0FBRSxNQUFNLENBQUM7QUFBQSxLQUFHLEtBQUUsUUFBRyxHQUFFLFFBQVEsUUFBTyxFQUFFLEdBQUUsS0FBRSxRQUFHO0FBQUEsSUFBQyxNQUFNLE1BQUcsWUFBWSxJQUFJLElBQUUsTUFBRyxNQUFJLEtBQUUsS0FBSyxNQUFNLEtBQUUsRUFBRSxHQUFFLEtBQUUsS0FBSyxNQUFNLEtBQUUsRUFBRTtBQUFBLElBQUUsT0FBTyxLQUFFLElBQUUsSUFBSSxPQUFNLFNBQU0sSUFBSTtBQUFBLEtBQU8sSUFBRSxDQUFDLEtBQUUsT0FBSztBQUFBLElBQUMsSUFBRSxNQUFHLElBQUUsR0FBRyxHQUFFLEtBQUUsR0FBRSxFQUFDLEdBQUUsS0FBRSxZQUFZLElBQUksR0FBRSxRQUFRLE9BQU8sTUFBTSxHQUFHLDBCQUFFLEtBQUssQ0FBQztBQUFBLENBQzFUO0FBQUEsSUFBRSxJQUFJLEtBQUUsR0FBRSxLQUFFO0FBQUEsSUFBRSxHQUFFLEdBQUUsSUFBRSxZQUFZLE1BQUk7QUFBQSxNQUFDLElBQUcsS0FBRyxPQUFJO0FBQUEsUUFBRTtBQUFBLE1BQU8sR0FBRSxHQUFFLEtBQUU7QUFBQSxNQUFFLE1BQU0sS0FBRSwwQkFBRSxRQUFRLEVBQUUsR0FBRTtBQUFBLE1BQUUsSUFBRztBQUFBLFFBQUUsUUFBUSxPQUFPLE1BQU0sR0FBRyxPQUFNLE9BQU07QUFBQSxNQUFPLFNBQUcsTUFBSTtBQUFBLFFBQVEsUUFBUSxPQUFPLE1BQU0sR0FBRyxPQUFNLE1BQUssR0FBRSxFQUFDLEdBQUc7QUFBQSxNQUFNO0FBQUEsUUFBQyxNQUFNLEtBQUUs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QSxFQUtMLE1BQU0sQ0FBQyxTQUFTO0FBQUEsSUFDWixRQUFRLFFBQVEsVUFBVSxLQUFLLFNBQVMsTUFBTTtBQUFBLE1BQzFDLEtBQUs7QUFBQSxTQUNGO0FBQUEsTUFDSCxTQUFTO0FBQUEsUUFDTCxnQkFBZ0I7QUFBQSxXQUNiLFFBQVE7QUFBQSxNQUNmO0FBQUEsSUFDSixDQUFDO0FBQUE7QUFBQSxFQUtMLFFBQVEsQ0FBQyxTQUFTO0FBQUEsSUFDZCxRQUFRLFFBQVEsVUFBVSxLQUFLLFNBQVMsSUFBSTtBQUFBLE1BQ3hDLEtBQUs7QUFBQSxTQUNGO0FBQUEsSUFDUCxDQUFDO0FBQUE7QUFBQSxFQUtMLElBQUksQ0FBQyxTQUFTO0FBQUEsSUFDVixRQUFRLFFBQVEsVUFBVSxLQUFLLFNBQVMsSUFBSTtBQUFBLE1BQ3hDLEtBQUs7QUFBQSxTQUNGO0FBQUEsSUFDUCxDQUFDO0FBQUE7QUFBQSxFQUtMLElBQUksQ0FBQyxTQUFTO0FBQUEsSUFDVixRQUFRLFFBQVEsVUFBVSxLQUFLLFNBQVMsS0FBSztBQUFBLE1BQ3pDLEtBQUs7QUFBQSxTQUNGO0FBQUEsTUFDSCxTQUFTO0FBQUEsUUFDTCxnQkFBZ0I7QUFBQSxXQUNiLFFBQVE7QUFBQSxNQUNmO0FBQUEsSUFDSixDQUFDO0FBQUE7QUFBQSxFQUtMLElBQUksQ0FBQyxTQUFTO0FBQUEsSUFDVixRQUFRLFFBQVEsVUFBVSxLQUFLLFNBQVMsS0FBSztBQUFBLE1BQ3pDLEtBQUs7QUFBQSxTQUNGO0FBQUEsTUFDSCxTQUFTO0FBQUEsUUFDTCxnQkFBZ0I7QUFBQSxXQUNiLFFBQVE7QUFBQSxNQUNmO0FBQUEsSUFDSixDQUFDO0FBQUE7QUFBQSxFQUtMLEtBQUssQ0FBQyxTQUFTO0FBQUEsSUFDWCxRQUFRLFFBQVEsVUFBVSxLQUFLLFNBQVMsS0FBSztBQUFBLE1BQ3pDLEtBQUs7QUFBQSxTQUNGO0FBQUEsSUFDUCxDQUFDO0FBQUE7QUFBQSxFQUtMLE9BQU8sQ0FBQyxTQUFTO0FBQUEsSUFDYixRQUFRLFFBQVEsVUFBVSxLQUFLLFNBQVMsT0FBTztB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QUksUUFBUSxFQUFFLFFBQVEsS0FBSyxRQUFRLENBQUM7QUFBQSxFQUM5QyxNQUFNLElBQUksSUFBSSxFQUFFLFFBQVEsS0FBSyxRQUFRLENBQUM7QUFBQSxFQUN0QyxTQUFTLElBQUksT0FBTyxFQUFFLFFBQVEsS0FBSyxRQUFRLENBQUM7QUFBQSxFQUM1QyxPQUFPLElBQUksS0FBSyxFQUFFLFFBQVEsS0FBSyxRQUFRLENBQUM7QUFBQSxFQUN4QyxXQUFXLElBQUksU0FBUyxFQUFFLFFBQVEsS0FBSyxRQUFRLENBQUM7QUFBQSxFQUNoRCxPQUFPLElBQUksS0FBSyxFQUFFLFFBQVEsS0FBSyxRQUFRLENBQUM7QUFBQSxFQUN4QyxNQUFNLElBQUksSUFBSSxFQUFFLFFBQVEsS0FBSyxRQUFRLENBQUM7QUFBQSxFQUN0QyxVQUFVLElBQUksUUFBUSxFQUFFLFFBQVEsS0FBSyxRQUFRLENBQUM7QUFBQSxFQUM5QyxVQUFVLElBQUksUUFBUSxFQUFFLFFBQVEsS0FBSyxRQUFRLENBQUM7QUFBQSxFQUM5QyxXQUFXLElBQUksU0FBUyxFQUFFLFFBQVEsS0FBSyxRQUFRLENBQUM7QUFBQSxFQUNoRCxPQUFPLElBQUksS0FBSyxFQUFFLFFBQVEsS0FBSyxRQUFRLENBQUM7QUFBQSxFQUN4QyxPQUFPLElBQUksS0FBSyxFQUFFLFFBQVEsS0FBSyxRQUFRLENBQUM7QUFBQSxFQUN4QyxNQUFNLElBQUksSUFBSSxFQUFFLFFBQVEsS0FBSyxRQUFRLENBQUM7QUFBQSxFQUN0QyxNQUFNLElBQUksSUFBSSxFQUFFLFFBQVEsS0FBSyxRQUFRLENBQUM7QUFBQSxFQUN0QyxNQUFNLElBQUksSUFBSSxFQUFFLFFBQVEsS0FBSyxRQUFRLENBQUM7QUFBQSxFQUN0QyxZQUFZLElBQUksVUFBVSxFQUFFLFFBQVEsS0FBSyxRQUFRLENBQUM7QUFBQSxFQUNsRCxNQUFNLElBQUksSUFBSSxFQUFFLFFBQVEsS0FBSyxRQUFRLENBQUM7QUFBQSxFQUN0QyxPQUFPLElBQUksS0FBSyxFQUFFLFFBQVEsS0FBSyxRQUFRLENBQUM7QUFBQSxFQUN4QyxRQUFRLElBQUksTUFBTSxFQUFFLFFBQVEsS0FBSyxRQUFRLENBQUM7QUFDOUM7OztBQzUyQk8sU0FBUyxvQkFBb0IsQ0FBQyxRQUFRO0FBQUEsRUFDekMsSUFBSSxDQUFDLFFBQVEsT0FBTztBQUFBLElBQ2hCLE1BQU0sY0FBYyxDQUFDLFFBQVE7QUFBQSxNQUV6QixJQUFJLFVBQVU7QUFBQSxNQUNkLE9BQU8sTUFBTSxHQUFHO0FBQUE7QUFBQSxJQUVwQixTQUFTO0FBQUEsU0FDRjtBQUFBLE1BQ0gsT0FBTztBQUFBLElBQ1g7QUFBQSxFQUNKO0FBQUEsRUFDQSxJQUFJLFFBQVEsV0FBVztBQUFBLElBQ25CLE9BQU8sVUFBVTtBQUFBLFNBQ1YsT0FBTztBQUFBLE1BQ1Ysd0JBQXdCLE9BQU87QUFBQSxJQUNuQztBQUFBLEVBQ0o7QUFBQSxFQUNBLE1BQU0sVUFBUyxhQUFhLE1BQU07QUFBQSxFQUNsQyxPQUFPLElBQUksZUFBZSxFQUFFLGdCQUFPLENBQUM7QUFBQTs7QUN2QnhDO0FBQ0EsZUFBc0Isb0JBQW9CLENBQUMsU0FBUztBQUFBLEVBQ2hELFVBQVUsT0FBTyxPQUFPO0FBQUEsSUFDcEIsVUFBVTtBQUFBLElBQ1YsTUFBTTtBQUFBLElBQ04sU0FBUztBQUFBLEVBQ2IsR0FBRyxXQUFXLENBQUMsQ0FBQztBQUFBLEVBQ2hCLE1BQU0sT0FBTyxDQUFDLFNBQVMsY0FBYyxRQUFRLFlBQVksVUFBVSxRQUFRLE1BQU07QUFBQSxFQUNqRixJQUFJLFFBQVEsUUFBUTtBQUFBLElBQ2hCLEtBQUssS0FBSyxlQUFlLFFBQVEsT0FBTyxVQUFVO0FBQUEsRUFDdEQsTUFBTSxPQUFPLE1BQU0sWUFBWSxNQUFNO0FBQUEsSUFDakMsUUFBUSxRQUFRO0FBQUEsSUFDaEIsS0FBSztBQUFBLFNBQ0UsUUFBUTtBQUFBLE1BQ1gseUJBQXlCLEtBQUssVUFBVSxRQUFRLFVBQVUsQ0FBQyxDQUFDO0FBQUEsSUFDaEU7QUFBQSxFQUNKLENBQUM7QUFBQSxFQUNELE1BQU0sTUFBTSxNQUFNLElBQUksUUFBUSxDQUFDLFNBQVMsV0FBVztBQUFBLElBQy9DLE1BQU0sS0FBSyxXQUFXLE1BQU07QUFBQSxNQUN4QixPQUFPLElBQUksTUFBTSw2Q0FBNkMsUUFBUSxXQUFXLENBQUM7QUFBQSxPQUNuRixRQUFRLE9BQU87QUFBQSxJQUNsQixJQUFJLFNBQVM7QUFBQSxJQUNiLEtBQUssUUFBUSxHQUFHLFFBQVEsQ0FBQyxVQUFVO0FBQUEsTUFDL0IsVUFBVSxNQUFNLFNBQVM7QUFBQSxNQUN6QixNQUFNLFFBQVEsT0FBTyxNQUFNO0FBQUEsQ0FBSTtBQUFBLE1BQy9CLFdBQVcsUUFBUSxPQUFPO0FBQUEsUUFDdEIsSUFBSSxLQUFLLFdBQVcsMkJBQTJCLEdBQUc7QUFBQSxVQUM5QyxNQUFNLFFBQVEsS0FBSyxNQUFNLDBCQUEwQjtBQUFBLFVBQ25ELElBQUksQ0FBQyxPQUFPO0FBQUEsWUFDUixNQUFNLElBQUksTUFBTSwyQ0FBMkMsTUFBTTtBQUFBLFVBQ3JFO0FBQUEsVUFDQSxhQUFhLEVBQUU7QUFBQSxVQUNmLFFBQVEsTUFBTSxFQUFFO0FBQUEsVUFDaEI7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUFBLEtBQ0g7QUFBQSxJQUNELEtBQUssUUFBUSxHQUFHLFFBQVEsQ0FBQyxVQUFVO0FBQUEsTUFDL0IsVUFBVSxNQUFNLFNBQVM7QUFBQSxLQUM1QjtBQUFBLElBQ0QsS0FBSyxHQUFHLFFBQVEsQ0FBQyxTQUFTO0FBQUEsTUFDdEIsYUFBYSxFQUFFO0FBQUEsTUFDZixJQUFJLE1BQU0sMkJBQTJCO0FBQUEsTUFDckMsSUFBSSxPQUFPLEtBQUssR0FBRztBQUFBLFFBQ2YsT0FBTztBQUFBLGlCQUFvQjtBQUFBLE1BQy9CO0FBQUEsTUFDQSxPQUFPLElBQUksTUFBTSxHQUFHLENBQUM7QUFBQSxLQUN4QjtBQUFBLElBQ0QsS0FBSyxHQUFHLFNBQVMsQ0FBQyxVQUFVO0FBQUEsTUFDeEIsYUFBYSxFQUFFO0FBQUEsTUFDZixPQUFPLEtBQUs7QUFBQSxLQUNmO0FBQUEsSUFDRCxJQUFJLFFBQVEsUUFBUTtBQUFBLE1BQ2hCLFFBQVEsT0FBTyxpQkFBaUIsU0FBUyxNQUFNO0FBQUEsUUFDM0MsYUFBYSxFQUFFO0FBQUEsUUFDZixPQUFPLElBQUksTUFBTSxTQUFTLENBQUM7QUFBQSxPQUM5QjtBQUFBLElBQ0w7QUFBQSxHQUNIO0FBQUEsRUFDRCxPQUFPO0FBQUEsSUFDSDtBQUFBLElBQ0EsS0FBSyxHQUFHO0FBQUEsTUFDSixLQUFLLEtBQUs7QUFBQTtBQUFBLEVBRWxCO0FBQUE7O0FDNURKLGVBQXNCLGNBQWMsQ0FBQyxTQUFTO0FBQUEsRUFDMUMsTUFBTSxVQUFTLE1BQU0scUJBQXFCO0FBQUEsT0FDbkM7QUFBQSxFQUNQLENBQUM7QUFBQSxFQUNELE1BQU0sVUFBUyxxQkFBcUI7QUFBQSxJQUNoQyxTQUFTLFFBQU87QUFBQSxFQUNwQixDQUFDO0FBQUEsRUFDRCxPQUFPO0FBQUEsSUFDSDtBQUFBLElBQ0E7QUFBQSxFQUNKO0FBQUE7OztBYkNKLElBQU0sTUFBTSxJQUFJLE9BQU8sRUFBRSxTQUFTLGtCQUFrQixDQUFDO0FBQUE7QUFzRTlDLE1BQU0sZUFBZTtBQUFBLEVBQ2hCO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0EsWUFBb0IsUUFBUSxJQUFJO0FBQUEsRUFDaEMsU0FBb0Q7QUFBQSxFQUNwRDtBQUFBLEVBS0EsV0FBVyxDQUNmLFNBQ0EsU0FDQSxTQUF1QixDQUFDLEdBQzFCO0FBQUEsSUFDRSxLQUFLLFNBQVM7QUFBQSxJQUNkLEtBQUssU0FBUztBQUFBLElBQ2QsS0FBSyxVQUFVLE9BQU8sV0FBVztBQUFBLElBQ2pDLEtBQUssZ0JBQWdCLE9BQU8saUJBQWlCO0FBQUEsSUFFN0MsTUFBTSxtQkFBbUIsT0FBTyxTQUM1QixRQUFRLElBQUksOEJBQThCLElBQzFDLEVBQ0o7QUFBQSxJQUNBLE1BQU0sd0JBQXdCLE9BQU8sU0FBUyxnQkFBZ0IsSUFDeEQsbUJBQ0E7QUFBQSxJQUdOLEtBQUssZ0JBQ0QsT0FBTyxpQkFBaUIseUJBQXlCO0FBQUEsSUFFckQsS0FBSyxZQUNELE9BQU8sYUFBYSxRQUFRLElBQUksc0JBQXNCLFFBQVEsSUFBSTtBQUFBLElBRXRFLEtBQUssdUJBQXVCLE9BQU8sd0JBQXdCO0FBQUEsSUFDM0QsS0FBSyxpQkFBaUIsSUFBSTtBQUFBLElBRTFCLElBQUksTUFBTSw4QkFBOEI7QUFBQSxNQUNwQyxjQUFjLENBQUMsQ0FBQyxLQUFLO0FBQUEsTUFDckIsU0FBUyxLQUFLO0FBQUEsTUFDZCxzQkFBc0IsS0FBSztBQUFBLElBQy9CLENBQUM7QUFBQTtBQUFBLGNBUWdCLGlCQUFnQixHQUFvQjtBQUFBLElBQ3JELElBQUk7QUFBQSxNQUVBLE1BQU0sY0FBYztBQUFBLE1BQ3BCLE1BQU0scUJBQ0YsTUFBTSxlQUFlLGdCQUFnQixXQUFXO0FBQUEsTUFFcEQsSUFBSSxDQUFDLG9CQUFvQjtBQUFBLFFBQ3JCLElBQUksS0FDQSxpRkFDSjtBQUFBLE1BQ0osRUFBTztBQUFBLFFBQ0gsSUFBSSxNQUNBLDhEQUNKO0FBQUE7QUFBQSxNQUlKLE1BQU0sY0FBYyxNQUFNLGVBQWUsa0JBQWtCO0FBQUEsTUFDM0QsSUFBSSxLQUNBLDZDQUE2QyxhQUNqRDtBQUFBLE1BQ0EsT0FBTztBQUFBLE1BQ1QsT0FBTyxPQUFPO0FBQUEsTUFDWixNQUFNLFdBQ0YsaUJBQWlCLFFBQVEsTUFBTSxVQUFVLE9BQU8sS0FBSztBQUFBLE1BQ3pELElBQUksTUFBTSx5Q0FBeUM7QUFBQSxRQUMvQyxPQUFPO0FBQUEsTUFDWCxDQUFDO0FBQUEsTUFDRCxNQUFNLElBQUksTUFDTiwwQ0FBMEMsVUFDOUM7QUFBQTtBQUFBO0FBQUEsY0FPYSxnQkFBZSxDQUFDLE1BQWdDO0FBQUEsSUFDakUsT0FBTyxJQUFJLFFBQVEsQ0FBQyxZQUFZO0FBQUEsTUFDNUIsTUFBTSxVQUFTLGFBQWE7QUFBQSxNQUU1QixRQUFPLE9BQU8sTUFBTSxNQUFNO0FBQUEsUUFDdEIsUUFBTyxLQUFLLFNBQVMsTUFBTSxRQUFRLElBQUksQ0FBQztBQUFBLFFBQ3hDLFFBQU8sTUFBTTtBQUFBLE9BQ2hCO0FBQUEsTUFFRCxRQUFPLEdBQUcsU0FBUyxNQUFNLFFBQVEsS0FBSyxDQUFDO0FBQUEsS0FDMUM7QUFBQTtBQUFBLGNBTWdCLGtCQUFpQixHQUFvQjtBQUFBLElBQ3RELE9BQU8sSUFBSSxRQUFRLENBQUMsU0FBUyxXQUFXO0FBQUEsTUFDcEMsTUFBTSxVQUFTLGFBQWE7QUFBQSxNQUU1QixRQUFPLE9BQU8sR0FBRyxNQUFNO0FBQUEsUUFDbkIsTUFBTSxVQUFVLFFBQU8sUUFBUTtBQUFBLFFBQy9CLElBQUksV0FBVyxPQUFPLFlBQVksVUFBVTtBQUFBLFVBQ3hDLFFBQU8sS0FBSyxTQUFTLE1BQU0sUUFBUSxRQUFRLElBQUksQ0FBQztBQUFBLFVBQ2hELFFBQU8sTUFBTTtBQUFBLFFBQ2pCLEVBQU87QUFBQSxVQUNILE9BQU8sSUFBSSxNQUFNLDhCQUE4QixDQUFDO0FBQUE7QUFBQSxPQUV2RDtBQUFBLE1BRUQsUUFBTyxHQUFHLFNBQVMsTUFBTTtBQUFBLEtBQzVCO0FBQUE7QUFBQSxjQWNRLE9BQU0sQ0FBQyxTQUF1QixDQUFDLEdBQTRCO0FBQUEsSUFDcEUsSUFBSTtBQUFBLE1BRUEsSUFBSSxPQUFPLFFBQVE7QUFBQSxRQUNmLElBQUksS0FBSyxxREFBcUQ7QUFBQSxRQUM5RCxPQUFPLElBQUksZUFBZSxPQUFPLFFBQVEsTUFBTSxNQUFNO0FBQUEsTUFDekQ7QUFBQSxNQUdBLElBQUksT0FBTyxtQkFBbUI7QUFBQSxRQUMxQixJQUFJLEtBQUssMENBQTBDO0FBQUEsVUFDL0MsS0FBSyxPQUFPO0FBQUEsUUFDaEIsQ0FBQztBQUFBLFFBQ0QsSUFBSTtBQUFBLFVBQ0EsTUFBTSxVQUFTLHFCQUFxQjtBQUFBLFlBQ2hDLFNBQVMsT0FBTztBQUFBLFVBQ3BCLENBQUM7QUFBQSxVQUdELElBQUksTUFBTSw0Q0FBNEM7QUFBQSxVQUl0RCxPQUFPLElBQUksZUFBZSxTQUFRLE1BQU0sTUFBTTtBQUFBLFVBQ2hELE9BQU8sT0FBTztBQUFBLFVBQ1osTUFBTSxXQUNGLGlCQUFpQixRQUFRLE1BQU0sVUFBVSxPQUFPLEtBQUs7QUFBQSxVQUN6RCxJQUFJLE1BQU0sd0NBQXdDO0FBQUEsWUFDOUMsS0FBSyxPQUFPO0FBQUEsWUFDWixPQUFPO0FBQUEsVUFDWCxDQUFDO0FBQUEsVUFDRCxNQUFNO0FBQUE7QUFBQSxNQUVkO0FBQUEsTUFLQSxJQUFJLEtBQUssbUNBQW1DO0FBQUEsUUFDeEMsU0FBUyxPQUFPLHdCQUF3QjtBQUFBLE1BQzVDLENBQUM7QUFBQSxNQUVELE1BQU0sZ0JBQWdCLE1BQU0sZUFBZSxpQkFBaUI7QUFBQSxNQUU1RCxRQUFRLGlCQUFRLG9CQUFXLE1BQU0sZUFBZTtBQUFBLFFBQzVDLFNBQVMsT0FBTyx3QkFBd0I7QUFBQSxRQUN4QyxNQUFNO0FBQUEsTUFDVixDQUFDO0FBQUEsTUFFRCxJQUFJLEtBQUssc0NBQXNDO0FBQUEsTUFDL0MsT0FBTyxJQUFJLGVBQWUsU0FBUSxTQUFRLE1BQU07QUFBQSxNQUNsRCxPQUFPLE9BQU87QUFBQSxNQUNaLE1BQU0sV0FDRixpQkFBaUIsUUFBUSxNQUFNLFVBQVUsT0FBTyxLQUFLO0FBQUEsTUFDekQsSUFBSSxNQUFNLG1DQUFtQyxFQUFFLE9BQU8sU0FBUyxDQUFDO0FBQUEsTUFDaEUsTUFBTSxJQUFJLE1BQU0sb0NBQW9DLFVBQVU7QUFBQTtBQUFBO0FBQUEsT0FPaEUsY0FBYSxDQUFDLFFBQWtDO0FBQUEsSUFDbEQsSUFBSTtBQUFBLE1BRUEsTUFBTSxTQUFTLE1BQU0sS0FBSyxPQUFPLFFBQVEsT0FBTztBQUFBLFFBQzVDLE1BQU07QUFBQSxVQUNGLE9BQU87QUFBQSxRQUNYO0FBQUEsTUFDSixDQUFDO0FBQUEsTUFFRCxJQUFJLENBQUMsT0FBTyxNQUFNO0FBQUEsUUFDZCxNQUFNLElBQUksTUFDTixzQ0FBc0MsS0FBSyxVQUFVLE9BQU8sS0FBSyxHQUNyRTtBQUFBLE1BQ0o7QUFBQSxNQUVBLE1BQU0sYUFBYSxPQUFPO0FBQUEsTUFLMUIsSUFBSSx1QkFBdUIsT0FBTyxLQUFLO0FBQUEsTUFDdkMsTUFBTSxvQkFBb0IsQ0FBQyxZQUFvQjtBQUFBLFFBQzNDLElBQUksQ0FBQztBQUFBLFVBQXNCLE9BQU87QUFBQSxRQUNsQyxNQUFNLFdBQVcsR0FBRztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBQWtDO0FBQUEsUUFDdEQsdUJBQXVCO0FBQUEsUUFDdkIsT0FBTztBQUFBO0FBQUEsTUFJWCxNQUFNLGtCQUErQyxDQUFDO0FBQUEsTUFHdEQsTUFBTSxVQUFtQjtBQUFBLFFBQ3JCLElBQUksV0FBVyxNQUFNLEtBQUssa0JBQWtCO0FBQUEsUUFDNUMsa0JBQWtCO0FBQUEsUUFDbEIsYUFBYSxPQUFPLFlBQW9CO0FBQUEsVUFDcEMsT0FBTyxLQUFLLGtCQUNSLFdBQVcsSUFDWCxrQkFBa0IsT0FBTyxDQUM3QjtBQUFBO0FBQUEsUUFFSixtQkFBbUIsT0FBTyxZQUFvQjtBQUFBLFVBQzFDLE9BQU8sS0FBSyx3QkFDUixXQUFXLElBQ1gsa0JBQWtCLE9BQU8sR0FDekIsZUFDSjtBQUFBO0FBQUEsUUFFSixPQUFPLFlBQVk7QUFBQSxVQUNmLE9BQU8sS0FBSyxtQkFBbUIsV0FBVyxFQUFFO0FBQUE7QUFBQSxNQUVwRDtBQUFBLE1BR0EsS0FBSyxlQUFlLElBQUksUUFBUSxJQUFJLE9BQU87QUFBQSxNQUUzQyxPQUFPO0FBQUEsTUFDVCxPQUFPLE9BQU87QUFBQSxNQUNaLE1BQU0sZUFDRixpQkFBaUIsUUFBUSxNQUFNLFVBQVUsT0FBTyxLQUFLO0FBQUEsTUFDekQsTUFBTSxJQUFJLE1BQ04sc0NBQXNDLGNBQzFDO0FBQUE7QUFBQTtBQUFBLE9BT0YsWUFBVyxDQUNiLFdBQ0EsU0FDd0I7QUFBQSxJQUN4QixNQUFNLFVBQVUsS0FBSyxlQUFlLElBQUksU0FBUztBQUFBLElBRWpELElBQUksQ0FBQyxTQUFTO0FBQUEsTUFDVixNQUFNLElBQUksTUFBTSxzQkFBc0IsV0FBVztBQUFBLElBQ3JEO0FBQUEsSUFFQSxPQUFPLEtBQUssa0JBQWtCLFdBQVcsT0FBTztBQUFBO0FBQUEsT0FNOUMsYUFBWSxDQUFDLFdBQWtDO0FBQUEsSUFDakQsTUFBTSxVQUFVLEtBQUssZUFBZSxJQUFJLFNBQVM7QUFBQSxJQUVqRCxJQUFJLENBQUMsU0FBUztBQUFBLE1BQ1YsTUFBTSxJQUFJLE1BQU0sc0JBQXNCLFdBQVc7QUFBQSxJQUNyRDtBQUFBLElBRUEsTUFBTSxLQUFLLG1CQUFtQixTQUFTO0FBQUEsSUFDdkMsS0FBSyxlQUFlLE9BQU8sU0FBUztBQUFBO0FBQUEsRUFNeEMsaUJBQWlCLEdBQWE7QUFBQSxJQUMxQixPQUFPLE1BQU0sS0FBSyxLQUFLLGVBQWUsS0FBSyxDQUFDO0FBQUE7QUFBQSxFQU1oRCxlQUFlLENBQUMsV0FBNEI7QUFBQSxJQUN4QyxPQUFPLEtBQUssZUFBZSxJQUFJLFNBQVM7QUFBQTtBQUFBLE9BTXRDLGlCQUFnQixHQUFrQjtBQUFBLElBQ3BDLE1BQU0sZ0JBQWdCLE1BQU0sS0FBSyxLQUFLLGVBQWUsS0FBSyxDQUFDLEVBQUUsSUFDekQsQ0FBQyxjQUNHLEtBQUssbUJBQW1CLFNBQVMsRUFBRSxNQUFNLENBQUMsVUFBVTtBQUFBLE1BQ2hELE1BQU0sV0FDRixpQkFBaUIsUUFBUSxNQUFNLFVBQVUsT0FBTyxLQUFLO0FBQUEsTUFDekQsSUFBSSxLQUFLLHlCQUF5QjtBQUFBLFFBQzlCO0FBQUEsUUFDQSxPQUFPO0FBQUEsTUFDWCxDQUFDO0FBQUEsS0FDSixDQUNUO0FBQUEsSUFFQSxNQUFNLFFBQVEsSUFBSSxhQUFhO0FBQUEsSUFDL0IsS0FBSyxlQUFlLE1BQU07QUFBQTtBQUFBLE9BTWhCLHdCQUF1QixDQUNqQyxXQUNBLFNBQ0EsaUJBQzBCO0FBQUEsSUFDMUIsSUFBSSxZQUEwQjtBQUFBLElBRTlCLE1BQU0seUJBQ0YsT0FBUSxLQUFLLFFBQWdCLFNBQVMsZ0JBQWdCLGNBQ3RELE9BQVEsS0FBSyxRQUFnQixPQUFPLGNBQWM7QUFBQSxJQUV0RCxTQUFTLFVBQVUsRUFBRyxXQUFXLEtBQUssZUFBZSxXQUFXO0FBQUEsTUFDNUQsSUFBSTtBQUFBLFFBRUEsTUFBTSxTQUFTLElBQUk7QUFBQSxRQUNuQixNQUFNLFNBQVMsT0FBTyxTQUFTLFVBQVU7QUFBQSxRQUd6QyxJQUFJLFlBQVk7QUFBQSxRQUNoQixNQUFNLFlBQVksWUFBWTtBQUFBLFVBQzFCLElBQUk7QUFBQSxZQUFXO0FBQUEsVUFDZixZQUFZO0FBQUEsVUFDWixJQUFJO0FBQUEsWUFDQSxNQUFNLE9BQU8sTUFBTTtBQUFBLFlBQ3JCLE1BQU07QUFBQTtBQUFBLFFBSVosTUFBTSxZQUFZLE9BQU8sUUFBaUI7QUFBQSxVQUN0QyxJQUFJO0FBQUEsWUFBVztBQUFBLFVBQ2YsWUFBWTtBQUFBLFVBQ1osSUFBSTtBQUFBLFlBQ0EsTUFBTSxPQUFPLE1BQU0sR0FBRztBQUFBLFlBQ3hCLE1BQU07QUFBQTtBQUFBLFFBT1osSUFBSSxDQUFDLHdCQUF3QjtBQUFBLFVBQ3pCLE1BQU0sZ0JBQWdCLEtBQUssT0FBTyxRQUFRLE9BQU87QUFBQSxZQUM3QyxNQUFNO0FBQUEsY0FDRixXQUFXLEtBQUssa0JBQWtCO0FBQUEsY0FDbEMsT0FBTztBQUFBLGdCQUNIO0FBQUEsa0JBQ0ksTUFBTTtBQUFBLGtCQUNOLE1BQU07QUFBQSxnQkFDVjtBQUFBLGNBQ0o7QUFBQSxZQUNKO0FBQUEsWUFDQSxNQUFNO0FBQUEsY0FDRixJQUFJO0FBQUEsWUFDUjtBQUFBLFlBQ0EsT0FBTztBQUFBLGNBQ0gsV0FBVyxLQUFLO0FBQUEsWUFDcEI7QUFBQSxVQUNKLENBQVE7QUFBQSxVQUVSLE1BQU0sa0JBQWlCLFlBQVk7QUFBQSxZQUMvQixJQUFJO0FBQUEsY0FDQSxNQUFNLFNBQVMsTUFBTTtBQUFBLGNBRXJCLElBQUksQ0FBQyxPQUFPLE1BQU07QUFBQSxnQkFDZCxNQUFNLElBQUksTUFDTixtQ0FBbUMsS0FBSyxVQUFVLE9BQU8sS0FBSyxHQUNsRTtBQUFBLGNBQ0o7QUFBQSxjQUVBLE1BQU0sV0FBVyxPQUFPO0FBQUEsY0FDeEIsTUFBTSxXQUFXLFNBQVMsT0FBTyxLQUM3QixDQUFDLFNBQWMsS0FBSyxTQUFTLE1BQ2pDO0FBQUEsY0FFQSxNQUFNLGVBQ0QsVUFBa0IsUUFDbkI7QUFBQSxjQUdKLE1BQU0sU0FBUyxLQUFLLGdCQUNoQixjQUNBLEVBQ0o7QUFBQSxjQUNBLE1BQU0sV0FBVSxJQUFJO0FBQUEsY0FDcEIsV0FBVyxTQUFTLFFBQVE7QUFBQSxnQkFDeEIsTUFBTSxPQUFPLE1BQU0sU0FBUSxPQUFPLEtBQUssQ0FBQztBQUFBLGdCQUN4QyxNQUFNLElBQUksUUFBUSxDQUFDLFlBQ2YsV0FBVyxTQUFTLEVBQUUsQ0FDMUI7QUFBQSxjQUNKO0FBQUEsY0FFQSxNQUFNLFVBQVU7QUFBQSxjQUNoQixPQUFPLEVBQUUsU0FBUyxhQUFhO0FBQUEsY0FDakMsT0FBTyxPQUFPO0FBQUEsY0FDWixNQUFNLFVBQVUsS0FBSztBQUFBLGNBQ3JCLE1BQU07QUFBQTtBQUFBLGFBRVg7QUFBQSxVQUVILE9BQU87QUFBQSxZQUNILFFBQVEsT0FBTztBQUFBLFlBQ2YsVUFBVTtBQUFBLFVBQ2Q7QUFBQSxRQUNKO0FBQUEsUUFHQSxNQUFNLFVBQVUsSUFBSTtBQUFBLFFBQ3BCLE1BQU0sbUJBQW1CLElBQUksTUFDekIsNkJBQTZCLEtBQUssaUJBQ3RDO0FBQUEsUUFDQSxNQUFNLG1CQUFtQixJQUFJLE1BQ3pCLDZCQUE2QixLQUFLLGdCQUFnQixLQUN0RDtBQUFBLFFBRUEsTUFBTSxhQUFhLElBQUk7QUFBQSxRQUN2QixJQUFJO0FBQUEsUUFDSixJQUFJO0FBQUEsUUFDSixJQUFJLGVBQWU7QUFBQSxRQUNuQixJQUFJLG1CQUFtQixLQUFLLElBQUk7QUFBQSxRQUNoQyxJQUFJLGVBQWU7QUFBQSxRQUduQixNQUFNLGlCQUFpQixNQUFNO0FBQUEsVUFDekIsSUFBSTtBQUFBLFlBQVcsYUFBYSxTQUFTO0FBQUEsVUFDckMsWUFBWSxXQUFXLE1BQU07QUFBQSxZQUN6QixJQUFJLEtBQUssa0NBQWtDO0FBQUEsY0FDdkM7QUFBQSxjQUNBLFdBQVcsS0FBSyxnQkFBZ0I7QUFBQSxZQUNwQyxDQUFDO0FBQUEsWUFDRCxJQUFJO0FBQUEsY0FDQSxXQUFXLE1BQU0sZ0JBQWdCO0FBQUEsY0FDbkMsTUFBTTtBQUFBLGFBR1QsS0FBSyxnQkFBZ0IsQ0FBQztBQUFBO0FBQUEsUUFJN0IsTUFBTSxpQkFBaUIsTUFBTTtBQUFBLFVBQ3pCLElBQUk7QUFBQSxZQUFXLGFBQWEsU0FBUztBQUFBLFVBQ3JDLFlBQVksV0FBVyxNQUFNO0FBQUEsWUFDekIsZUFBZTtBQUFBLFlBQ2YsSUFBSSxLQUFLLGtDQUFrQztBQUFBLGNBQ3ZDO0FBQUEsY0FDQSxXQUFXLEtBQUs7QUFBQSxjQUNoQjtBQUFBLGNBQ0EsbUJBQW1CLEtBQUssSUFBSSxJQUFJO0FBQUEsWUFDcEMsQ0FBQztBQUFBLFlBQ0QsSUFBSTtBQUFBLGNBQ0EsV0FBVyxNQUFNLGdCQUFnQjtBQUFBLGNBQ25DLE1BQU07QUFBQSxhQUdULEtBQUssYUFBYTtBQUFBO0FBQUEsUUFHekIsTUFBTSxpQkFBaUIsWUFBWTtBQUFBLFVBQy9CLElBQUk7QUFBQSxZQUNBLGVBQWU7QUFBQSxZQUNmLGVBQWU7QUFBQSxZQUVmLE1BQU0sZ0JBQWdCLEtBQUssa0JBQWtCO0FBQUEsWUFFN0MsSUFBSSxNQUFNLDhCQUE4QjtBQUFBLGNBQ3BDO0FBQUEsY0FDQSxlQUFlLFFBQVE7QUFBQSxjQUN2QjtBQUFBLFlBQ0osQ0FBQztBQUFBLFlBRUQsTUFBTyxLQUFLLE9BQWUsUUFBUSxZQUFZO0FBQUEsY0FDM0MsTUFBTTtBQUFBLGdCQUNGLFdBQVc7QUFBQSxnQkFDWCxPQUFPO0FBQUEsa0JBQ0g7QUFBQSxvQkFDSSxNQUFNO0FBQUEsb0JBQ04sTUFBTTtBQUFBLGtCQUNWO0FBQUEsZ0JBQ0o7QUFBQSxjQUNKO0FBQUEsY0FDQSxNQUFNO0FBQUEsZ0JBQ0YsSUFBSTtBQUFBLGNBQ1I7QUFBQSxjQUNBLE9BQU87QUFBQSxnQkFDSCxXQUFXLEtBQUs7QUFBQSxjQUNwQjtBQUFBLGNBQ0EsUUFBUSxXQUFXO0FBQUEsWUFDdkIsQ0FBQztBQUFBLFlBRUQsSUFBSSxNQUFNLHlCQUF5QjtBQUFBLGNBQy9CO0FBQUEsY0FDQSxXQUFXLEtBQUs7QUFBQSxZQUNwQixDQUFDO0FBQUEsWUFFRCxNQUFNLGVBQWUsTUFDakIsS0FBSyxPQUNQLE1BQU0sVUFBVTtBQUFBLGNBQ2QsT0FBTztBQUFBLGdCQUNILFdBQVcsS0FBSztBQUFBLGNBQ3BCO0FBQUEsY0FDQSxRQUFRLFdBQVc7QUFBQSxZQUN2QixDQUFDO0FBQUEsWUFFRCxJQUFJLHNCQUFvQztBQUFBLFlBQ3hDLElBQUksVUFBVTtBQUFBLFlBQ2QsSUFBSSxjQUFjO0FBQUEsWUFDbEIsSUFBSSxhQUFhO0FBQUEsWUFFakIsSUFBSSxNQUFNLG9DQUFvQztBQUFBLGNBQzFDO0FBQUEsWUFDSixDQUFDO0FBQUEsWUFFRCxpQkFBaUIsU0FBUyxhQUFhLFFBQStCO0FBQUEsY0FDbEU7QUFBQSxjQUdBLElBQUksTUFBTSxrQkFBa0I7QUFBQSxnQkFDeEI7QUFBQSxnQkFDQSxXQUFXLE9BQU87QUFBQSxnQkFDbEI7QUFBQSxnQkFDQSxlQUFlLENBQUMsQ0FBQyxPQUFPO0FBQUEsZ0JBQ3hCLG1CQUFtQixXQUFXLE9BQU87QUFBQSxjQUN6QyxDQUFDO0FBQUEsY0FFRCxJQUFJLFdBQVcsT0FBTyxTQUFTO0FBQUEsZ0JBQzNCLElBQUksTUFDQSwyQ0FDQTtBQUFBLGtCQUNJO0FBQUEsa0JBQ0E7QUFBQSxnQkFDSixDQUNKO0FBQUEsZ0JBQ0E7QUFBQSxjQUNKO0FBQUEsY0FFQSxJQUFJLENBQUMsU0FBUyxPQUFPLFVBQVUsVUFBVTtBQUFBLGdCQUNyQyxJQUFJLE1BQU0sNkJBQTZCO0FBQUEsa0JBQ25DO0FBQUEsa0JBQ0E7QUFBQSxnQkFDSixDQUFDO0FBQUEsZ0JBQ0Q7QUFBQSxjQUNKO0FBQUEsY0FFQSxJQUFJLE1BQU0sU0FBUyxtQkFBbUI7QUFBQSxnQkFDbEMsTUFBTSxPQUFRLE1BQWMsWUFBWTtBQUFBLGdCQUV4QyxJQUFJLE1BQU0seUJBQXlCO0FBQUEsa0JBQy9CO0FBQUEsa0JBQ0E7QUFBQSxrQkFDQSxVQUFVLE1BQU07QUFBQSxrQkFDaEIsZUFBZSxNQUFNO0FBQUEsa0JBQ3JCLGNBQWMsTUFBTTtBQUFBLGtCQUNwQixRQUFRLE1BQU07QUFBQSxrQkFDZCxtQkFDSSxNQUFNLGNBQWM7QUFBQSxrQkFDeEIsYUFBYSxNQUFNLFNBQVM7QUFBQSxrQkFDNUIsZUFDSSxNQUFNLGFBQWE7QUFBQSxnQkFDM0IsQ0FBQztBQUFBLGdCQUdELElBQ0ksTUFBTSxTQUFTLGVBQ2YsTUFBTSxjQUFjLGFBQ3BCLE1BQU0sYUFBYSxlQUNyQjtBQUFBLGtCQUNFLHNCQUFxQixLQUFLO0FBQUEsa0JBQzFCLElBQUksTUFDQSx1REFDQTtBQUFBLG9CQUNJO0FBQUEsb0JBQ0E7QUFBQSxrQkFDSixDQUNKO0FBQUEsZ0JBQ0osRUFJSyxTQUNELENBQUMsdUJBQ0QsTUFBTSxTQUFTLGVBQ2YsTUFBTSxjQUFjLFdBQ3RCO0FBQUEsa0JBQ0UsSUFBSSxNQUNBLHFFQUNBO0FBQUEsb0JBQ0k7QUFBQSxvQkFDQSxvQkFBb0IsS0FBSztBQUFBLG9CQUN6QixjQUFjLE1BQU07QUFBQSxvQkFDcEI7QUFBQSxrQkFDSixDQUNKO0FBQUEsa0JBQ0Esc0JBQXFCLEtBQUs7QUFBQSxnQkFDOUI7QUFBQSxnQkFJQSxJQUNJLE1BQU0sU0FBUyxlQUNmLE1BQU0sY0FBYyxXQUN0QjtBQUFBLGtCQUNFLG1CQUFtQixLQUFLLElBQUk7QUFBQSxrQkFDNUIsZUFBZTtBQUFBLGdCQUNuQjtBQUFBLGdCQUVBLElBQ0ksdUJBQ0EsTUFBTSxPQUFPLHFCQUNmO0FBQUEsa0JBQ0UsSUFBSSxNQUFNLE9BQU87QUFBQSxvQkFDYixNQUFNLFVBQ0YsS0FBSyxNQUFNLFFBQVE7QUFBQSxvQkFDdkIsTUFBTSxTQUNGLEtBQUssTUFBTSxNQUFNLFdBQ2pCLEtBQUssVUFDRCxLQUFLLE1BQU0sUUFBUSxDQUFDLENBQ3hCO0FBQUEsb0JBQ0osSUFBSSxNQUNBLDhCQUNBO0FBQUEsc0JBQ0k7QUFBQSxzQkFDQSxXQUFXO0FBQUEsc0JBQ1gsY0FBYztBQUFBLG9CQUNsQixDQUNKO0FBQUEsb0JBQ0EsTUFBTSxJQUFJLE1BQ04sR0FBRyxZQUFZLFFBQ25CO0FBQUEsa0JBQ0o7QUFBQSxrQkFFQSxJQUFJLE1BQU0sTUFBTSxXQUFXO0FBQUEsb0JBQ3ZCLElBQUksTUFDQSwrQkFDQTtBQUFBLHNCQUNJO0FBQUEsc0JBQ0E7QUFBQSxzQkFDQSxhQUNJLEtBQUssS0FBSztBQUFBLG9CQUNsQixDQUNKO0FBQUEsb0JBQ0E7QUFBQSxrQkFDSjtBQUFBLGdCQUNKO0FBQUEsZ0JBRUE7QUFBQSxjQUNKO0FBQUEsY0FFQSxJQUFJLE1BQU0sU0FBUyx3QkFBd0I7QUFBQSxnQkFFdkMsTUFBTSxPQUFRLE1BQWMsWUFDdEI7QUFBQSxnQkFFTixJQUFJLE1BQU0sd0JBQXdCO0FBQUEsa0JBQzlCO0FBQUEsa0JBQ0E7QUFBQSxrQkFDQSxTQUFTLENBQUMsQ0FBQztBQUFBLGtCQUNYLFVBQVUsTUFBTTtBQUFBLGtCQUNoQixlQUFlLE1BQU07QUFBQSxrQkFDckIsZUFBZSxNQUFNO0FBQUEsa0JBQ3JCO0FBQUEsa0JBQ0EsWUFDSSx1QkFDQSxNQUFNLGNBQWMsYUFDcEIsTUFBTSxjQUFjO0FBQUEsZ0JBQzVCLENBQUM7QUFBQSxnQkFFRCxJQUFJLENBQUM7QUFBQSxrQkFBb0I7QUFBQSxnQkFHekIsSUFBSSxNQUFNLFNBQVMsVUFBVSxpQkFBaUI7QUFBQSxrQkFDMUMsTUFBTSxTQUNGLEtBQUssVUFDTCxLQUFLLE1BQ0wsUUFBUTtBQUFBLGtCQUNaLE1BQU0sV0FDRixLQUFLLFlBQVksS0FBSyxRQUFRO0FBQUEsa0JBQ2xDLE1BQU0sWUFDRixLQUFLLFNBQVMsS0FBSyxjQUFjLENBQUM7QUFBQSxrQkFHdEMsTUFBTSxvQkFDRixnQkFBZ0IsVUFDWixDQUFDLE1BQU0sRUFBRSxPQUFPLE1BQ3BCO0FBQUEsa0JBQ0osTUFBTSxNQUFNLElBQUksS0FBSyxFQUFFLFlBQVk7QUFBQSxrQkFFbkMsSUFBSSxxQkFBcUIsR0FBRztBQUFBLG9CQUV4QixNQUFNLFdBQ0YsZ0JBQWdCO0FBQUEsb0JBQ3BCLFNBQVMsU0FDTCxLQUFLLFVBQ0wsS0FBSyxVQUNMLFNBQVM7QUFBQSxvQkFDYixTQUFTLFNBQ0wsS0FBSyxXQUFXLFVBQ1YsVUFDQTtBQUFBLG9CQUNWLFNBQVMsUUFDTCxLQUFLLFNBQVMsU0FBUztBQUFBLG9CQUMzQixTQUFTLGNBQ0wsS0FBSyxlQUFlO0FBQUEsb0JBRXhCLElBQUksTUFBTSwyQkFBMkI7QUFBQSxzQkFDakM7QUFBQSxzQkFDQTtBQUFBLHNCQUNBO0FBQUEsc0JBQ0EsUUFBUSxTQUFTO0FBQUEsb0JBQ3JCLENBQUM7QUFBQSxrQkFDTCxFQUFPO0FBQUEsb0JBRUgsTUFBTSxpQkFBaUI7QUFBQSxzQkFDbkIsSUFBSTtBQUFBLHNCQUNKLE1BQU07QUFBQSxzQkFDTixPQUFPO0FBQUEsc0JBQ1AsUUFBUSxLQUFLLFVBQVUsS0FBSztBQUFBLHNCQUM1QixRQUNJLEtBQUssV0FBVyxVQUNULFVBQ0E7QUFBQSxzQkFDWCxPQUFPLEtBQUs7QUFBQSxzQkFDWixXQUFXLEtBQUssYUFBYTtBQUFBLHNCQUM3QixhQUFhLEtBQUs7QUFBQSxvQkFDdEI7QUFBQSxvQkFDQSxnQkFBZ0IsS0FBSyxjQUFjO0FBQUEsb0JBRW5DLElBQUksTUFBTSwyQkFBMkI7QUFBQSxzQkFDakM7QUFBQSxzQkFDQTtBQUFBLHNCQUNBO0FBQUEsc0JBQ0EsT0FBTyxLQUFLLFVBQ1IsU0FDSixFQUFFLE1BQU0sR0FBRyxHQUFHO0FBQUEsb0JBQ2xCLENBQUM7QUFBQTtBQUFBLGtCQUtMLElBQ0ksS0FBSyxjQUFjLGFBQ25CLEtBQUssY0FBYyxxQkFDckIsQ0FFRixFQUFPO0FBQUEsb0JBRUgsbUJBQW1CLEtBQUssSUFBSTtBQUFBLG9CQUM1QixlQUFlO0FBQUE7QUFBQSxrQkFHbkI7QUFBQSxnQkFDSjtBQUFBLGdCQUVBLElBQUksQ0FBQyxRQUFRLEtBQUssU0FBUztBQUFBLGtCQUFRO0FBQUEsZ0JBQ25DLElBQUksS0FBSyxjQUFjO0FBQUEsa0JBQVc7QUFBQSxnQkFDbEMsSUFBSSxLQUFLLGNBQWM7QUFBQSxrQkFDbkI7QUFBQSxnQkFFSixNQUFNLFdBQVksTUFBYyxZQUMxQjtBQUFBLGdCQUVOLElBQUk7QUFBQSxnQkFLSixJQUFJLE9BQU8sS0FBSyxTQUFTLFVBQVU7QUFBQSxrQkFDL0IsTUFBTSxPQUFPLEtBQUs7QUFBQSxrQkFFbEIsSUFBSSxLQUFLLFdBQVcsV0FBVyxHQUFHO0FBQUEsb0JBQzlCLFlBQVksS0FBSyxNQUNiLFlBQVksTUFDaEI7QUFBQSxvQkFDQSxjQUFjO0FBQUEsa0JBQ2xCLEVBQU8sU0FBSSxZQUFZLFdBQVcsSUFBSSxHQUFHO0FBQUEsb0JBRXJDLFlBQVk7QUFBQSxrQkFDaEIsRUFBTztBQUFBLG9CQUVILFlBQVk7QUFBQSxvQkFDWixlQUFlO0FBQUE7QUFBQSxnQkFFdkIsRUFBTyxTQUFJLE9BQU8sYUFBYSxVQUFVO0FBQUEsa0JBQ3JDLFlBQVk7QUFBQSxrQkFDWixlQUFlO0FBQUEsZ0JBQ25CO0FBQUEsZ0JBRUEsSUFBSSxDQUFDO0FBQUEsa0JBQVc7QUFBQSxnQkFHaEIsbUJBQW1CLEtBQUssSUFBSTtBQUFBLGdCQUM1QixnQkFBZ0IsVUFBVTtBQUFBLGdCQUMxQixlQUFlO0FBQUEsZ0JBRWYsSUFBSSxNQUFNLDJCQUEyQjtBQUFBLGtCQUNqQztBQUFBLGtCQUNBLGFBQWEsVUFBVTtBQUFBLGtCQUN2QixtQkFBbUI7QUFBQSxrQkFDbkIsZUFBZSxRQUFRO0FBQUEsZ0JBQzNCLENBQUM7QUFBQSxnQkFFRCxXQUFXO0FBQUEsZ0JBQ1gsTUFBTSxPQUFPLE1BQU0sUUFBUSxPQUFPLFNBQVMsQ0FBQztBQUFBLGNBQ2hEO0FBQUEsWUFDSjtBQUFBLFlBRUEsSUFBSSxNQUFNLHNCQUFzQjtBQUFBLGNBQzVCO0FBQUEsY0FDQTtBQUFBLGNBQ0EsbUJBQW1CO0FBQUEsY0FDbkIsZUFBZSxRQUFRO0FBQUEsY0FDdkIsbUJBQW1CLFdBQVcsT0FBTztBQUFBLGNBQ3JDO0FBQUEsY0FDQSx5QkFBeUIsQ0FBQyxDQUFDO0FBQUEsWUFDL0IsQ0FBQztBQUFBLFlBRUQsTUFBTSxVQUFVO0FBQUEsWUFDaEIsT0FBTztBQUFBLGNBQ0gsU0FBUyxXQUFXO0FBQUEsY0FDcEIsYUFBYTtBQUFBLGdCQUNUO0FBQUEsZ0JBQ0EsZUFBZSxRQUFRO0FBQUEsZ0JBQ3ZCO0FBQUEsZ0JBQ0EseUJBQXlCLENBQUMsQ0FBQztBQUFBLGdCQUMzQjtBQUFBLGNBQ0o7QUFBQSxZQUNKO0FBQUEsWUFDRixPQUFPLE9BQU87QUFBQSxZQUNaLElBQUksTUFBTSx3QkFBd0I7QUFBQSxjQUM5QjtBQUFBLGNBQ0EsT0FDSSxpQkFBaUIsUUFDWCxNQUFNLFVBQ04sT0FBTyxLQUFLO0FBQUEsY0FDdEIsbUJBQW1CLFdBQVcsT0FBTztBQUFBLGNBQ3JDO0FBQUEsY0FDQTtBQUFBLGNBQ0EseUJBQXlCLENBQUMsQ0FBQztBQUFBLFlBQy9CLENBQUM7QUFBQSxZQUVELElBQUksV0FBVyxPQUFPLFNBQVM7QUFBQSxjQUMzQixNQUFNLFVBQVUsZ0JBQWdCO0FBQUEsY0FDaEMsTUFBTTtBQUFBLFlBQ1Y7QUFBQSxZQUNBLE1BQU0sVUFBVSxLQUFLO0FBQUEsWUFDckIsTUFBTTtBQUFBLG9CQUNSO0FBQUEsWUFDRSxJQUFJO0FBQUEsY0FBVyxhQUFhLFNBQVM7QUFBQSxZQUNyQyxJQUFJO0FBQUEsY0FBVyxhQUFhLFNBQVM7QUFBQSxZQUNyQyxJQUFJO0FBQUEsY0FDQSxJQUFJLENBQUMsV0FBVyxPQUFPO0FBQUEsZ0JBQVMsV0FBVyxNQUFNO0FBQUEsY0FDbkQsTUFBTTtBQUFBO0FBQUEsV0FJYjtBQUFBLFFBRUgsT0FBTztBQUFBLFVBQ0gsUUFBUSxPQUFPO0FBQUEsVUFDZixVQUFVO0FBQUEsUUFDZDtBQUFBLFFBQ0YsT0FBTyxPQUFPO0FBQUEsUUFDWixZQUNJLGlCQUFpQixRQUFRLFFBQVEsSUFBSSxNQUFNLE9BQU8sS0FBSyxDQUFDO0FBQUEsUUFFNUQsTUFBTSxjQUFjLEtBQUssaUJBQWlCLFNBQVM7QUFBQSxRQUVuRCxJQUFJLFlBQVksS0FBSyxlQUFlO0FBQUEsVUFDaEM7QUFBQSxRQUNKO0FBQUEsUUFFQSxNQUFNLFFBQVEsS0FBSyxnQkFBZ0IsU0FBUyxXQUFXO0FBQUEsUUFFdkQsSUFBSSxLQUFLLHFDQUFxQztBQUFBLFVBQzFDO0FBQUEsVUFDQSxlQUFlLEtBQUs7QUFBQSxVQUNwQixTQUFTO0FBQUEsVUFDVDtBQUFBLFVBQ0EsT0FBTyxVQUFVO0FBQUEsUUFDckIsQ0FBQztBQUFBLFFBRUQsTUFBTSxJQUFJLFFBQVEsQ0FBQyxZQUFZLFdBQVcsU0FBUyxLQUFLLENBQUM7QUFBQTtBQUFBLElBRWpFO0FBQUEsSUFFQSxNQUFNLElBQUksTUFDTixrQ0FBa0MsS0FBSywyQkFBMkIsV0FBVyxXQUFXLGlCQUM1RjtBQUFBO0FBQUEsRUFNSSxlQUFlLENBQUMsTUFBYyxXQUE2QjtBQUFBLElBQy9ELE1BQU0sU0FBbUIsQ0FBQztBQUFBLElBQzFCLFNBQVMsSUFBSSxFQUFHLElBQUksS0FBSyxRQUFRLEtBQUssV0FBVztBQUFBLE1BQzdDLE9BQU8sS0FBSyxLQUFLLE1BQU0sR0FBRyxJQUFJLFNBQVMsQ0FBQztBQUFBLElBQzVDO0FBQUEsSUFDQSxPQUFPLE9BQU8sU0FBUyxJQUFJLFNBQVMsQ0FBQyxJQUFJO0FBQUE7QUFBQSxPQU0vQixrQkFBaUIsQ0FDM0IsV0FDQSxTQUN3QjtBQUFBLElBQ3hCLElBQUksWUFBMEI7QUFBQSxJQUU5QixTQUFTLFVBQVUsRUFBRyxXQUFXLEtBQUssZUFBZSxXQUFXO0FBQUEsTUFDNUQsSUFBSTtBQUFBLFFBQ0EsTUFBTSxlQUFlLElBQUksTUFDckIsd0JBQXdCLEtBQUssaUJBQ2pDO0FBQUEsUUFFQSxNQUFNLGFBQWEsSUFBSTtBQUFBLFFBQ3ZCLE1BQU0sUUFBUSxXQUFXLE1BQU07QUFBQSxVQUMzQixJQUFJO0FBQUEsWUFDQSxXQUFXLE1BQU0sWUFBWTtBQUFBLFlBQy9CLE1BQU07QUFBQSxXQUdULEtBQUssYUFBYTtBQUFBLFFBRXJCLElBQUk7QUFBQSxRQUNKLElBQUk7QUFBQSxVQUNBLFNBQVMsTUFBTSxLQUFLLE9BQU8sUUFBUSxPQUFPO0FBQUEsWUFDdEMsTUFBTTtBQUFBLGNBQ0YsV0FBVyxLQUFLLGtCQUFrQjtBQUFBLGNBQ2xDLE9BQU87QUFBQSxnQkFDSDtBQUFBLGtCQUNJLE1BQU07QUFBQSxrQkFDTixNQUFNO0FBQUEsZ0JBQ1Y7QUFBQSxjQUNKO0FBQUEsWUFDSjtBQUFBLFlBQ0EsTUFBTTtBQUFBLGNBQ0YsSUFBSTtBQUFBLFlBQ1I7QUFBQSxZQUNBLE9BQU87QUFBQSxjQUNILFdBQVcsS0FBSztBQUFBLFlBQ3BCO0FBQUEsWUFDQSxRQUFRLFdBQVc7QUFBQSxVQUN2QixDQUFRO0FBQUEsVUFDVixPQUFPLE9BQU87QUFBQSxVQUNaLElBQUksV0FBVyxPQUFPLFNBQVM7QUFBQSxZQUMzQixNQUFNO0FBQUEsVUFDVjtBQUFBLFVBQ0EsTUFBTTtBQUFBLGtCQUNSO0FBQUEsVUFDRSxhQUFhLEtBQUs7QUFBQTtBQUFBLFFBR3RCLElBQUksQ0FBQyxPQUFPLE1BQU07QUFBQSxVQUNkLE1BQU0sSUFBSSxNQUNOLG1DQUFtQyxLQUFLLFVBQVUsT0FBTyxLQUFLLEdBQ2xFO0FBQUEsUUFDSjtBQUFBLFFBR0EsTUFBTSxXQUFXLE9BQU87QUFBQSxRQUd4QixNQUFNLFdBQVcsU0FBUyxPQUFPLEtBQzdCLENBQUMsU0FBYyxLQUFLLFNBQVMsTUFDakM7QUFBQSxRQUNBLE9BQU8sRUFBRSxTQUFTLFVBQVUsUUFBUSxzQkFBc0I7QUFBQSxRQUM1RCxPQUFPLE9BQU87QUFBQSxRQUNaLFlBQ0ksaUJBQWlCLFFBQVEsUUFBUSxJQUFJLE1BQU0sT0FBTyxLQUFLLENBQUM7QUFBQSxRQUc1RCxNQUFNLGNBQWMsS0FBSyxpQkFBaUIsU0FBUztBQUFBLFFBRW5ELElBQUksWUFBWSxLQUFLLGVBQWU7QUFBQSxVQUNoQztBQUFBLFFBQ0o7QUFBQSxRQUdBLE1BQU0sUUFBUSxLQUFLLGdCQUFnQixTQUFTLFdBQVc7QUFBQSxRQUV2RCxJQUFJLEtBQUsscUNBQXFDO0FBQUEsVUFDMUM7QUFBQSxVQUNBLGVBQWUsS0FBSztBQUFBLFVBQ3BCLFNBQVM7QUFBQSxVQUNUO0FBQUEsVUFDQSxPQUFPLFVBQVU7QUFBQSxRQUNyQixDQUFDO0FBQUEsUUFFRCxNQUFNLElBQUksUUFBUSxDQUFDLFlBQVksV0FBVyxTQUFTLEtBQUssQ0FBQztBQUFBO0FBQUEsSUFFakU7QUFBQSxJQUVBLE1BQU0sSUFBSSxNQUNOLGdDQUFnQyxLQUFLLDJCQUEyQixXQUFXLFdBQVcsaUJBQzFGO0FBQUE7QUFBQSxFQU1JLGdCQUFnQixDQUFDLE9BQXVCO0FBQUEsSUFDNUMsTUFBTSxNQUFNO0FBQUEsSUFDWixPQUNJLElBQUksV0FBVyxPQUNmLHdDQUF3QyxLQUFLLE1BQU0sT0FBTztBQUFBO0FBQUEsRUFPMUQsZUFBZSxDQUFDLFNBQWlCLGFBQThCO0FBQUEsSUFDbkUsTUFBTSxPQUFPLGNBQWMsT0FBTztBQUFBLElBQ2xDLE1BQU0sY0FBYyxPQUFPLE1BQU0sVUFBVTtBQUFBLElBQzNDLE1BQU0sU0FBUyxLQUFLLE9BQU8sSUFBSTtBQUFBLElBQy9CLE9BQU8sS0FBSyxJQUFJLGNBQWMsUUFBUSxLQUFLO0FBQUE7QUFBQSxPQU1qQyxtQkFBa0IsQ0FBQyxXQUFrQztBQUFBLElBQy9ELElBQUk7QUFBQSxNQUlBLElBQUksTUFBTSxrQkFBa0IsRUFBRSxVQUFVLENBQUM7QUFBQSxNQUMzQyxPQUFPLE9BQU87QUFBQSxNQUNaLE1BQU0sZUFDRixpQkFBaUIsUUFBUSxNQUFNLFVBQVUsT0FBTyxLQUFLO0FBQUEsTUFDekQsSUFBSSxLQUFLLDJCQUEyQjtBQUFBLFFBQ2hDO0FBQUEsUUFDQSxPQUFPO0FBQUEsTUFDWCxDQUFDO0FBQUE7QUFBQTtBQUFBLEVBT0QsaUJBQWlCLEdBQVc7QUFBQSxJQUNoQyxPQUFPLFdBQVcsS0FBSyxJQUFJLEtBQUssS0FBSyxPQUFPLEVBQUUsU0FBUyxFQUFFLEVBQUUsT0FBTyxHQUFHLENBQUM7QUFBQTtBQUFBLEVBT2xFLGlCQUFpQixHQUFXO0FBQUEsSUFDaEMsT0FBTyxPQUFPLEtBQUssSUFBSSxLQUFLLEtBQUssT0FBTyxFQUFFLFNBQVMsRUFBRSxFQUFFLFVBQVUsR0FBRyxDQUFDO0FBQUE7QUFBQSxPQU1uRSxRQUFPLEdBQWtCO0FBQUEsSUFDM0IsSUFBSTtBQUFBLE1BQ0EsSUFBSSxNQUFNLHVCQUF1QjtBQUFBLFFBQzdCLGdCQUFnQixLQUFLLGVBQWU7QUFBQSxRQUNwQyxXQUFXLENBQUMsQ0FBQyxLQUFLO0FBQUEsTUFDdEIsQ0FBQztBQUFBLE1BR0QsTUFBTSxLQUFLLGlCQUFpQjtBQUFBLE1BRzVCLElBQUksS0FBSyxRQUFRO0FBQUEsUUFDYixJQUFJLEtBQUssaUNBQWlDO0FBQUEsUUFDMUMsSUFBSTtBQUFBLFVBQ0EsS0FBSyxPQUFPLE1BQU07QUFBQSxVQUNsQixLQUFLLFNBQVM7QUFBQSxVQUNkLElBQUksS0FBSyxxQ0FBcUM7QUFBQSxVQUNoRCxPQUFPLE9BQU87QUFBQSxVQUNaLE1BQU0sV0FDRixpQkFBaUIsUUFBUSxNQUFNLFVBQVUsT0FBTyxLQUFLO0FBQUEsVUFDekQsSUFBSSxNQUFNLGlDQUFpQztBQUFBLFlBQ3ZDLE9BQU87QUFBQSxVQUNYLENBQUM7QUFBQTtBQUFBLE1BRVQsRUFBTztBQUFBLFFBQ0gsSUFBSSxNQUNBLDJEQUNKO0FBQUE7QUFBQSxNQUdKLElBQUksS0FBSyxrQkFBa0I7QUFBQSxNQUMzQjtBQUFBLE1BQ0YsT0FBTyxPQUFPO0FBQUEsTUFDWixNQUFNLFdBQ0YsaUJBQWlCLFFBQVEsTUFBTSxVQUFVLE9BQU8sS0FBSztBQUFBLE1BQ3pELElBQUksTUFBTSx3Q0FBd0M7QUFBQSxRQUM5QyxPQUFPO0FBQUEsTUFDWCxDQUFDO0FBQUEsTUFDRDtBQUFBO0FBQUE7QUFHWjs7O0FjanJDQTtBQUNBO0FBQ0EscUJBQVM7QUFDVCxpQkFBUztBQUdUOzs7QUNKQSxJQUFNLHNCQUFzQjtBQUFBLEVBQ3hCLE9BQU8sQ0FBQyxTQUFTLE9BQU8sU0FBUyxPQUFPLFNBQVMsV0FBVyxjQUFjO0FBQUEsRUFDMUUsUUFBUTtBQUFBLElBQ0o7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLEVBQ0o7QUFBQSxFQUNBLFVBQVU7QUFBQSxJQUNOO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxFQUNKO0FBQUEsRUFDQSxXQUFXLENBQUMsYUFBYSxTQUFTLFVBQVUsV0FBVyxTQUFTLE1BQU07QUFBQSxFQUN0RSxTQUFTLENBQUMsV0FBVyxhQUFhLGFBQWEsWUFBWSxlQUFlO0FBQzlFO0FBS0EsSUFBTSxrQkFBNEM7QUFBQSxFQUM5QyxVQUFVO0FBQUEsSUFDTjtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLEVBQ0o7QUFBQSxFQUNBLFVBQVU7QUFBQSxJQUNOO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxFQUNKO0FBQUEsRUFDQSxTQUFTO0FBQUEsSUFDTDtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLEVBQ0o7QUFBQSxFQUNBLFVBQVU7QUFBQSxJQUNOO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLEVBQ0o7QUFBQSxFQUNBLFFBQVE7QUFBQSxJQUNKO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElB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QkFBcUIsT0FBTyxhQUN0QixPQUFPLFNBQVMsT0FBTyxVQUFVLElBQ2pDO0FBQUEsSUFDTixXQUFXLE9BQU87QUFBQSxFQUN0QjtBQUFBLEVBR0EsT0FBTyxFQUFFLE9BQU8sV0FBVyxZQUFZLE1BQU0sQ0FBQyxFQUFFO0FBQUE7QUFNcEQsZUFBZSxRQUFRLENBQUMsTUFBK0I7QUFBQSxFQUNuRCxRQUFRLFVBQVUsZ0JBQWdCLElBQUk7QUFBQSxFQUd0QyxJQUFJLE1BQU0sTUFBTTtBQUFBLElBQ1osUUFBUSxJQUFJLGVBQWU7QUFBQSxJQUMzQjtBQUFBLEVBQ0o7QUFBQSxFQUdBLE1BQU0sSUFBSSxLQUFLO0FBQUEsSUFDWCxPQUFPLE1BQU0sYUFBYTtBQUFBLElBQzFCLE9BQU8sTUFBTSxZQUFZO0FBQUEsSUFDekIsUUFBUTtBQUFBLEVBQ1osQ0FBQztBQUFBLEVBRUQsSUFBSSxRQUFRLEtBQUsseUJBQXlCO0FBQUEsSUFDdEMsT0FBTyxLQUFLLFVBQVUsS0FBSztBQUFBLEVBQy9CLENBQUM7QUFBQSxFQUdELE1BQU0sU0FBUyxNQUFNLFdBQVcsS0FBSztBQUFBLEVBR3JDLElBQUksTUFBTSxLQUFLO0FBQUEsSUFDWCxHQUFHLEtBQUssK0NBQStDO0FBQUEsSUFDdkQsR0FBRyxLQUFLLG1EQUFtRDtBQUFBLEVBQy9EO0FBQUEsRUFDQSxNQUFNLE9BQU8sUUFBUSxLQUFLO0FBQUE7QUFHOUIsZUFBZSxJQUFJLEdBQUc7QUFBQSxFQUNsQixJQUFJO0FBQUEsSUFFQSxNQUFNLFVBQVUsUUFBUSxLQUFLLE1BQU0sQ0FBQztBQUFBLElBR3BDLElBQ0ksUUFBUSxXQUFXLEtBQ25CLFFBQVEsT0FBTyxZQUNmLFFBQVEsT0FBTyxNQUNqQjtBQUFBLE1BQ0UsUUFBUSxJQUFJLGFBQWE7QUFBQSxNQUN6QixRQUFRLEtBQUssQ0FBQztBQUFBLElBQ2xCO0FBQUEsSUFFQSxNQUFNLGFBQWEsUUFBUTtBQUFBLElBQzNCLE1BQU0saUJBQWlCLFFBQVEsTUFBTSxDQUFDO0FBQUEsSUFHdEMsUUFBUTtBQUFBLFdBQ0M7QUFBQSxRQUNELE1BQU0sUUFBUSxjQUFjO0FBQUEsUUFDNUI7QUFBQSxXQUVDO0FBQUEsV0FDQTtBQUFBLFFBQ0QsTUFBTSxXQUFXLGNBQWM7QUFBQSxRQUMvQjtBQUFBLFdBRUM7QUFBQSxXQUNBO0FBQUEsUUFDRCxNQUFNLFNBQVMsY0FBYztBQUFBLFFBQzdCO0FBQUEsV0FFQztBQUFBLFdBQ0E7QUFBQSxRQUNELFFBQVEsSUFBSSxhQUFhO0FBQUEsUUFDekI7QUFBQTtBQUFBLFFBS0EsTUFBTSxTQUFTLE9BQU87QUFBQSxRQUN0QjtBQUFBO0FBQUEsSUFFVixPQUFPLE9BQU87QUFBQSxJQUNaLEdBQUcsTUFBTSxpQkFBaUIsUUFBUSxNQUFNLFVBQVUsT0FBTyxLQUFLLENBQUM7QUFBQSxJQUMvRCxRQUFRLEtBQUssQ0FBQztBQUFBO0FBQUE7IiwKICAiZGVidWdJZCI6ICJEODRGM0REOEIxMzRFRjRENjQ3NTZFMjE2NDc1NkUyMSIsCiAgIm5hbWVzIjogW10KfQ==

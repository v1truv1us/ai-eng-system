#!/usr/bin/env node
import { createRequire } from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// node_modules/yaml/dist/nodes/identity.js
var require_identity = __commonJS((exports) => {
  var ALIAS = Symbol.for("yaml.alias");
  var DOC = Symbol.for("yaml.document");
  var MAP = Symbol.for("yaml.map");
  var PAIR = Symbol.for("yaml.pair");
  var SCALAR = Symbol.for("yaml.scalar");
  var SEQ = Symbol.for("yaml.seq");
  var NODE_TYPE = Symbol.for("yaml.node.type");
  var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
  var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
  var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
  var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
  var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
  var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
  function isCollection(node) {
    if (node && typeof node === "object")
      switch (node[NODE_TYPE]) {
        case MAP:
        case SEQ:
          return true;
      }
    return false;
  }
  function isNode(node) {
    if (node && typeof node === "object")
      switch (node[NODE_TYPE]) {
        case ALIAS:
        case MAP:
        case SCALAR:
        case SEQ:
          return true;
      }
    return false;
  }
  var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
  exports.ALIAS = ALIAS;
  exports.DOC = DOC;
  exports.MAP = MAP;
  exports.NODE_TYPE = NODE_TYPE;
  exports.PAIR = PAIR;
  exports.SCALAR = SCALAR;
  exports.SEQ = SEQ;
  exports.hasAnchor = hasAnchor;
  exports.isAlias = isAlias;
  exports.isCollection = isCollection;
  exports.isDocument = isDocument;
  exports.isMap = isMap;
  exports.isNode = isNode;
  exports.isPair = isPair;
  exports.isScalar = isScalar;
  exports.isSeq = isSeq;
});

// node_modules/yaml/dist/visit.js
var require_visit = __commonJS((exports) => {
  var identity = require_identity();
  var BREAK = Symbol("break visit");
  var SKIP = Symbol("skip children");
  var REMOVE = Symbol("remove node");
  function visit(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (identity.isDocument(node)) {
      const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
      if (cd === REMOVE)
        node.contents = null;
    } else
      visit_(null, node, visitor_, Object.freeze([]));
  }
  visit.BREAK = BREAK;
  visit.SKIP = SKIP;
  visit.REMOVE = REMOVE;
  function visit_(key, node, visitor, path) {
    const ctrl = callVisitor(key, node, visitor, path);
    if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
      replaceNode(key, path, ctrl);
      return visit_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== "symbol") {
      if (identity.isCollection(node)) {
        path = Object.freeze(path.concat(node));
        for (let i = 0;i < node.items.length; ++i) {
          const ci = visit_(i, node.items[i], visitor, path);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            node.items.splice(i, 1);
            i -= 1;
          }
        }
      } else if (identity.isPair(node)) {
        path = Object.freeze(path.concat(node));
        const ck = visit_("key", node.key, visitor, path);
        if (ck === BREAK)
          return BREAK;
        else if (ck === REMOVE)
          node.key = null;
        const cv = visit_("value", node.value, visitor, path);
        if (cv === BREAK)
          return BREAK;
        else if (cv === REMOVE)
          node.value = null;
      }
    }
    return ctrl;
  }
  async function visitAsync(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (identity.isDocument(node)) {
      const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
      if (cd === REMOVE)
        node.contents = null;
    } else
      await visitAsync_(null, node, visitor_, Object.freeze([]));
  }
  visitAsync.BREAK = BREAK;
  visitAsync.SKIP = SKIP;
  visitAsync.REMOVE = REMOVE;
  async function visitAsync_(key, node, visitor, path) {
    const ctrl = await callVisitor(key, node, visitor, path);
    if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
      replaceNode(key, path, ctrl);
      return visitAsync_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== "symbol") {
      if (identity.isCollection(node)) {
        path = Object.freeze(path.concat(node));
        for (let i = 0;i < node.items.length; ++i) {
          const ci = await visitAsync_(i, node.items[i], visitor, path);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            node.items.splice(i, 1);
            i -= 1;
          }
        }
      } else if (identity.isPair(node)) {
        path = Object.freeze(path.concat(node));
        const ck = await visitAsync_("key", node.key, visitor, path);
        if (ck === BREAK)
          return BREAK;
        else if (ck === REMOVE)
          node.key = null;
        const cv = await visitAsync_("value", node.value, visitor, path);
        if (cv === BREAK)
          return BREAK;
        else if (cv === REMOVE)
          node.value = null;
      }
    }
    return ctrl;
  }
  function initVisitor(visitor) {
    if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
      return Object.assign({
        Alias: visitor.Node,
        Map: visitor.Node,
        Scalar: visitor.Node,
        Seq: visitor.Node
      }, visitor.Value && {
        Map: visitor.Value,
        Scalar: visitor.Value,
        Seq: visitor.Value
      }, visitor.Collection && {
        Map: visitor.Collection,
        Seq: visitor.Collection
      }, visitor);
    }
    return visitor;
  }
  function callVisitor(key, node, visitor, path) {
    if (typeof visitor === "function")
      return visitor(key, node, path);
    if (identity.isMap(node))
      return visitor.Map?.(key, node, path);
    if (identity.isSeq(node))
      return visitor.Seq?.(key, node, path);
    if (identity.isPair(node))
      return visitor.Pair?.(key, node, path);
    if (identity.isScalar(node))
      return visitor.Scalar?.(key, node, path);
    if (identity.isAlias(node))
      return visitor.Alias?.(key, node, path);
    return;
  }
  function replaceNode(key, path, node) {
    const parent = path[path.length - 1];
    if (identity.isCollection(parent)) {
      parent.items[key] = node;
    } else if (identity.isPair(parent)) {
      if (key === "key")
        parent.key = node;
      else
        parent.value = node;
    } else if (identity.isDocument(parent)) {
      parent.contents = node;
    } else {
      const pt = identity.isAlias(parent) ? "alias" : "scalar";
      throw new Error(`Cannot replace node with ${pt} parent`);
    }
  }
  exports.visit = visit;
  exports.visitAsync = visitAsync;
});

// node_modules/yaml/dist/doc/directives.js
var require_directives = __commonJS((exports) => {
  var identity = require_identity();
  var visit = require_visit();
  var escapeChars = {
    "!": "%21",
    ",": "%2C",
    "[": "%5B",
    "]": "%5D",
    "{": "%7B",
    "}": "%7D"
  };
  var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);

  class Directives {
    constructor(yaml, tags) {
      this.docStart = null;
      this.docEnd = false;
      this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
      this.tags = Object.assign({}, Directives.defaultTags, tags);
    }
    clone() {
      const copy = new Directives(this.yaml, this.tags);
      copy.docStart = this.docStart;
      return copy;
    }
    atDocument() {
      const res = new Directives(this.yaml, this.tags);
      switch (this.yaml.version) {
        case "1.1":
          this.atNextDocument = true;
          break;
        case "1.2":
          this.atNextDocument = false;
          this.yaml = {
            explicit: Directives.defaultYaml.explicit,
            version: "1.2"
          };
          this.tags = Object.assign({}, Directives.defaultTags);
          break;
      }
      return res;
    }
    add(line, onError) {
      if (this.atNextDocument) {
        this.yaml = { explicit: Directives.defaultYaml.explicit, version: "1.1" };
        this.tags = Object.assign({}, Directives.defaultTags);
        this.atNextDocument = false;
      }
      const parts = line.trim().split(/[ \t]+/);
      const name = parts.shift();
      switch (name) {
        case "%TAG": {
          if (parts.length !== 2) {
            onError(0, "%TAG directive should contain exactly two parts");
            if (parts.length < 2)
              return false;
          }
          const [handle, prefix] = parts;
          this.tags[handle] = prefix;
          return true;
        }
        case "%YAML": {
          this.yaml.explicit = true;
          if (parts.length !== 1) {
            onError(0, "%YAML directive should contain exactly one part");
            return false;
          }
          const [version] = parts;
          if (version === "1.1" || version === "1.2") {
            this.yaml.version = version;
            return true;
          } else {
            const isValid = /^\d+\.\d+$/.test(version);
            onError(6, `Unsupported YAML version ${version}`, isValid);
            return false;
          }
        }
        default:
          onError(0, `Unknown directive ${name}`, true);
          return false;
      }
    }
    tagName(source, onError) {
      if (source === "!")
        return "!";
      if (source[0] !== "!") {
        onError(`Not a valid tag: ${source}`);
        return null;
      }
      if (source[1] === "<") {
        const verbatim = source.slice(2, -1);
        if (verbatim === "!" || verbatim === "!!") {
          onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
          return null;
        }
        if (source[source.length - 1] !== ">")
          onError("Verbatim tags must end with a >");
        return verbatim;
      }
      const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
      if (!suffix)
        onError(`The ${source} tag has no suffix`);
      const prefix = this.tags[handle];
      if (prefix) {
        try {
          return prefix + decodeURIComponent(suffix);
        } catch (error) {
          onError(String(error));
          return null;
        }
      }
      if (handle === "!")
        return source;
      onError(`Could not resolve tag: ${source}`);
      return null;
    }
    tagString(tag) {
      for (const [handle, prefix] of Object.entries(this.tags)) {
        if (tag.startsWith(prefix))
          return handle + escapeTagName(tag.substring(prefix.length));
      }
      return tag[0] === "!" ? tag : `!<${tag}>`;
    }
    toString(doc) {
      const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
      const tagEntries = Object.entries(this.tags);
      let tagNames;
      if (doc && tagEntries.length > 0 && identity.isNode(doc.contents)) {
        const tags = {};
        visit.visit(doc.contents, (_key, node) => {
          if (identity.isNode(node) && node.tag)
            tags[node.tag] = true;
        });
        tagNames = Object.keys(tags);
      } else
        tagNames = [];
      for (const [handle, prefix] of tagEntries) {
        if (handle === "!!" && prefix === "tag:yaml.org,2002:")
          continue;
        if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
          lines.push(`%TAG ${handle} ${prefix}`);
      }
      return lines.join(`
`);
    }
  }
  Directives.defaultYaml = { explicit: false, version: "1.2" };
  Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
  exports.Directives = Directives;
});

// node_modules/yaml/dist/doc/anchors.js
var require_anchors = __commonJS((exports) => {
  var identity = require_identity();
  var visit = require_visit();
  function anchorIsValid(anchor) {
    if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
      const sa = JSON.stringify(anchor);
      const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
      throw new Error(msg);
    }
    return true;
  }
  function anchorNames(root) {
    const anchors = new Set;
    visit.visit(root, {
      Value(_key, node) {
        if (node.anchor)
          anchors.add(node.anchor);
      }
    });
    return anchors;
  }
  function findNewAnchor(prefix, exclude) {
    for (let i = 1;; ++i) {
      const name = `${prefix}${i}`;
      if (!exclude.has(name))
        return name;
    }
  }
  function createNodeAnchors(doc, prefix) {
    const aliasObjects = [];
    const sourceObjects = new Map;
    let prevAnchors = null;
    return {
      onAnchor: (source) => {
        aliasObjects.push(source);
        prevAnchors ?? (prevAnchors = anchorNames(doc));
        const anchor = findNewAnchor(prefix, prevAnchors);
        prevAnchors.add(anchor);
        return anchor;
      },
      setAnchors: () => {
        for (const source of aliasObjects) {
          const ref = sourceObjects.get(source);
          if (typeof ref === "object" && ref.anchor && (identity.isScalar(ref.node) || identity.isCollection(ref.node))) {
            ref.node.anchor = ref.anchor;
          } else {
            const error = new Error("Failed to resolve repeated object (this should not happen)");
            error.source = source;
            throw error;
          }
        }
      },
      sourceObjects
    };
  }
  exports.anchorIsValid = anchorIsValid;
  exports.anchorNames = anchorNames;
  exports.createNodeAnchors = createNodeAnchors;
  exports.findNewAnchor = findNewAnchor;
});

// node_modules/yaml/dist/doc/applyReviver.js
var require_applyReviver = __commonJS((exports) => {
  function applyReviver(reviver, obj, key, val) {
    if (val && typeof val === "object") {
      if (Array.isArray(val)) {
        for (let i = 0, len = val.length;i < len; ++i) {
          const v0 = val[i];
          const v1 = applyReviver(reviver, val, String(i), v0);
          if (v1 === undefined)
            delete val[i];
          else if (v1 !== v0)
            val[i] = v1;
        }
      } else if (val instanceof Map) {
        for (const k of Array.from(val.keys())) {
          const v0 = val.get(k);
          const v1 = applyReviver(reviver, val, k, v0);
          if (v1 === undefined)
            val.delete(k);
          else if (v1 !== v0)
            val.set(k, v1);
        }
      } else if (val instanceof Set) {
        for (const v0 of Array.from(val)) {
          const v1 = applyReviver(reviver, val, v0, v0);
          if (v1 === undefined)
            val.delete(v0);
          else if (v1 !== v0) {
            val.delete(v0);
            val.add(v1);
          }
        }
      } else {
        for (const [k, v0] of Object.entries(val)) {
          const v1 = applyReviver(reviver, val, k, v0);
          if (v1 === undefined)
            delete val[k];
          else if (v1 !== v0)
            val[k] = v1;
        }
      }
    }
    return reviver.call(obj, key, val);
  }
  exports.applyReviver = applyReviver;
});

// node_modules/yaml/dist/nodes/toJS.js
var require_toJS = __commonJS((exports) => {
  var identity = require_identity();
  function toJS(value, arg, ctx) {
    if (Array.isArray(value))
      return value.map((v, i) => toJS(v, String(i), ctx));
    if (value && typeof value.toJSON === "function") {
      if (!ctx || !identity.hasAnchor(value))
        return value.toJSON(arg, ctx);
      const data = { aliasCount: 0, count: 1, res: undefined };
      ctx.anchors.set(value, data);
      ctx.onCreate = (res2) => {
        data.res = res2;
        delete ctx.onCreate;
      };
      const res = value.toJSON(arg, ctx);
      if (ctx.onCreate)
        ctx.onCreate(res);
      return res;
    }
    if (typeof value === "bigint" && !ctx?.keep)
      return Number(value);
    return value;
  }
  exports.toJS = toJS;
});

// node_modules/yaml/dist/nodes/Node.js
var require_Node = __commonJS((exports) => {
  var applyReviver = require_applyReviver();
  var identity = require_identity();
  var toJS = require_toJS();

  class NodeBase {
    constructor(type) {
      Object.defineProperty(this, identity.NODE_TYPE, { value: type });
    }
    clone() {
      const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
      if (this.range)
        copy.range = this.range.slice();
      return copy;
    }
    toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
      if (!identity.isDocument(doc))
        throw new TypeError("A document argument is required");
      const ctx = {
        anchors: new Map,
        doc,
        keep: true,
        mapAsMap: mapAsMap === true,
        mapKeyWarned: false,
        maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
      };
      const res = toJS.toJS(this, "", ctx);
      if (typeof onAnchor === "function")
        for (const { count, res: res2 } of ctx.anchors.values())
          onAnchor(res2, count);
      return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
    }
  }
  exports.NodeBase = NodeBase;
});

// node_modules/yaml/dist/nodes/Alias.js
var require_Alias = __commonJS((exports) => {
  var anchors = require_anchors();
  var visit = require_visit();
  var identity = require_identity();
  var Node = require_Node();
  var toJS = require_toJS();

  class Alias extends Node.NodeBase {
    constructor(source) {
      super(identity.ALIAS);
      this.source = source;
      Object.defineProperty(this, "tag", {
        set() {
          throw new Error("Alias nodes cannot have tags");
        }
      });
    }
    resolve(doc, ctx) {
      let nodes;
      if (ctx?.aliasResolveCache) {
        nodes = ctx.aliasResolveCache;
      } else {
        nodes = [];
        visit.visit(doc, {
          Node: (_key, node) => {
            if (identity.isAlias(node) || identity.hasAnchor(node))
              nodes.push(node);
          }
        });
        if (ctx)
          ctx.aliasResolveCache = nodes;
      }
      let found = undefined;
      for (const node of nodes) {
        if (node === this)
          break;
        if (node.anchor === this.source)
          found = node;
      }
      return found;
    }
    toJSON(_arg, ctx) {
      if (!ctx)
        return { source: this.source };
      const { anchors: anchors2, doc, maxAliasCount } = ctx;
      const source = this.resolve(doc, ctx);
      if (!source) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new ReferenceError(msg);
      }
      let data = anchors2.get(source);
      if (!data) {
        toJS.toJS(source, null, ctx);
        data = anchors2.get(source);
      }
      if (data?.res === undefined) {
        const msg = "This should not happen: Alias anchor was not resolved?";
        throw new ReferenceError(msg);
      }
      if (maxAliasCount >= 0) {
        data.count += 1;
        if (data.aliasCount === 0)
          data.aliasCount = getAliasCount(doc, source, anchors2);
        if (data.count * data.aliasCount > maxAliasCount) {
          const msg = "Excessive alias count indicates a resource exhaustion attack";
          throw new ReferenceError(msg);
        }
      }
      return data.res;
    }
    toString(ctx, _onComment, _onChompKeep) {
      const src = `*${this.source}`;
      if (ctx) {
        anchors.anchorIsValid(this.source);
        if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new Error(msg);
        }
        if (ctx.implicitKey)
          return `${src} `;
      }
      return src;
    }
  }
  function getAliasCount(doc, node, anchors2) {
    if (identity.isAlias(node)) {
      const source = node.resolve(doc);
      const anchor = anchors2 && source && anchors2.get(source);
      return anchor ? anchor.count * anchor.aliasCount : 0;
    } else if (identity.isCollection(node)) {
      let count = 0;
      for (const item of node.items) {
        const c = getAliasCount(doc, item, anchors2);
        if (c > count)
          count = c;
      }
      return count;
    } else if (identity.isPair(node)) {
      const kc = getAliasCount(doc, node.key, anchors2);
      const vc = getAliasCount(doc, node.value, anchors2);
      return Math.max(kc, vc);
    }
    return 1;
  }
  exports.Alias = Alias;
});

// node_modules/yaml/dist/nodes/Scalar.js
var require_Scalar = __commonJS((exports) => {
  var identity = require_identity();
  var Node = require_Node();
  var toJS = require_toJS();
  var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";

  class Scalar extends Node.NodeBase {
    constructor(value) {
      super(identity.SCALAR);
      this.value = value;
    }
    toJSON(arg, ctx) {
      return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
    }
    toString() {
      return String(this.value);
    }
  }
  Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
  Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
  Scalar.PLAIN = "PLAIN";
  Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
  Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
  exports.Scalar = Scalar;
  exports.isScalarValue = isScalarValue;
});

// node_modules/yaml/dist/doc/createNode.js
var require_createNode = __commonJS((exports) => {
  var Alias = require_Alias();
  var identity = require_identity();
  var Scalar = require_Scalar();
  var defaultTagPrefix = "tag:yaml.org,2002:";
  function findTagObject(value, tagName, tags) {
    if (tagName) {
      const match = tags.filter((t) => t.tag === tagName);
      const tagObj = match.find((t) => !t.format) ?? match[0];
      if (!tagObj)
        throw new Error(`Tag ${tagName} not found`);
      return tagObj;
    }
    return tags.find((t) => t.identify?.(value) && !t.format);
  }
  function createNode(value, tagName, ctx) {
    if (identity.isDocument(value))
      value = value.contents;
    if (identity.isNode(value))
      return value;
    if (identity.isPair(value)) {
      const map = ctx.schema[identity.MAP].createNode?.(ctx.schema, null, ctx);
      map.items.push(value);
      return map;
    }
    if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
      value = value.valueOf();
    }
    const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
    let ref = undefined;
    if (aliasDuplicateObjects && value && typeof value === "object") {
      ref = sourceObjects.get(value);
      if (ref) {
        ref.anchor ?? (ref.anchor = onAnchor(value));
        return new Alias.Alias(ref.anchor);
      } else {
        ref = { anchor: null, node: null };
        sourceObjects.set(value, ref);
      }
    }
    if (tagName?.startsWith("!!"))
      tagName = defaultTagPrefix + tagName.slice(2);
    let tagObj = findTagObject(value, tagName, schema.tags);
    if (!tagObj) {
      if (value && typeof value.toJSON === "function") {
        value = value.toJSON();
      }
      if (!value || typeof value !== "object") {
        const node2 = new Scalar.Scalar(value);
        if (ref)
          ref.node = node2;
        return node2;
      }
      tagObj = value instanceof Map ? schema[identity.MAP] : (Symbol.iterator in Object(value)) ? schema[identity.SEQ] : schema[identity.MAP];
    }
    if (onTagObj) {
      onTagObj(tagObj);
      delete ctx.onTagObj;
    }
    const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar.Scalar(value);
    if (tagName)
      node.tag = tagName;
    else if (!tagObj.default)
      node.tag = tagObj.tag;
    if (ref)
      ref.node = node;
    return node;
  }
  exports.createNode = createNode;
});

// node_modules/yaml/dist/nodes/Collection.js
var require_Collection = __commonJS((exports) => {
  var createNode = require_createNode();
  var identity = require_identity();
  var Node = require_Node();
  function collectionFromPath(schema, path, value) {
    let v = value;
    for (let i = path.length - 1;i >= 0; --i) {
      const k = path[i];
      if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
        const a = [];
        a[k] = v;
        v = a;
      } else {
        v = new Map([[k, v]]);
      }
    }
    return createNode.createNode(v, undefined, {
      aliasDuplicateObjects: false,
      keepUndefined: false,
      onAnchor: () => {
        throw new Error("This should not happen, please report a bug.");
      },
      schema,
      sourceObjects: new Map
    });
  }
  var isEmptyPath = (path) => path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;

  class Collection extends Node.NodeBase {
    constructor(type, schema) {
      super(type);
      Object.defineProperty(this, "schema", {
        value: schema,
        configurable: true,
        enumerable: false,
        writable: true
      });
    }
    clone(schema) {
      const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
      if (schema)
        copy.schema = schema;
      copy.items = copy.items.map((it) => identity.isNode(it) || identity.isPair(it) ? it.clone(schema) : it);
      if (this.range)
        copy.range = this.range.slice();
      return copy;
    }
    addIn(path, value) {
      if (isEmptyPath(path))
        this.add(value);
      else {
        const [key, ...rest] = path;
        const node = this.get(key, true);
        if (identity.isCollection(node))
          node.addIn(rest, value);
        else if (node === undefined && this.schema)
          this.set(key, collectionFromPath(this.schema, rest, value));
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
    }
    deleteIn(path) {
      const [key, ...rest] = path;
      if (rest.length === 0)
        return this.delete(key);
      const node = this.get(key, true);
      if (identity.isCollection(node))
        return node.deleteIn(rest);
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
    getIn(path, keepScalar) {
      const [key, ...rest] = path;
      const node = this.get(key, true);
      if (rest.length === 0)
        return !keepScalar && identity.isScalar(node) ? node.value : node;
      else
        return identity.isCollection(node) ? node.getIn(rest, keepScalar) : undefined;
    }
    hasAllNullValues(allowScalar) {
      return this.items.every((node) => {
        if (!identity.isPair(node))
          return false;
        const n = node.value;
        return n == null || allowScalar && identity.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
      });
    }
    hasIn(path) {
      const [key, ...rest] = path;
      if (rest.length === 0)
        return this.has(key);
      const node = this.get(key, true);
      return identity.isCollection(node) ? node.hasIn(rest) : false;
    }
    setIn(path, value) {
      const [key, ...rest] = path;
      if (rest.length === 0) {
        this.set(key, value);
      } else {
        const node = this.get(key, true);
        if (identity.isCollection(node))
          node.setIn(rest, value);
        else if (node === undefined && this.schema)
          this.set(key, collectionFromPath(this.schema, rest, value));
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
    }
  }
  exports.Collection = Collection;
  exports.collectionFromPath = collectionFromPath;
  exports.isEmptyPath = isEmptyPath;
});

// node_modules/yaml/dist/stringify/stringifyComment.js
var require_stringifyComment = __commonJS((exports) => {
  var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
  function indentComment(comment, indent) {
    if (/^\n+$/.test(comment))
      return comment.substring(1);
    return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
  }
  var lineComment = (str, indent, comment) => str.endsWith(`
`) ? indentComment(comment, indent) : comment.includes(`
`) ? `
` + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;
  exports.indentComment = indentComment;
  exports.lineComment = lineComment;
  exports.stringifyComment = stringifyComment;
});

// node_modules/yaml/dist/stringify/foldFlowLines.js
var require_foldFlowLines = __commonJS((exports) => {
  var FOLD_FLOW = "flow";
  var FOLD_BLOCK = "block";
  var FOLD_QUOTED = "quoted";
  function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
    if (!lineWidth || lineWidth < 0)
      return text;
    if (lineWidth < minContentWidth)
      minContentWidth = 0;
    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
    if (text.length <= endStep)
      return text;
    const folds = [];
    const escapedFolds = {};
    let end = lineWidth - indent.length;
    if (typeof indentAtStart === "number") {
      if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
        folds.push(0);
      else
        end = lineWidth - indentAtStart;
    }
    let split = undefined;
    let prev = undefined;
    let overflow = false;
    let i = -1;
    let escStart = -1;
    let escEnd = -1;
    if (mode === FOLD_BLOCK) {
      i = consumeMoreIndentedLines(text, i, indent.length);
      if (i !== -1)
        end = i + endStep;
    }
    for (let ch;ch = text[i += 1]; ) {
      if (mode === FOLD_QUOTED && ch === "\\") {
        escStart = i;
        switch (text[i + 1]) {
          case "x":
            i += 3;
            break;
          case "u":
            i += 5;
            break;
          case "U":
            i += 9;
            break;
          default:
            i += 1;
        }
        escEnd = i;
      }
      if (ch === `
`) {
        if (mode === FOLD_BLOCK)
          i = consumeMoreIndentedLines(text, i, indent.length);
        end = i + indent.length + endStep;
        split = undefined;
      } else {
        if (ch === " " && prev && prev !== " " && prev !== `
` && prev !== "\t") {
          const next = text[i + 1];
          if (next && next !== " " && next !== `
` && next !== "\t")
            split = i;
        }
        if (i >= end) {
          if (split) {
            folds.push(split);
            end = split + endStep;
            split = undefined;
          } else if (mode === FOLD_QUOTED) {
            while (prev === " " || prev === "\t") {
              prev = ch;
              ch = text[i += 1];
              overflow = true;
            }
            const j = i > escEnd + 1 ? i - 2 : escStart - 1;
            if (escapedFolds[j])
              return text;
            folds.push(j);
            escapedFolds[j] = true;
            end = j + endStep;
            split = undefined;
          } else {
            overflow = true;
          }
        }
      }
      prev = ch;
    }
    if (overflow && onOverflow)
      onOverflow();
    if (folds.length === 0)
      return text;
    if (onFold)
      onFold();
    let res = text.slice(0, folds[0]);
    for (let i2 = 0;i2 < folds.length; ++i2) {
      const fold = folds[i2];
      const end2 = folds[i2 + 1] || text.length;
      if (fold === 0)
        res = `
${indent}${text.slice(0, end2)}`;
      else {
        if (mode === FOLD_QUOTED && escapedFolds[fold])
          res += `${text[fold]}\\`;
        res += `
${indent}${text.slice(fold + 1, end2)}`;
      }
    }
    return res;
  }
  function consumeMoreIndentedLines(text, i, indent) {
    let end = i;
    let start = i + 1;
    let ch = text[start];
    while (ch === " " || ch === "\t") {
      if (i < start + indent) {
        ch = text[++i];
      } else {
        do {
          ch = text[++i];
        } while (ch && ch !== `
`);
        end = i;
        start = i + 1;
        ch = text[start];
      }
    }
    return end;
  }
  exports.FOLD_BLOCK = FOLD_BLOCK;
  exports.FOLD_FLOW = FOLD_FLOW;
  exports.FOLD_QUOTED = FOLD_QUOTED;
  exports.foldFlowLines = foldFlowLines;
});

// node_modules/yaml/dist/stringify/stringifyString.js
var require_stringifyString = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var foldFlowLines = require_foldFlowLines();
  var getFoldOptions = (ctx, isBlock) => ({
    indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
    lineWidth: ctx.options.lineWidth,
    minContentWidth: ctx.options.minContentWidth
  });
  var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
  function lineLengthOverLimit(str, lineWidth, indentLength) {
    if (!lineWidth || lineWidth < 0)
      return false;
    const limit = lineWidth - indentLength;
    const strLen = str.length;
    if (strLen <= limit)
      return false;
    for (let i = 0, start = 0;i < strLen; ++i) {
      if (str[i] === `
`) {
        if (i - start > limit)
          return true;
        start = i + 1;
        if (strLen - start <= limit)
          return false;
      }
    }
    return true;
  }
  function doubleQuotedString(value, ctx) {
    const json = JSON.stringify(value);
    if (ctx.options.doubleQuotedAsJSON)
      return json;
    const { implicitKey } = ctx;
    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
    const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
    let str = "";
    let start = 0;
    for (let i = 0, ch = json[i];ch; ch = json[++i]) {
      if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
        str += json.slice(start, i) + "\\ ";
        i += 1;
        start = i;
        ch = "\\";
      }
      if (ch === "\\")
        switch (json[i + 1]) {
          case "u":
            {
              str += json.slice(start, i);
              const code = json.substr(i + 2, 4);
              switch (code) {
                case "0000":
                  str += "\\0";
                  break;
                case "0007":
                  str += "\\a";
                  break;
                case "000b":
                  str += "\\v";
                  break;
                case "001b":
                  str += "\\e";
                  break;
                case "0085":
                  str += "\\N";
                  break;
                case "00a0":
                  str += "\\_";
                  break;
                case "2028":
                  str += "\\L";
                  break;
                case "2029":
                  str += "\\P";
                  break;
                default:
                  if (code.substr(0, 2) === "00")
                    str += "\\x" + code.substr(2);
                  else
                    str += json.substr(i, 6);
              }
              i += 5;
              start = i + 1;
            }
            break;
          case "n":
            if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
              i += 1;
            } else {
              str += json.slice(start, i) + `

`;
              while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
                str += `
`;
                i += 2;
              }
              str += indent;
              if (json[i + 2] === " ")
                str += "\\";
              i += 1;
              start = i + 1;
            }
            break;
          default:
            i += 1;
        }
    }
    str = start ? str + json.slice(start) : json;
    return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));
  }
  function singleQuotedString(value, ctx) {
    if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes(`
`) || /[ \t]\n|\n[ \t]/.test(value))
      return doubleQuotedString(value, ctx);
    const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
    const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
    return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
  }
  function quotedString(value, ctx) {
    const { singleQuote } = ctx.options;
    let qs;
    if (singleQuote === false)
      qs = doubleQuotedString;
    else {
      const hasDouble = value.includes('"');
      const hasSingle = value.includes("'");
      if (hasDouble && !hasSingle)
        qs = singleQuotedString;
      else if (hasSingle && !hasDouble)
        qs = doubleQuotedString;
      else
        qs = singleQuote ? singleQuotedString : doubleQuotedString;
    }
    return qs(value, ctx);
  }
  var blockEndNewlines;
  try {
    blockEndNewlines = new RegExp(`(^|(?<!
))
+(?!
|$)`, "g");
  } catch {
    blockEndNewlines = /\n+(?!\n|$)/g;
  }
  function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
    const { blockQuote, commentString, lineWidth } = ctx.options;
    if (!blockQuote || /\n[\t ]+$/.test(value)) {
      return quotedString(value, ctx);
    }
    const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
    const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.Scalar.BLOCK_FOLDED ? false : type === Scalar.Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
    if (!value)
      return literal ? `|
` : `>
`;
    let chomp;
    let endStart;
    for (endStart = value.length;endStart > 0; --endStart) {
      const ch = value[endStart - 1];
      if (ch !== `
` && ch !== "\t" && ch !== " ")
        break;
    }
    let end = value.substring(endStart);
    const endNlPos = end.indexOf(`
`);
    if (endNlPos === -1) {
      chomp = "-";
    } else if (value === end || endNlPos !== end.length - 1) {
      chomp = "+";
      if (onChompKeep)
        onChompKeep();
    } else {
      chomp = "";
    }
    if (end) {
      value = value.slice(0, -end.length);
      if (end[end.length - 1] === `
`)
        end = end.slice(0, -1);
      end = end.replace(blockEndNewlines, `$&${indent}`);
    }
    let startWithSpace = false;
    let startEnd;
    let startNlPos = -1;
    for (startEnd = 0;startEnd < value.length; ++startEnd) {
      const ch = value[startEnd];
      if (ch === " ")
        startWithSpace = true;
      else if (ch === `
`)
        startNlPos = startEnd;
      else
        break;
    }
    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
    if (start) {
      value = value.substring(start.length);
      start = start.replace(/\n+/g, `$&${indent}`);
    }
    const indentSize = indent ? "2" : "1";
    let header = (startWithSpace ? indentSize : "") + chomp;
    if (comment) {
      header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
      if (onComment)
        onComment();
    }
    if (!literal) {
      const foldedValue = value.replace(/\n+/g, `
$&`).replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
      let literalFallback = false;
      const foldOptions = getFoldOptions(ctx, true);
      if (blockQuote !== "folded" && type !== Scalar.Scalar.BLOCK_FOLDED) {
        foldOptions.onOverflow = () => {
          literalFallback = true;
        };
      }
      const body = foldFlowLines.foldFlowLines(`${start}${foldedValue}${end}`, indent, foldFlowLines.FOLD_BLOCK, foldOptions);
      if (!literalFallback)
        return `>${header}
${indent}${body}`;
    }
    value = value.replace(/\n+/g, `$&${indent}`);
    return `|${header}
${indent}${start}${value}${end}`;
  }
  function plainString(item, ctx, onComment, onChompKeep) {
    const { type, value } = item;
    const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
    if (implicitKey && value.includes(`
`) || inFlow && /[[\]{},]/.test(value)) {
      return quotedString(value, ctx);
    }
    if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
      return implicitKey || inFlow || !value.includes(`
`) ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
    }
    if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value.includes(`
`)) {
      return blockString(item, ctx, onComment, onChompKeep);
    }
    if (containsDocumentMarker(value)) {
      if (indent === "") {
        ctx.forceBlockIndent = true;
        return blockString(item, ctx, onComment, onChompKeep);
      } else if (implicitKey && indent === indentStep) {
        return quotedString(value, ctx);
      }
    }
    const str = value.replace(/\n+/g, `$&
${indent}`);
    if (actualString) {
      const test = (tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str);
      const { compat, tags } = ctx.doc.schema;
      if (tags.some(test) || compat?.some(test))
        return quotedString(value, ctx);
    }
    return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
  }
  function stringifyString(item, ctx, onComment, onChompKeep) {
    const { implicitKey, inFlow } = ctx;
    const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
    let { type } = item;
    if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
      if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
        type = Scalar.Scalar.QUOTE_DOUBLE;
    }
    const _stringify = (_type) => {
      switch (_type) {
        case Scalar.Scalar.BLOCK_FOLDED:
        case Scalar.Scalar.BLOCK_LITERAL:
          return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
        case Scalar.Scalar.QUOTE_DOUBLE:
          return doubleQuotedString(ss.value, ctx);
        case Scalar.Scalar.QUOTE_SINGLE:
          return singleQuotedString(ss.value, ctx);
        case Scalar.Scalar.PLAIN:
          return plainString(ss, ctx, onComment, onChompKeep);
        default:
          return null;
      }
    };
    let res = _stringify(type);
    if (res === null) {
      const { defaultKeyType, defaultStringType } = ctx.options;
      const t = implicitKey && defaultKeyType || defaultStringType;
      res = _stringify(t);
      if (res === null)
        throw new Error(`Unsupported default string type ${t}`);
    }
    return res;
  }
  exports.stringifyString = stringifyString;
});

// node_modules/yaml/dist/stringify/stringify.js
var require_stringify = __commonJS((exports) => {
  var anchors = require_anchors();
  var identity = require_identity();
  var stringifyComment = require_stringifyComment();
  var stringifyString = require_stringifyString();
  function createStringifyContext(doc, options) {
    const opt = Object.assign({
      blockQuote: true,
      commentString: stringifyComment.stringifyComment,
      defaultKeyType: null,
      defaultStringType: "PLAIN",
      directives: null,
      doubleQuotedAsJSON: false,
      doubleQuotedMinMultiLineLength: 40,
      falseStr: "false",
      flowCollectionPadding: true,
      indentSeq: true,
      lineWidth: 80,
      minContentWidth: 20,
      nullStr: "null",
      simpleKeys: false,
      singleQuote: null,
      trueStr: "true",
      verifyAliasOrder: true
    }, doc.schema.toStringOptions, options);
    let inFlow;
    switch (opt.collectionStyle) {
      case "block":
        inFlow = false;
        break;
      case "flow":
        inFlow = true;
        break;
      default:
        inFlow = null;
    }
    return {
      anchors: new Set,
      doc,
      flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
      indent: "",
      indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
      inFlow,
      options: opt
    };
  }
  function getTagObject(tags, item) {
    if (item.tag) {
      const match = tags.filter((t) => t.tag === item.tag);
      if (match.length > 0)
        return match.find((t) => t.format === item.format) ?? match[0];
    }
    let tagObj = undefined;
    let obj;
    if (identity.isScalar(item)) {
      obj = item.value;
      let match = tags.filter((t) => t.identify?.(obj));
      if (match.length > 1) {
        const testMatch = match.filter((t) => t.test);
        if (testMatch.length > 0)
          match = testMatch;
      }
      tagObj = match.find((t) => t.format === item.format) ?? match.find((t) => !t.format);
    } else {
      obj = item;
      tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
    }
    if (!tagObj) {
      const name = obj?.constructor?.name ?? (obj === null ? "null" : typeof obj);
      throw new Error(`Tag not resolved for ${name} value`);
    }
    return tagObj;
  }
  function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
    if (!doc.directives)
      return "";
    const props = [];
    const anchor = (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;
    if (anchor && anchors.anchorIsValid(anchor)) {
      anchors$1.add(anchor);
      props.push(`&${anchor}`);
    }
    const tag = node.tag ?? (tagObj.default ? null : tagObj.tag);
    if (tag)
      props.push(doc.directives.tagString(tag));
    return props.join(" ");
  }
  function stringify(item, ctx, onComment, onChompKeep) {
    if (identity.isPair(item))
      return item.toString(ctx, onComment, onChompKeep);
    if (identity.isAlias(item)) {
      if (ctx.doc.directives)
        return item.toString(ctx);
      if (ctx.resolvedAliases?.has(item)) {
        throw new TypeError(`Cannot stringify circular structure without alias nodes`);
      } else {
        if (ctx.resolvedAliases)
          ctx.resolvedAliases.add(item);
        else
          ctx.resolvedAliases = new Set([item]);
        item = item.resolve(ctx.doc);
      }
    }
    let tagObj = undefined;
    const node = identity.isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
    tagObj ?? (tagObj = getTagObject(ctx.doc.schema.tags, node));
    const props = stringifyProps(node, tagObj, ctx);
    if (props.length > 0)
      ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
    const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : identity.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
    if (!props)
      return str;
    return identity.isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
  }
  exports.createStringifyContext = createStringifyContext;
  exports.stringify = stringify;
});

// node_modules/yaml/dist/stringify/stringifyPair.js
var require_stringifyPair = __commonJS((exports) => {
  var identity = require_identity();
  var Scalar = require_Scalar();
  var stringify = require_stringify();
  var stringifyComment = require_stringifyComment();
  function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
    const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
    let keyComment = identity.isNode(key) && key.comment || null;
    if (simpleKeys) {
      if (keyComment) {
        throw new Error("With simple keys, key nodes cannot have comments");
      }
      if (identity.isCollection(key) || !identity.isNode(key) && typeof key === "object") {
        const msg = "With simple keys, collection cannot be used as a key value";
        throw new Error(msg);
      }
    }
    let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || identity.isCollection(key) || (identity.isScalar(key) ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL : typeof key === "object"));
    ctx = Object.assign({}, ctx, {
      allNullValues: false,
      implicitKey: !explicitKey && (simpleKeys || !allNullValues),
      indent: indent + indentStep
    });
    let keyCommentDone = false;
    let chompKeep = false;
    let str = stringify.stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
    if (!explicitKey && !ctx.inFlow && str.length > 1024) {
      if (simpleKeys)
        throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
      explicitKey = true;
    }
    if (ctx.inFlow) {
      if (allNullValues || value == null) {
        if (keyCommentDone && onComment)
          onComment();
        return str === "" ? "?" : explicitKey ? `? ${str}` : str;
      }
    } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
      str = `? ${str}`;
      if (keyComment && !keyCommentDone) {
        str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
      } else if (chompKeep && onChompKeep)
        onChompKeep();
      return str;
    }
    if (keyCommentDone)
      keyComment = null;
    if (explicitKey) {
      if (keyComment)
        str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
      str = `? ${str}
${indent}:`;
    } else {
      str = `${str}:`;
      if (keyComment)
        str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
    }
    let vsb, vcb, valueComment;
    if (identity.isNode(value)) {
      vsb = !!value.spaceBefore;
      vcb = value.commentBefore;
      valueComment = value.comment;
    } else {
      vsb = false;
      vcb = null;
      valueComment = null;
      if (value && typeof value === "object")
        value = doc.createNode(value);
    }
    ctx.implicitKey = false;
    if (!explicitKey && !keyComment && identity.isScalar(value))
      ctx.indentAtStart = str.length + 1;
    chompKeep = false;
    if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && identity.isSeq(value) && !value.flow && !value.tag && !value.anchor) {
      ctx.indent = ctx.indent.substring(2);
    }
    let valueCommentDone = false;
    const valueStr = stringify.stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
    let ws = " ";
    if (keyComment || vsb || vcb) {
      ws = vsb ? `
` : "";
      if (vcb) {
        const cs = commentString(vcb);
        ws += `
${stringifyComment.indentComment(cs, ctx.indent)}`;
      }
      if (valueStr === "" && !ctx.inFlow) {
        if (ws === `
` && valueComment)
          ws = `

`;
      } else {
        ws += `
${ctx.indent}`;
      }
    } else if (!explicitKey && identity.isCollection(value)) {
      const vs0 = valueStr[0];
      const nl0 = valueStr.indexOf(`
`);
      const hasNewline = nl0 !== -1;
      const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
      if (hasNewline || !flow) {
        let hasPropsLine = false;
        if (hasNewline && (vs0 === "&" || vs0 === "!")) {
          let sp0 = valueStr.indexOf(" ");
          if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
            sp0 = valueStr.indexOf(" ", sp0 + 1);
          }
          if (sp0 === -1 || nl0 < sp0)
            hasPropsLine = true;
        }
        if (!hasPropsLine)
          ws = `
${ctx.indent}`;
      }
    } else if (valueStr === "" || valueStr[0] === `
`) {
      ws = "";
    }
    str += ws + valueStr;
    if (ctx.inFlow) {
      if (valueCommentDone && onComment)
        onComment();
    } else if (valueComment && !valueCommentDone) {
      str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));
    } else if (chompKeep && onChompKeep) {
      onChompKeep();
    }
    return str;
  }
  exports.stringifyPair = stringifyPair;
});

// node_modules/yaml/dist/log.js
var require_log = __commonJS((exports) => {
  var node_process = __require("process");
  function debug(logLevel, ...messages) {
    if (logLevel === "debug")
      console.log(...messages);
  }
  function warn(logLevel, warning) {
    if (logLevel === "debug" || logLevel === "warn") {
      if (typeof node_process.emitWarning === "function")
        node_process.emitWarning(warning);
      else
        console.warn(warning);
    }
  }
  exports.debug = debug;
  exports.warn = warn;
});

// node_modules/yaml/dist/schema/yaml-1.1/merge.js
var require_merge = __commonJS((exports) => {
  var identity = require_identity();
  var Scalar = require_Scalar();
  var MERGE_KEY = "<<";
  var merge = {
    identify: (value) => value === MERGE_KEY || typeof value === "symbol" && value.description === MERGE_KEY,
    default: "key",
    tag: "tag:yaml.org,2002:merge",
    test: /^<<$/,
    resolve: () => Object.assign(new Scalar.Scalar(Symbol(MERGE_KEY)), {
      addToJSMap: addMergeToJSMap
    }),
    stringify: () => MERGE_KEY
  };
  var isMergeKey = (ctx, key) => (merge.identify(key) || identity.isScalar(key) && (!key.type || key.type === Scalar.Scalar.PLAIN) && merge.identify(key.value)) && ctx?.doc.schema.tags.some((tag) => tag.tag === merge.tag && tag.default);
  function addMergeToJSMap(ctx, map, value) {
    value = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
    if (identity.isSeq(value))
      for (const it of value.items)
        mergeValue(ctx, map, it);
    else if (Array.isArray(value))
      for (const it of value)
        mergeValue(ctx, map, it);
    else
      mergeValue(ctx, map, value);
  }
  function mergeValue(ctx, map, value) {
    const source = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
    if (!identity.isMap(source))
      throw new Error("Merge sources must be maps or map aliases");
    const srcMap = source.toJSON(null, ctx, Map);
    for (const [key, value2] of srcMap) {
      if (map instanceof Map) {
        if (!map.has(key))
          map.set(key, value2);
      } else if (map instanceof Set) {
        map.add(key);
      } else if (!Object.prototype.hasOwnProperty.call(map, key)) {
        Object.defineProperty(map, key, {
          value: value2,
          writable: true,
          enumerable: true,
          configurable: true
        });
      }
    }
    return map;
  }
  exports.addMergeToJSMap = addMergeToJSMap;
  exports.isMergeKey = isMergeKey;
  exports.merge = merge;
});

// node_modules/yaml/dist/nodes/addPairToJSMap.js
var require_addPairToJSMap = __commonJS((exports) => {
  var log = require_log();
  var merge = require_merge();
  var stringify = require_stringify();
  var identity = require_identity();
  var toJS = require_toJS();
  function addPairToJSMap(ctx, map, { key, value }) {
    if (identity.isNode(key) && key.addToJSMap)
      key.addToJSMap(ctx, map, value);
    else if (merge.isMergeKey(ctx, key))
      merge.addMergeToJSMap(ctx, map, value);
    else {
      const jsKey = toJS.toJS(key, "", ctx);
      if (map instanceof Map) {
        map.set(jsKey, toJS.toJS(value, jsKey, ctx));
      } else if (map instanceof Set) {
        map.add(jsKey);
      } else {
        const stringKey = stringifyKey(key, jsKey, ctx);
        const jsValue = toJS.toJS(value, stringKey, ctx);
        if (stringKey in map)
          Object.defineProperty(map, stringKey, {
            value: jsValue,
            writable: true,
            enumerable: true,
            configurable: true
          });
        else
          map[stringKey] = jsValue;
      }
    }
    return map;
  }
  function stringifyKey(key, jsKey, ctx) {
    if (jsKey === null)
      return "";
    if (typeof jsKey !== "object")
      return String(jsKey);
    if (identity.isNode(key) && ctx?.doc) {
      const strCtx = stringify.createStringifyContext(ctx.doc, {});
      strCtx.anchors = new Set;
      for (const node of ctx.anchors.keys())
        strCtx.anchors.add(node.anchor);
      strCtx.inFlow = true;
      strCtx.inStringifyKey = true;
      const strKey = key.toString(strCtx);
      if (!ctx.mapKeyWarned) {
        let jsonStr = JSON.stringify(strKey);
        if (jsonStr.length > 40)
          jsonStr = jsonStr.substring(0, 36) + '..."';
        log.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
        ctx.mapKeyWarned = true;
      }
      return strKey;
    }
    return JSON.stringify(jsKey);
  }
  exports.addPairToJSMap = addPairToJSMap;
});

// node_modules/yaml/dist/nodes/Pair.js
var require_Pair = __commonJS((exports) => {
  var createNode = require_createNode();
  var stringifyPair = require_stringifyPair();
  var addPairToJSMap = require_addPairToJSMap();
  var identity = require_identity();
  function createPair(key, value, ctx) {
    const k = createNode.createNode(key, undefined, ctx);
    const v = createNode.createNode(value, undefined, ctx);
    return new Pair(k, v);
  }

  class Pair {
    constructor(key, value = null) {
      Object.defineProperty(this, identity.NODE_TYPE, { value: identity.PAIR });
      this.key = key;
      this.value = value;
    }
    clone(schema) {
      let { key, value } = this;
      if (identity.isNode(key))
        key = key.clone(schema);
      if (identity.isNode(value))
        value = value.clone(schema);
      return new Pair(key, value);
    }
    toJSON(_, ctx) {
      const pair = ctx?.mapAsMap ? new Map : {};
      return addPairToJSMap.addPairToJSMap(ctx, pair, this);
    }
    toString(ctx, onComment, onChompKeep) {
      return ctx?.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
    }
  }
  exports.Pair = Pair;
  exports.createPair = createPair;
});

// node_modules/yaml/dist/stringify/stringifyCollection.js
var require_stringifyCollection = __commonJS((exports) => {
  var identity = require_identity();
  var stringify = require_stringify();
  var stringifyComment = require_stringifyComment();
  function stringifyCollection(collection, ctx, options) {
    const flow = ctx.inFlow ?? collection.flow;
    const stringify2 = flow ? stringifyFlowCollection : stringifyBlockCollection;
    return stringify2(collection, ctx, options);
  }
  function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
    const { indent, options: { commentString } } = ctx;
    const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
    let chompKeep = false;
    const lines = [];
    for (let i = 0;i < items.length; ++i) {
      const item = items[i];
      let comment2 = null;
      if (identity.isNode(item)) {
        if (!chompKeep && item.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
        if (item.comment)
          comment2 = item.comment;
      } else if (identity.isPair(item)) {
        const ik = identity.isNode(item.key) ? item.key : null;
        if (ik) {
          if (!chompKeep && ik.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
        }
      }
      chompKeep = false;
      let str2 = stringify.stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
      if (comment2)
        str2 += stringifyComment.lineComment(str2, itemIndent, commentString(comment2));
      if (chompKeep && comment2)
        chompKeep = false;
      lines.push(blockItemPrefix + str2);
    }
    let str;
    if (lines.length === 0) {
      str = flowChars.start + flowChars.end;
    } else {
      str = lines[0];
      for (let i = 1;i < lines.length; ++i) {
        const line = lines[i];
        str += line ? `
${indent}${line}` : `
`;
      }
    }
    if (comment) {
      str += `
` + stringifyComment.indentComment(commentString(comment), indent);
      if (onComment)
        onComment();
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
    const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
    itemIndent += indentStep;
    const itemCtx = Object.assign({}, ctx, {
      indent: itemIndent,
      inFlow: true,
      type: null
    });
    let reqNewline = false;
    let linesAtValue = 0;
    const lines = [];
    for (let i = 0;i < items.length; ++i) {
      const item = items[i];
      let comment = null;
      if (identity.isNode(item)) {
        if (item.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, item.commentBefore, false);
        if (item.comment)
          comment = item.comment;
      } else if (identity.isPair(item)) {
        const ik = identity.isNode(item.key) ? item.key : null;
        if (ik) {
          if (ik.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, ik.commentBefore, false);
          if (ik.comment)
            reqNewline = true;
        }
        const iv = identity.isNode(item.value) ? item.value : null;
        if (iv) {
          if (iv.comment)
            comment = iv.comment;
          if (iv.commentBefore)
            reqNewline = true;
        } else if (item.value == null && ik?.comment) {
          comment = ik.comment;
        }
      }
      if (comment)
        reqNewline = true;
      let str = stringify.stringify(item, itemCtx, () => comment = null);
      if (i < items.length - 1)
        str += ",";
      if (comment)
        str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
      if (!reqNewline && (lines.length > linesAtValue || str.includes(`
`)))
        reqNewline = true;
      lines.push(str);
      linesAtValue = lines.length;
    }
    const { start, end } = flowChars;
    if (lines.length === 0) {
      return start + end;
    } else {
      if (!reqNewline) {
        const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
        reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
      }
      if (reqNewline) {
        let str = start;
        for (const line of lines)
          str += line ? `
${indentStep}${indent}${line}` : `
`;
        return `${str}
${indent}${end}`;
      } else {
        return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
      }
    }
  }
  function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
    if (comment && chompKeep)
      comment = comment.replace(/^\n+/, "");
    if (comment) {
      const ic = stringifyComment.indentComment(commentString(comment), indent);
      lines.push(ic.trimStart());
    }
  }
  exports.stringifyCollection = stringifyCollection;
});

// node_modules/yaml/dist/nodes/YAMLMap.js
var require_YAMLMap = __commonJS((exports) => {
  var stringifyCollection = require_stringifyCollection();
  var addPairToJSMap = require_addPairToJSMap();
  var Collection = require_Collection();
  var identity = require_identity();
  var Pair = require_Pair();
  var Scalar = require_Scalar();
  function findPair(items, key) {
    const k = identity.isScalar(key) ? key.value : key;
    for (const it of items) {
      if (identity.isPair(it)) {
        if (it.key === key || it.key === k)
          return it;
        if (identity.isScalar(it.key) && it.key.value === k)
          return it;
      }
    }
    return;
  }

  class YAMLMap extends Collection.Collection {
    static get tagName() {
      return "tag:yaml.org,2002:map";
    }
    constructor(schema) {
      super(identity.MAP, schema);
      this.items = [];
    }
    static from(schema, obj, ctx) {
      const { keepUndefined, replacer } = ctx;
      const map = new this(schema);
      const add = (key, value) => {
        if (typeof replacer === "function")
          value = replacer.call(obj, key, value);
        else if (Array.isArray(replacer) && !replacer.includes(key))
          return;
        if (value !== undefined || keepUndefined)
          map.items.push(Pair.createPair(key, value, ctx));
      };
      if (obj instanceof Map) {
        for (const [key, value] of obj)
          add(key, value);
      } else if (obj && typeof obj === "object") {
        for (const key of Object.keys(obj))
          add(key, obj[key]);
      }
      if (typeof schema.sortMapEntries === "function") {
        map.items.sort(schema.sortMapEntries);
      }
      return map;
    }
    add(pair, overwrite) {
      let _pair;
      if (identity.isPair(pair))
        _pair = pair;
      else if (!pair || typeof pair !== "object" || !("key" in pair)) {
        _pair = new Pair.Pair(pair, pair?.value);
      } else
        _pair = new Pair.Pair(pair.key, pair.value);
      const prev = findPair(this.items, _pair.key);
      const sortEntries = this.schema?.sortMapEntries;
      if (prev) {
        if (!overwrite)
          throw new Error(`Key ${_pair.key} already set`);
        if (identity.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))
          prev.value.value = _pair.value;
        else
          prev.value = _pair.value;
      } else if (sortEntries) {
        const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
        if (i === -1)
          this.items.push(_pair);
        else
          this.items.splice(i, 0, _pair);
      } else {
        this.items.push(_pair);
      }
    }
    delete(key) {
      const it = findPair(this.items, key);
      if (!it)
        return false;
      const del = this.items.splice(this.items.indexOf(it), 1);
      return del.length > 0;
    }
    get(key, keepScalar) {
      const it = findPair(this.items, key);
      const node = it?.value;
      return (!keepScalar && identity.isScalar(node) ? node.value : node) ?? undefined;
    }
    has(key) {
      return !!findPair(this.items, key);
    }
    set(key, value) {
      this.add(new Pair.Pair(key, value), true);
    }
    toJSON(_, ctx, Type) {
      const map = Type ? new Type : ctx?.mapAsMap ? new Map : {};
      if (ctx?.onCreate)
        ctx.onCreate(map);
      for (const item of this.items)
        addPairToJSMap.addPairToJSMap(ctx, map, item);
      return map;
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      for (const item of this.items) {
        if (!identity.isPair(item))
          throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
      }
      if (!ctx.allNullValues && this.hasAllNullValues(false))
        ctx = Object.assign({}, ctx, { allNullValues: true });
      return stringifyCollection.stringifyCollection(this, ctx, {
        blockItemPrefix: "",
        flowChars: { start: "{", end: "}" },
        itemIndent: ctx.indent || "",
        onChompKeep,
        onComment
      });
    }
  }
  exports.YAMLMap = YAMLMap;
  exports.findPair = findPair;
});

// node_modules/yaml/dist/schema/common/map.js
var require_map = __commonJS((exports) => {
  var identity = require_identity();
  var YAMLMap = require_YAMLMap();
  var map = {
    collection: "map",
    default: true,
    nodeClass: YAMLMap.YAMLMap,
    tag: "tag:yaml.org,2002:map",
    resolve(map2, onError) {
      if (!identity.isMap(map2))
        onError("Expected a mapping for this tag");
      return map2;
    },
    createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx)
  };
  exports.map = map;
});

// node_modules/yaml/dist/nodes/YAMLSeq.js
var require_YAMLSeq = __commonJS((exports) => {
  var createNode = require_createNode();
  var stringifyCollection = require_stringifyCollection();
  var Collection = require_Collection();
  var identity = require_identity();
  var Scalar = require_Scalar();
  var toJS = require_toJS();

  class YAMLSeq extends Collection.Collection {
    static get tagName() {
      return "tag:yaml.org,2002:seq";
    }
    constructor(schema) {
      super(identity.SEQ, schema);
      this.items = [];
    }
    add(value) {
      this.items.push(value);
    }
    delete(key) {
      const idx = asItemIndex(key);
      if (typeof idx !== "number")
        return false;
      const del = this.items.splice(idx, 1);
      return del.length > 0;
    }
    get(key, keepScalar) {
      const idx = asItemIndex(key);
      if (typeof idx !== "number")
        return;
      const it = this.items[idx];
      return !keepScalar && identity.isScalar(it) ? it.value : it;
    }
    has(key) {
      const idx = asItemIndex(key);
      return typeof idx === "number" && idx < this.items.length;
    }
    set(key, value) {
      const idx = asItemIndex(key);
      if (typeof idx !== "number")
        throw new Error(`Expected a valid index, not ${key}.`);
      const prev = this.items[idx];
      if (identity.isScalar(prev) && Scalar.isScalarValue(value))
        prev.value = value;
      else
        this.items[idx] = value;
    }
    toJSON(_, ctx) {
      const seq = [];
      if (ctx?.onCreate)
        ctx.onCreate(seq);
      let i = 0;
      for (const item of this.items)
        seq.push(toJS.toJS(item, String(i++), ctx));
      return seq;
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      return stringifyCollection.stringifyCollection(this, ctx, {
        blockItemPrefix: "- ",
        flowChars: { start: "[", end: "]" },
        itemIndent: (ctx.indent || "") + "  ",
        onChompKeep,
        onComment
      });
    }
    static from(schema, obj, ctx) {
      const { replacer } = ctx;
      const seq = new this(schema);
      if (obj && Symbol.iterator in Object(obj)) {
        let i = 0;
        for (let it of obj) {
          if (typeof replacer === "function") {
            const key = obj instanceof Set ? it : String(i++);
            it = replacer.call(obj, key, it);
          }
          seq.items.push(createNode.createNode(it, undefined, ctx));
        }
      }
      return seq;
    }
  }
  function asItemIndex(key) {
    let idx = identity.isScalar(key) ? key.value : key;
    if (idx && typeof idx === "string")
      idx = Number(idx);
    return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
  }
  exports.YAMLSeq = YAMLSeq;
});

// node_modules/yaml/dist/schema/common/seq.js
var require_seq = __commonJS((exports) => {
  var identity = require_identity();
  var YAMLSeq = require_YAMLSeq();
  var seq = {
    collection: "seq",
    default: true,
    nodeClass: YAMLSeq.YAMLSeq,
    tag: "tag:yaml.org,2002:seq",
    resolve(seq2, onError) {
      if (!identity.isSeq(seq2))
        onError("Expected a sequence for this tag");
      return seq2;
    },
    createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx)
  };
  exports.seq = seq;
});

// node_modules/yaml/dist/schema/common/string.js
var require_string = __commonJS((exports) => {
  var stringifyString = require_stringifyString();
  var string = {
    identify: (value) => typeof value === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str) => str,
    stringify(item, ctx, onComment, onChompKeep) {
      ctx = Object.assign({ actualString: true }, ctx);
      return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
    }
  };
  exports.string = string;
});

// node_modules/yaml/dist/schema/common/null.js
var require_null = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var nullTag = {
    identify: (value) => value == null,
    createNode: () => new Scalar.Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^(?:~|[Nn]ull|NULL)?$/,
    resolve: () => new Scalar.Scalar(null),
    stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
  };
  exports.nullTag = nullTag;
});

// node_modules/yaml/dist/schema/core/bool.js
var require_bool = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var boolTag = {
    identify: (value) => typeof value === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
    resolve: (str) => new Scalar.Scalar(str[0] === "t" || str[0] === "T"),
    stringify({ source, value }, ctx) {
      if (source && boolTag.test.test(source)) {
        const sv = source[0] === "t" || source[0] === "T";
        if (value === sv)
          return source;
      }
      return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
  };
  exports.boolTag = boolTag;
});

// node_modules/yaml/dist/stringify/stringifyNumber.js
var require_stringifyNumber = __commonJS((exports) => {
  function stringifyNumber({ format, minFractionDigits, tag, value }) {
    if (typeof value === "bigint")
      return String(value);
    const num = typeof value === "number" ? value : Number(value);
    if (!isFinite(num))
      return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
    let n = Object.is(value, -0) ? "-0" : JSON.stringify(value);
    if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
      let i = n.indexOf(".");
      if (i < 0) {
        i = n.length;
        n += ".";
      }
      let d = minFractionDigits - (n.length - i - 1);
      while (d-- > 0)
        n += "0";
    }
    return n;
  }
  exports.stringifyNumber = stringifyNumber;
});

// node_modules/yaml/dist/schema/core/float.js
var require_float = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var stringifyNumber = require_stringifyNumber();
  var floatNaN = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
    resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
  };
  var floatExp = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str),
    stringify(node) {
      const num = Number(node.value);
      return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
    }
  };
  var float = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
    resolve(str) {
      const node = new Scalar.Scalar(parseFloat(str));
      const dot = str.indexOf(".");
      if (dot !== -1 && str[str.length - 1] === "0")
        node.minFractionDigits = str.length - dot - 1;
      return node;
    },
    stringify: stringifyNumber.stringifyNumber
  };
  exports.float = float;
  exports.floatExp = floatExp;
  exports.floatNaN = floatNaN;
});

// node_modules/yaml/dist/schema/core/int.js
var require_int = __commonJS((exports) => {
  var stringifyNumber = require_stringifyNumber();
  var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
  var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
  function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value) && value >= 0)
      return prefix + value.toString(radix);
    return stringifyNumber.stringifyNumber(node);
  }
  var intOct = {
    identify: (value) => intIdentify(value) && value >= 0,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^0o[0-7]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
    stringify: (node) => intStringify(node, 8, "0o")
  };
  var int = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^[-+]?[0-9]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
  };
  var intHex = {
    identify: (value) => intIdentify(value) && value >= 0,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^0x[0-9a-fA-F]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: (node) => intStringify(node, 16, "0x")
  };
  exports.int = int;
  exports.intHex = intHex;
  exports.intOct = intOct;
});

// node_modules/yaml/dist/schema/core/schema.js
var require_schema = __commonJS((exports) => {
  var map = require_map();
  var _null = require_null();
  var seq = require_seq();
  var string = require_string();
  var bool = require_bool();
  var float = require_float();
  var int = require_int();
  var schema = [
    map.map,
    seq.seq,
    string.string,
    _null.nullTag,
    bool.boolTag,
    int.intOct,
    int.int,
    int.intHex,
    float.floatNaN,
    float.floatExp,
    float.float
  ];
  exports.schema = schema;
});

// node_modules/yaml/dist/schema/json/schema.js
var require_schema2 = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var map = require_map();
  var seq = require_seq();
  function intIdentify(value) {
    return typeof value === "bigint" || Number.isInteger(value);
  }
  var stringifyJSON = ({ value }) => JSON.stringify(value);
  var jsonScalars = [
    {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str) => str,
      stringify: stringifyJSON
    },
    {
      identify: (value) => value == null,
      createNode: () => new Scalar.Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^null$/,
      resolve: () => null,
      stringify: stringifyJSON
    },
    {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^true$|^false$/,
      resolve: (str) => str === "true",
      stringify: stringifyJSON
    },
    {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^-?(?:0|[1-9][0-9]*)$/,
      resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
      stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)
    },
    {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
      resolve: (str) => parseFloat(str),
      stringify: stringifyJSON
    }
  ];
  var jsonError = {
    default: true,
    tag: "",
    test: /^/,
    resolve(str, onError) {
      onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
      return str;
    }
  };
  var schema = [map.map, seq.seq].concat(jsonScalars, jsonError);
  exports.schema = schema;
});

// node_modules/yaml/dist/schema/yaml-1.1/binary.js
var require_binary = __commonJS((exports) => {
  var node_buffer = __require("buffer");
  var Scalar = require_Scalar();
  var stringifyString = require_stringifyString();
  var binary = {
    identify: (value) => value instanceof Uint8Array,
    default: false,
    tag: "tag:yaml.org,2002:binary",
    resolve(src, onError) {
      if (typeof node_buffer.Buffer === "function") {
        return node_buffer.Buffer.from(src, "base64");
      } else if (typeof atob === "function") {
        const str = atob(src.replace(/[\n\r]/g, ""));
        const buffer = new Uint8Array(str.length);
        for (let i = 0;i < str.length; ++i)
          buffer[i] = str.charCodeAt(i);
        return buffer;
      } else {
        onError("This environment does not support reading binary tags; either Buffer or atob is required");
        return src;
      }
    },
    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
      if (!value)
        return "";
      const buf = value;
      let str;
      if (typeof node_buffer.Buffer === "function") {
        str = buf instanceof node_buffer.Buffer ? buf.toString("base64") : node_buffer.Buffer.from(buf.buffer).toString("base64");
      } else if (typeof btoa === "function") {
        let s = "";
        for (let i = 0;i < buf.length; ++i)
          s += String.fromCharCode(buf[i]);
        str = btoa(s);
      } else {
        throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
      }
      type ?? (type = Scalar.Scalar.BLOCK_LITERAL);
      if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
        const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
        const n = Math.ceil(str.length / lineWidth);
        const lines = new Array(n);
        for (let i = 0, o = 0;i < n; ++i, o += lineWidth) {
          lines[i] = str.substr(o, lineWidth);
        }
        str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? `
` : " ");
      }
      return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
    }
  };
  exports.binary = binary;
});

// node_modules/yaml/dist/schema/yaml-1.1/pairs.js
var require_pairs = __commonJS((exports) => {
  var identity = require_identity();
  var Pair = require_Pair();
  var Scalar = require_Scalar();
  var YAMLSeq = require_YAMLSeq();
  function resolvePairs(seq, onError) {
    if (identity.isSeq(seq)) {
      for (let i = 0;i < seq.items.length; ++i) {
        let item = seq.items[i];
        if (identity.isPair(item))
          continue;
        else if (identity.isMap(item)) {
          if (item.items.length > 1)
            onError("Each pair must have its own sequence indicator");
          const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
          if (item.commentBefore)
            pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
          if (item.comment) {
            const cn = pair.value ?? pair.key;
            cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
          }
          item = pair;
        }
        seq.items[i] = identity.isPair(item) ? item : new Pair.Pair(item);
      }
    } else
      onError("Expected a sequence for this tag");
    return seq;
  }
  function createPairs(schema, iterable, ctx) {
    const { replacer } = ctx;
    const pairs2 = new YAMLSeq.YAMLSeq(schema);
    pairs2.tag = "tag:yaml.org,2002:pairs";
    let i = 0;
    if (iterable && Symbol.iterator in Object(iterable))
      for (let it of iterable) {
        if (typeof replacer === "function")
          it = replacer.call(iterable, String(i++), it);
        let key, value;
        if (Array.isArray(it)) {
          if (it.length === 2) {
            key = it[0];
            value = it[1];
          } else
            throw new TypeError(`Expected [key, value] tuple: ${it}`);
        } else if (it && it instanceof Object) {
          const keys = Object.keys(it);
          if (keys.length === 1) {
            key = keys[0];
            value = it[key];
          } else {
            throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
          }
        } else {
          key = it;
        }
        pairs2.items.push(Pair.createPair(key, value, ctx));
      }
    return pairs2;
  }
  var pairs = {
    collection: "seq",
    default: false,
    tag: "tag:yaml.org,2002:pairs",
    resolve: resolvePairs,
    createNode: createPairs
  };
  exports.createPairs = createPairs;
  exports.pairs = pairs;
  exports.resolvePairs = resolvePairs;
});

// node_modules/yaml/dist/schema/yaml-1.1/omap.js
var require_omap = __commonJS((exports) => {
  var identity = require_identity();
  var toJS = require_toJS();
  var YAMLMap = require_YAMLMap();
  var YAMLSeq = require_YAMLSeq();
  var pairs = require_pairs();

  class YAMLOMap extends YAMLSeq.YAMLSeq {
    constructor() {
      super();
      this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
      this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
      this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
      this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
      this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
      this.tag = YAMLOMap.tag;
    }
    toJSON(_, ctx) {
      if (!ctx)
        return super.toJSON(_);
      const map = new Map;
      if (ctx?.onCreate)
        ctx.onCreate(map);
      for (const pair of this.items) {
        let key, value;
        if (identity.isPair(pair)) {
          key = toJS.toJS(pair.key, "", ctx);
          value = toJS.toJS(pair.value, key, ctx);
        } else {
          key = toJS.toJS(pair, "", ctx);
        }
        if (map.has(key))
          throw new Error("Ordered maps must not include duplicate keys");
        map.set(key, value);
      }
      return map;
    }
    static from(schema, iterable, ctx) {
      const pairs$1 = pairs.createPairs(schema, iterable, ctx);
      const omap2 = new this;
      omap2.items = pairs$1.items;
      return omap2;
    }
  }
  YAMLOMap.tag = "tag:yaml.org,2002:omap";
  var omap = {
    collection: "seq",
    identify: (value) => value instanceof Map,
    nodeClass: YAMLOMap,
    default: false,
    tag: "tag:yaml.org,2002:omap",
    resolve(seq, onError) {
      const pairs$1 = pairs.resolvePairs(seq, onError);
      const seenKeys = [];
      for (const { key } of pairs$1.items) {
        if (identity.isScalar(key)) {
          if (seenKeys.includes(key.value)) {
            onError(`Ordered maps must not include duplicate keys: ${key.value}`);
          } else {
            seenKeys.push(key.value);
          }
        }
      }
      return Object.assign(new YAMLOMap, pairs$1);
    },
    createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
  };
  exports.YAMLOMap = YAMLOMap;
  exports.omap = omap;
});

// node_modules/yaml/dist/schema/yaml-1.1/bool.js
var require_bool2 = __commonJS((exports) => {
  var Scalar = require_Scalar();
  function boolStringify({ value, source }, ctx) {
    const boolObj = value ? trueTag : falseTag;
    if (source && boolObj.test.test(source))
      return source;
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
  var trueTag = {
    identify: (value) => value === true,
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
    resolve: () => new Scalar.Scalar(true),
    stringify: boolStringify
  };
  var falseTag = {
    identify: (value) => value === false,
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
    resolve: () => new Scalar.Scalar(false),
    stringify: boolStringify
  };
  exports.falseTag = falseTag;
  exports.trueTag = trueTag;
});

// node_modules/yaml/dist/schema/yaml-1.1/float.js
var require_float2 = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var stringifyNumber = require_stringifyNumber();
  var floatNaN = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
    resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
  };
  var floatExp = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "EXP",
    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str.replace(/_/g, "")),
    stringify(node) {
      const num = Number(node.value);
      return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
    }
  };
  var float = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
    resolve(str) {
      const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, "")));
      const dot = str.indexOf(".");
      if (dot !== -1) {
        const f = str.substring(dot + 1).replace(/_/g, "");
        if (f[f.length - 1] === "0")
          node.minFractionDigits = f.length;
      }
      return node;
    },
    stringify: stringifyNumber.stringifyNumber
  };
  exports.float = float;
  exports.floatExp = floatExp;
  exports.floatNaN = floatNaN;
});

// node_modules/yaml/dist/schema/yaml-1.1/int.js
var require_int2 = __commonJS((exports) => {
  var stringifyNumber = require_stringifyNumber();
  var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
  function intResolve(str, offset, radix, { intAsBigInt }) {
    const sign = str[0];
    if (sign === "-" || sign === "+")
      offset += 1;
    str = str.substring(offset).replace(/_/g, "");
    if (intAsBigInt) {
      switch (radix) {
        case 2:
          str = `0b${str}`;
          break;
        case 8:
          str = `0o${str}`;
          break;
        case 16:
          str = `0x${str}`;
          break;
      }
      const n2 = BigInt(str);
      return sign === "-" ? BigInt(-1) * n2 : n2;
    }
    const n = parseInt(str, radix);
    return sign === "-" ? -1 * n : n;
  }
  function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value)) {
      const str = value.toString(radix);
      return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
    }
    return stringifyNumber.stringifyNumber(node);
  }
  var intBin = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "BIN",
    test: /^[-+]?0b[0-1_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
    stringify: (node) => intStringify(node, 2, "0b")
  };
  var intOct = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "OCT",
    test: /^[-+]?0[0-7_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
    stringify: (node) => intStringify(node, 8, "0")
  };
  var int = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^[-+]?[0-9][0-9_]*$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
  };
  var intHex = {
    identify: intIdentify,
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "HEX",
    test: /^[-+]?0x[0-9a-fA-F_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: (node) => intStringify(node, 16, "0x")
  };
  exports.int = int;
  exports.intBin = intBin;
  exports.intHex = intHex;
  exports.intOct = intOct;
});

// node_modules/yaml/dist/schema/yaml-1.1/set.js
var require_set = __commonJS((exports) => {
  var identity = require_identity();
  var Pair = require_Pair();
  var YAMLMap = require_YAMLMap();

  class YAMLSet extends YAMLMap.YAMLMap {
    constructor(schema) {
      super(schema);
      this.tag = YAMLSet.tag;
    }
    add(key) {
      let pair;
      if (identity.isPair(key))
        pair = key;
      else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
        pair = new Pair.Pair(key.key, null);
      else
        pair = new Pair.Pair(key, null);
      const prev = YAMLMap.findPair(this.items, pair.key);
      if (!prev)
        this.items.push(pair);
    }
    get(key, keepPair) {
      const pair = YAMLMap.findPair(this.items, key);
      return !keepPair && identity.isPair(pair) ? identity.isScalar(pair.key) ? pair.key.value : pair.key : pair;
    }
    set(key, value) {
      if (typeof value !== "boolean")
        throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
      const prev = YAMLMap.findPair(this.items, key);
      if (prev && !value) {
        this.items.splice(this.items.indexOf(prev), 1);
      } else if (!prev && value) {
        this.items.push(new Pair.Pair(key));
      }
    }
    toJSON(_, ctx) {
      return super.toJSON(_, ctx, Set);
    }
    toString(ctx, onComment, onChompKeep) {
      if (!ctx)
        return JSON.stringify(this);
      if (this.hasAllNullValues(true))
        return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
      else
        throw new Error("Set items must all have null values");
    }
    static from(schema, iterable, ctx) {
      const { replacer } = ctx;
      const set2 = new this(schema);
      if (iterable && Symbol.iterator in Object(iterable))
        for (let value of iterable) {
          if (typeof replacer === "function")
            value = replacer.call(iterable, value, value);
          set2.items.push(Pair.createPair(value, null, ctx));
        }
      return set2;
    }
  }
  YAMLSet.tag = "tag:yaml.org,2002:set";
  var set = {
    collection: "map",
    identify: (value) => value instanceof Set,
    nodeClass: YAMLSet,
    default: false,
    tag: "tag:yaml.org,2002:set",
    createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
    resolve(map, onError) {
      if (identity.isMap(map)) {
        if (map.hasAllNullValues(true))
          return Object.assign(new YAMLSet, map);
        else
          onError("Set items must all have null values");
      } else
        onError("Expected a mapping for this tag");
      return map;
    }
  };
  exports.YAMLSet = YAMLSet;
  exports.set = set;
});

// node_modules/yaml/dist/schema/yaml-1.1/timestamp.js
var require_timestamp = __commonJS((exports) => {
  var stringifyNumber = require_stringifyNumber();
  function parseSexagesimal(str, asBigInt) {
    const sign = str[0];
    const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
    const num = (n) => asBigInt ? BigInt(n) : Number(n);
    const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
    return sign === "-" ? num(-1) * res : res;
  }
  function stringifySexagesimal(node) {
    let { value } = node;
    let num = (n) => n;
    if (typeof value === "bigint")
      num = (n) => BigInt(n);
    else if (isNaN(value) || !isFinite(value))
      return stringifyNumber.stringifyNumber(node);
    let sign = "";
    if (value < 0) {
      sign = "-";
      value *= num(-1);
    }
    const _60 = num(60);
    const parts = [value % _60];
    if (value < 60) {
      parts.unshift(0);
    } else {
      value = (value - parts[0]) / _60;
      parts.unshift(value % _60);
      if (value >= 60) {
        value = (value - parts[0]) / _60;
        parts.unshift(value);
      }
    }
    return sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
  }
  var intTime = {
    identify: (value) => typeof value === "bigint" || Number.isInteger(value),
    default: true,
    tag: "tag:yaml.org,2002:int",
    format: "TIME",
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
    resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
    stringify: stringifySexagesimal
  };
  var floatTime = {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    format: "TIME",
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
    resolve: (str) => parseSexagesimal(str, false),
    stringify: stringifySexagesimal
  };
  var timestamp = {
    identify: (value) => value instanceof Date,
    default: true,
    tag: "tag:yaml.org,2002:timestamp",
    test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})" + "(?:" + "(?:t|T|[ \\t]+)" + "([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)" + "(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?" + ")?$"),
    resolve(str) {
      const match = str.match(timestamp.test);
      if (!match)
        throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
      const [, year, month, day, hour, minute, second] = match.map(Number);
      const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
      let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
      const tz = match[8];
      if (tz && tz !== "Z") {
        let d = parseSexagesimal(tz, false);
        if (Math.abs(d) < 30)
          d *= 60;
        date -= 60000 * d;
      }
      return new Date(date);
    },
    stringify: ({ value }) => value?.toISOString().replace(/(T00:00:00)?\.000Z$/, "") ?? ""
  };
  exports.floatTime = floatTime;
  exports.intTime = intTime;
  exports.timestamp = timestamp;
});

// node_modules/yaml/dist/schema/yaml-1.1/schema.js
var require_schema3 = __commonJS((exports) => {
  var map = require_map();
  var _null = require_null();
  var seq = require_seq();
  var string = require_string();
  var binary = require_binary();
  var bool = require_bool2();
  var float = require_float2();
  var int = require_int2();
  var merge = require_merge();
  var omap = require_omap();
  var pairs = require_pairs();
  var set = require_set();
  var timestamp = require_timestamp();
  var schema = [
    map.map,
    seq.seq,
    string.string,
    _null.nullTag,
    bool.trueTag,
    bool.falseTag,
    int.intBin,
    int.intOct,
    int.int,
    int.intHex,
    float.floatNaN,
    float.floatExp,
    float.float,
    binary.binary,
    merge.merge,
    omap.omap,
    pairs.pairs,
    set.set,
    timestamp.intTime,
    timestamp.floatTime,
    timestamp.timestamp
  ];
  exports.schema = schema;
});

// node_modules/yaml/dist/schema/tags.js
var require_tags = __commonJS((exports) => {
  var map = require_map();
  var _null = require_null();
  var seq = require_seq();
  var string = require_string();
  var bool = require_bool();
  var float = require_float();
  var int = require_int();
  var schema = require_schema();
  var schema$1 = require_schema2();
  var binary = require_binary();
  var merge = require_merge();
  var omap = require_omap();
  var pairs = require_pairs();
  var schema$2 = require_schema3();
  var set = require_set();
  var timestamp = require_timestamp();
  var schemas = new Map([
    ["core", schema.schema],
    ["failsafe", [map.map, seq.seq, string.string]],
    ["json", schema$1.schema],
    ["yaml11", schema$2.schema],
    ["yaml-1.1", schema$2.schema]
  ]);
  var tagsByName = {
    binary: binary.binary,
    bool: bool.boolTag,
    float: float.float,
    floatExp: float.floatExp,
    floatNaN: float.floatNaN,
    floatTime: timestamp.floatTime,
    int: int.int,
    intHex: int.intHex,
    intOct: int.intOct,
    intTime: timestamp.intTime,
    map: map.map,
    merge: merge.merge,
    null: _null.nullTag,
    omap: omap.omap,
    pairs: pairs.pairs,
    seq: seq.seq,
    set: set.set,
    timestamp: timestamp.timestamp
  };
  var coreKnownTags = {
    "tag:yaml.org,2002:binary": binary.binary,
    "tag:yaml.org,2002:merge": merge.merge,
    "tag:yaml.org,2002:omap": omap.omap,
    "tag:yaml.org,2002:pairs": pairs.pairs,
    "tag:yaml.org,2002:set": set.set,
    "tag:yaml.org,2002:timestamp": timestamp.timestamp
  };
  function getTags(customTags, schemaName, addMergeTag) {
    const schemaTags = schemas.get(schemaName);
    if (schemaTags && !customTags) {
      return addMergeTag && !schemaTags.includes(merge.merge) ? schemaTags.concat(merge.merge) : schemaTags.slice();
    }
    let tags = schemaTags;
    if (!tags) {
      if (Array.isArray(customTags))
        tags = [];
      else {
        const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
      }
    }
    if (Array.isArray(customTags)) {
      for (const tag of customTags)
        tags = tags.concat(tag);
    } else if (typeof customTags === "function") {
      tags = customTags(tags.slice());
    }
    if (addMergeTag)
      tags = tags.concat(merge.merge);
    return tags.reduce((tags2, tag) => {
      const tagObj = typeof tag === "string" ? tagsByName[tag] : tag;
      if (!tagObj) {
        const tagName = JSON.stringify(tag);
        const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
        throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
      }
      if (!tags2.includes(tagObj))
        tags2.push(tagObj);
      return tags2;
    }, []);
  }
  exports.coreKnownTags = coreKnownTags;
  exports.getTags = getTags;
});

// node_modules/yaml/dist/schema/Schema.js
var require_Schema = __commonJS((exports) => {
  var identity = require_identity();
  var map = require_map();
  var seq = require_seq();
  var string = require_string();
  var tags = require_tags();
  var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;

  class Schema {
    constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
      this.compat = Array.isArray(compat) ? tags.getTags(compat, "compat") : compat ? tags.getTags(null, compat) : null;
      this.name = typeof schema === "string" && schema || "core";
      this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
      this.tags = tags.getTags(customTags, this.name, merge);
      this.toStringOptions = toStringDefaults ?? null;
      Object.defineProperty(this, identity.MAP, { value: map.map });
      Object.defineProperty(this, identity.SCALAR, { value: string.string });
      Object.defineProperty(this, identity.SEQ, { value: seq.seq });
      this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
    }
    clone() {
      const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
      copy.tags = this.tags.slice();
      return copy;
    }
  }
  exports.Schema = Schema;
});

// node_modules/yaml/dist/stringify/stringifyDocument.js
var require_stringifyDocument = __commonJS((exports) => {
  var identity = require_identity();
  var stringify = require_stringify();
  var stringifyComment = require_stringifyComment();
  function stringifyDocument(doc, options) {
    const lines = [];
    let hasDirectives = options.directives === true;
    if (options.directives !== false && doc.directives) {
      const dir = doc.directives.toString(doc);
      if (dir) {
        lines.push(dir);
        hasDirectives = true;
      } else if (doc.directives.docStart)
        hasDirectives = true;
    }
    if (hasDirectives)
      lines.push("---");
    const ctx = stringify.createStringifyContext(doc, options);
    const { commentString } = ctx.options;
    if (doc.commentBefore) {
      if (lines.length !== 1)
        lines.unshift("");
      const cs = commentString(doc.commentBefore);
      lines.unshift(stringifyComment.indentComment(cs, ""));
    }
    let chompKeep = false;
    let contentComment = null;
    if (doc.contents) {
      if (identity.isNode(doc.contents)) {
        if (doc.contents.spaceBefore && hasDirectives)
          lines.push("");
        if (doc.contents.commentBefore) {
          const cs = commentString(doc.contents.commentBefore);
          lines.push(stringifyComment.indentComment(cs, ""));
        }
        ctx.forceBlockIndent = !!doc.comment;
        contentComment = doc.contents.comment;
      }
      const onChompKeep = contentComment ? undefined : () => chompKeep = true;
      let body = stringify.stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
      if (contentComment)
        body += stringifyComment.lineComment(body, "", commentString(contentComment));
      if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
        lines[lines.length - 1] = `--- ${body}`;
      } else
        lines.push(body);
    } else {
      lines.push(stringify.stringify(doc.contents, ctx));
    }
    if (doc.directives?.docEnd) {
      if (doc.comment) {
        const cs = commentString(doc.comment);
        if (cs.includes(`
`)) {
          lines.push("...");
          lines.push(stringifyComment.indentComment(cs, ""));
        } else {
          lines.push(`... ${cs}`);
        }
      } else {
        lines.push("...");
      }
    } else {
      let dc = doc.comment;
      if (dc && chompKeep)
        dc = dc.replace(/^\n+/, "");
      if (dc) {
        if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
          lines.push("");
        lines.push(stringifyComment.indentComment(commentString(dc), ""));
      }
    }
    return lines.join(`
`) + `
`;
  }
  exports.stringifyDocument = stringifyDocument;
});

// node_modules/yaml/dist/doc/Document.js
var require_Document = __commonJS((exports) => {
  var Alias = require_Alias();
  var Collection = require_Collection();
  var identity = require_identity();
  var Pair = require_Pair();
  var toJS = require_toJS();
  var Schema = require_Schema();
  var stringifyDocument = require_stringifyDocument();
  var anchors = require_anchors();
  var applyReviver = require_applyReviver();
  var createNode = require_createNode();
  var directives = require_directives();

  class Document {
    constructor(value, replacer, options) {
      this.commentBefore = null;
      this.comment = null;
      this.errors = [];
      this.warnings = [];
      Object.defineProperty(this, identity.NODE_TYPE, { value: identity.DOC });
      let _replacer = null;
      if (typeof replacer === "function" || Array.isArray(replacer)) {
        _replacer = replacer;
      } else if (options === undefined && replacer) {
        options = replacer;
        replacer = undefined;
      }
      const opt = Object.assign({
        intAsBigInt: false,
        keepSourceTokens: false,
        logLevel: "warn",
        prettyErrors: true,
        strict: true,
        stringKeys: false,
        uniqueKeys: true,
        version: "1.2"
      }, options);
      this.options = opt;
      let { version } = opt;
      if (options?._directives) {
        this.directives = options._directives.atDocument();
        if (this.directives.yaml.explicit)
          version = this.directives.yaml.version;
      } else
        this.directives = new directives.Directives({ version });
      this.setSchema(version, options);
      this.contents = value === undefined ? null : this.createNode(value, _replacer, options);
    }
    clone() {
      const copy = Object.create(Document.prototype, {
        [identity.NODE_TYPE]: { value: identity.DOC }
      });
      copy.commentBefore = this.commentBefore;
      copy.comment = this.comment;
      copy.errors = this.errors.slice();
      copy.warnings = this.warnings.slice();
      copy.options = Object.assign({}, this.options);
      if (this.directives)
        copy.directives = this.directives.clone();
      copy.schema = this.schema.clone();
      copy.contents = identity.isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
      if (this.range)
        copy.range = this.range.slice();
      return copy;
    }
    add(value) {
      if (assertCollection(this.contents))
        this.contents.add(value);
    }
    addIn(path, value) {
      if (assertCollection(this.contents))
        this.contents.addIn(path, value);
    }
    createAlias(node, name) {
      if (!node.anchor) {
        const prev = anchors.anchorNames(this);
        node.anchor = !name || prev.has(name) ? anchors.findNewAnchor(name || "a", prev) : name;
      }
      return new Alias.Alias(node.anchor);
    }
    createNode(value, replacer, options) {
      let _replacer = undefined;
      if (typeof replacer === "function") {
        value = replacer.call({ "": value }, "", value);
        _replacer = replacer;
      } else if (Array.isArray(replacer)) {
        const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
        const asStr = replacer.filter(keyToStr).map(String);
        if (asStr.length > 0)
          replacer = replacer.concat(asStr);
        _replacer = replacer;
      } else if (options === undefined && replacer) {
        options = replacer;
        replacer = undefined;
      }
      const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
      const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(this, anchorPrefix || "a");
      const ctx = {
        aliasDuplicateObjects: aliasDuplicateObjects ?? true,
        keepUndefined: keepUndefined ?? false,
        onAnchor,
        onTagObj,
        replacer: _replacer,
        schema: this.schema,
        sourceObjects
      };
      const node = createNode.createNode(value, tag, ctx);
      if (flow && identity.isCollection(node))
        node.flow = true;
      setAnchors();
      return node;
    }
    createPair(key, value, options = {}) {
      const k = this.createNode(key, null, options);
      const v = this.createNode(value, null, options);
      return new Pair.Pair(k, v);
    }
    delete(key) {
      return assertCollection(this.contents) ? this.contents.delete(key) : false;
    }
    deleteIn(path) {
      if (Collection.isEmptyPath(path)) {
        if (this.contents == null)
          return false;
        this.contents = null;
        return true;
      }
      return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
    }
    get(key, keepScalar) {
      return identity.isCollection(this.contents) ? this.contents.get(key, keepScalar) : undefined;
    }
    getIn(path, keepScalar) {
      if (Collection.isEmptyPath(path))
        return !keepScalar && identity.isScalar(this.contents) ? this.contents.value : this.contents;
      return identity.isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : undefined;
    }
    has(key) {
      return identity.isCollection(this.contents) ? this.contents.has(key) : false;
    }
    hasIn(path) {
      if (Collection.isEmptyPath(path))
        return this.contents !== undefined;
      return identity.isCollection(this.contents) ? this.contents.hasIn(path) : false;
    }
    set(key, value) {
      if (this.contents == null) {
        this.contents = Collection.collectionFromPath(this.schema, [key], value);
      } else if (assertCollection(this.contents)) {
        this.contents.set(key, value);
      }
    }
    setIn(path, value) {
      if (Collection.isEmptyPath(path)) {
        this.contents = value;
      } else if (this.contents == null) {
        this.contents = Collection.collectionFromPath(this.schema, Array.from(path), value);
      } else if (assertCollection(this.contents)) {
        this.contents.setIn(path, value);
      }
    }
    setSchema(version, options = {}) {
      if (typeof version === "number")
        version = String(version);
      let opt;
      switch (version) {
        case "1.1":
          if (this.directives)
            this.directives.yaml.version = "1.1";
          else
            this.directives = new directives.Directives({ version: "1.1" });
          opt = { resolveKnownTags: false, schema: "yaml-1.1" };
          break;
        case "1.2":
        case "next":
          if (this.directives)
            this.directives.yaml.version = version;
          else
            this.directives = new directives.Directives({ version });
          opt = { resolveKnownTags: true, schema: "core" };
          break;
        case null:
          if (this.directives)
            delete this.directives;
          opt = null;
          break;
        default: {
          const sv = JSON.stringify(version);
          throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
        }
      }
      if (options.schema instanceof Object)
        this.schema = options.schema;
      else if (opt)
        this.schema = new Schema.Schema(Object.assign(opt, options));
      else
        throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
    }
    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
      const ctx = {
        anchors: new Map,
        doc: this,
        keep: !json,
        mapAsMap: mapAsMap === true,
        mapKeyWarned: false,
        maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
      };
      const res = toJS.toJS(this.contents, jsonArg ?? "", ctx);
      if (typeof onAnchor === "function")
        for (const { count, res: res2 } of ctx.anchors.values())
          onAnchor(res2, count);
      return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
    }
    toJSON(jsonArg, onAnchor) {
      return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
    }
    toString(options = {}) {
      if (this.errors.length > 0)
        throw new Error("Document with errors cannot be stringified");
      if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
        const s = JSON.stringify(options.indent);
        throw new Error(`"indent" option must be a positive integer, not ${s}`);
      }
      return stringifyDocument.stringifyDocument(this, options);
    }
  }
  function assertCollection(contents) {
    if (identity.isCollection(contents))
      return true;
    throw new Error("Expected a YAML collection as document contents");
  }
  exports.Document = Document;
});

// node_modules/yaml/dist/errors.js
var require_errors = __commonJS((exports) => {
  class YAMLError extends Error {
    constructor(name, pos, code, message) {
      super();
      this.name = name;
      this.code = code;
      this.message = message;
      this.pos = pos;
    }
  }

  class YAMLParseError extends YAMLError {
    constructor(pos, code, message) {
      super("YAMLParseError", pos, code, message);
    }
  }

  class YAMLWarning extends YAMLError {
    constructor(pos, code, message) {
      super("YAMLWarning", pos, code, message);
    }
  }
  var prettifyError = (src, lc) => (error) => {
    if (error.pos[0] === -1)
      return;
    error.linePos = error.pos.map((pos) => lc.linePos(pos));
    const { line, col } = error.linePos[0];
    error.message += ` at line ${line}, column ${col}`;
    let ci = col - 1;
    let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
    if (ci >= 60 && lineStr.length > 80) {
      const trimStart = Math.min(ci - 39, lineStr.length - 79);
      lineStr = "" + lineStr.substring(trimStart);
      ci -= trimStart - 1;
    }
    if (lineStr.length > 80)
      lineStr = lineStr.substring(0, 79) + "";
    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
      let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
      if (prev.length > 80)
        prev = prev.substring(0, 79) + `
`;
      lineStr = prev + lineStr;
    }
    if (/[^ ]/.test(lineStr)) {
      let count = 1;
      const end = error.linePos[1];
      if (end?.line === line && end.col > col) {
        count = Math.max(1, Math.min(end.col - col, 80 - ci));
      }
      const pointer = " ".repeat(ci) + "^".repeat(count);
      error.message += `:

${lineStr}
${pointer}
`;
    }
  };
  exports.YAMLError = YAMLError;
  exports.YAMLParseError = YAMLParseError;
  exports.YAMLWarning = YAMLWarning;
  exports.prettifyError = prettifyError;
});

// node_modules/yaml/dist/compose/resolve-props.js
var require_resolve_props = __commonJS((exports) => {
  function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {
    let spaceBefore = false;
    let atNewline = startOnNewline;
    let hasSpace = startOnNewline;
    let comment = "";
    let commentSep = "";
    let hasNewline = false;
    let reqSpace = false;
    let tab = null;
    let anchor = null;
    let tag = null;
    let newlineAfterProp = null;
    let comma = null;
    let found = null;
    let start = null;
    for (const token of tokens) {
      if (reqSpace) {
        if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
          onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
        reqSpace = false;
      }
      if (tab) {
        if (atNewline && token.type !== "comment" && token.type !== "newline") {
          onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
        }
        tab = null;
      }
      switch (token.type) {
        case "space":
          if (!flow && (indicator !== "doc-start" || next?.type !== "flow-collection") && token.source.includes("\t")) {
            tab = token;
          }
          hasSpace = true;
          break;
        case "comment": {
          if (!hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = token.source.substring(1) || " ";
          if (!comment)
            comment = cb;
          else
            comment += commentSep + cb;
          commentSep = "";
          atNewline = false;
          break;
        }
        case "newline":
          if (atNewline) {
            if (comment)
              comment += token.source;
            else if (!found || indicator !== "seq-item-ind")
              spaceBefore = true;
          } else
            commentSep += token.source;
          atNewline = true;
          hasNewline = true;
          if (anchor || tag)
            newlineAfterProp = token;
          hasSpace = true;
          break;
        case "anchor":
          if (anchor)
            onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
          if (token.source.endsWith(":"))
            onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
          anchor = token;
          start ?? (start = token.offset);
          atNewline = false;
          hasSpace = false;
          reqSpace = true;
          break;
        case "tag": {
          if (tag)
            onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
          tag = token;
          start ?? (start = token.offset);
          atNewline = false;
          hasSpace = false;
          reqSpace = true;
          break;
        }
        case indicator:
          if (anchor || tag)
            onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
          if (found)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
          found = token;
          atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
          hasSpace = false;
          break;
        case "comma":
          if (flow) {
            if (comma)
              onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
            comma = token;
            atNewline = false;
            hasSpace = false;
            break;
          }
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
          atNewline = false;
          hasSpace = false;
      }
    }
    const last = tokens[tokens.length - 1];
    const end = last ? last.offset + last.source.length : offset;
    if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) {
      onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
    }
    if (tab && (atNewline && tab.indent <= parentIndent || next?.type === "block-map" || next?.type === "block-seq"))
      onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
    return {
      comma,
      found,
      spaceBefore,
      comment,
      hasNewline,
      anchor,
      tag,
      newlineAfterProp,
      end,
      start: start ?? end
    };
  }
  exports.resolveProps = resolveProps;
});

// node_modules/yaml/dist/compose/util-contains-newline.js
var require_util_contains_newline = __commonJS((exports) => {
  function containsNewline(key) {
    if (!key)
      return null;
    switch (key.type) {
      case "alias":
      case "scalar":
      case "double-quoted-scalar":
      case "single-quoted-scalar":
        if (key.source.includes(`
`))
          return true;
        if (key.end) {
          for (const st of key.end)
            if (st.type === "newline")
              return true;
        }
        return false;
      case "flow-collection":
        for (const it of key.items) {
          for (const st of it.start)
            if (st.type === "newline")
              return true;
          if (it.sep) {
            for (const st of it.sep)
              if (st.type === "newline")
                return true;
          }
          if (containsNewline(it.key) || containsNewline(it.value))
            return true;
        }
        return false;
      default:
        return true;
    }
  }
  exports.containsNewline = containsNewline;
});

// node_modules/yaml/dist/compose/util-flow-indent-check.js
var require_util_flow_indent_check = __commonJS((exports) => {
  var utilContainsNewline = require_util_contains_newline();
  function flowIndentCheck(indent, fc, onError) {
    if (fc?.type === "flow-collection") {
      const end = fc.end[0];
      if (end.indent === indent && (end.source === "]" || end.source === "}") && utilContainsNewline.containsNewline(fc)) {
        const msg = "Flow end indicator should be more indented than parent";
        onError(end, "BAD_INDENT", msg, true);
      }
    }
  }
  exports.flowIndentCheck = flowIndentCheck;
});

// node_modules/yaml/dist/compose/util-map-includes.js
var require_util_map_includes = __commonJS((exports) => {
  var identity = require_identity();
  function mapIncludes(ctx, items, search) {
    const { uniqueKeys } = ctx.options;
    if (uniqueKeys === false)
      return false;
    const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || identity.isScalar(a) && identity.isScalar(b) && a.value === b.value;
    return items.some((pair) => isEqual(pair.key, search));
  }
  exports.mapIncludes = mapIncludes;
});

// node_modules/yaml/dist/compose/resolve-block-map.js
var require_resolve_block_map = __commonJS((exports) => {
  var Pair = require_Pair();
  var YAMLMap = require_YAMLMap();
  var resolveProps = require_resolve_props();
  var utilContainsNewline = require_util_contains_newline();
  var utilFlowIndentCheck = require_util_flow_indent_check();
  var utilMapIncludes = require_util_map_includes();
  var startColMsg = "All mapping items must start at the same column";
  function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLMap.YAMLMap;
    const map = new NodeClass(ctx.schema);
    if (ctx.atRoot)
      ctx.atRoot = false;
    let offset = bm.offset;
    let commentEnd = null;
    for (const collItem of bm.items) {
      const { start, key, sep, value } = collItem;
      const keyProps = resolveProps.resolveProps(start, {
        indicator: "explicit-key-ind",
        next: key ?? sep?.[0],
        offset,
        onError,
        parentIndent: bm.indent,
        startOnNewline: true
      });
      const implicitKey = !keyProps.found;
      if (implicitKey) {
        if (key) {
          if (key.type === "block-seq")
            onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
          else if ("indent" in key && key.indent !== bm.indent)
            onError(offset, "BAD_INDENT", startColMsg);
        }
        if (!keyProps.anchor && !keyProps.tag && !sep) {
          commentEnd = keyProps.end;
          if (keyProps.comment) {
            if (map.comment)
              map.comment += `
` + keyProps.comment;
            else
              map.comment = keyProps.comment;
          }
          continue;
        }
        if (keyProps.newlineAfterProp || utilContainsNewline.containsNewline(key)) {
          onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
        }
      } else if (keyProps.found?.indent !== bm.indent) {
        onError(offset, "BAD_INDENT", startColMsg);
      }
      ctx.atKey = true;
      const keyStart = keyProps.end;
      const keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
      if (ctx.schema.compat)
        utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);
      ctx.atKey = false;
      if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
        onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
      const valueProps = resolveProps.resolveProps(sep ?? [], {
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        parentIndent: bm.indent,
        startOnNewline: !key || key.type === "block-scalar"
      });
      offset = valueProps.end;
      if (valueProps.found) {
        if (implicitKey) {
          if (value?.type === "block-map" && !valueProps.hasNewline)
            onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
          if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
            onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
        }
        const valueNode = value ? composeNode(ctx, value, valueProps, onError) : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError);
        offset = valueNode.range[2];
        const pair = new Pair.Pair(keyNode, valueNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        map.items.push(pair);
      } else {
        if (implicitKey)
          onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
        if (valueProps.comment) {
          if (keyNode.comment)
            keyNode.comment += `
` + valueProps.comment;
          else
            keyNode.comment = valueProps.comment;
        }
        const pair = new Pair.Pair(keyNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        map.items.push(pair);
      }
    }
    if (commentEnd && commentEnd < offset)
      onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
    map.range = [bm.offset, offset, commentEnd ?? offset];
    return map;
  }
  exports.resolveBlockMap = resolveBlockMap;
});

// node_modules/yaml/dist/compose/resolve-block-seq.js
var require_resolve_block_seq = __commonJS((exports) => {
  var YAMLSeq = require_YAMLSeq();
  var resolveProps = require_resolve_props();
  var utilFlowIndentCheck = require_util_flow_indent_check();
  function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLSeq.YAMLSeq;
    const seq = new NodeClass(ctx.schema);
    if (ctx.atRoot)
      ctx.atRoot = false;
    if (ctx.atKey)
      ctx.atKey = false;
    let offset = bs.offset;
    let commentEnd = null;
    for (const { start, value } of bs.items) {
      const props = resolveProps.resolveProps(start, {
        indicator: "seq-item-ind",
        next: value,
        offset,
        onError,
        parentIndent: bs.indent,
        startOnNewline: true
      });
      if (!props.found) {
        if (props.anchor || props.tag || value) {
          if (value?.type === "block-seq")
            onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
          else
            onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
        } else {
          commentEnd = props.end;
          if (props.comment)
            seq.comment = props.comment;
          continue;
        }
      }
      const node = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
      if (ctx.schema.compat)
        utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError);
      offset = node.range[2];
      seq.items.push(node);
    }
    seq.range = [bs.offset, offset, commentEnd ?? offset];
    return seq;
  }
  exports.resolveBlockSeq = resolveBlockSeq;
});

// node_modules/yaml/dist/compose/resolve-end.js
var require_resolve_end = __commonJS((exports) => {
  function resolveEnd(end, offset, reqSpace, onError) {
    let comment = "";
    if (end) {
      let hasSpace = false;
      let sep = "";
      for (const token of end) {
        const { source, type } = token;
        switch (type) {
          case "space":
            hasSpace = true;
            break;
          case "comment": {
            if (reqSpace && !hasSpace)
              onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
            const cb = source.substring(1) || " ";
            if (!comment)
              comment = cb;
            else
              comment += sep + cb;
            sep = "";
            break;
          }
          case "newline":
            if (comment)
              sep += source;
            hasSpace = true;
            break;
          default:
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
        }
        offset += source.length;
      }
    }
    return { comment, offset };
  }
  exports.resolveEnd = resolveEnd;
});

// node_modules/yaml/dist/compose/resolve-flow-collection.js
var require_resolve_flow_collection = __commonJS((exports) => {
  var identity = require_identity();
  var Pair = require_Pair();
  var YAMLMap = require_YAMLMap();
  var YAMLSeq = require_YAMLSeq();
  var resolveEnd = require_resolve_end();
  var resolveProps = require_resolve_props();
  var utilContainsNewline = require_util_contains_newline();
  var utilMapIncludes = require_util_map_includes();
  var blockMsg = "Block collections are not allowed within flow collections";
  var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
  function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {
    const isMap = fc.start.source === "{";
    const fcName = isMap ? "flow map" : "flow sequence";
    const NodeClass = tag?.nodeClass ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq);
    const coll = new NodeClass(ctx.schema);
    coll.flow = true;
    const atRoot = ctx.atRoot;
    if (atRoot)
      ctx.atRoot = false;
    if (ctx.atKey)
      ctx.atKey = false;
    let offset = fc.offset + fc.start.source.length;
    for (let i = 0;i < fc.items.length; ++i) {
      const collItem = fc.items[i];
      const { start, key, sep, value } = collItem;
      const props = resolveProps.resolveProps(start, {
        flow: fcName,
        indicator: "explicit-key-ind",
        next: key ?? sep?.[0],
        offset,
        onError,
        parentIndent: fc.indent,
        startOnNewline: false
      });
      if (!props.found) {
        if (!props.anchor && !props.tag && !sep && !value) {
          if (i === 0 && props.comma)
            onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
          else if (i < fc.items.length - 1)
            onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
          if (props.comment) {
            if (coll.comment)
              coll.comment += `
` + props.comment;
            else
              coll.comment = props.comment;
          }
          offset = props.end;
          continue;
        }
        if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))
          onError(key, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
      }
      if (i === 0) {
        if (props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
      } else {
        if (!props.comma)
          onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
        if (props.comment) {
          let prevItemComment = "";
          loop:
            for (const st of start) {
              switch (st.type) {
                case "comma":
                case "space":
                  break;
                case "comment":
                  prevItemComment = st.source.substring(1);
                  break loop;
                default:
                  break loop;
              }
            }
          if (prevItemComment) {
            let prev = coll.items[coll.items.length - 1];
            if (identity.isPair(prev))
              prev = prev.value ?? prev.key;
            if (prev.comment)
              prev.comment += `
` + prevItemComment;
            else
              prev.comment = prevItemComment;
            props.comment = props.comment.substring(prevItemComment.length + 1);
          }
        }
      }
      if (!isMap && !sep && !props.found) {
        const valueNode = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, sep, null, props, onError);
        coll.items.push(valueNode);
        offset = valueNode.range[2];
        if (isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else {
        ctx.atKey = true;
        const keyStart = props.end;
        const keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);
        if (isBlock(key))
          onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
        ctx.atKey = false;
        const valueProps = resolveProps.resolveProps(sep ?? [], {
          flow: fcName,
          indicator: "map-value-ind",
          next: value,
          offset: keyNode.range[2],
          onError,
          parentIndent: fc.indent,
          startOnNewline: false
        });
        if (valueProps.found) {
          if (!isMap && !props.found && ctx.options.strict) {
            if (sep)
              for (const st of sep) {
                if (st === valueProps.found)
                  break;
                if (st.type === "newline") {
                  onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                  break;
                }
              }
            if (props.start < valueProps.found.offset - 1024)
              onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
          }
        } else if (value) {
          if ("source" in value && value.source?.[0] === ":")
            onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
          else
            onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
        }
        const valueNode = value ? composeNode(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError) : null;
        if (valueNode) {
          if (isBlock(value))
            onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
        } else if (valueProps.comment) {
          if (keyNode.comment)
            keyNode.comment += `
` + valueProps.comment;
          else
            keyNode.comment = valueProps.comment;
        }
        const pair = new Pair.Pair(keyNode, valueNode);
        if (ctx.options.keepSourceTokens)
          pair.srcToken = collItem;
        if (isMap) {
          const map = coll;
          if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
            onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
          map.items.push(pair);
        } else {
          const map = new YAMLMap.YAMLMap(ctx.schema);
          map.flow = true;
          map.items.push(pair);
          const endRange = (valueNode ?? keyNode).range;
          map.range = [keyNode.range[0], endRange[1], endRange[2]];
          coll.items.push(map);
        }
        offset = valueNode ? valueNode.range[2] : valueProps.end;
      }
    }
    const expectedEnd = isMap ? "}" : "]";
    const [ce, ...ee] = fc.end;
    let cePos = offset;
    if (ce?.source === expectedEnd)
      cePos = ce.offset + ce.source.length;
    else {
      const name = fcName[0].toUpperCase() + fcName.substring(1);
      const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
      onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
      if (ce && ce.source.length !== 1)
        ee.unshift(ce);
    }
    if (ee.length > 0) {
      const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
      if (end.comment) {
        if (coll.comment)
          coll.comment += `
` + end.comment;
        else
          coll.comment = end.comment;
      }
      coll.range = [fc.offset, cePos, end.offset];
    } else {
      coll.range = [fc.offset, cePos, cePos];
    }
    return coll;
  }
  exports.resolveFlowCollection = resolveFlowCollection;
});

// node_modules/yaml/dist/compose/compose-collection.js
var require_compose_collection = __commonJS((exports) => {
  var identity = require_identity();
  var Scalar = require_Scalar();
  var YAMLMap = require_YAMLMap();
  var YAMLSeq = require_YAMLSeq();
  var resolveBlockMap = require_resolve_block_map();
  var resolveBlockSeq = require_resolve_block_seq();
  var resolveFlowCollection = require_resolve_flow_collection();
  function resolveCollection(CN, ctx, token, onError, tagName, tag) {
    const coll = token.type === "block-map" ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError, tag) : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError, tag);
    const Coll = coll.constructor;
    if (tagName === "!" || tagName === Coll.tagName) {
      coll.tag = Coll.tagName;
      return coll;
    }
    if (tagName)
      coll.tag = tagName;
    return coll;
  }
  function composeCollection(CN, ctx, token, props, onError) {
    const tagToken = props.tag;
    const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
    if (token.type === "block-seq") {
      const { anchor, newlineAfterProp: nl } = props;
      const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
      if (lastProp && (!nl || nl.offset < lastProp.offset)) {
        const message = "Missing newline after block sequence props";
        onError(lastProp, "MISSING_CHAR", message);
      }
    }
    const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
    if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.YAMLSeq.tagName && expType === "seq") {
      return resolveCollection(CN, ctx, token, onError, tagName);
    }
    let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
    if (!tag) {
      const kt = ctx.schema.knownTags[tagName];
      if (kt?.collection === expType) {
        ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
        tag = kt;
      } else {
        if (kt) {
          onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? "scalar"}`, true);
        } else {
          onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
        }
        return resolveCollection(CN, ctx, token, onError, tagName);
      }
    }
    const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);
    const res = tag.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
    const node = identity.isNode(res) ? res : new Scalar.Scalar(res);
    node.range = coll.range;
    node.tag = tagName;
    if (tag?.format)
      node.format = tag.format;
    return node;
  }
  exports.composeCollection = composeCollection;
});

// node_modules/yaml/dist/compose/resolve-block-scalar.js
var require_resolve_block_scalar = __commonJS((exports) => {
  var Scalar = require_Scalar();
  function resolveBlockScalar(ctx, scalar, onError) {
    const start = scalar.offset;
    const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
    if (!header)
      return { value: "", type: null, comment: "", range: [start, start, start] };
    const type = header.mode === ">" ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
    const lines = scalar.source ? splitLines(scalar.source) : [];
    let chompStart = lines.length;
    for (let i = lines.length - 1;i >= 0; --i) {
      const content = lines[i][1];
      if (content === "" || content === "\r")
        chompStart = i;
      else
        break;
    }
    if (chompStart === 0) {
      const value2 = header.chomp === "+" && lines.length > 0 ? `
`.repeat(Math.max(1, lines.length - 1)) : "";
      let end2 = start + header.length;
      if (scalar.source)
        end2 += scalar.source.length;
      return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
    }
    let trimIndent = scalar.indent + header.indent;
    let offset = scalar.offset + header.length;
    let contentStart = 0;
    for (let i = 0;i < chompStart; ++i) {
      const [indent, content] = lines[i];
      if (content === "" || content === "\r") {
        if (header.indent === 0 && indent.length > trimIndent)
          trimIndent = indent.length;
      } else {
        if (indent.length < trimIndent) {
          const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
          onError(offset + indent.length, "MISSING_CHAR", message);
        }
        if (header.indent === 0)
          trimIndent = indent.length;
        contentStart = i;
        if (trimIndent === 0 && !ctx.atRoot) {
          const message = "Block scalar values in collections must be indented";
          onError(offset, "BAD_INDENT", message);
        }
        break;
      }
      offset += indent.length + content.length + 1;
    }
    for (let i = lines.length - 1;i >= chompStart; --i) {
      if (lines[i][0].length > trimIndent)
        chompStart = i + 1;
    }
    let value = "";
    let sep = "";
    let prevMoreIndented = false;
    for (let i = 0;i < contentStart; ++i)
      value += lines[i][0].slice(trimIndent) + `
`;
    for (let i = contentStart;i < chompStart; ++i) {
      let [indent, content] = lines[i];
      offset += indent.length + content.length + 1;
      const crlf = content[content.length - 1] === "\r";
      if (crlf)
        content = content.slice(0, -1);
      if (content && indent.length < trimIndent) {
        const src = header.indent ? "explicit indentation indicator" : "first line";
        const message = `Block scalar lines must not be less indented than their ${src}`;
        onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
        indent = "";
      }
      if (type === Scalar.Scalar.BLOCK_LITERAL) {
        value += sep + indent.slice(trimIndent) + content;
        sep = `
`;
      } else if (indent.length > trimIndent || content[0] === "\t") {
        if (sep === " ")
          sep = `
`;
        else if (!prevMoreIndented && sep === `
`)
          sep = `

`;
        value += sep + indent.slice(trimIndent) + content;
        sep = `
`;
        prevMoreIndented = true;
      } else if (content === "") {
        if (sep === `
`)
          value += `
`;
        else
          sep = `
`;
      } else {
        value += sep + content;
        sep = " ";
        prevMoreIndented = false;
      }
    }
    switch (header.chomp) {
      case "-":
        break;
      case "+":
        for (let i = chompStart;i < lines.length; ++i)
          value += `
` + lines[i][0].slice(trimIndent);
        if (value[value.length - 1] !== `
`)
          value += `
`;
        break;
      default:
        value += `
`;
    }
    const end = start + header.length + scalar.source.length;
    return { value, type, comment: header.comment, range: [start, end, end] };
  }
  function parseBlockScalarHeader({ offset, props }, strict, onError) {
    if (props[0].type !== "block-scalar-header") {
      onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
      return null;
    }
    const { source } = props[0];
    const mode = source[0];
    let indent = 0;
    let chomp = "";
    let error = -1;
    for (let i = 1;i < source.length; ++i) {
      const ch = source[i];
      if (!chomp && (ch === "-" || ch === "+"))
        chomp = ch;
      else {
        const n = Number(ch);
        if (!indent && n)
          indent = n;
        else if (error === -1)
          error = offset + i;
      }
    }
    if (error !== -1)
      onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
    let hasSpace = false;
    let comment = "";
    let length = source.length;
    for (let i = 1;i < props.length; ++i) {
      const token = props[i];
      switch (token.type) {
        case "space":
          hasSpace = true;
        case "newline":
          length += token.source.length;
          break;
        case "comment":
          if (strict && !hasSpace) {
            const message = "Comments must be separated from other tokens by white space characters";
            onError(token, "MISSING_CHAR", message);
          }
          length += token.source.length;
          comment = token.source.substring(1);
          break;
        case "error":
          onError(token, "UNEXPECTED_TOKEN", token.message);
          length += token.source.length;
          break;
        default: {
          const message = `Unexpected token in block scalar header: ${token.type}`;
          onError(token, "UNEXPECTED_TOKEN", message);
          const ts = token.source;
          if (ts && typeof ts === "string")
            length += ts.length;
        }
      }
    }
    return { mode, indent, chomp, comment, length };
  }
  function splitLines(source) {
    const split = source.split(/\n( *)/);
    const first = split[0];
    const m = first.match(/^( *)/);
    const line0 = m?.[1] ? [m[1], first.slice(m[1].length)] : ["", first];
    const lines = [line0];
    for (let i = 1;i < split.length; i += 2)
      lines.push([split[i], split[i + 1]]);
    return lines;
  }
  exports.resolveBlockScalar = resolveBlockScalar;
});

// node_modules/yaml/dist/compose/resolve-flow-scalar.js
var require_resolve_flow_scalar = __commonJS((exports) => {
  var Scalar = require_Scalar();
  var resolveEnd = require_resolve_end();
  function resolveFlowScalar(scalar, strict, onError) {
    const { offset, type, source, end } = scalar;
    let _type;
    let value;
    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
    switch (type) {
      case "scalar":
        _type = Scalar.Scalar.PLAIN;
        value = plainValue(source, _onError);
        break;
      case "single-quoted-scalar":
        _type = Scalar.Scalar.QUOTE_SINGLE;
        value = singleQuotedValue(source, _onError);
        break;
      case "double-quoted-scalar":
        _type = Scalar.Scalar.QUOTE_DOUBLE;
        value = doubleQuotedValue(source, _onError);
        break;
      default:
        onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
        return {
          value: "",
          type: null,
          comment: "",
          range: [offset, offset + source.length, offset + source.length]
        };
    }
    const valueEnd = offset + source.length;
    const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
    return {
      value,
      type: _type,
      comment: re.comment,
      range: [offset, valueEnd, re.offset]
    };
  }
  function plainValue(source, onError) {
    let badChar = "";
    switch (source[0]) {
      case "\t":
        badChar = "a tab character";
        break;
      case ",":
        badChar = "flow indicator character ,";
        break;
      case "%":
        badChar = "directive indicator character %";
        break;
      case "|":
      case ">": {
        badChar = `block scalar indicator ${source[0]}`;
        break;
      }
      case "@":
      case "`": {
        badChar = `reserved character ${source[0]}`;
        break;
      }
    }
    if (badChar)
      onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
    return foldLines(source);
  }
  function singleQuotedValue(source, onError) {
    if (source[source.length - 1] !== "'" || source.length === 1)
      onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
    return foldLines(source.slice(1, -1)).replace(/''/g, "'");
  }
  function foldLines(source) {
    let first, line;
    try {
      first = new RegExp(`(.*?)(?<![ 	])[ 	]*\r?
`, "sy");
      line = new RegExp(`[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?
`, "sy");
    } catch {
      first = /(.*?)[ \t]*\r?\n/sy;
      line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
    }
    let match = first.exec(source);
    if (!match)
      return source;
    let res = match[1];
    let sep = " ";
    let pos = first.lastIndex;
    line.lastIndex = pos;
    while (match = line.exec(source)) {
      if (match[1] === "") {
        if (sep === `
`)
          res += sep;
        else
          sep = `
`;
      } else {
        res += sep + match[1];
        sep = " ";
      }
      pos = line.lastIndex;
    }
    const last = /[ \t]*(.*)/sy;
    last.lastIndex = pos;
    match = last.exec(source);
    return res + sep + (match?.[1] ?? "");
  }
  function doubleQuotedValue(source, onError) {
    let res = "";
    for (let i = 1;i < source.length - 1; ++i) {
      const ch = source[i];
      if (ch === "\r" && source[i + 1] === `
`)
        continue;
      if (ch === `
`) {
        const { fold, offset } = foldNewline(source, i);
        res += fold;
        i = offset;
      } else if (ch === "\\") {
        let next = source[++i];
        const cc = escapeCodes[next];
        if (cc)
          res += cc;
        else if (next === `
`) {
          next = source[i + 1];
          while (next === " " || next === "\t")
            next = source[++i + 1];
        } else if (next === "\r" && source[i + 1] === `
`) {
          next = source[++i + 1];
          while (next === " " || next === "\t")
            next = source[++i + 1];
        } else if (next === "x" || next === "u" || next === "U") {
          const length = { x: 2, u: 4, U: 8 }[next];
          res += parseCharCode(source, i + 1, length, onError);
          i += length;
        } else {
          const raw = source.substr(i - 1, 2);
          onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
          res += raw;
        }
      } else if (ch === " " || ch === "\t") {
        const wsStart = i;
        let next = source[i + 1];
        while (next === " " || next === "\t")
          next = source[++i + 1];
        if (next !== `
` && !(next === "\r" && source[i + 2] === `
`))
          res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
      } else {
        res += ch;
      }
    }
    if (source[source.length - 1] !== '"' || source.length === 1)
      onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
    return res;
  }
  function foldNewline(source, offset) {
    let fold = "";
    let ch = source[offset + 1];
    while (ch === " " || ch === "\t" || ch === `
` || ch === "\r") {
      if (ch === "\r" && source[offset + 2] !== `
`)
        break;
      if (ch === `
`)
        fold += `
`;
      offset += 1;
      ch = source[offset + 1];
    }
    if (!fold)
      fold = " ";
    return { fold, offset };
  }
  var escapeCodes = {
    "0": "\x00",
    a: "\x07",
    b: "\b",
    e: "\x1B",
    f: "\f",
    n: `
`,
    r: "\r",
    t: "\t",
    v: "\v",
    N: "",
    _: "",
    L: "\u2028",
    P: "\u2029",
    " ": " ",
    '"': '"',
    "/": "/",
    "\\": "\\",
    "\t": "\t"
  };
  function parseCharCode(source, offset, length, onError) {
    const cc = source.substr(offset, length);
    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
    const code = ok ? parseInt(cc, 16) : NaN;
    if (isNaN(code)) {
      const raw = source.substr(offset - 2, length + 2);
      onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
      return raw;
    }
    return String.fromCodePoint(code);
  }
  exports.resolveFlowScalar = resolveFlowScalar;
});

// node_modules/yaml/dist/compose/compose-scalar.js
var require_compose_scalar = __commonJS((exports) => {
  var identity = require_identity();
  var Scalar = require_Scalar();
  var resolveBlockScalar = require_resolve_block_scalar();
  var resolveFlowScalar = require_resolve_flow_scalar();
  function composeScalar(ctx, token, tagToken, onError) {
    const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar.resolveBlockScalar(ctx, token, onError) : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);
    const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
    let tag;
    if (ctx.options.stringKeys && ctx.atKey) {
      tag = ctx.schema[identity.SCALAR];
    } else if (tagName)
      tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
    else if (token.type === "scalar")
      tag = findScalarTagByTest(ctx, value, token, onError);
    else
      tag = ctx.schema[identity.SCALAR];
    let scalar;
    try {
      const res = tag.resolve(value, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
      scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);
    } catch (error) {
      const msg = error instanceof Error ? error.message : String(error);
      onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
      scalar = new Scalar.Scalar(value);
    }
    scalar.range = range;
    scalar.source = value;
    if (type)
      scalar.type = type;
    if (tagName)
      scalar.tag = tagName;
    if (tag.format)
      scalar.format = tag.format;
    if (comment)
      scalar.comment = comment;
    return scalar;
  }
  function findScalarTagByName(schema, value, tagName, tagToken, onError) {
    if (tagName === "!")
      return schema[identity.SCALAR];
    const matchWithTest = [];
    for (const tag of schema.tags) {
      if (!tag.collection && tag.tag === tagName) {
        if (tag.default && tag.test)
          matchWithTest.push(tag);
        else
          return tag;
      }
    }
    for (const tag of matchWithTest)
      if (tag.test?.test(value))
        return tag;
    const kt = schema.knownTags[tagName];
    if (kt && !kt.collection) {
      schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));
      return kt;
    }
    onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
    return schema[identity.SCALAR];
  }
  function findScalarTagByTest({ atKey, directives, schema }, value, token, onError) {
    const tag = schema.tags.find((tag2) => (tag2.default === true || atKey && tag2.default === "key") && tag2.test?.test(value)) || schema[identity.SCALAR];
    if (schema.compat) {
      const compat = schema.compat.find((tag2) => tag2.default && tag2.test?.test(value)) ?? schema[identity.SCALAR];
      if (tag.tag !== compat.tag) {
        const ts = directives.tagString(tag.tag);
        const cs = directives.tagString(compat.tag);
        const msg = `Value may be parsed as either ${ts} or ${cs}`;
        onError(token, "TAG_RESOLVE_FAILED", msg, true);
      }
    }
    return tag;
  }
  exports.composeScalar = composeScalar;
});

// node_modules/yaml/dist/compose/util-empty-scalar-position.js
var require_util_empty_scalar_position = __commonJS((exports) => {
  function emptyScalarPosition(offset, before, pos) {
    if (before) {
      pos ?? (pos = before.length);
      for (let i = pos - 1;i >= 0; --i) {
        let st = before[i];
        switch (st.type) {
          case "space":
          case "comment":
          case "newline":
            offset -= st.source.length;
            continue;
        }
        st = before[++i];
        while (st?.type === "space") {
          offset += st.source.length;
          st = before[++i];
        }
        break;
      }
    }
    return offset;
  }
  exports.emptyScalarPosition = emptyScalarPosition;
});

// node_modules/yaml/dist/compose/compose-node.js
var require_compose_node = __commonJS((exports) => {
  var Alias = require_Alias();
  var identity = require_identity();
  var composeCollection = require_compose_collection();
  var composeScalar = require_compose_scalar();
  var resolveEnd = require_resolve_end();
  var utilEmptyScalarPosition = require_util_empty_scalar_position();
  var CN = { composeNode, composeEmptyNode };
  function composeNode(ctx, token, props, onError) {
    const atKey = ctx.atKey;
    const { spaceBefore, comment, anchor, tag } = props;
    let node;
    let isSrcToken = true;
    switch (token.type) {
      case "alias":
        node = composeAlias(ctx, token, onError);
        if (anchor || tag)
          onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
        break;
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
      case "block-scalar":
        node = composeScalar.composeScalar(ctx, token, tag, onError);
        if (anchor)
          node.anchor = anchor.source.substring(1);
        break;
      case "block-map":
      case "block-seq":
      case "flow-collection":
        node = composeCollection.composeCollection(CN, ctx, token, props, onError);
        if (anchor)
          node.anchor = anchor.source.substring(1);
        break;
      default: {
        const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
        onError(token, "UNEXPECTED_TOKEN", message);
        node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);
        isSrcToken = false;
      }
    }
    if (anchor && node.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
    if (atKey && ctx.options.stringKeys && (!identity.isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) {
      const msg = "With stringKeys, all keys must be strings";
      onError(tag ?? token, "NON_STRING_KEY", msg);
    }
    if (spaceBefore)
      node.spaceBefore = true;
    if (comment) {
      if (token.type === "scalar" && token.source === "")
        node.comment = comment;
      else
        node.commentBefore = comment;
    }
    if (ctx.options.keepSourceTokens && isSrcToken)
      node.srcToken = token;
    return node;
  }
  function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
    const token = {
      type: "scalar",
      offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
      indent: -1,
      source: ""
    };
    const node = composeScalar.composeScalar(ctx, token, tag, onError);
    if (anchor) {
      node.anchor = anchor.source.substring(1);
      if (node.anchor === "")
        onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
    }
    if (spaceBefore)
      node.spaceBefore = true;
    if (comment) {
      node.comment = comment;
      node.range[2] = end;
    }
    return node;
  }
  function composeAlias({ options }, { offset, source, end }, onError) {
    const alias = new Alias.Alias(source.substring(1));
    if (alias.source === "")
      onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
    if (alias.source.endsWith(":"))
      onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
    const valueEnd = offset + source.length;
    const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
    alias.range = [offset, valueEnd, re.offset];
    if (re.comment)
      alias.comment = re.comment;
    return alias;
  }
  exports.composeEmptyNode = composeEmptyNode;
  exports.composeNode = composeNode;
});

// node_modules/yaml/dist/compose/compose-doc.js
var require_compose_doc = __commonJS((exports) => {
  var Document = require_Document();
  var composeNode = require_compose_node();
  var resolveEnd = require_resolve_end();
  var resolveProps = require_resolve_props();
  function composeDoc(options, directives, { offset, start, value, end }, onError) {
    const opts = Object.assign({ _directives: directives }, options);
    const doc = new Document.Document(undefined, opts);
    const ctx = {
      atKey: false,
      atRoot: true,
      directives: doc.directives,
      options: doc.options,
      schema: doc.schema
    };
    const props = resolveProps.resolveProps(start, {
      indicator: "doc-start",
      next: value ?? end?.[0],
      offset,
      onError,
      parentIndent: 0,
      startOnNewline: true
    });
    if (props.found) {
      doc.directives.docStart = true;
      if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
        onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
    }
    doc.contents = value ? composeNode.composeNode(ctx, value, props, onError) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
    const contentEnd = doc.contents.range[2];
    const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);
    if (re.comment)
      doc.comment = re.comment;
    doc.range = [offset, contentEnd, re.offset];
    return doc;
  }
  exports.composeDoc = composeDoc;
});

// node_modules/yaml/dist/compose/composer.js
var require_composer = __commonJS((exports) => {
  var node_process = __require("process");
  var directives = require_directives();
  var Document = require_Document();
  var errors = require_errors();
  var identity = require_identity();
  var composeDoc = require_compose_doc();
  var resolveEnd = require_resolve_end();
  function getErrorPos(src) {
    if (typeof src === "number")
      return [src, src + 1];
    if (Array.isArray(src))
      return src.length === 2 ? src : [src[0], src[1]];
    const { offset, source } = src;
    return [offset, offset + (typeof source === "string" ? source.length : 1)];
  }
  function parsePrelude(prelude) {
    let comment = "";
    let atComment = false;
    let afterEmptyLine = false;
    for (let i = 0;i < prelude.length; ++i) {
      const source = prelude[i];
      switch (source[0]) {
        case "#":
          comment += (comment === "" ? "" : afterEmptyLine ? `

` : `
`) + (source.substring(1) || " ");
          atComment = true;
          afterEmptyLine = false;
          break;
        case "%":
          if (prelude[i + 1]?.[0] !== "#")
            i += 1;
          atComment = false;
          break;
        default:
          if (!atComment)
            afterEmptyLine = true;
          atComment = false;
      }
    }
    return { comment, afterEmptyLine };
  }

  class Composer {
    constructor(options = {}) {
      this.doc = null;
      this.atDirectives = false;
      this.prelude = [];
      this.errors = [];
      this.warnings = [];
      this.onError = (source, code, message, warning) => {
        const pos = getErrorPos(source);
        if (warning)
          this.warnings.push(new errors.YAMLWarning(pos, code, message));
        else
          this.errors.push(new errors.YAMLParseError(pos, code, message));
      };
      this.directives = new directives.Directives({ version: options.version || "1.2" });
      this.options = options;
    }
    decorate(doc, afterDoc) {
      const { comment, afterEmptyLine } = parsePrelude(this.prelude);
      if (comment) {
        const dc = doc.contents;
        if (afterDoc) {
          doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
        } else if (afterEmptyLine || doc.directives.docStart || !dc) {
          doc.commentBefore = comment;
        } else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {
          let it = dc.items[0];
          if (identity.isPair(it))
            it = it.key;
          const cb = it.commentBefore;
          it.commentBefore = cb ? `${comment}
${cb}` : comment;
        } else {
          const cb = dc.commentBefore;
          dc.commentBefore = cb ? `${comment}
${cb}` : comment;
        }
      }
      if (afterDoc) {
        Array.prototype.push.apply(doc.errors, this.errors);
        Array.prototype.push.apply(doc.warnings, this.warnings);
      } else {
        doc.errors = this.errors;
        doc.warnings = this.warnings;
      }
      this.prelude = [];
      this.errors = [];
      this.warnings = [];
    }
    streamInfo() {
      return {
        comment: parsePrelude(this.prelude).comment,
        directives: this.directives,
        errors: this.errors,
        warnings: this.warnings
      };
    }
    *compose(tokens, forceDoc = false, endOffset = -1) {
      for (const token of tokens)
        yield* this.next(token);
      yield* this.end(forceDoc, endOffset);
    }
    *next(token) {
      if (node_process.env.LOG_STREAM)
        console.dir(token, { depth: null });
      switch (token.type) {
        case "directive":
          this.directives.add(token.source, (offset, message, warning) => {
            const pos = getErrorPos(token);
            pos[0] += offset;
            this.onError(pos, "BAD_DIRECTIVE", message, warning);
          });
          this.prelude.push(token.source);
          this.atDirectives = true;
          break;
        case "document": {
          const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
          if (this.atDirectives && !doc.directives.docStart)
            this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
          this.decorate(doc, false);
          if (this.doc)
            yield this.doc;
          this.doc = doc;
          this.atDirectives = false;
          break;
        }
        case "byte-order-mark":
        case "space":
          break;
        case "comment":
        case "newline":
          this.prelude.push(token.source);
          break;
        case "error": {
          const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
          const error = new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
          if (this.atDirectives || !this.doc)
            this.errors.push(error);
          else
            this.doc.errors.push(error);
          break;
        }
        case "doc-end": {
          if (!this.doc) {
            const msg = "Unexpected doc-end without preceding document";
            this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
            break;
          }
          this.doc.directives.docEnd = true;
          const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
          this.decorate(this.doc, true);
          if (end.comment) {
            const dc = this.doc.comment;
            this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
          }
          this.doc.range[2] = end.offset;
          break;
        }
        default:
          this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
      }
    }
    *end(forceDoc = false, endOffset = -1) {
      if (this.doc) {
        this.decorate(this.doc, true);
        yield this.doc;
        this.doc = null;
      } else if (forceDoc) {
        const opts = Object.assign({ _directives: this.directives }, this.options);
        const doc = new Document.Document(undefined, opts);
        if (this.atDirectives)
          this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
        doc.range = [0, endOffset, endOffset];
        this.decorate(doc, false);
        yield doc;
      }
    }
  }
  exports.Composer = Composer;
});

// node_modules/yaml/dist/parse/cst-scalar.js
var require_cst_scalar = __commonJS((exports) => {
  var resolveBlockScalar = require_resolve_block_scalar();
  var resolveFlowScalar = require_resolve_flow_scalar();
  var errors = require_errors();
  var stringifyString = require_stringifyString();
  function resolveAsScalar(token, strict = true, onError) {
    if (token) {
      const _onError = (pos, code, message) => {
        const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
        if (onError)
          onError(offset, code, message);
        else
          throw new errors.YAMLParseError([offset, offset + 1], code, message);
      };
      switch (token.type) {
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
        case "block-scalar":
          return resolveBlockScalar.resolveBlockScalar({ options: { strict } }, token, _onError);
      }
    }
    return null;
  }
  function createScalarToken(value, context) {
    const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context;
    const source = stringifyString.stringifyString({ type, value }, {
      implicitKey,
      indent: indent > 0 ? " ".repeat(indent) : "",
      inFlow,
      options: { blockQuote: true, lineWidth: -1 }
    });
    const end = context.end ?? [
      { type: "newline", offset: -1, indent, source: `
` }
    ];
    switch (source[0]) {
      case "|":
      case ">": {
        const he = source.indexOf(`
`);
        const head = source.substring(0, he);
        const body = source.substring(he + 1) + `
`;
        const props = [
          { type: "block-scalar-header", offset, indent, source: head }
        ];
        if (!addEndtoBlockProps(props, end))
          props.push({ type: "newline", offset: -1, indent, source: `
` });
        return { type: "block-scalar", offset, indent, props, source: body };
      }
      case '"':
        return { type: "double-quoted-scalar", offset, indent, source, end };
      case "'":
        return { type: "single-quoted-scalar", offset, indent, source, end };
      default:
        return { type: "scalar", offset, indent, source, end };
    }
  }
  function setScalarValue(token, value, context = {}) {
    let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
    let indent = "indent" in token ? token.indent : null;
    if (afterKey && typeof indent === "number")
      indent += 2;
    if (!type)
      switch (token.type) {
        case "single-quoted-scalar":
          type = "QUOTE_SINGLE";
          break;
        case "double-quoted-scalar":
          type = "QUOTE_DOUBLE";
          break;
        case "block-scalar": {
          const header = token.props[0];
          if (header.type !== "block-scalar-header")
            throw new Error("Invalid block scalar header");
          type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
          break;
        }
        default:
          type = "PLAIN";
      }
    const source = stringifyString.stringifyString({ type, value }, {
      implicitKey: implicitKey || indent === null,
      indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
      inFlow,
      options: { blockQuote: true, lineWidth: -1 }
    });
    switch (source[0]) {
      case "|":
      case ">":
        setBlockScalarValue(token, source);
        break;
      case '"':
        setFlowScalarValue(token, source, "double-quoted-scalar");
        break;
      case "'":
        setFlowScalarValue(token, source, "single-quoted-scalar");
        break;
      default:
        setFlowScalarValue(token, source, "scalar");
    }
  }
  function setBlockScalarValue(token, source) {
    const he = source.indexOf(`
`);
    const head = source.substring(0, he);
    const body = source.substring(he + 1) + `
`;
    if (token.type === "block-scalar") {
      const header = token.props[0];
      if (header.type !== "block-scalar-header")
        throw new Error("Invalid block scalar header");
      header.source = head;
      token.source = body;
    } else {
      const { offset } = token;
      const indent = "indent" in token ? token.indent : -1;
      const props = [
        { type: "block-scalar-header", offset, indent, source: head }
      ];
      if (!addEndtoBlockProps(props, "end" in token ? token.end : undefined))
        props.push({ type: "newline", offset: -1, indent, source: `
` });
      for (const key of Object.keys(token))
        if (key !== "type" && key !== "offset")
          delete token[key];
      Object.assign(token, { type: "block-scalar", indent, props, source: body });
    }
  }
  function addEndtoBlockProps(props, end) {
    if (end)
      for (const st of end)
        switch (st.type) {
          case "space":
          case "comment":
            props.push(st);
            break;
          case "newline":
            props.push(st);
            return true;
        }
    return false;
  }
  function setFlowScalarValue(token, source, type) {
    switch (token.type) {
      case "scalar":
      case "double-quoted-scalar":
      case "single-quoted-scalar":
        token.type = type;
        token.source = source;
        break;
      case "block-scalar": {
        const end = token.props.slice(1);
        let oa = source.length;
        if (token.props[0].type === "block-scalar-header")
          oa -= token.props[0].source.length;
        for (const tok of end)
          tok.offset += oa;
        delete token.props;
        Object.assign(token, { type, source, end });
        break;
      }
      case "block-map":
      case "block-seq": {
        const offset = token.offset + source.length;
        const nl = { type: "newline", offset, indent: token.indent, source: `
` };
        delete token.items;
        Object.assign(token, { type, source, end: [nl] });
        break;
      }
      default: {
        const indent = "indent" in token ? token.indent : -1;
        const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
        for (const key of Object.keys(token))
          if (key !== "type" && key !== "offset")
            delete token[key];
        Object.assign(token, { type, indent, source, end });
      }
    }
  }
  exports.createScalarToken = createScalarToken;
  exports.resolveAsScalar = resolveAsScalar;
  exports.setScalarValue = setScalarValue;
});

// node_modules/yaml/dist/parse/cst-stringify.js
var require_cst_stringify = __commonJS((exports) => {
  var stringify = (cst) => ("type" in cst) ? stringifyToken(cst) : stringifyItem(cst);
  function stringifyToken(token) {
    switch (token.type) {
      case "block-scalar": {
        let res = "";
        for (const tok of token.props)
          res += stringifyToken(tok);
        return res + token.source;
      }
      case "block-map":
      case "block-seq": {
        let res = "";
        for (const item of token.items)
          res += stringifyItem(item);
        return res;
      }
      case "flow-collection": {
        let res = token.start.source;
        for (const item of token.items)
          res += stringifyItem(item);
        for (const st of token.end)
          res += st.source;
        return res;
      }
      case "document": {
        let res = stringifyItem(token);
        if (token.end)
          for (const st of token.end)
            res += st.source;
        return res;
      }
      default: {
        let res = token.source;
        if ("end" in token && token.end)
          for (const st of token.end)
            res += st.source;
        return res;
      }
    }
  }
  function stringifyItem({ start, key, sep, value }) {
    let res = "";
    for (const st of start)
      res += st.source;
    if (key)
      res += stringifyToken(key);
    if (sep)
      for (const st of sep)
        res += st.source;
    if (value)
      res += stringifyToken(value);
    return res;
  }
  exports.stringify = stringify;
});

// node_modules/yaml/dist/parse/cst-visit.js
var require_cst_visit = __commonJS((exports) => {
  var BREAK = Symbol("break visit");
  var SKIP = Symbol("skip children");
  var REMOVE = Symbol("remove item");
  function visit(cst, visitor) {
    if ("type" in cst && cst.type === "document")
      cst = { start: cst.start, value: cst.value };
    _visit(Object.freeze([]), cst, visitor);
  }
  visit.BREAK = BREAK;
  visit.SKIP = SKIP;
  visit.REMOVE = REMOVE;
  visit.itemAtPath = (cst, path) => {
    let item = cst;
    for (const [field, index] of path) {
      const tok = item?.[field];
      if (tok && "items" in tok) {
        item = tok.items[index];
      } else
        return;
    }
    return item;
  };
  visit.parentCollection = (cst, path) => {
    const parent = visit.itemAtPath(cst, path.slice(0, -1));
    const field = path[path.length - 1][0];
    const coll = parent?.[field];
    if (coll && "items" in coll)
      return coll;
    throw new Error("Parent collection not found");
  };
  function _visit(path, item, visitor) {
    let ctrl = visitor(item, path);
    if (typeof ctrl === "symbol")
      return ctrl;
    for (const field of ["key", "value"]) {
      const token = item[field];
      if (token && "items" in token) {
        for (let i = 0;i < token.items.length; ++i) {
          const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);
          if (typeof ci === "number")
            i = ci - 1;
          else if (ci === BREAK)
            return BREAK;
          else if (ci === REMOVE) {
            token.items.splice(i, 1);
            i -= 1;
          }
        }
        if (typeof ctrl === "function" && field === "key")
          ctrl = ctrl(item, path);
      }
    }
    return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
  }
  exports.visit = visit;
});

// node_modules/yaml/dist/parse/cst.js
var require_cst = __commonJS((exports) => {
  var cstScalar = require_cst_scalar();
  var cstStringify = require_cst_stringify();
  var cstVisit = require_cst_visit();
  var BOM = "\uFEFF";
  var DOCUMENT = "\x02";
  var FLOW_END = "\x18";
  var SCALAR = "\x1F";
  var isCollection = (token) => !!token && ("items" in token);
  var isScalar = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
  function prettyToken(token) {
    switch (token) {
      case BOM:
        return "<BOM>";
      case DOCUMENT:
        return "<DOC>";
      case FLOW_END:
        return "<FLOW_END>";
      case SCALAR:
        return "<SCALAR>";
      default:
        return JSON.stringify(token);
    }
  }
  function tokenType(source) {
    switch (source) {
      case BOM:
        return "byte-order-mark";
      case DOCUMENT:
        return "doc-mode";
      case FLOW_END:
        return "flow-error-end";
      case SCALAR:
        return "scalar";
      case "---":
        return "doc-start";
      case "...":
        return "doc-end";
      case "":
      case `
`:
      case `\r
`:
        return "newline";
      case "-":
        return "seq-item-ind";
      case "?":
        return "explicit-key-ind";
      case ":":
        return "map-value-ind";
      case "{":
        return "flow-map-start";
      case "}":
        return "flow-map-end";
      case "[":
        return "flow-seq-start";
      case "]":
        return "flow-seq-end";
      case ",":
        return "comma";
    }
    switch (source[0]) {
      case " ":
      case "\t":
        return "space";
      case "#":
        return "comment";
      case "%":
        return "directive-line";
      case "*":
        return "alias";
      case "&":
        return "anchor";
      case "!":
        return "tag";
      case "'":
        return "single-quoted-scalar";
      case '"':
        return "double-quoted-scalar";
      case "|":
      case ">":
        return "block-scalar-header";
    }
    return null;
  }
  exports.createScalarToken = cstScalar.createScalarToken;
  exports.resolveAsScalar = cstScalar.resolveAsScalar;
  exports.setScalarValue = cstScalar.setScalarValue;
  exports.stringify = cstStringify.stringify;
  exports.visit = cstVisit.visit;
  exports.BOM = BOM;
  exports.DOCUMENT = DOCUMENT;
  exports.FLOW_END = FLOW_END;
  exports.SCALAR = SCALAR;
  exports.isCollection = isCollection;
  exports.isScalar = isScalar;
  exports.prettyToken = prettyToken;
  exports.tokenType = tokenType;
});

// node_modules/yaml/dist/parse/lexer.js
var require_lexer = __commonJS((exports) => {
  var cst = require_cst();
  function isEmpty(ch) {
    switch (ch) {
      case undefined:
      case " ":
      case `
`:
      case "\r":
      case "\t":
        return true;
      default:
        return false;
    }
  }
  var hexDigits = new Set("0123456789ABCDEFabcdef");
  var tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
  var flowIndicatorChars = new Set(",[]{}");
  var invalidAnchorChars = new Set(` ,[]{}
\r	`);
  var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);

  class Lexer {
    constructor() {
      this.atEnd = false;
      this.blockScalarIndent = -1;
      this.blockScalarKeep = false;
      this.buffer = "";
      this.flowKey = false;
      this.flowLevel = 0;
      this.indentNext = 0;
      this.indentValue = 0;
      this.lineEndPos = null;
      this.next = null;
      this.pos = 0;
    }
    *lex(source, incomplete = false) {
      if (source) {
        if (typeof source !== "string")
          throw TypeError("source is not a string");
        this.buffer = this.buffer ? this.buffer + source : source;
        this.lineEndPos = null;
      }
      this.atEnd = !incomplete;
      let next = this.next ?? "stream";
      while (next && (incomplete || this.hasChars(1)))
        next = yield* this.parseNext(next);
    }
    atLineEnd() {
      let i = this.pos;
      let ch = this.buffer[i];
      while (ch === " " || ch === "\t")
        ch = this.buffer[++i];
      if (!ch || ch === "#" || ch === `
`)
        return true;
      if (ch === "\r")
        return this.buffer[i + 1] === `
`;
      return false;
    }
    charAt(n) {
      return this.buffer[this.pos + n];
    }
    continueScalar(offset) {
      let ch = this.buffer[offset];
      if (this.indentNext > 0) {
        let indent = 0;
        while (ch === " ")
          ch = this.buffer[++indent + offset];
        if (ch === "\r") {
          const next = this.buffer[indent + offset + 1];
          if (next === `
` || !next && !this.atEnd)
            return offset + indent + 1;
        }
        return ch === `
` || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
      }
      if (ch === "-" || ch === ".") {
        const dt = this.buffer.substr(offset, 3);
        if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
          return -1;
      }
      return offset;
    }
    getLine() {
      let end = this.lineEndPos;
      if (typeof end !== "number" || end !== -1 && end < this.pos) {
        end = this.buffer.indexOf(`
`, this.pos);
        this.lineEndPos = end;
      }
      if (end === -1)
        return this.atEnd ? this.buffer.substring(this.pos) : null;
      if (this.buffer[end - 1] === "\r")
        end -= 1;
      return this.buffer.substring(this.pos, end);
    }
    hasChars(n) {
      return this.pos + n <= this.buffer.length;
    }
    setNext(state) {
      this.buffer = this.buffer.substring(this.pos);
      this.pos = 0;
      this.lineEndPos = null;
      this.next = state;
      return null;
    }
    peek(n) {
      return this.buffer.substr(this.pos, n);
    }
    *parseNext(next) {
      switch (next) {
        case "stream":
          return yield* this.parseStream();
        case "line-start":
          return yield* this.parseLineStart();
        case "block-start":
          return yield* this.parseBlockStart();
        case "doc":
          return yield* this.parseDocument();
        case "flow":
          return yield* this.parseFlowCollection();
        case "quoted-scalar":
          return yield* this.parseQuotedScalar();
        case "block-scalar":
          return yield* this.parseBlockScalar();
        case "plain-scalar":
          return yield* this.parsePlainScalar();
      }
    }
    *parseStream() {
      let line = this.getLine();
      if (line === null)
        return this.setNext("stream");
      if (line[0] === cst.BOM) {
        yield* this.pushCount(1);
        line = line.substring(1);
      }
      if (line[0] === "%") {
        let dirEnd = line.length;
        let cs = line.indexOf("#");
        while (cs !== -1) {
          const ch = line[cs - 1];
          if (ch === " " || ch === "\t") {
            dirEnd = cs - 1;
            break;
          } else {
            cs = line.indexOf("#", cs + 1);
          }
        }
        while (true) {
          const ch = line[dirEnd - 1];
          if (ch === " " || ch === "\t")
            dirEnd -= 1;
          else
            break;
        }
        const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
        yield* this.pushCount(line.length - n);
        this.pushNewline();
        return "stream";
      }
      if (this.atLineEnd()) {
        const sp = yield* this.pushSpaces(true);
        yield* this.pushCount(line.length - sp);
        yield* this.pushNewline();
        return "stream";
      }
      yield cst.DOCUMENT;
      return yield* this.parseLineStart();
    }
    *parseLineStart() {
      const ch = this.charAt(0);
      if (!ch && !this.atEnd)
        return this.setNext("line-start");
      if (ch === "-" || ch === ".") {
        if (!this.atEnd && !this.hasChars(4))
          return this.setNext("line-start");
        const s = this.peek(3);
        if ((s === "---" || s === "...") && isEmpty(this.charAt(3))) {
          yield* this.pushCount(3);
          this.indentValue = 0;
          this.indentNext = 0;
          return s === "---" ? "doc" : "stream";
        }
      }
      this.indentValue = yield* this.pushSpaces(false);
      if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
        this.indentNext = this.indentValue;
      return yield* this.parseBlockStart();
    }
    *parseBlockStart() {
      const [ch0, ch1] = this.peek(2);
      if (!ch1 && !this.atEnd)
        return this.setNext("block-start");
      if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
        const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
        this.indentNext = this.indentValue + 1;
        this.indentValue += n;
        return yield* this.parseBlockStart();
      }
      return "doc";
    }
    *parseDocument() {
      yield* this.pushSpaces(true);
      const line = this.getLine();
      if (line === null)
        return this.setNext("doc");
      let n = yield* this.pushIndicators();
      switch (line[n]) {
        case "#":
          yield* this.pushCount(line.length - n);
        case undefined:
          yield* this.pushNewline();
          return yield* this.parseLineStart();
        case "{":
        case "[":
          yield* this.pushCount(1);
          this.flowKey = false;
          this.flowLevel = 1;
          return "flow";
        case "}":
        case "]":
          yield* this.pushCount(1);
          return "doc";
        case "*":
          yield* this.pushUntil(isNotAnchorChar);
          return "doc";
        case '"':
        case "'":
          return yield* this.parseQuotedScalar();
        case "|":
        case ">":
          n += yield* this.parseBlockScalarHeader();
          n += yield* this.pushSpaces(true);
          yield* this.pushCount(line.length - n);
          yield* this.pushNewline();
          return yield* this.parseBlockScalar();
        default:
          return yield* this.parsePlainScalar();
      }
    }
    *parseFlowCollection() {
      let nl, sp;
      let indent = -1;
      do {
        nl = yield* this.pushNewline();
        if (nl > 0) {
          sp = yield* this.pushSpaces(false);
          this.indentValue = indent = sp;
        } else {
          sp = 0;
        }
        sp += yield* this.pushSpaces(true);
      } while (nl + sp > 0);
      const line = this.getLine();
      if (line === null)
        return this.setNext("flow");
      if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
        const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
        if (!atFlowEndMarker) {
          this.flowLevel = 0;
          yield cst.FLOW_END;
          return yield* this.parseLineStart();
        }
      }
      let n = 0;
      while (line[n] === ",") {
        n += yield* this.pushCount(1);
        n += yield* this.pushSpaces(true);
        this.flowKey = false;
      }
      n += yield* this.pushIndicators();
      switch (line[n]) {
        case undefined:
          return "flow";
        case "#":
          yield* this.pushCount(line.length - n);
          return "flow";
        case "{":
        case "[":
          yield* this.pushCount(1);
          this.flowKey = false;
          this.flowLevel += 1;
          return "flow";
        case "}":
        case "]":
          yield* this.pushCount(1);
          this.flowKey = true;
          this.flowLevel -= 1;
          return this.flowLevel ? "flow" : "doc";
        case "*":
          yield* this.pushUntil(isNotAnchorChar);
          return "flow";
        case '"':
        case "'":
          this.flowKey = true;
          return yield* this.parseQuotedScalar();
        case ":": {
          const next = this.charAt(1);
          if (this.flowKey || isEmpty(next) || next === ",") {
            this.flowKey = false;
            yield* this.pushCount(1);
            yield* this.pushSpaces(true);
            return "flow";
          }
        }
        default:
          this.flowKey = false;
          return yield* this.parsePlainScalar();
      }
    }
    *parseQuotedScalar() {
      const quote = this.charAt(0);
      let end = this.buffer.indexOf(quote, this.pos + 1);
      if (quote === "'") {
        while (end !== -1 && this.buffer[end + 1] === "'")
          end = this.buffer.indexOf("'", end + 2);
      } else {
        while (end !== -1) {
          let n = 0;
          while (this.buffer[end - 1 - n] === "\\")
            n += 1;
          if (n % 2 === 0)
            break;
          end = this.buffer.indexOf('"', end + 1);
        }
      }
      const qb = this.buffer.substring(0, end);
      let nl = qb.indexOf(`
`, this.pos);
      if (nl !== -1) {
        while (nl !== -1) {
          const cs = this.continueScalar(nl + 1);
          if (cs === -1)
            break;
          nl = qb.indexOf(`
`, cs);
        }
        if (nl !== -1) {
          end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
        }
      }
      if (end === -1) {
        if (!this.atEnd)
          return this.setNext("quoted-scalar");
        end = this.buffer.length;
      }
      yield* this.pushToIndex(end + 1, false);
      return this.flowLevel ? "flow" : "doc";
    }
    *parseBlockScalarHeader() {
      this.blockScalarIndent = -1;
      this.blockScalarKeep = false;
      let i = this.pos;
      while (true) {
        const ch = this.buffer[++i];
        if (ch === "+")
          this.blockScalarKeep = true;
        else if (ch > "0" && ch <= "9")
          this.blockScalarIndent = Number(ch) - 1;
        else if (ch !== "-")
          break;
      }
      return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
    }
    *parseBlockScalar() {
      let nl = this.pos - 1;
      let indent = 0;
      let ch;
      loop:
        for (let i2 = this.pos;ch = this.buffer[i2]; ++i2) {
          switch (ch) {
            case " ":
              indent += 1;
              break;
            case `
`:
              nl = i2;
              indent = 0;
              break;
            case "\r": {
              const next = this.buffer[i2 + 1];
              if (!next && !this.atEnd)
                return this.setNext("block-scalar");
              if (next === `
`)
                break;
            }
            default:
              break loop;
          }
        }
      if (!ch && !this.atEnd)
        return this.setNext("block-scalar");
      if (indent >= this.indentNext) {
        if (this.blockScalarIndent === -1)
          this.indentNext = indent;
        else {
          this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
        }
        do {
          const cs = this.continueScalar(nl + 1);
          if (cs === -1)
            break;
          nl = this.buffer.indexOf(`
`, cs);
        } while (nl !== -1);
        if (nl === -1) {
          if (!this.atEnd)
            return this.setNext("block-scalar");
          nl = this.buffer.length;
        }
      }
      let i = nl + 1;
      ch = this.buffer[i];
      while (ch === " ")
        ch = this.buffer[++i];
      if (ch === "\t") {
        while (ch === "\t" || ch === " " || ch === "\r" || ch === `
`)
          ch = this.buffer[++i];
        nl = i - 1;
      } else if (!this.blockScalarKeep) {
        do {
          let i2 = nl - 1;
          let ch2 = this.buffer[i2];
          if (ch2 === "\r")
            ch2 = this.buffer[--i2];
          const lastChar = i2;
          while (ch2 === " ")
            ch2 = this.buffer[--i2];
          if (ch2 === `
` && i2 >= this.pos && i2 + 1 + indent > lastChar)
            nl = i2;
          else
            break;
        } while (true);
      }
      yield cst.SCALAR;
      yield* this.pushToIndex(nl + 1, true);
      return yield* this.parseLineStart();
    }
    *parsePlainScalar() {
      const inFlow = this.flowLevel > 0;
      let end = this.pos - 1;
      let i = this.pos - 1;
      let ch;
      while (ch = this.buffer[++i]) {
        if (ch === ":") {
          const next = this.buffer[i + 1];
          if (isEmpty(next) || inFlow && flowIndicatorChars.has(next))
            break;
          end = i;
        } else if (isEmpty(ch)) {
          let next = this.buffer[i + 1];
          if (ch === "\r") {
            if (next === `
`) {
              i += 1;
              ch = `
`;
              next = this.buffer[i + 1];
            } else
              end = i;
          }
          if (next === "#" || inFlow && flowIndicatorChars.has(next))
            break;
          if (ch === `
`) {
            const cs = this.continueScalar(i + 1);
            if (cs === -1)
              break;
            i = Math.max(i, cs - 2);
          }
        } else {
          if (inFlow && flowIndicatorChars.has(ch))
            break;
          end = i;
        }
      }
      if (!ch && !this.atEnd)
        return this.setNext("plain-scalar");
      yield cst.SCALAR;
      yield* this.pushToIndex(end + 1, true);
      return inFlow ? "flow" : "doc";
    }
    *pushCount(n) {
      if (n > 0) {
        yield this.buffer.substr(this.pos, n);
        this.pos += n;
        return n;
      }
      return 0;
    }
    *pushToIndex(i, allowEmpty) {
      const s = this.buffer.slice(this.pos, i);
      if (s) {
        yield s;
        this.pos += s.length;
        return s.length;
      } else if (allowEmpty)
        yield "";
      return 0;
    }
    *pushIndicators() {
      switch (this.charAt(0)) {
        case "!":
          return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        case "&":
          return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        case "-":
        case "?":
        case ":": {
          const inFlow = this.flowLevel > 0;
          const ch1 = this.charAt(1);
          if (isEmpty(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
            if (!inFlow)
              this.indentNext = this.indentValue + 1;
            else if (this.flowKey)
              this.flowKey = false;
            return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          }
        }
      }
      return 0;
    }
    *pushTag() {
      if (this.charAt(1) === "<") {
        let i = this.pos + 2;
        let ch = this.buffer[i];
        while (!isEmpty(ch) && ch !== ">")
          ch = this.buffer[++i];
        return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
      } else {
        let i = this.pos + 1;
        let ch = this.buffer[i];
        while (ch) {
          if (tagChars.has(ch))
            ch = this.buffer[++i];
          else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) {
            ch = this.buffer[i += 3];
          } else
            break;
        }
        return yield* this.pushToIndex(i, false);
      }
    }
    *pushNewline() {
      const ch = this.buffer[this.pos];
      if (ch === `
`)
        return yield* this.pushCount(1);
      else if (ch === "\r" && this.charAt(1) === `
`)
        return yield* this.pushCount(2);
      else
        return 0;
    }
    *pushSpaces(allowTabs) {
      let i = this.pos - 1;
      let ch;
      do {
        ch = this.buffer[++i];
      } while (ch === " " || allowTabs && ch === "\t");
      const n = i - this.pos;
      if (n > 0) {
        yield this.buffer.substr(this.pos, n);
        this.pos = i;
      }
      return n;
    }
    *pushUntil(test) {
      let i = this.pos;
      let ch = this.buffer[i];
      while (!test(ch))
        ch = this.buffer[++i];
      return yield* this.pushToIndex(i, false);
    }
  }
  exports.Lexer = Lexer;
});

// node_modules/yaml/dist/parse/line-counter.js
var require_line_counter = __commonJS((exports) => {
  class LineCounter {
    constructor() {
      this.lineStarts = [];
      this.addNewLine = (offset) => this.lineStarts.push(offset);
      this.linePos = (offset) => {
        let low = 0;
        let high = this.lineStarts.length;
        while (low < high) {
          const mid = low + high >> 1;
          if (this.lineStarts[mid] < offset)
            low = mid + 1;
          else
            high = mid;
        }
        if (this.lineStarts[low] === offset)
          return { line: low + 1, col: 1 };
        if (low === 0)
          return { line: 0, col: offset };
        const start = this.lineStarts[low - 1];
        return { line: low, col: offset - start + 1 };
      };
    }
  }
  exports.LineCounter = LineCounter;
});

// node_modules/yaml/dist/parse/parser.js
var require_parser = __commonJS((exports) => {
  var node_process = __require("process");
  var cst = require_cst();
  var lexer = require_lexer();
  function includesToken(list, type) {
    for (let i = 0;i < list.length; ++i)
      if (list[i].type === type)
        return true;
    return false;
  }
  function findNonEmptyIndex(list) {
    for (let i = 0;i < list.length; ++i) {
      switch (list[i].type) {
        case "space":
        case "comment":
        case "newline":
          break;
        default:
          return i;
      }
    }
    return -1;
  }
  function isFlowToken(token) {
    switch (token?.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
      case "flow-collection":
        return true;
      default:
        return false;
    }
  }
  function getPrevProps(parent) {
    switch (parent.type) {
      case "document":
        return parent.start;
      case "block-map": {
        const it = parent.items[parent.items.length - 1];
        return it.sep ?? it.start;
      }
      case "block-seq":
        return parent.items[parent.items.length - 1].start;
      default:
        return [];
    }
  }
  function getFirstKeyStartProps(prev) {
    if (prev.length === 0)
      return [];
    let i = prev.length;
    loop:
      while (--i >= 0) {
        switch (prev[i].type) {
          case "doc-start":
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
          case "newline":
            break loop;
        }
      }
    while (prev[++i]?.type === "space") {}
    return prev.splice(i, prev.length);
  }
  function fixFlowSeqItems(fc) {
    if (fc.start.type === "flow-seq-start") {
      for (const it of fc.items) {
        if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
          if (it.key)
            it.value = it.key;
          delete it.key;
          if (isFlowToken(it.value)) {
            if (it.value.end)
              Array.prototype.push.apply(it.value.end, it.sep);
            else
              it.value.end = it.sep;
          } else
            Array.prototype.push.apply(it.start, it.sep);
          delete it.sep;
        }
      }
    }
  }

  class Parser {
    constructor(onNewLine) {
      this.atNewLine = true;
      this.atScalar = false;
      this.indent = 0;
      this.offset = 0;
      this.onKeyLine = false;
      this.stack = [];
      this.source = "";
      this.type = "";
      this.lexer = new lexer.Lexer;
      this.onNewLine = onNewLine;
    }
    *parse(source, incomplete = false) {
      if (this.onNewLine && this.offset === 0)
        this.onNewLine(0);
      for (const lexeme of this.lexer.lex(source, incomplete))
        yield* this.next(lexeme);
      if (!incomplete)
        yield* this.end();
    }
    *next(source) {
      this.source = source;
      if (node_process.env.LOG_TOKENS)
        console.log("|", cst.prettyToken(source));
      if (this.atScalar) {
        this.atScalar = false;
        yield* this.step();
        this.offset += source.length;
        return;
      }
      const type = cst.tokenType(source);
      if (!type) {
        const message = `Not a YAML token: ${source}`;
        yield* this.pop({ type: "error", offset: this.offset, message, source });
        this.offset += source.length;
      } else if (type === "scalar") {
        this.atNewLine = false;
        this.atScalar = true;
        this.type = "scalar";
      } else {
        this.type = type;
        yield* this.step();
        switch (type) {
          case "newline":
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine)
              this.onNewLine(this.offset + source.length);
            break;
          case "space":
            if (this.atNewLine && source[0] === " ")
              this.indent += source.length;
            break;
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
            if (this.atNewLine)
              this.indent += source.length;
            break;
          case "doc-mode":
          case "flow-error-end":
            return;
          default:
            this.atNewLine = false;
        }
        this.offset += source.length;
      }
    }
    *end() {
      while (this.stack.length > 0)
        yield* this.pop();
    }
    get sourceToken() {
      const st = {
        type: this.type,
        offset: this.offset,
        indent: this.indent,
        source: this.source
      };
      return st;
    }
    *step() {
      const top = this.peek(1);
      if (this.type === "doc-end" && top?.type !== "doc-end") {
        while (this.stack.length > 0)
          yield* this.pop();
        this.stack.push({
          type: "doc-end",
          offset: this.offset,
          source: this.source
        });
        return;
      }
      if (!top)
        return yield* this.stream();
      switch (top.type) {
        case "document":
          return yield* this.document(top);
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return yield* this.scalar(top);
        case "block-scalar":
          return yield* this.blockScalar(top);
        case "block-map":
          return yield* this.blockMap(top);
        case "block-seq":
          return yield* this.blockSequence(top);
        case "flow-collection":
          return yield* this.flowCollection(top);
        case "doc-end":
          return yield* this.documentEnd(top);
      }
      yield* this.pop();
    }
    peek(n) {
      return this.stack[this.stack.length - n];
    }
    *pop(error) {
      const token = error ?? this.stack.pop();
      if (!token) {
        const message = "Tried to pop an empty stack";
        yield { type: "error", offset: this.offset, source: "", message };
      } else if (this.stack.length === 0) {
        yield token;
      } else {
        const top = this.peek(1);
        if (token.type === "block-scalar") {
          token.indent = "indent" in top ? top.indent : 0;
        } else if (token.type === "flow-collection" && top.type === "document") {
          token.indent = 0;
        }
        if (token.type === "flow-collection")
          fixFlowSeqItems(token);
        switch (top.type) {
          case "document":
            top.value = token;
            break;
          case "block-scalar":
            top.props.push(token);
            break;
          case "block-map": {
            const it = top.items[top.items.length - 1];
            if (it.value) {
              top.items.push({ start: [], key: token, sep: [] });
              this.onKeyLine = true;
              return;
            } else if (it.sep) {
              it.value = token;
            } else {
              Object.assign(it, { key: token, sep: [] });
              this.onKeyLine = !it.explicitKey;
              return;
            }
            break;
          }
          case "block-seq": {
            const it = top.items[top.items.length - 1];
            if (it.value)
              top.items.push({ start: [], value: token });
            else
              it.value = token;
            break;
          }
          case "flow-collection": {
            const it = top.items[top.items.length - 1];
            if (!it || it.value)
              top.items.push({ start: [], key: token, sep: [] });
            else if (it.sep)
              it.value = token;
            else
              Object.assign(it, { key: token, sep: [] });
            return;
          }
          default:
            yield* this.pop();
            yield* this.pop(token);
        }
        if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
          const last = token.items[token.items.length - 1];
          if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
            if (top.type === "document")
              top.end = last.start;
            else
              top.items.push({ start: last.start });
            token.items.splice(-1, 1);
          }
        }
      }
    }
    *stream() {
      switch (this.type) {
        case "directive-line":
          yield { type: "directive", offset: this.offset, source: this.source };
          return;
        case "byte-order-mark":
        case "space":
        case "comment":
        case "newline":
          yield this.sourceToken;
          return;
        case "doc-mode":
        case "doc-start": {
          const doc = {
            type: "document",
            offset: this.offset,
            start: []
          };
          if (this.type === "doc-start")
            doc.start.push(this.sourceToken);
          this.stack.push(doc);
          return;
        }
      }
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML stream`,
        source: this.source
      };
    }
    *document(doc) {
      if (doc.value)
        return yield* this.lineEnd(doc);
      switch (this.type) {
        case "doc-start": {
          if (findNonEmptyIndex(doc.start) !== -1) {
            yield* this.pop();
            yield* this.step();
          } else
            doc.start.push(this.sourceToken);
          return;
        }
        case "anchor":
        case "tag":
        case "space":
        case "comment":
        case "newline":
          doc.start.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(doc);
      if (bv)
        this.stack.push(bv);
      else {
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML document`,
          source: this.source
        };
      }
    }
    *scalar(scalar) {
      if (this.type === "map-value-ind") {
        const prev = getPrevProps(this.peek(2));
        const start = getFirstKeyStartProps(prev);
        let sep;
        if (scalar.end) {
          sep = scalar.end;
          sep.push(this.sourceToken);
          delete scalar.end;
        } else
          sep = [this.sourceToken];
        const map = {
          type: "block-map",
          offset: scalar.offset,
          indent: scalar.indent,
          items: [{ start, key: scalar, sep }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map;
      } else
        yield* this.lineEnd(scalar);
    }
    *blockScalar(scalar) {
      switch (this.type) {
        case "space":
        case "comment":
        case "newline":
          scalar.props.push(this.sourceToken);
          return;
        case "scalar":
          scalar.source = this.source;
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine) {
            let nl = this.source.indexOf(`
`) + 1;
            while (nl !== 0) {
              this.onNewLine(this.offset + nl);
              nl = this.source.indexOf(`
`, nl) + 1;
            }
          }
          yield* this.pop();
          break;
        default:
          yield* this.pop();
          yield* this.step();
      }
    }
    *blockMap(map) {
      const it = map.items[map.items.length - 1];
      switch (this.type) {
        case "newline":
          this.onKeyLine = false;
          if (it.value) {
            const end = "end" in it.value ? it.value.end : undefined;
            const last = Array.isArray(end) ? end[end.length - 1] : undefined;
            if (last?.type === "comment")
              end?.push(this.sourceToken);
            else
              map.items.push({ start: [this.sourceToken] });
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            it.start.push(this.sourceToken);
          }
          return;
        case "space":
        case "comment":
          if (it.value) {
            map.items.push({ start: [this.sourceToken] });
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            if (this.atIndentedComment(it.start, map.indent)) {
              const prev = map.items[map.items.length - 2];
              const end = prev?.value?.end;
              if (Array.isArray(end)) {
                Array.prototype.push.apply(end, it.start);
                end.push(this.sourceToken);
                map.items.pop();
                return;
              }
            }
            it.start.push(this.sourceToken);
          }
          return;
      }
      if (this.indent >= map.indent) {
        const atMapIndent = !this.onKeyLine && this.indent === map.indent;
        const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
        let start = [];
        if (atNextItem && it.sep && !it.value) {
          const nl = [];
          for (let i = 0;i < it.sep.length; ++i) {
            const st = it.sep[i];
            switch (st.type) {
              case "newline":
                nl.push(i);
                break;
              case "space":
                break;
              case "comment":
                if (st.indent > map.indent)
                  nl.length = 0;
                break;
              default:
                nl.length = 0;
            }
          }
          if (nl.length >= 2)
            start = it.sep.splice(nl[1]);
        }
        switch (this.type) {
          case "anchor":
          case "tag":
            if (atNextItem || it.value) {
              start.push(this.sourceToken);
              map.items.push({ start });
              this.onKeyLine = true;
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              it.start.push(this.sourceToken);
            }
            return;
          case "explicit-key-ind":
            if (!it.sep && !it.explicitKey) {
              it.start.push(this.sourceToken);
              it.explicitKey = true;
            } else if (atNextItem || it.value) {
              start.push(this.sourceToken);
              map.items.push({ start, explicitKey: true });
            } else {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: [this.sourceToken], explicitKey: true }]
              });
            }
            this.onKeyLine = true;
            return;
          case "map-value-ind":
            if (it.explicitKey) {
              if (!it.sep) {
                if (includesToken(it.start, "newline")) {
                  Object.assign(it, { key: null, sep: [this.sourceToken] });
                } else {
                  const start2 = getFirstKeyStartProps(it.start);
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                  });
                }
              } else if (it.value) {
                map.items.push({ start: [], key: null, sep: [this.sourceToken] });
              } else if (includesToken(it.sep, "map-value-ind")) {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start, key: null, sep: [this.sourceToken] }]
                });
              } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                const start2 = getFirstKeyStartProps(it.start);
                const key = it.key;
                const sep = it.sep;
                sep.push(this.sourceToken);
                delete it.key;
                delete it.sep;
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: start2, key, sep }]
                });
              } else if (start.length > 0) {
                it.sep = it.sep.concat(start, this.sourceToken);
              } else {
                it.sep.push(this.sourceToken);
              }
            } else {
              if (!it.sep) {
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              } else if (it.value || atNextItem) {
                map.items.push({ start, key: null, sep: [this.sourceToken] });
              } else if (includesToken(it.sep, "map-value-ind")) {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [], key: null, sep: [this.sourceToken] }]
                });
              } else {
                it.sep.push(this.sourceToken);
              }
            }
            this.onKeyLine = true;
            return;
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar": {
            const fs = this.flowScalar(this.type);
            if (atNextItem || it.value) {
              map.items.push({ start, key: fs, sep: [] });
              this.onKeyLine = true;
            } else if (it.sep) {
              this.stack.push(fs);
            } else {
              Object.assign(it, { key: fs, sep: [] });
              this.onKeyLine = true;
            }
            return;
          }
          default: {
            const bv = this.startBlockValue(map);
            if (bv) {
              if (bv.type === "block-seq") {
                if (!it.explicitKey && it.sep && !includesToken(it.sep, "newline")) {
                  yield* this.pop({
                    type: "error",
                    offset: this.offset,
                    message: "Unexpected block-seq-ind on same line with key",
                    source: this.source
                  });
                  return;
                }
              } else if (atMapIndent) {
                map.items.push({ start });
              }
              this.stack.push(bv);
              return;
            }
          }
        }
      }
      yield* this.pop();
      yield* this.step();
    }
    *blockSequence(seq) {
      const it = seq.items[seq.items.length - 1];
      switch (this.type) {
        case "newline":
          if (it.value) {
            const end = "end" in it.value ? it.value.end : undefined;
            const last = Array.isArray(end) ? end[end.length - 1] : undefined;
            if (last?.type === "comment")
              end?.push(this.sourceToken);
            else
              seq.items.push({ start: [this.sourceToken] });
          } else
            it.start.push(this.sourceToken);
          return;
        case "space":
        case "comment":
          if (it.value)
            seq.items.push({ start: [this.sourceToken] });
          else {
            if (this.atIndentedComment(it.start, seq.indent)) {
              const prev = seq.items[seq.items.length - 2];
              const end = prev?.value?.end;
              if (Array.isArray(end)) {
                Array.prototype.push.apply(end, it.start);
                end.push(this.sourceToken);
                seq.items.pop();
                return;
              }
            }
            it.start.push(this.sourceToken);
          }
          return;
        case "anchor":
        case "tag":
          if (it.value || this.indent <= seq.indent)
            break;
          it.start.push(this.sourceToken);
          return;
        case "seq-item-ind":
          if (this.indent !== seq.indent)
            break;
          if (it.value || includesToken(it.start, "seq-item-ind"))
            seq.items.push({ start: [this.sourceToken] });
          else
            it.start.push(this.sourceToken);
          return;
      }
      if (this.indent > seq.indent) {
        const bv = this.startBlockValue(seq);
        if (bv) {
          this.stack.push(bv);
          return;
        }
      }
      yield* this.pop();
      yield* this.step();
    }
    *flowCollection(fc) {
      const it = fc.items[fc.items.length - 1];
      if (this.type === "flow-error-end") {
        let top;
        do {
          yield* this.pop();
          top = this.peek(1);
        } while (top?.type === "flow-collection");
      } else if (fc.end.length === 0) {
        switch (this.type) {
          case "comma":
          case "explicit-key-ind":
            if (!it || it.sep)
              fc.items.push({ start: [this.sourceToken] });
            else
              it.start.push(this.sourceToken);
            return;
          case "map-value-ind":
            if (!it || it.value)
              fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
            else if (it.sep)
              it.sep.push(this.sourceToken);
            else
              Object.assign(it, { key: null, sep: [this.sourceToken] });
            return;
          case "space":
          case "comment":
          case "newline":
          case "anchor":
          case "tag":
            if (!it || it.value)
              fc.items.push({ start: [this.sourceToken] });
            else if (it.sep)
              it.sep.push(this.sourceToken);
            else
              it.start.push(this.sourceToken);
            return;
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar": {
            const fs = this.flowScalar(this.type);
            if (!it || it.value)
              fc.items.push({ start: [], key: fs, sep: [] });
            else if (it.sep)
              this.stack.push(fs);
            else
              Object.assign(it, { key: fs, sep: [] });
            return;
          }
          case "flow-map-end":
          case "flow-seq-end":
            fc.end.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(fc);
        if (bv)
          this.stack.push(bv);
        else {
          yield* this.pop();
          yield* this.step();
        }
      } else {
        const parent = this.peek(2);
        if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
          yield* this.pop();
          yield* this.step();
        } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
          const prev = getPrevProps(parent);
          const start = getFirstKeyStartProps(prev);
          fixFlowSeqItems(fc);
          const sep = fc.end.splice(1, fc.end.length);
          sep.push(this.sourceToken);
          const map = {
            type: "block-map",
            offset: fc.offset,
            indent: fc.indent,
            items: [{ start, key: fc, sep }]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map;
        } else {
          yield* this.lineEnd(fc);
        }
      }
    }
    flowScalar(type) {
      if (this.onNewLine) {
        let nl = this.source.indexOf(`
`) + 1;
        while (nl !== 0) {
          this.onNewLine(this.offset + nl);
          nl = this.source.indexOf(`
`, nl) + 1;
        }
      }
      return {
        type,
        offset: this.offset,
        indent: this.indent,
        source: this.source
      };
    }
    startBlockValue(parent) {
      switch (this.type) {
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return this.flowScalar(this.type);
        case "block-scalar-header":
          return {
            type: "block-scalar",
            offset: this.offset,
            indent: this.indent,
            props: [this.sourceToken],
            source: ""
          };
        case "flow-map-start":
        case "flow-seq-start":
          return {
            type: "flow-collection",
            offset: this.offset,
            indent: this.indent,
            start: this.sourceToken,
            items: [],
            end: []
          };
        case "seq-item-ind":
          return {
            type: "block-seq",
            offset: this.offset,
            indent: this.indent,
            items: [{ start: [this.sourceToken] }]
          };
        case "explicit-key-ind": {
          this.onKeyLine = true;
          const prev = getPrevProps(parent);
          const start = getFirstKeyStartProps(prev);
          start.push(this.sourceToken);
          return {
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start, explicitKey: true }]
          };
        }
        case "map-value-ind": {
          this.onKeyLine = true;
          const prev = getPrevProps(parent);
          const start = getFirstKeyStartProps(prev);
          return {
            type: "block-map",
            offset: this.offset,
            indent: this.indent,
            items: [{ start, key: null, sep: [this.sourceToken] }]
          };
        }
      }
      return null;
    }
    atIndentedComment(start, indent) {
      if (this.type !== "comment")
        return false;
      if (this.indent <= indent)
        return false;
      return start.every((st) => st.type === "newline" || st.type === "space");
    }
    *documentEnd(docEnd) {
      if (this.type !== "doc-mode") {
        if (docEnd.end)
          docEnd.end.push(this.sourceToken);
        else
          docEnd.end = [this.sourceToken];
        if (this.type === "newline")
          yield* this.pop();
      }
    }
    *lineEnd(token) {
      switch (this.type) {
        case "comma":
        case "doc-start":
        case "doc-end":
        case "flow-seq-end":
        case "flow-map-end":
        case "map-value-ind":
          yield* this.pop();
          yield* this.step();
          break;
        case "newline":
          this.onKeyLine = false;
        case "space":
        case "comment":
        default:
          if (token.end)
            token.end.push(this.sourceToken);
          else
            token.end = [this.sourceToken];
          if (this.type === "newline")
            yield* this.pop();
      }
    }
  }
  exports.Parser = Parser;
});

// node_modules/yaml/dist/public-api.js
var require_public_api = __commonJS((exports) => {
  var composer = require_composer();
  var Document = require_Document();
  var errors = require_errors();
  var log = require_log();
  var identity = require_identity();
  var lineCounter = require_line_counter();
  var parser = require_parser();
  function parseOptions(options) {
    const prettyErrors = options.prettyErrors !== false;
    const lineCounter$1 = options.lineCounter || prettyErrors && new lineCounter.LineCounter || null;
    return { lineCounter: lineCounter$1, prettyErrors };
  }
  function parseAllDocuments(source, options = {}) {
    const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
    const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
    const composer$1 = new composer.Composer(options);
    const docs = Array.from(composer$1.compose(parser$1.parse(source)));
    if (prettyErrors && lineCounter2)
      for (const doc of docs) {
        doc.errors.forEach(errors.prettifyError(source, lineCounter2));
        doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
      }
    if (docs.length > 0)
      return docs;
    return Object.assign([], { empty: true }, composer$1.streamInfo());
  }
  function parseDocument(source, options = {}) {
    const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
    const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
    const composer$1 = new composer.Composer(options);
    let doc = null;
    for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {
      if (!doc)
        doc = _doc;
      else if (doc.options.logLevel !== "silent") {
        doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
        break;
      }
    }
    if (prettyErrors && lineCounter2) {
      doc.errors.forEach(errors.prettifyError(source, lineCounter2));
      doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
    }
    return doc;
  }
  function parse(src, reviver, options) {
    let _reviver = undefined;
    if (typeof reviver === "function") {
      _reviver = reviver;
    } else if (options === undefined && reviver && typeof reviver === "object") {
      options = reviver;
    }
    const doc = parseDocument(src, options);
    if (!doc)
      return null;
    doc.warnings.forEach((warning) => log.warn(doc.options.logLevel, warning));
    if (doc.errors.length > 0) {
      if (doc.options.logLevel !== "silent")
        throw doc.errors[0];
      else
        doc.errors = [];
    }
    return doc.toJS(Object.assign({ reviver: _reviver }, options));
  }
  function stringify(value, replacer, options) {
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer)) {
      _replacer = replacer;
    } else if (options === undefined && replacer) {
      options = replacer;
    }
    if (typeof options === "string")
      options = options.length;
    if (typeof options === "number") {
      const indent = Math.round(options);
      options = indent < 1 ? undefined : indent > 8 ? { indent: 8 } : { indent };
    }
    if (value === undefined) {
      const { keepUndefined } = options ?? replacer ?? {};
      if (!keepUndefined)
        return;
    }
    if (identity.isDocument(value) && !_replacer)
      return value.toString(options);
    return new Document.Document(value, _replacer, options).toString(options);
  }
  exports.parse = parse;
  exports.parseAllDocuments = parseAllDocuments;
  exports.parseDocument = parseDocument;
  exports.stringify = stringify;
});

// node_modules/yaml/dist/index.js
var require_dist = __commonJS((exports) => {
  var composer = require_composer();
  var Document = require_Document();
  var Schema = require_Schema();
  var errors = require_errors();
  var Alias = require_Alias();
  var identity = require_identity();
  var Pair = require_Pair();
  var Scalar = require_Scalar();
  var YAMLMap = require_YAMLMap();
  var YAMLSeq = require_YAMLSeq();
  var cst = require_cst();
  var lexer = require_lexer();
  var lineCounter = require_line_counter();
  var parser = require_parser();
  var publicApi = require_public_api();
  var visit = require_visit();
  exports.Composer = composer.Composer;
  exports.Document = Document.Document;
  exports.Schema = Schema.Schema;
  exports.YAMLError = errors.YAMLError;
  exports.YAMLParseError = errors.YAMLParseError;
  exports.YAMLWarning = errors.YAMLWarning;
  exports.Alias = Alias.Alias;
  exports.isAlias = identity.isAlias;
  exports.isCollection = identity.isCollection;
  exports.isDocument = identity.isDocument;
  exports.isMap = identity.isMap;
  exports.isNode = identity.isNode;
  exports.isPair = identity.isPair;
  exports.isScalar = identity.isScalar;
  exports.isSeq = identity.isSeq;
  exports.Pair = Pair.Pair;
  exports.Scalar = Scalar.Scalar;
  exports.YAMLMap = YAMLMap.YAMLMap;
  exports.YAMLSeq = YAMLSeq.YAMLSeq;
  exports.CST = cst;
  exports.Lexer = lexer.Lexer;
  exports.LineCounter = lineCounter.LineCounter;
  exports.Parser = parser.Parser;
  exports.parse = publicApi.parse;
  exports.parseAllDocuments = publicApi.parseAllDocuments;
  exports.parseDocument = publicApi.parseDocument;
  exports.stringify = publicApi.stringify;
  exports.visit = visit.visit;
  exports.visitAsync = visit.visitAsync;
});

// node_modules/sisteransi/src/index.js
var require_src = __commonJS((exports, module) => {
  var ESC = "\x1B";
  var CSI = `${ESC}[`;
  var beep = "\x07";
  var cursor = {
    to(x, y) {
      if (!y)
        return `${CSI}${x + 1}G`;
      return `${CSI}${y + 1};${x + 1}H`;
    },
    move(x, y) {
      let ret = "";
      if (x < 0)
        ret += `${CSI}${-x}D`;
      else if (x > 0)
        ret += `${CSI}${x}C`;
      if (y < 0)
        ret += `${CSI}${-y}A`;
      else if (y > 0)
        ret += `${CSI}${y}B`;
      return ret;
    },
    up: (count = 1) => `${CSI}${count}A`,
    down: (count = 1) => `${CSI}${count}B`,
    forward: (count = 1) => `${CSI}${count}C`,
    backward: (count = 1) => `${CSI}${count}D`,
    nextLine: (count = 1) => `${CSI}E`.repeat(count),
    prevLine: (count = 1) => `${CSI}F`.repeat(count),
    left: `${CSI}G`,
    hide: `${CSI}?25l`,
    show: `${CSI}?25h`,
    save: `${ESC}7`,
    restore: `${ESC}8`
  };
  var scroll = {
    up: (count = 1) => `${CSI}S`.repeat(count),
    down: (count = 1) => `${CSI}T`.repeat(count)
  };
  var erase = {
    screen: `${CSI}2J`,
    up: (count = 1) => `${CSI}1J`.repeat(count),
    down: (count = 1) => `${CSI}J`.repeat(count),
    line: `${CSI}2K`,
    lineEnd: `${CSI}K`,
    lineStart: `${CSI}1K`,
    lines(count) {
      let clear = "";
      for (let i = 0;i < count; i++)
        clear += this.line + (i < count - 1 ? cursor.up() : "");
      if (count)
        clear += cursor.left;
      return clear;
    }
  };
  module.exports = { cursor, scroll, erase, beep };
});

// node_modules/picocolors/picocolors.js
var require_picocolors = __commonJS((exports, module) => {
  var p = process || {};
  var argv = p.argv || [];
  var env = p.env || {};
  var isColorSupported = !(!!env.NO_COLOR || argv.includes("--no-color")) && (!!env.FORCE_COLOR || argv.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env.TERM !== "dumb" || !!env.CI);
  var formatter = (open, close, replace = open) => (input) => {
    let string = "" + input, index = string.indexOf(close, open.length);
    return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
  };
  var replaceClose = (string, close, replace, index) => {
    let result = "", cursor = 0;
    do {
      result += string.substring(cursor, index) + replace;
      cursor = index + close.length;
      index = string.indexOf(close, cursor);
    } while (~index);
    return result + string.substring(cursor);
  };
  var createColors = (enabled = isColorSupported) => {
    let f = enabled ? formatter : () => String;
    return {
      isColorSupported: enabled,
      reset: f("\x1B[0m", "\x1B[0m"),
      bold: f("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
      dim: f("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
      italic: f("\x1B[3m", "\x1B[23m"),
      underline: f("\x1B[4m", "\x1B[24m"),
      inverse: f("\x1B[7m", "\x1B[27m"),
      hidden: f("\x1B[8m", "\x1B[28m"),
      strikethrough: f("\x1B[9m", "\x1B[29m"),
      black: f("\x1B[30m", "\x1B[39m"),
      red: f("\x1B[31m", "\x1B[39m"),
      green: f("\x1B[32m", "\x1B[39m"),
      yellow: f("\x1B[33m", "\x1B[39m"),
      blue: f("\x1B[34m", "\x1B[39m"),
      magenta: f("\x1B[35m", "\x1B[39m"),
      cyan: f("\x1B[36m", "\x1B[39m"),
      white: f("\x1B[37m", "\x1B[39m"),
      gray: f("\x1B[90m", "\x1B[39m"),
      bgBlack: f("\x1B[40m", "\x1B[49m"),
      bgRed: f("\x1B[41m", "\x1B[49m"),
      bgGreen: f("\x1B[42m", "\x1B[49m"),
      bgYellow: f("\x1B[43m", "\x1B[49m"),
      bgBlue: f("\x1B[44m", "\x1B[49m"),
      bgMagenta: f("\x1B[45m", "\x1B[49m"),
      bgCyan: f("\x1B[46m", "\x1B[49m"),
      bgWhite: f("\x1B[47m", "\x1B[49m"),
      blackBright: f("\x1B[90m", "\x1B[39m"),
      redBright: f("\x1B[91m", "\x1B[39m"),
      greenBright: f("\x1B[92m", "\x1B[39m"),
      yellowBright: f("\x1B[93m", "\x1B[39m"),
      blueBright: f("\x1B[94m", "\x1B[39m"),
      magentaBright: f("\x1B[95m", "\x1B[39m"),
      cyanBright: f("\x1B[96m", "\x1B[39m"),
      whiteBright: f("\x1B[97m", "\x1B[39m"),
      bgBlackBright: f("\x1B[100m", "\x1B[49m"),
      bgRedBright: f("\x1B[101m", "\x1B[49m"),
      bgGreenBright: f("\x1B[102m", "\x1B[49m"),
      bgYellowBright: f("\x1B[103m", "\x1B[49m"),
      bgBlueBright: f("\x1B[104m", "\x1B[49m"),
      bgMagentaBright: f("\x1B[105m", "\x1B[49m"),
      bgCyanBright: f("\x1B[106m", "\x1B[49m"),
      bgWhiteBright: f("\x1B[107m", "\x1B[49m")
    };
  };
  module.exports = createColors();
  module.exports.createColors = createColors;
});

// src/cli/ui.ts
import { EOL } from "node:os";
var UI;
var init_ui = __esm(() => {
  ((UI) => {
    UI.Style = {
      TEXT_HIGHLIGHT: "\x1B[96m",
      TEXT_HIGHLIGHT_BOLD: "\x1B[96m\x1B[1m",
      TEXT_DIM: "\x1B[90m",
      TEXT_DIM_BOLD: "\x1B[90m\x1B[1m",
      TEXT_NORMAL: "\x1B[0m",
      TEXT_NORMAL_BOLD: "\x1B[1m",
      TEXT_WARNING: "\x1B[93m",
      TEXT_WARNING_BOLD: "\x1B[93m\x1B[1m",
      TEXT_DANGER: "\x1B[91m",
      TEXT_DANGER_BOLD: "\x1B[91m\x1B[1m",
      TEXT_SUCCESS: "\x1B[92m",
      TEXT_SUCCESS_BOLD: "\x1B[92m\x1B[1m",
      TEXT_INFO: "\x1B[94m",
      TEXT_INFO_BOLD: "\x1B[94m\x1B[1m"
    };
    function println(...message) {
      process.stderr.write(message.join(" ") + EOL);
    }
    UI.println = println;
    function print(...message) {
      process.stderr.write(message.join(" "));
    }
    UI.print = print;
    function error(message) {
      println(`${UI.Style.TEXT_DANGER_BOLD}Error: ${UI.Style.TEXT_NORMAL}${message}`);
    }
    UI.error = error;
    function success(message) {
      println(`${UI.Style.TEXT_SUCCESS_BOLD} ${UI.Style.TEXT_NORMAL}${message}`);
    }
    UI.success = success;
    function info(message) {
      println(`${UI.Style.TEXT_INFO_BOLD} ${UI.Style.TEXT_NORMAL}${message}`);
    }
    UI.info = info;
    function warn(message) {
      println(`${UI.Style.TEXT_WARNING_BOLD}! ${UI.Style.TEXT_NORMAL}${message}`);
    }
    UI.warn = warn;
    function header(title) {
      println();
      println(UI.Style.TEXT_HIGHLIGHT_BOLD + title + UI.Style.TEXT_NORMAL);
      println(UI.Style.TEXT_DIM + "".repeat(50) + UI.Style.TEXT_NORMAL);
    }
    UI.header = header;
  })(UI ||= {});
});

// src/install/init.ts
var exports_init = {};
__export(exports_init, {
  initConfig: () => initConfig
});
import { existsSync as existsSync2, writeFile } from "node:fs/promises";
import { join as join4 } from "node:path";
async function initConfig(flags) {
  const configDir = join4(process.cwd(), ".ai-eng");
  const configPath = join4(configDir, "config.yaml");
  if (existsSync2(configPath) && !flags.overwrite) {
    UI.error("Configuration file already exists:");
    console.error(`  ${configPath}`);
    console.error("Use --overwrite to replace it, or edit the existing file.");
    process.exit(1);
  }
  if (flags.interactive) {
    console.log("  Interactive mode requires additional dependencies.");
    console.log("  npm install @clack/prompts");
    console.log(`For now, creating config with defaults...
`);
  }
  try {
    const yamlContent = import_yaml2.default.stringify(CONFIG_TEMPLATE, {
      indent: 2,
      lineWidth: 0
    });
    await writeFile(configPath, yamlContent, "utf-8");
    console.log(" Initialized .ai-eng/config.yaml with defaults");
    console.log(`
\uD83D\uDCCB Next steps:`);
    console.log("  1. Edit .ai-eng/config.yaml to customize settings");
    console.log("  2. Set up AI models and backends");
    console.log("  3. Configure quality gates for your project");
    console.log(`  4. Run 'ai-eng ralph "your task"' to start development`);
  } catch (error) {
    console.error("Failed to write configuration file");
    process.exit(1);
  }
}
var import_yaml2, CONFIG_TEMPLATE;
var init_init = __esm(() => {
  init_ui();
  import_yaml2 = __toESM(require_dist(), 1);
  CONFIG_TEMPLATE = {
    version: 1,
    runner: {
      backend: "opencode",
      review: "opencode",
      artifactsDir: ".ai-eng/runs",
      maxIters: 3,
      printLogs: false,
      logLevel: "INFO"
    },
    loop: {
      maxCycles: 50,
      cycleRetries: 2,
      checkpointFrequency: 1,
      stuckThreshold: 5
    },
    debug: {
      work: false
    },
    opencode: {
      model: "claude-3-5-sonnet-latest",
      temperature: 0.2,
      promptTimeoutMs: 120000
    },
    anthropic: {
      enabled: false,
      model: "claude-3-5-sonnet-latest"
    },
    gates: {
      lint: { command: "bun run lint" },
      typecheck: { command: "bun run typecheck" },
      test: { command: "bun test" },
      build: { command: "bun run build" },
      acceptance: { command: "git diff --name-only" }
    },
    models: {
      research: "github-copilot/gpt-5.2",
      planning: "github-copilot/gpt-5.2",
      exploration: "github-copilot/gpt-5.2",
      coding: "github-copilot/gpt-5.2",
      default: "github-copilot/gpt-5.2"
    },
    notifications: {
      discord: {
        enabled: false,
        username: "Ralph",
        webhook: {
          source: "env",
          envVar: "DISCORD_WEBHOOK_URL"
        }
      }
    },
    ui: {
      silent: false
    }
  };
});

// src/install/install.ts
var exports_install = {};
__export(exports_install, {
  runInstaller: () => runInstaller
});
import fs2 from "node:fs";
import path2 from "node:path";
import { fileURLToPath } from "node:url";
async function cleanNamespacedDirectory(baseDir, subdir, namespace, silent = false) {
  const dir = path2.join(baseDir, subdir, namespace);
  if (fs2.existsSync(dir)) {
    fs2.rmSync(dir, { recursive: true, force: true });
    if (!silent) {
      console.log(`   Cleaned existing ${subdir}/${namespace}/`);
    }
  }
}
async function cleanAiEngSkills(targetOpenCodeDir, distOpenCodeDir, silent = false) {
  const targetSkillDir = path2.join(targetOpenCodeDir, "skill");
  const distSkillDir = path2.join(distOpenCodeDir, "skill");
  if (!fs2.existsSync(distSkillDir))
    return;
  const aiEngSkillNames = fs2.readdirSync(distSkillDir, { withFileTypes: true }).filter((entry) => entry.isDirectory()).map((entry) => entry.name);
  if (aiEngSkillNames.length === 0)
    return;
  let cleanedCount = 0;
  for (const skillName of aiEngSkillNames) {
    const skillPath = path2.join(targetSkillDir, skillName);
    if (fs2.existsSync(skillPath)) {
      fs2.rmSync(skillPath, { recursive: true, force: true });
      cleanedCount++;
    }
  }
  if (!silent && cleanedCount > 0) {
    console.log(`   Cleaned ${cleanedCount} existing ai-eng skills`);
  }
}
function isPluginReferenced(configPath) {
  try {
    const configContent = fs2.readFileSync(configPath, "utf-8");
    const config = JSON.parse(configContent);
    if (Array.isArray(config.plugin)) {
      return config.plugin.includes("ai-eng-system");
    }
    return false;
  } catch {
    return false;
  }
}
function findOpenCodeConfig(projectDir) {
  const homeDir = process.env.HOME || process.env.USERPROFILE || "";
  const projectConfig = path2.join(projectDir, ".opencode", "opencode.jsonc");
  if (fs2.existsSync(projectConfig)) {
    return { path: projectConfig, isGlobal: false };
  }
  const globalConfig = path2.join(homeDir, ".config", "opencode", "opencode.jsonc");
  if (fs2.existsSync(globalConfig)) {
    return { path: globalConfig, isGlobal: true };
  }
  return null;
}
function detectInstallationScope(projectDir) {
  const config = findOpenCodeConfig(projectDir);
  if (config)
    return config.isGlobal ? "global" : "project";
  if (fs2.existsSync(path2.join(projectDir, "package.json"))) {
    return "project";
  }
  return "global";
}
async function runInstaller(flags) {
  const projectDir = process.cwd();
  const homeDir = process.env.HOME || process.env.USERPROFILE || "";
  const distOpenCodeDir = path2.join(ROOT2, "dist", ".opencode");
  let scope = flags.scope;
  if (!scope || scope === "auto") {
    const detected = detectInstallationScope(projectDir);
    if (!detected) {
      console.log(" Could not detect installation scope. Use --scope project|global");
      process.exit(1);
    }
    scope = detected;
  }
  const targetOpenCodeDir = scope === "global" ? path2.join(homeDir, ".config", "opencode") : path2.join(projectDir, ".opencode");
  if (flags.verbose) {
    console.log(`Installing to: ${targetOpenCodeDir}`);
    console.log(`Scope: ${scope}`);
  }
  if (scope === "project") {
    const opencodeDir = path2.join(projectDir, ".opencode");
    if (!fs2.existsSync(opencodeDir)) {
      console.log(" No .opencode/ directory found in project");
      console.log("   Run 'opencode init' first or use --scope global");
      process.exit(1);
    }
  }
  const config = findOpenCodeConfig(projectDir);
  if (config && !isPluginReferenced(config.path)) {
    console.log("  opencode.jsonc does not reference ai-eng-system plugin");
    console.log("   Add 'ai-eng-system' to the plugin array in opencode.jsonc");
  }
  if (flags.dryRun) {
    console.log("\uD83D\uDD0D dry-run: Would install the following files:");
    console.log(`   Commands -> ${targetOpenCodeDir}/command/${NAMESPACE_PREFIX}/`);
    console.log(`   Agents   -> ${targetOpenCodeDir}/agent/${NAMESPACE_PREFIX}/`);
    console.log(`   Skills   -> ${targetOpenCodeDir}/skill/`);
    return;
  }
  const commandsDir = path2.join(targetOpenCodeDir, "command", NAMESPACE_PREFIX);
  const distCommandsDir = path2.join(distOpenCodeDir, "command", NAMESPACE_PREFIX);
  if (fs2.existsSync(distCommandsDir)) {
    await cleanNamespacedDirectory(targetOpenCodeDir, "command", NAMESPACE_PREFIX);
    fs2.cpSync(distCommandsDir, commandsDir, { recursive: true });
    console.log(`   Installed commands to ${commandsDir}`);
  }
  const agentsDir = path2.join(targetOpenCodeDir, "agent", NAMESPACE_PREFIX);
  const distAgentsDir = path2.join(distOpenCodeDir, "agent", NAMESPACE_PREFIX);
  if (fs2.existsSync(distAgentsDir)) {
    await cleanNamespacedDirectory(targetOpenCodeDir, "agent", NAMESPACE_PREFIX);
    fs2.cpSync(distAgentsDir, agentsDir, { recursive: true });
    console.log(`   Installed agents to ${agentsDir}`);
  }
  const skillsDir = path2.join(targetOpenCodeDir, "skill");
  const distSkillsDir = path2.join(distOpenCodeDir, "skill");
  if (fs2.existsSync(distSkillsDir)) {
    await cleanAiEngSkills(targetOpenCodeDir, distOpenCodeDir);
    fs2.cpSync(distSkillsDir, skillsDir, { recursive: true });
    console.log(`   Installed skills to ${skillsDir}`);
  }
  console.log(`
 Installation complete!`);
  console.log("   Restart OpenCode or Claude Code to use new commands and agents.");
}
var __filename2, __dirname2, ROOT2, NAMESPACE_PREFIX = "ai-eng";
var init_install = __esm(() => {
  __filename2 = fileURLToPath(import.meta.url);
  __dirname2 = path2.dirname(__filename2);
  ROOT2 = path2.dirname(__dirname2);
});

// src/cli/run.ts
import { parseArgs } from "node:util";

// src/config/loadConfig.ts
var import_yaml = __toESM(require_dist(), 1);
import { readFile } from "node:fs/promises";
import { join } from "node:path";

// src/config/schema.ts
var DEFAULT_CONFIG = {
  version: 1,
  runner: {
    backend: "opencode",
    review: "opencode",
    artifactsDir: ".ai-eng/runs",
    maxIters: 3,
    printLogs: false,
    logLevel: "INFO"
  },
  loop: {
    maxCycles: 50,
    cycleRetries: 2,
    checkpointFrequency: 1,
    stuckThreshold: 5
  },
  debug: {
    work: false
  },
  opencode: {
    model: "claude-3-5-sonnet-latest",
    temperature: 0.2,
    serverUrl: undefined,
    directory: undefined,
    promptTimeoutMs: 120000
  },
  anthropic: {
    enabled: false,
    model: "claude-3-5-sonnet-latest"
  },
  gates: {
    lint: { command: "bun run lint" },
    typecheck: { command: "bun run typecheck" },
    test: { command: "bun test" },
    build: { command: "bun run build" },
    acceptance: { command: "git diff --name-only" }
  },
  models: {
    research: "github-copilot/gpt-5.2",
    planning: "github-copilot/gpt-5.2",
    exploration: "github-copilot/gpt-5.2",
    coding: "github-copilot/gpt-5.2",
    default: "github-copilot/gpt-5.2"
  },
  notifications: {
    discord: {
      enabled: false,
      username: "Ralph",
      avatarUrl: undefined,
      webhook: {
        source: "env",
        envVar: "DISCORD_WEBHOOK_URL"
      }
    }
  },
  ui: {
    silent: false
  }
};

// src/config/loadConfig.ts
var ROOT = process.env.TEST_ROOT ?? process.cwd();
function applyEnvOverrides(config) {
  if (process.env.OPENCODE_URL) {
    config.opencode.serverUrl = process.env.OPENCODE_URL;
  }
  if (process.env.OPENCODE_DIRECTORY) {
    config.opencode.directory = process.env.OPENCODE_DIRECTORY;
  }
  if (process.env.OPENCODE_PROMPT_TIMEOUT_MS) {
    const timeout = Number.parseInt(process.env.OPENCODE_PROMPT_TIMEOUT_MS, 10);
    if (Number.isNaN(timeout)) {
      config.opencode.promptTimeoutMs = timeout;
    }
  }
  if (process.env.DISCORD_BOT_USERNAME) {
    config.notifications.discord.username = process.env.DISCORD_BOT_USERNAME;
  }
  if (process.env.DISCORD_BOT_AVATAR_URL) {
    config.notifications.discord.avatarUrl = process.env.DISCORD_BOT_AVATAR_URL;
  }
  if (process.env.AI_ENG_SILENT) {
    config.ui.silent = process.env.AI_ENG_SILENT === "1" || process.env.AI_ENG_SILENT === "true";
  }
  if (process.env.AI_ENG_CYCLE_RETRIES) {
    const retries = Number.parseInt(process.env.AI_ENG_CYCLE_RETRIES, 10);
    if (!Number.isNaN(retries)) {
      config.loop.cycleRetries = retries;
    }
  }
  if (process.env.AI_ENG_DEBUG_WORK) {
    config.debug.work = process.env.AI_ENG_DEBUG_WORK === "1" || process.env.AI_ENG_DEBUG_WORK === "true";
  }
  if (process.env.AI_ENG_TEST_CMD) {
    config.gates.test.command = process.env.AI_ENG_TEST_CMD;
  }
  if (process.env.AI_ENG_LINT_CMD) {
    config.gates.lint.command = process.env.AI_ENG_LINT_CMD;
  }
  if (process.env.AI_ENG_ACCEPTANCE_CMD) {
    config.gates.acceptance.command = process.env.AI_ENG_ACCEPTANCE_CMD;
  }
  if (process.env.AI_ENG_TYPECHECK_CMD) {
    config.gates.typecheck.command = process.env.AI_ENG_TYPECHECK_CMD;
  }
  if (process.env.AI_ENG_BUILD_CMD) {
    config.gates.build.command = process.env.AI_ENG_BUILD_CMD;
  }
}
function mergeGateConfig(existing, incoming) {
  if (typeof incoming === "string") {
    return { command: incoming };
  }
  return {
    command: incoming.command ?? existing.command
  };
}
async function loadConfig(flags) {
  const config = {
    version: DEFAULT_CONFIG.version,
    runner: { ...DEFAULT_CONFIG.runner },
    loop: { ...DEFAULT_CONFIG.loop },
    debug: { ...DEFAULT_CONFIG.debug },
    opencode: { ...DEFAULT_CONFIG.opencode },
    anthropic: { ...DEFAULT_CONFIG.anthropic },
    gates: {
      lint: { ...DEFAULT_CONFIG.gates.lint },
      typecheck: { ...DEFAULT_CONFIG.gates.typecheck },
      test: { ...DEFAULT_CONFIG.gates.test },
      build: { ...DEFAULT_CONFIG.gates.build },
      acceptance: { ...DEFAULT_CONFIG.gates.acceptance }
    },
    models: { ...DEFAULT_CONFIG.models },
    notifications: {
      discord: { ...DEFAULT_CONFIG.notifications.discord }
    },
    ui: { ...DEFAULT_CONFIG.ui }
  };
  const configPath = join(ROOT, ".ai-eng", "config.yaml");
  try {
    const configContent = await readFile(configPath, "utf-8");
    const userConfig = import_yaml.default.parse(configContent);
    if (userConfig.version) {
      config.version = userConfig.version;
    }
    if (userConfig.runner) {
      config.runner = { ...config.runner, ...userConfig.runner };
    }
    if (userConfig.loop) {
      config.loop = { ...config.loop, ...userConfig.loop };
    }
    if (userConfig.debug) {
      config.debug = { ...config.debug, ...userConfig.debug };
    }
    if (userConfig.opencode) {
      config.opencode = { ...config.opencode, ...userConfig.opencode };
    }
    if (userConfig.anthropic) {
      config.anthropic = { ...config.anthropic, ...userConfig.anthropic };
    }
    if (userConfig.gates) {
      if (userConfig.gates.lint) {
        config.gates.lint = mergeGateConfig(config.gates.lint, userConfig.gates.lint);
      }
      if (userConfig.gates.typecheck) {
        config.gates.typecheck = mergeGateConfig(config.gates.typecheck, userConfig.gates.typecheck);
      }
      if (userConfig.gates.test) {
        config.gates.test = mergeGateConfig(config.gates.test, userConfig.gates.test);
      }
      if (userConfig.gates.build) {
        config.gates.build = mergeGateConfig(config.gates.build, userConfig.gates.build);
      }
      if (userConfig.gates.acceptance) {
        config.gates.acceptance = mergeGateConfig(config.gates.acceptance, userConfig.gates.acceptance);
      }
    }
    if (userConfig.models) {
      config.models = { ...config.models, ...userConfig.models };
    }
    if (userConfig.notifications) {
      if (userConfig.notifications.discord) {
        config.notifications.discord = {
          ...config.notifications.discord,
          ...userConfig.notifications.discord
        };
      }
    }
    if (userConfig.ui) {
      config.ui = { ...config.ui, ...userConfig.ui };
    }
  } catch (error) {
    if (!(error instanceof Error && error.message.includes("ENOENT"))) {
      console.warn(`Warning: Failed to load config from ${configPath}, using defaults`);
    }
  }
  applyEnvOverrides(config);
  if (flags.maxIters !== undefined) {
    config.runner.maxIters = flags.maxIters;
  }
  if (flags.review !== undefined) {
    config.runner.review = flags.review;
  }
  if (flags.maxCycles !== undefined) {
    config.loop.maxCycles = flags.maxCycles;
  }
  if (flags.stuckThreshold !== undefined) {
    config.loop.stuckThreshold = flags.stuckThreshold;
  }
  if (flags.checkpointFrequency !== undefined) {
    config.loop.checkpointFrequency = flags.checkpointFrequency;
  }
  if (flags.printLogs !== undefined) {
    config.runner.printLogs = flags.printLogs;
  }
  if (flags.logLevel !== undefined) {
    config.runner.logLevel = flags.logLevel;
  }
  if (flags.verbose) {
    config.runner.logLevel = "DEBUG";
  }
  if (flags.workingDir !== undefined) {
    config.opencode.directory = flags.workingDir;
  }
  if (flags.dryRun !== undefined) {}
  return config;
}

// src/util/log.ts
import fs from "node:fs/promises";
import path from "node:path";
var Log;
((Log) => {
  const levelPriority = {
    DEBUG: 0,
    INFO: 1,
    WARN: 2,
    ERROR: 3
  };
  let currentLevel = "INFO";
  let logPath = "";
  let write = (msg) => process.stderr.write(msg);
  function shouldLog(level) {
    return levelPriority[level] >= levelPriority[currentLevel];
  }
  function file() {
    return logPath;
  }
  Log.file = file;
  async function init(options) {
    if (options.level)
      currentLevel = options.level;
    const stderrWriter = (msg) => {
      process.stderr.write(msg);
    };
    if (options.logDir) {
      const timestamp = new Date().toISOString().replace(/[:.]/g, "-").slice(0, -1);
      logPath = path.join(options.logDir, `ralph-${timestamp}.log`);
      await fs.mkdir(options.logDir, { recursive: true });
      const file2 = Bun.file(logPath);
      const fileWriter = file2.writer();
      write = (msg) => {
        if (options.print) {
          stderrWriter(msg);
        }
        fileWriter.write(msg);
        fileWriter.flush();
      };
    } else if (options.print) {
      write = stderrWriter;
    }
  }
  Log.init = init;
  function formatExtra(extra) {
    if (!extra)
      return "";
    const extraStr = Object.entries(extra).map(([k, v]) => `${k}=${typeof v === "object" ? JSON.stringify(v) : v}`).join(" ");
    return extraStr ? ` ${extraStr}` : "";
  }
  function create(tags) {
    const tagStr = tags ? Object.entries(tags).map(([k, v]) => `${k}=${v}`).join(" ") : "";
    const tagStrWithSpace = tagStr ? `${tagStr} ` : "";
    return {
      debug(message, extra) {
        if (shouldLog("DEBUG")) {
          write(`DEBUG ${new Date().toISOString()} ${tagStr}${message}${formatExtra(extra)}
`);
        }
      },
      info(message, extra) {
        if (shouldLog("INFO")) {
          write(`INFO  ${new Date().toISOString()} ${tagStr}${message}${formatExtra(extra)}
`);
        }
      },
      warn(message, extra) {
        if (shouldLog("WARN")) {
          write(`WARN  ${new Date().toISOString()} ${tagStr}${message}${formatExtra(extra)}
`);
        }
      },
      error(message, extra) {
        if (shouldLog("ERROR")) {
          write(`ERROR ${new Date().toISOString()} ${tagStr}${message}${formatExtra(extra)}
`);
        }
      }
    };
  }
  Log.create = create;
  Log.Default = create({ service: "ralph" });
})(Log ||= {});

// node_modules/@clack/core/dist/index.mjs
var import_sisteransi = __toESM(require_src(), 1);
import { stdin as j, stdout as M } from "node:process";
import * as g from "node:readline";
import O from "node:readline";
import { Writable as X } from "node:stream";
function DD({ onlyFirst: e = false } = {}) {
  const t = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?(?:\\u0007|\\u001B\\u005C|\\u009C))", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"].join("|");
  return new RegExp(t, e ? undefined : "g");
}
var uD = DD();
function P(e) {
  if (typeof e != "string")
    throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``);
  return e.replace(uD, "");
}
function L(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var W = { exports: {} };
(function(e) {
  var u = {};
  e.exports = u, u.eastAsianWidth = function(F) {
    var s = F.charCodeAt(0), i = F.length == 2 ? F.charCodeAt(1) : 0, D = s;
    return 55296 <= s && s <= 56319 && 56320 <= i && i <= 57343 && (s &= 1023, i &= 1023, D = s << 10 | i, D += 65536), D == 12288 || 65281 <= D && D <= 65376 || 65504 <= D && D <= 65510 ? "F" : D == 8361 || 65377 <= D && D <= 65470 || 65474 <= D && D <= 65479 || 65482 <= D && D <= 65487 || 65490 <= D && D <= 65495 || 65498 <= D && D <= 65500 || 65512 <= D && D <= 65518 ? "H" : 4352 <= D && D <= 4447 || 4515 <= D && D <= 4519 || 4602 <= D && D <= 4607 || 9001 <= D && D <= 9002 || 11904 <= D && D <= 11929 || 11931 <= D && D <= 12019 || 12032 <= D && D <= 12245 || 12272 <= D && D <= 12283 || 12289 <= D && D <= 12350 || 12353 <= D && D <= 12438 || 12441 <= D && D <= 12543 || 12549 <= D && D <= 12589 || 12593 <= D && D <= 12686 || 12688 <= D && D <= 12730 || 12736 <= D && D <= 12771 || 12784 <= D && D <= 12830 || 12832 <= D && D <= 12871 || 12880 <= D && D <= 13054 || 13056 <= D && D <= 19903 || 19968 <= D && D <= 42124 || 42128 <= D && D <= 42182 || 43360 <= D && D <= 43388 || 44032 <= D && D <= 55203 || 55216 <= D && D <= 55238 || 55243 <= D && D <= 55291 || 63744 <= D && D <= 64255 || 65040 <= D && D <= 65049 || 65072 <= D && D <= 65106 || 65108 <= D && D <= 65126 || 65128 <= D && D <= 65131 || 110592 <= D && D <= 110593 || 127488 <= D && D <= 127490 || 127504 <= D && D <= 127546 || 127552 <= D && D <= 127560 || 127568 <= D && D <= 127569 || 131072 <= D && D <= 194367 || 177984 <= D && D <= 196605 || 196608 <= D && D <= 262141 ? "W" : 32 <= D && D <= 126 || 162 <= D && D <= 163 || 165 <= D && D <= 166 || D == 172 || D == 175 || 10214 <= D && D <= 10221 || 10629 <= D && D <= 10630 ? "Na" : D == 161 || D == 164 || 167 <= D && D <= 168 || D == 170 || 173 <= D && D <= 174 || 176 <= D && D <= 180 || 182 <= D && D <= 186 || 188 <= D && D <= 191 || D == 198 || D == 208 || 215 <= D && D <= 216 || 222 <= D && D <= 225 || D == 230 || 232 <= D && D <= 234 || 236 <= D && D <= 237 || D == 240 || 242 <= D && D <= 243 || 247 <= D && D <= 250 || D == 252 || D == 254 || D == 257 || D == 273 || D == 275 || D == 283 || 294 <= D && D <= 295 || D == 299 || 305 <= D && D <= 307 || D == 312 || 319 <= D && D <= 322 || D == 324 || 328 <= D && D <= 331 || D == 333 || 338 <= D && D <= 339 || 358 <= D && D <= 359 || D == 363 || D == 462 || D == 464 || D == 466 || D == 468 || D == 470 || D == 472 || D == 474 || D == 476 || D == 593 || D == 609 || D == 708 || D == 711 || 713 <= D && D <= 715 || D == 717 || D == 720 || 728 <= D && D <= 731 || D == 733 || D == 735 || 768 <= D && D <= 879 || 913 <= D && D <= 929 || 931 <= D && D <= 937 || 945 <= D && D <= 961 || 963 <= D && D <= 969 || D == 1025 || 1040 <= D && D <= 1103 || D == 1105 || D == 8208 || 8211 <= D && D <= 8214 || 8216 <= D && D <= 8217 || 8220 <= D && D <= 8221 || 8224 <= D && D <= 8226 || 8228 <= D && D <= 8231 || D == 8240 || 8242 <= D && D <= 8243 || D == 8245 || D == 8251 || D == 8254 || D == 8308 || D == 8319 || 8321 <= D && D <= 8324 || D == 8364 || D == 8451 || D == 8453 || D == 8457 || D == 8467 || D == 8470 || 8481 <= D && D <= 8482 || D == 8486 || D == 8491 || 8531 <= D && D <= 8532 || 8539 <= D && D <= 8542 || 8544 <= D && D <= 8555 || 8560 <= D && D <= 8569 || D == 8585 || 8592 <= D && D <= 8601 || 8632 <= D && D <= 8633 || D == 8658 || D == 8660 || D == 8679 || D == 8704 || 8706 <= D && D <= 8707 || 8711 <= D && D <= 8712 || D == 8715 || D == 8719 || D == 8721 || D == 8725 || D == 8730 || 8733 <= D && D <= 8736 || D == 8739 || D == 8741 || 8743 <= D && D <= 8748 || D == 8750 || 8756 <= D && D <= 8759 || 8764 <= D && D <= 8765 || D == 8776 || D == 8780 || D == 8786 || 8800 <= D && D <= 8801 || 8804 <= D && D <= 8807 || 8810 <= D && D <= 8811 || 8814 <= D && D <= 8815 || 8834 <= D && D <= 8835 || 8838 <= D && D <= 8839 || D == 8853 || D == 8857 || D == 8869 || D == 8895 || D == 8978 || 9312 <= D && D <= 9449 || 9451 <= D && D <= 9547 || 9552 <= D && D <= 9587 || 9600 <= D && D <= 9615 || 9618 <= D && D <= 9621 || 9632 <= D && D <= 9633 || 9635 <= D && D <= 9641 || 9650 <= D && D <= 9651 || 9654 <= D && D <= 9655 || 9660 <= D && D <= 9661 || 9664 <= D && D <= 9665 || 9670 <= D && D <= 9672 || D == 9675 || 9678 <= D && D <= 9681 || 9698 <= D && D <= 9701 || D == 9711 || 9733 <= D && D <= 9734 || D == 9737 || 9742 <= D && D <= 9743 || 9748 <= D && D <= 9749 || D == 9756 || D == 9758 || D == 9792 || D == 9794 || 9824 <= D && D <= 9825 || 9827 <= D && D <= 9829 || 9831 <= D && D <= 9834 || 9836 <= D && D <= 9837 || D == 9839 || 9886 <= D && D <= 9887 || 9918 <= D && D <= 9919 || 9924 <= D && D <= 9933 || 9935 <= D && D <= 9953 || D == 9955 || 9960 <= D && D <= 9983 || D == 10045 || D == 10071 || 10102 <= D && D <= 10111 || 11093 <= D && D <= 11097 || 12872 <= D && D <= 12879 || 57344 <= D && D <= 63743 || 65024 <= D && D <= 65039 || D == 65533 || 127232 <= D && D <= 127242 || 127248 <= D && D <= 127277 || 127280 <= D && D <= 127337 || 127344 <= D && D <= 127386 || 917760 <= D && D <= 917999 || 983040 <= D && D <= 1048573 || 1048576 <= D && D <= 1114109 ? "A" : "N";
  }, u.characterLength = function(F) {
    var s = this.eastAsianWidth(F);
    return s == "F" || s == "W" || s == "A" ? 2 : 1;
  };
  function t(F) {
    return F.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]|[^\uD800-\uDFFF]/g) || [];
  }
  u.length = function(F) {
    for (var s = t(F), i = 0, D = 0;D < s.length; D++)
      i = i + this.characterLength(s[D]);
    return i;
  }, u.slice = function(F, s, i) {
    textLen = u.length(F), s = s || 0, i = i || 1, s < 0 && (s = textLen + s), i < 0 && (i = textLen + i);
    for (var D = "", C = 0, n = t(F), E = 0;E < n.length; E++) {
      var a = n[E], o = u.length(a);
      if (C >= s - (o == 2 ? 1 : 0))
        if (C + o <= i)
          D += a;
        else
          break;
      C += o;
    }
    return D;
  };
})(W);
var tD = W.exports;
var eD = L(tD);
var FD = function() {
  return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
};
var sD = L(FD);
function p(e, u = {}) {
  if (typeof e != "string" || e.length === 0 || (u = { ambiguousIsNarrow: true, ...u }, e = P(e), e.length === 0))
    return 0;
  e = e.replace(sD(), "  ");
  const t = u.ambiguousIsNarrow ? 1 : 2;
  let F = 0;
  for (const s of e) {
    const i = s.codePointAt(0);
    if (i <= 31 || i >= 127 && i <= 159 || i >= 768 && i <= 879)
      continue;
    switch (eD.eastAsianWidth(s)) {
      case "F":
      case "W":
        F += 2;
        break;
      case "A":
        F += t;
        break;
      default:
        F += 1;
    }
  }
  return F;
}
var w = 10;
var N = (e = 0) => (u) => `\x1B[${u + e}m`;
var I = (e = 0) => (u) => `\x1B[${38 + e};5;${u}m`;
var R = (e = 0) => (u, t, F) => `\x1B[${38 + e};2;${u};${t};${F}m`;
var r = { modifier: { reset: [0, 0], bold: [1, 22], dim: [2, 22], italic: [3, 23], underline: [4, 24], overline: [53, 55], inverse: [7, 27], hidden: [8, 28], strikethrough: [9, 29] }, color: { black: [30, 39], red: [31, 39], green: [32, 39], yellow: [33, 39], blue: [34, 39], magenta: [35, 39], cyan: [36, 39], white: [37, 39], blackBright: [90, 39], gray: [90, 39], grey: [90, 39], redBright: [91, 39], greenBright: [92, 39], yellowBright: [93, 39], blueBright: [94, 39], magentaBright: [95, 39], cyanBright: [96, 39], whiteBright: [97, 39] }, bgColor: { bgBlack: [40, 49], bgRed: [41, 49], bgGreen: [42, 49], bgYellow: [43, 49], bgBlue: [44, 49], bgMagenta: [45, 49], bgCyan: [46, 49], bgWhite: [47, 49], bgBlackBright: [100, 49], bgGray: [100, 49], bgGrey: [100, 49], bgRedBright: [101, 49], bgGreenBright: [102, 49], bgYellowBright: [103, 49], bgBlueBright: [104, 49], bgMagentaBright: [105, 49], bgCyanBright: [106, 49], bgWhiteBright: [107, 49] } };
Object.keys(r.modifier);
var iD = Object.keys(r.color);
var CD = Object.keys(r.bgColor);
[...iD, ...CD];
function rD() {
  const e = new Map;
  for (const [u, t] of Object.entries(r)) {
    for (const [F, s] of Object.entries(t))
      r[F] = { open: `\x1B[${s[0]}m`, close: `\x1B[${s[1]}m` }, t[F] = r[F], e.set(s[0], s[1]);
    Object.defineProperty(r, u, { value: t, enumerable: false });
  }
  return Object.defineProperty(r, "codes", { value: e, enumerable: false }), r.color.close = "\x1B[39m", r.bgColor.close = "\x1B[49m", r.color.ansi = N(), r.color.ansi256 = I(), r.color.ansi16m = R(), r.bgColor.ansi = N(w), r.bgColor.ansi256 = I(w), r.bgColor.ansi16m = R(w), Object.defineProperties(r, { rgbToAnsi256: { value: (u, t, F) => u === t && t === F ? u < 8 ? 16 : u > 248 ? 231 : Math.round((u - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(u / 255 * 5) + 6 * Math.round(t / 255 * 5) + Math.round(F / 255 * 5), enumerable: false }, hexToRgb: { value: (u) => {
    const t = /[a-f\d]{6}|[a-f\d]{3}/i.exec(u.toString(16));
    if (!t)
      return [0, 0, 0];
    let [F] = t;
    F.length === 3 && (F = [...F].map((i) => i + i).join(""));
    const s = Number.parseInt(F, 16);
    return [s >> 16 & 255, s >> 8 & 255, s & 255];
  }, enumerable: false }, hexToAnsi256: { value: (u) => r.rgbToAnsi256(...r.hexToRgb(u)), enumerable: false }, ansi256ToAnsi: { value: (u) => {
    if (u < 8)
      return 30 + u;
    if (u < 16)
      return 90 + (u - 8);
    let t, F, s;
    if (u >= 232)
      t = ((u - 232) * 10 + 8) / 255, F = t, s = t;
    else {
      u -= 16;
      const C = u % 36;
      t = Math.floor(u / 36) / 5, F = Math.floor(C / 6) / 5, s = C % 6 / 5;
    }
    const i = Math.max(t, F, s) * 2;
    if (i === 0)
      return 30;
    let D = 30 + (Math.round(s) << 2 | Math.round(F) << 1 | Math.round(t));
    return i === 2 && (D += 60), D;
  }, enumerable: false }, rgbToAnsi: { value: (u, t, F) => r.ansi256ToAnsi(r.rgbToAnsi256(u, t, F)), enumerable: false }, hexToAnsi: { value: (u) => r.ansi256ToAnsi(r.hexToAnsi256(u)), enumerable: false } }), r;
}
var ED = rD();
var d = new Set(["\x1B", ""]);
var oD = 39;
var y = "\x07";
var V = "[";
var nD = "]";
var G = "m";
var _ = `${nD}8;;`;
var z = (e) => `${d.values().next().value}${V}${e}${G}`;
var K = (e) => `${d.values().next().value}${_}${e}${y}`;
var aD = (e) => e.split(" ").map((u) => p(u));
var k = (e, u, t) => {
  const F = [...u];
  let s = false, i = false, D = p(P(e[e.length - 1]));
  for (const [C, n] of F.entries()) {
    const E = p(n);
    if (D + E <= t ? e[e.length - 1] += n : (e.push(n), D = 0), d.has(n) && (s = true, i = F.slice(C + 1).join("").startsWith(_)), s) {
      i ? n === y && (s = false, i = false) : n === G && (s = false);
      continue;
    }
    D += E, D === t && C < F.length - 1 && (e.push(""), D = 0);
  }
  !D && e[e.length - 1].length > 0 && e.length > 1 && (e[e.length - 2] += e.pop());
};
var hD = (e) => {
  const u = e.split(" ");
  let t = u.length;
  for (;t > 0 && !(p(u[t - 1]) > 0); )
    t--;
  return t === u.length ? e : u.slice(0, t).join(" ") + u.slice(t).join("");
};
var lD = (e, u, t = {}) => {
  if (t.trim !== false && e.trim() === "")
    return "";
  let F = "", s, i;
  const D = aD(e);
  let C = [""];
  for (const [E, a] of e.split(" ").entries()) {
    t.trim !== false && (C[C.length - 1] = C[C.length - 1].trimStart());
    let o = p(C[C.length - 1]);
    if (E !== 0 && (o >= u && (t.wordWrap === false || t.trim === false) && (C.push(""), o = 0), (o > 0 || t.trim === false) && (C[C.length - 1] += " ", o++)), t.hard && D[E] > u) {
      const c = u - o, f = 1 + Math.floor((D[E] - c - 1) / u);
      Math.floor((D[E] - 1) / u) < f && C.push(""), k(C, a, u);
      continue;
    }
    if (o + D[E] > u && o > 0 && D[E] > 0) {
      if (t.wordWrap === false && o < u) {
        k(C, a, u);
        continue;
      }
      C.push("");
    }
    if (o + D[E] > u && t.wordWrap === false) {
      k(C, a, u);
      continue;
    }
    C[C.length - 1] += a;
  }
  t.trim !== false && (C = C.map((E) => hD(E)));
  const n = [...C.join(`
`)];
  for (const [E, a] of n.entries()) {
    if (F += a, d.has(a)) {
      const { groups: c } = new RegExp(`(?:\\${V}(?<code>\\d+)m|\\${_}(?<uri>.*)${y})`).exec(n.slice(E).join("")) || { groups: {} };
      if (c.code !== undefined) {
        const f = Number.parseFloat(c.code);
        s = f === oD ? undefined : f;
      } else
        c.uri !== undefined && (i = c.uri.length === 0 ? undefined : c.uri);
    }
    const o = ED.codes.get(Number(s));
    n[E + 1] === `
` ? (i && (F += K("")), s && o && (F += z(o))) : a === `
` && (s && o && (F += z(s)), i && (F += K(i)));
  }
  return F;
};
function Y(e, u, t) {
  return String(e).normalize().replace(/\r\n/g, `
`).split(`
`).map((F) => lD(F, u, t)).join(`
`);
}
var xD = ["up", "down", "left", "right", "space", "enter", "cancel"];
var B = { actions: new Set(xD), aliases: new Map([["k", "up"], ["j", "down"], ["h", "left"], ["l", "right"], ["\x03", "cancel"], ["escape", "cancel"]]) };
function $(e, u) {
  if (typeof e == "string")
    return B.aliases.get(e) === u;
  for (const t of e)
    if (t !== undefined && $(t, u))
      return true;
  return false;
}
function BD(e, u) {
  if (e === u)
    return;
  const t = e.split(`
`), F = u.split(`
`), s = [];
  for (let i = 0;i < Math.max(t.length, F.length); i++)
    t[i] !== F[i] && s.push(i);
  return s;
}
var AD = globalThis.process.platform.startsWith("win");
var S = Symbol("clack:cancel");
function pD(e) {
  return e === S;
}
function m(e, u) {
  const t = e;
  t.isTTY && t.setRawMode(u);
}
function fD({ input: e = j, output: u = M, overwrite: t = true, hideCursor: F = true } = {}) {
  const s = g.createInterface({ input: e, output: u, prompt: "", tabSize: 1 });
  g.emitKeypressEvents(e, s), e.isTTY && e.setRawMode(true);
  const i = (D, { name: C, sequence: n }) => {
    const E = String(D);
    if ($([E, C, n], "cancel")) {
      F && u.write(import_sisteransi.cursor.show), process.exit(0);
      return;
    }
    if (!t)
      return;
    const a = C === "return" ? 0 : -1, o = C === "return" ? -1 : 0;
    g.moveCursor(u, a, o, () => {
      g.clearLine(u, 1, () => {
        e.once("keypress", i);
      });
    });
  };
  return F && u.write(import_sisteransi.cursor.hide), e.once("keypress", i), () => {
    e.off("keypress", i), F && u.write(import_sisteransi.cursor.show), e.isTTY && !AD && e.setRawMode(false), s.terminal = false, s.close();
  };
}
var gD = Object.defineProperty;
var vD = (e, u, t) => (u in e) ? gD(e, u, { enumerable: true, configurable: true, writable: true, value: t }) : e[u] = t;
var h = (e, u, t) => (vD(e, typeof u != "symbol" ? u + "" : u, t), t);

class x {
  constructor(u, t = true) {
    h(this, "input"), h(this, "output"), h(this, "_abortSignal"), h(this, "rl"), h(this, "opts"), h(this, "_render"), h(this, "_track", false), h(this, "_prevFrame", ""), h(this, "_subscribers", new Map), h(this, "_cursor", 0), h(this, "state", "initial"), h(this, "error", ""), h(this, "value");
    const { input: F = j, output: s = M, render: i, signal: D, ...C } = u;
    this.opts = C, this.onKeypress = this.onKeypress.bind(this), this.close = this.close.bind(this), this.render = this.render.bind(this), this._render = i.bind(this), this._track = t, this._abortSignal = D, this.input = F, this.output = s;
  }
  unsubscribe() {
    this._subscribers.clear();
  }
  setSubscriber(u, t) {
    const F = this._subscribers.get(u) ?? [];
    F.push(t), this._subscribers.set(u, F);
  }
  on(u, t) {
    this.setSubscriber(u, { cb: t });
  }
  once(u, t) {
    this.setSubscriber(u, { cb: t, once: true });
  }
  emit(u, ...t) {
    const F = this._subscribers.get(u) ?? [], s = [];
    for (const i of F)
      i.cb(...t), i.once && s.push(() => F.splice(F.indexOf(i), 1));
    for (const i of s)
      i();
  }
  prompt() {
    return new Promise((u, t) => {
      if (this._abortSignal) {
        if (this._abortSignal.aborted)
          return this.state = "cancel", this.close(), u(S);
        this._abortSignal.addEventListener("abort", () => {
          this.state = "cancel", this.close();
        }, { once: true });
      }
      const F = new X;
      F._write = (s, i, D) => {
        this._track && (this.value = this.rl?.line.replace(/\t/g, ""), this._cursor = this.rl?.cursor ?? 0, this.emit("value", this.value)), D();
      }, this.input.pipe(F), this.rl = O.createInterface({ input: this.input, output: F, tabSize: 2, prompt: "", escapeCodeTimeout: 50, terminal: true }), O.emitKeypressEvents(this.input, this.rl), this.rl.prompt(), this.opts.initialValue !== undefined && this._track && this.rl.write(this.opts.initialValue), this.input.on("keypress", this.onKeypress), m(this.input, true), this.output.on("resize", this.render), this.render(), this.once("submit", () => {
        this.output.write(import_sisteransi.cursor.show), this.output.off("resize", this.render), m(this.input, false), u(this.value);
      }), this.once("cancel", () => {
        this.output.write(import_sisteransi.cursor.show), this.output.off("resize", this.render), m(this.input, false), u(S);
      });
    });
  }
  onKeypress(u, t) {
    if (this.state === "error" && (this.state = "active"), t?.name && (!this._track && B.aliases.has(t.name) && this.emit("cursor", B.aliases.get(t.name)), B.actions.has(t.name) && this.emit("cursor", t.name)), u && (u.toLowerCase() === "y" || u.toLowerCase() === "n") && this.emit("confirm", u.toLowerCase() === "y"), u === "\t" && this.opts.placeholder && (this.value || (this.rl?.write(this.opts.placeholder), this.emit("value", this.opts.placeholder))), u && this.emit("key", u.toLowerCase()), t?.name === "return") {
      if (this.opts.validate) {
        const F = this.opts.validate(this.value);
        F && (this.error = F instanceof Error ? F.message : F, this.state = "error", this.rl?.write(this.value));
      }
      this.state !== "error" && (this.state = "submit");
    }
    $([u, t?.name, t?.sequence], "cancel") && (this.state = "cancel"), (this.state === "submit" || this.state === "cancel") && this.emit("finalize"), this.render(), (this.state === "submit" || this.state === "cancel") && this.close();
  }
  close() {
    this.input.unpipe(), this.input.removeListener("keypress", this.onKeypress), this.output.write(`
`), m(this.input, false), this.rl?.close(), this.rl = undefined, this.emit(`${this.state}`, this.value), this.unsubscribe();
  }
  restoreCursor() {
    const u = Y(this._prevFrame, process.stdout.columns, { hard: true }).split(`
`).length - 1;
    this.output.write(import_sisteransi.cursor.move(-999, u * -1));
  }
  render() {
    const u = Y(this._render(this) ?? "", process.stdout.columns, { hard: true });
    if (u !== this._prevFrame) {
      if (this.state === "initial")
        this.output.write(import_sisteransi.cursor.hide);
      else {
        const t = BD(this._prevFrame, u);
        if (this.restoreCursor(), t && t?.length === 1) {
          const F = t[0];
          this.output.write(import_sisteransi.cursor.move(0, F)), this.output.write(import_sisteransi.erase.lines(1));
          const s = u.split(`
`);
          this.output.write(s[F]), this._prevFrame = u, this.output.write(import_sisteransi.cursor.move(0, s.length - F - 1));
          return;
        }
        if (t && t?.length > 1) {
          const F = t[0];
          this.output.write(import_sisteransi.cursor.move(0, F)), this.output.write(import_sisteransi.erase.down());
          const s = u.split(`
`).slice(F);
          this.output.write(s.join(`
`)), this._prevFrame = u;
          return;
        }
        this.output.write(import_sisteransi.erase.down());
      }
      this.output.write(u), this.state === "initial" && (this.state = "active"), this._prevFrame = u;
    }
  }
}
var A;
A = new WeakMap;
var OD = Object.defineProperty;
var PD = (e, u, t) => (u in e) ? OD(e, u, { enumerable: true, configurable: true, writable: true, value: t }) : e[u] = t;
var J = (e, u, t) => (PD(e, typeof u != "symbol" ? u + "" : u, t), t);

class LD extends x {
  constructor(u) {
    super(u, false), J(this, "options"), J(this, "cursor", 0), this.options = u.options, this.cursor = this.options.findIndex(({ value: t }) => t === u.initialValue), this.cursor === -1 && (this.cursor = 0), this.changeValue(), this.on("cursor", (t) => {
      switch (t) {
        case "left":
        case "up":
          this.cursor = this.cursor === 0 ? this.options.length - 1 : this.cursor - 1;
          break;
        case "down":
        case "right":
          this.cursor = this.cursor === this.options.length - 1 ? 0 : this.cursor + 1;
          break;
      }
      this.changeValue();
    });
  }
  get _value() {
    return this.options[this.cursor];
  }
  changeValue() {
    this.value = this._value.value;
  }
}

// node_modules/@clack/prompts/dist/index.mjs
var import_picocolors = __toESM(require_picocolors(), 1);
var import_sisteransi2 = __toESM(require_src(), 1);
import y2 from "node:process";
function ce() {
  return y2.platform !== "win32" ? y2.env.TERM !== "linux" : !!y2.env.CI || !!y2.env.WT_SESSION || !!y2.env.TERMINUS_SUBLIME || y2.env.ConEmuTask === "{cmd::Cmder}" || y2.env.TERM_PROGRAM === "Terminus-Sublime" || y2.env.TERM_PROGRAM === "vscode" || y2.env.TERM === "xterm-256color" || y2.env.TERM === "alacritty" || y2.env.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}
var V2 = ce();
var u = (t, n) => V2 ? t : n;
var le = u("", "*");
var L2 = u("", "x");
var W2 = u("", "x");
var C = u("", "o");
var ue = u("", "T");
var o = u("", "|");
var d2 = u("", "");
var k2 = u("", ">");
var P2 = u("", " ");
var A2 = u("", "[]");
var T = u("", "[+]");
var F = u("", "[ ]");
var $e = u("", "");
var _2 = u("", "-");
var me = u("", "+");
var de = u("", "+");
var pe = u("", "+");
var q = u("", "");
var D = u("", "*");
var U = u("", "!");
var K2 = u("", "x");
var b2 = (t) => {
  switch (t) {
    case "initial":
    case "active":
      return import_picocolors.default.cyan(le);
    case "cancel":
      return import_picocolors.default.red(L2);
    case "error":
      return import_picocolors.default.yellow(W2);
    case "submit":
      return import_picocolors.default.green(C);
  }
};
var G2 = (t) => {
  const { cursor: n, options: r2, style: i } = t, s = t.maxItems ?? Number.POSITIVE_INFINITY, c = Math.max(process.stdout.rows - 4, 0), a = Math.min(c, Math.max(s, 5));
  let l2 = 0;
  n >= l2 + a - 3 ? l2 = Math.max(Math.min(n - a + 3, r2.length - a), 0) : n < l2 + 2 && (l2 = Math.max(n - 2, 0));
  const $2 = a < r2.length && l2 > 0, g2 = a < r2.length && l2 + a < r2.length;
  return r2.slice(l2, l2 + a).map((p2, v, f) => {
    const j2 = v === 0 && $2, E = v === f.length - 1 && g2;
    return j2 || E ? import_picocolors.default.dim("...") : i(p2, v + l2 === n);
  });
};
var ve = (t) => {
  const n = (r2, i) => {
    const s = r2.label ?? String(r2.value);
    switch (i) {
      case "selected":
        return `${import_picocolors.default.dim(s)}`;
      case "active":
        return `${import_picocolors.default.green(k2)} ${s} ${r2.hint ? import_picocolors.default.dim(`(${r2.hint})`) : ""}`;
      case "cancelled":
        return `${import_picocolors.default.strikethrough(import_picocolors.default.dim(s))}`;
      default:
        return `${import_picocolors.default.dim(P2)} ${import_picocolors.default.dim(s)}`;
    }
  };
  return new LD({ options: t.options, initialValue: t.initialValue, render() {
    const r2 = `${import_picocolors.default.gray(o)}
${b2(this.state)}  ${t.message}
`;
    switch (this.state) {
      case "submit":
        return `${r2}${import_picocolors.default.gray(o)}  ${n(this.options[this.cursor], "selected")}`;
      case "cancel":
        return `${r2}${import_picocolors.default.gray(o)}  ${n(this.options[this.cursor], "cancelled")}
${import_picocolors.default.gray(o)}`;
      default:
        return `${r2}${import_picocolors.default.cyan(o)}  ${G2({ cursor: this.cursor, options: this.options, maxItems: t.maxItems, style: (i, s) => n(i, s ? "active" : "inactive") }).join(`
${import_picocolors.default.cyan(o)}  `)}
${import_picocolors.default.cyan(d2)}
`;
    }
  } }).prompt();
};
var Se = (t = "") => {
  process.stdout.write(`${import_picocolors.default.gray(o)}
${import_picocolors.default.gray(d2)}  ${t}

`);
};
var J2 = `${import_picocolors.default.gray(o)}  `;
var Y2 = ({ indicator: t = "dots" } = {}) => {
  const n = V2 ? ["", "", "", ""] : ["", "o", "O", "0"], r2 = V2 ? 80 : 120, i = process.env.CI === "true";
  let s, c, a = false, l2 = "", $2, g2 = performance.now();
  const p2 = (m2) => {
    const h2 = m2 > 1 ? "Something went wrong" : "Canceled";
    a && N2(h2, m2);
  }, v = () => p2(2), f = () => p2(1), j2 = () => {
    process.on("uncaughtExceptionMonitor", v), process.on("unhandledRejection", v), process.on("SIGINT", f), process.on("SIGTERM", f), process.on("exit", p2);
  }, E = () => {
    process.removeListener("uncaughtExceptionMonitor", v), process.removeListener("unhandledRejection", v), process.removeListener("SIGINT", f), process.removeListener("SIGTERM", f), process.removeListener("exit", p2);
  }, B2 = () => {
    if ($2 === undefined)
      return;
    i && process.stdout.write(`
`);
    const m2 = $2.split(`
`);
    process.stdout.write(import_sisteransi2.cursor.move(-999, m2.length - 1)), process.stdout.write(import_sisteransi2.erase.down(m2.length));
  }, R2 = (m2) => m2.replace(/\.+$/, ""), O2 = (m2) => {
    const h2 = (performance.now() - m2) / 1000, w2 = Math.floor(h2 / 60), I2 = Math.floor(h2 % 60);
    return w2 > 0 ? `[${w2}m ${I2}s]` : `[${I2}s]`;
  }, H = (m2 = "") => {
    a = true, s = fD(), l2 = R2(m2), g2 = performance.now(), process.stdout.write(`${import_picocolors.default.gray(o)}
`);
    let h2 = 0, w2 = 0;
    j2(), c = setInterval(() => {
      if (i && l2 === $2)
        return;
      B2(), $2 = l2;
      const I2 = import_picocolors.default.magenta(n[h2]);
      if (i)
        process.stdout.write(`${I2}  ${l2}...`);
      else if (t === "timer")
        process.stdout.write(`${I2}  ${l2} ${O2(g2)}`);
      else {
        const z2 = ".".repeat(Math.floor(w2)).slice(0, 3);
        process.stdout.write(`${I2}  ${l2}${z2}`);
      }
      h2 = h2 + 1 < n.length ? h2 + 1 : 0, w2 = w2 < n.length ? w2 + 0.125 : 0;
    }, r2);
  }, N2 = (m2 = "", h2 = 0) => {
    a = false, clearInterval(c), B2();
    const w2 = h2 === 0 ? import_picocolors.default.green(C) : h2 === 1 ? import_picocolors.default.red(L2) : import_picocolors.default.red(W2);
    l2 = R2(m2 ?? l2), t === "timer" ? process.stdout.write(`${w2}  ${l2} ${O2(g2)}
`) : process.stdout.write(`${w2}  ${l2}
`), E(), s();
  };
  return { start: H, stop: N2, message: (m2 = "") => {
    l2 = R2(m2 ?? l2);
  } };
};

// src/backends/opencode/client.ts
import { createServer } from "node:net";
// node_modules/@opencode-ai/sdk/dist/gen/core/serverSentEvents.gen.js
var createSseClient = ({ onSseError, onSseEvent, responseTransformer, responseValidator, sseDefaultRetryDelay, sseMaxRetryAttempts, sseMaxRetryDelay, sseSleepFn, url, ...options }) => {
  let lastEventId;
  const sleep = sseSleepFn ?? ((ms) => new Promise((resolve) => setTimeout(resolve, ms)));
  const createStream = async function* () {
    let retryDelay = sseDefaultRetryDelay ?? 3000;
    let attempt = 0;
    const signal = options.signal ?? new AbortController().signal;
    while (true) {
      if (signal.aborted)
        break;
      attempt++;
      const headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers);
      if (lastEventId !== undefined) {
        headers.set("Last-Event-ID", lastEventId);
      }
      try {
        const response = await fetch(url, { ...options, headers, signal });
        if (!response.ok)
          throw new Error(`SSE failed: ${response.status} ${response.statusText}`);
        if (!response.body)
          throw new Error("No body in SSE response");
        const reader = response.body.pipeThrough(new TextDecoderStream).getReader();
        let buffer = "";
        const abortHandler = () => {
          try {
            reader.cancel();
          } catch {}
        };
        signal.addEventListener("abort", abortHandler);
        try {
          while (true) {
            const { done, value } = await reader.read();
            if (done)
              break;
            buffer += value;
            const chunks = buffer.split(`

`);
            buffer = chunks.pop() ?? "";
            for (const chunk of chunks) {
              const lines = chunk.split(`
`);
              const dataLines = [];
              let eventName;
              for (const line of lines) {
                if (line.startsWith("data:")) {
                  dataLines.push(line.replace(/^data:\s*/, ""));
                } else if (line.startsWith("event:")) {
                  eventName = line.replace(/^event:\s*/, "");
                } else if (line.startsWith("id:")) {
                  lastEventId = line.replace(/^id:\s*/, "");
                } else if (line.startsWith("retry:")) {
                  const parsed = Number.parseInt(line.replace(/^retry:\s*/, ""), 10);
                  if (!Number.isNaN(parsed)) {
                    retryDelay = parsed;
                  }
                }
              }
              let data;
              let parsedJson = false;
              if (dataLines.length) {
                const rawData = dataLines.join(`
`);
                try {
                  data = JSON.parse(rawData);
                  parsedJson = true;
                } catch {
                  data = rawData;
                }
              }
              if (parsedJson) {
                if (responseValidator) {
                  await responseValidator(data);
                }
                if (responseTransformer) {
                  data = await responseTransformer(data);
                }
              }
              onSseEvent?.({
                data,
                event: eventName,
                id: lastEventId,
                retry: retryDelay
              });
              if (dataLines.length) {
                yield data;
              }
            }
          }
        } finally {
          signal.removeEventListener("abort", abortHandler);
          reader.releaseLock();
        }
        break;
      } catch (error) {
        onSseError?.(error);
        if (sseMaxRetryAttempts !== undefined && attempt >= sseMaxRetryAttempts) {
          break;
        }
        const backoff = Math.min(retryDelay * 2 ** (attempt - 1), sseMaxRetryDelay ?? 30000);
        await sleep(backoff);
      }
    }
  };
  const stream = createStream();
  return { stream };
};

// node_modules/@opencode-ai/sdk/dist/gen/core/auth.gen.js
var getAuthToken = async (auth, callback) => {
  const token = typeof callback === "function" ? await callback(auth) : callback;
  if (!token) {
    return;
  }
  if (auth.scheme === "bearer") {
    return `Bearer ${token}`;
  }
  if (auth.scheme === "basic") {
    return `Basic ${btoa(token)}`;
  }
  return token;
};

// node_modules/@opencode-ai/sdk/dist/gen/core/bodySerializer.gen.js
var jsonBodySerializer = {
  bodySerializer: (body) => JSON.stringify(body, (_key, value) => typeof value === "bigint" ? value.toString() : value)
};

// node_modules/@opencode-ai/sdk/dist/gen/core/pathSerializer.gen.js
var separatorArrayExplode = (style) => {
  switch (style) {
    case "label":
      return ".";
    case "matrix":
      return ";";
    case "simple":
      return ",";
    default:
      return "&";
  }
};
var separatorArrayNoExplode = (style) => {
  switch (style) {
    case "form":
      return ",";
    case "pipeDelimited":
      return "|";
    case "spaceDelimited":
      return "%20";
    default:
      return ",";
  }
};
var separatorObjectExplode = (style) => {
  switch (style) {
    case "label":
      return ".";
    case "matrix":
      return ";";
    case "simple":
      return ",";
    default:
      return "&";
  }
};
var serializeArrayParam = ({ allowReserved, explode, name, style, value }) => {
  if (!explode) {
    const joinedValues2 = (allowReserved ? value : value.map((v) => encodeURIComponent(v))).join(separatorArrayNoExplode(style));
    switch (style) {
      case "label":
        return `.${joinedValues2}`;
      case "matrix":
        return `;${name}=${joinedValues2}`;
      case "simple":
        return joinedValues2;
      default:
        return `${name}=${joinedValues2}`;
    }
  }
  const separator = separatorArrayExplode(style);
  const joinedValues = value.map((v) => {
    if (style === "label" || style === "simple") {
      return allowReserved ? v : encodeURIComponent(v);
    }
    return serializePrimitiveParam({
      allowReserved,
      name,
      value: v
    });
  }).join(separator);
  return style === "label" || style === "matrix" ? separator + joinedValues : joinedValues;
};
var serializePrimitiveParam = ({ allowReserved, name, value }) => {
  if (value === undefined || value === null) {
    return "";
  }
  if (typeof value === "object") {
    throw new Error("Deeply-nested arrays/objects arent supported. Provide your own `querySerializer()` to handle these.");
  }
  return `${name}=${allowReserved ? value : encodeURIComponent(value)}`;
};
var serializeObjectParam = ({ allowReserved, explode, name, style, value, valueOnly }) => {
  if (value instanceof Date) {
    return valueOnly ? value.toISOString() : `${name}=${value.toISOString()}`;
  }
  if (style !== "deepObject" && !explode) {
    let values = [];
    Object.entries(value).forEach(([key, v]) => {
      values = [...values, key, allowReserved ? v : encodeURIComponent(v)];
    });
    const joinedValues2 = values.join(",");
    switch (style) {
      case "form":
        return `${name}=${joinedValues2}`;
      case "label":
        return `.${joinedValues2}`;
      case "matrix":
        return `;${name}=${joinedValues2}`;
      default:
        return joinedValues2;
    }
  }
  const separator = separatorObjectExplode(style);
  const joinedValues = Object.entries(value).map(([key, v]) => serializePrimitiveParam({
    allowReserved,
    name: style === "deepObject" ? `${name}[${key}]` : key,
    value: v
  })).join(separator);
  return style === "label" || style === "matrix" ? separator + joinedValues : joinedValues;
};

// node_modules/@opencode-ai/sdk/dist/gen/core/utils.gen.js
var PATH_PARAM_RE = /\{[^{}]+\}/g;
var defaultPathSerializer = ({ path: path2, url: _url }) => {
  let url = _url;
  const matches = _url.match(PATH_PARAM_RE);
  if (matches) {
    for (const match of matches) {
      let explode = false;
      let name = match.substring(1, match.length - 1);
      let style = "simple";
      if (name.endsWith("*")) {
        explode = true;
        name = name.substring(0, name.length - 1);
      }
      if (name.startsWith(".")) {
        name = name.substring(1);
        style = "label";
      } else if (name.startsWith(";")) {
        name = name.substring(1);
        style = "matrix";
      }
      const value = path2[name];
      if (value === undefined || value === null) {
        continue;
      }
      if (Array.isArray(value)) {
        url = url.replace(match, serializeArrayParam({ explode, name, style, value }));
        continue;
      }
      if (typeof value === "object") {
        url = url.replace(match, serializeObjectParam({
          explode,
          name,
          style,
          value,
          valueOnly: true
        }));
        continue;
      }
      if (style === "matrix") {
        url = url.replace(match, `;${serializePrimitiveParam({
          name,
          value
        })}`);
        continue;
      }
      const replaceValue = encodeURIComponent(style === "label" ? `.${value}` : value);
      url = url.replace(match, replaceValue);
    }
  }
  return url;
};
var getUrl = ({ baseUrl, path: path2, query, querySerializer, url: _url }) => {
  const pathUrl = _url.startsWith("/") ? _url : `/${_url}`;
  let url = (baseUrl ?? "") + pathUrl;
  if (path2) {
    url = defaultPathSerializer({ path: path2, url });
  }
  let search = query ? querySerializer(query) : "";
  if (search.startsWith("?")) {
    search = search.substring(1);
  }
  if (search) {
    url += `?${search}`;
  }
  return url;
};

// node_modules/@opencode-ai/sdk/dist/gen/client/utils.gen.js
var createQuerySerializer = ({ allowReserved, array, object } = {}) => {
  const querySerializer = (queryParams) => {
    const search = [];
    if (queryParams && typeof queryParams === "object") {
      for (const name in queryParams) {
        const value = queryParams[name];
        if (value === undefined || value === null) {
          continue;
        }
        if (Array.isArray(value)) {
          const serializedArray = serializeArrayParam({
            allowReserved,
            explode: true,
            name,
            style: "form",
            value,
            ...array
          });
          if (serializedArray)
            search.push(serializedArray);
        } else if (typeof value === "object") {
          const serializedObject = serializeObjectParam({
            allowReserved,
            explode: true,
            name,
            style: "deepObject",
            value,
            ...object
          });
          if (serializedObject)
            search.push(serializedObject);
        } else {
          const serializedPrimitive = serializePrimitiveParam({
            allowReserved,
            name,
            value
          });
          if (serializedPrimitive)
            search.push(serializedPrimitive);
        }
      }
    }
    return search.join("&");
  };
  return querySerializer;
};
var getParseAs = (contentType) => {
  if (!contentType) {
    return "stream";
  }
  const cleanContent = contentType.split(";")[0]?.trim();
  if (!cleanContent) {
    return;
  }
  if (cleanContent.startsWith("application/json") || cleanContent.endsWith("+json")) {
    return "json";
  }
  if (cleanContent === "multipart/form-data") {
    return "formData";
  }
  if (["application/", "audio/", "image/", "video/"].some((type) => cleanContent.startsWith(type))) {
    return "blob";
  }
  if (cleanContent.startsWith("text/")) {
    return "text";
  }
  return;
};
var checkForExistence = (options, name) => {
  if (!name) {
    return false;
  }
  if (options.headers.has(name) || options.query?.[name] || options.headers.get("Cookie")?.includes(`${name}=`)) {
    return true;
  }
  return false;
};
var setAuthParams = async ({ security, ...options }) => {
  for (const auth of security) {
    if (checkForExistence(options, auth.name)) {
      continue;
    }
    const token = await getAuthToken(auth, options.auth);
    if (!token) {
      continue;
    }
    const name = auth.name ?? "Authorization";
    switch (auth.in) {
      case "query":
        if (!options.query) {
          options.query = {};
        }
        options.query[name] = token;
        break;
      case "cookie":
        options.headers.append("Cookie", `${name}=${token}`);
        break;
      case "header":
      default:
        options.headers.set(name, token);
        break;
    }
  }
};
var buildUrl = (options) => getUrl({
  baseUrl: options.baseUrl,
  path: options.path,
  query: options.query,
  querySerializer: typeof options.querySerializer === "function" ? options.querySerializer : createQuerySerializer(options.querySerializer),
  url: options.url
});
var mergeConfigs = (a, b3) => {
  const config = { ...a, ...b3 };
  if (config.baseUrl?.endsWith("/")) {
    config.baseUrl = config.baseUrl.substring(0, config.baseUrl.length - 1);
  }
  config.headers = mergeHeaders(a.headers, b3.headers);
  return config;
};
var mergeHeaders = (...headers) => {
  const mergedHeaders = new Headers;
  for (const header of headers) {
    if (!header || typeof header !== "object") {
      continue;
    }
    const iterator = header instanceof Headers ? header.entries() : Object.entries(header);
    for (const [key, value] of iterator) {
      if (value === null) {
        mergedHeaders.delete(key);
      } else if (Array.isArray(value)) {
        for (const v of value) {
          mergedHeaders.append(key, v);
        }
      } else if (value !== undefined) {
        mergedHeaders.set(key, typeof value === "object" ? JSON.stringify(value) : value);
      }
    }
  }
  return mergedHeaders;
};

class Interceptors {
  _fns;
  constructor() {
    this._fns = [];
  }
  clear() {
    this._fns = [];
  }
  getInterceptorIndex(id) {
    if (typeof id === "number") {
      return this._fns[id] ? id : -1;
    } else {
      return this._fns.indexOf(id);
    }
  }
  exists(id) {
    const index = this.getInterceptorIndex(id);
    return !!this._fns[index];
  }
  eject(id) {
    const index = this.getInterceptorIndex(id);
    if (this._fns[index]) {
      this._fns[index] = null;
    }
  }
  update(id, fn) {
    const index = this.getInterceptorIndex(id);
    if (this._fns[index]) {
      this._fns[index] = fn;
      return id;
    } else {
      return false;
    }
  }
  use(fn) {
    this._fns = [...this._fns, fn];
    return this._fns.length - 1;
  }
}
var createInterceptors = () => ({
  error: new Interceptors,
  request: new Interceptors,
  response: new Interceptors
});
var defaultQuerySerializer = createQuerySerializer({
  allowReserved: false,
  array: {
    explode: true,
    style: "form"
  },
  object: {
    explode: true,
    style: "deepObject"
  }
});
var defaultHeaders = {
  "Content-Type": "application/json"
};
var createConfig = (override = {}) => ({
  ...jsonBodySerializer,
  headers: defaultHeaders,
  parseAs: "auto",
  querySerializer: defaultQuerySerializer,
  ...override
});

// node_modules/@opencode-ai/sdk/dist/gen/client/client.gen.js
var createClient = (config = {}) => {
  let _config = mergeConfigs(createConfig(), config);
  const getConfig = () => ({ ..._config });
  const setConfig = (config2) => {
    _config = mergeConfigs(_config, config2);
    return getConfig();
  };
  const interceptors = createInterceptors();
  const beforeRequest = async (options) => {
    const opts = {
      ..._config,
      ...options,
      fetch: options.fetch ?? _config.fetch ?? globalThis.fetch,
      headers: mergeHeaders(_config.headers, options.headers),
      serializedBody: undefined
    };
    if (opts.security) {
      await setAuthParams({
        ...opts,
        security: opts.security
      });
    }
    if (opts.requestValidator) {
      await opts.requestValidator(opts);
    }
    if (opts.body && opts.bodySerializer) {
      opts.serializedBody = opts.bodySerializer(opts.body);
    }
    if (opts.serializedBody === undefined || opts.serializedBody === "") {
      opts.headers.delete("Content-Type");
    }
    const url = buildUrl(opts);
    return { opts, url };
  };
  const request = async (options) => {
    const { opts, url } = await beforeRequest(options);
    const requestInit = {
      redirect: "follow",
      ...opts,
      body: opts.serializedBody
    };
    let request2 = new Request(url, requestInit);
    for (const fn of interceptors.request._fns) {
      if (fn) {
        request2 = await fn(request2, opts);
      }
    }
    const _fetch = opts.fetch;
    let response = await _fetch(request2);
    for (const fn of interceptors.response._fns) {
      if (fn) {
        response = await fn(response, request2, opts);
      }
    }
    const result = {
      request: request2,
      response
    };
    if (response.ok) {
      if (response.status === 204 || response.headers.get("Content-Length") === "0") {
        return opts.responseStyle === "data" ? {} : {
          data: {},
          ...result
        };
      }
      const parseAs = (opts.parseAs === "auto" ? getParseAs(response.headers.get("Content-Type")) : opts.parseAs) ?? "json";
      let data;
      switch (parseAs) {
        case "arrayBuffer":
        case "blob":
        case "formData":
        case "json":
        case "text":
          data = await response[parseAs]();
          break;
        case "stream":
          return opts.responseStyle === "data" ? response.body : {
            data: response.body,
            ...result
          };
      }
      if (parseAs === "json") {
        if (opts.responseValidator) {
          await opts.responseValidator(data);
        }
        if (opts.responseTransformer) {
          data = await opts.responseTransformer(data);
        }
      }
      return opts.responseStyle === "data" ? data : {
        data,
        ...result
      };
    }
    const textError = await response.text();
    let jsonError;
    try {
      jsonError = JSON.parse(textError);
    } catch {}
    const error = jsonError ?? textError;
    let finalError = error;
    for (const fn of interceptors.error._fns) {
      if (fn) {
        finalError = await fn(error, response, request2, opts);
      }
    }
    finalError = finalError || {};
    if (opts.throwOnError) {
      throw finalError;
    }
    return opts.responseStyle === "data" ? undefined : {
      error: finalError,
      ...result
    };
  };
  const makeMethod = (method) => {
    const fn = (options) => request({ ...options, method });
    fn.sse = async (options) => {
      const { opts, url } = await beforeRequest(options);
      return createSseClient({
        ...opts,
        body: opts.body,
        headers: opts.headers,
        method,
        url
      });
    };
    return fn;
  };
  return {
    buildUrl,
    connect: makeMethod("CONNECT"),
    delete: makeMethod("DELETE"),
    get: makeMethod("GET"),
    getConfig,
    head: makeMethod("HEAD"),
    interceptors,
    options: makeMethod("OPTIONS"),
    patch: makeMethod("PATCH"),
    post: makeMethod("POST"),
    put: makeMethod("PUT"),
    request,
    setConfig,
    trace: makeMethod("TRACE")
  };
};
// node_modules/@opencode-ai/sdk/dist/gen/core/params.gen.js
var extraPrefixesMap = {
  $body_: "body",
  $headers_: "headers",
  $path_: "path",
  $query_: "query"
};
var extraPrefixes = Object.entries(extraPrefixesMap);
// node_modules/@opencode-ai/sdk/dist/gen/client.gen.js
var client = createClient(createConfig({
  baseUrl: "http://localhost:4096"
}));

// node_modules/@opencode-ai/sdk/dist/gen/sdk.gen.js
class _HeyApiClient {
  _client = client;
  constructor(args) {
    if (args?.client) {
      this._client = args.client;
    }
  }
}

class Global extends _HeyApiClient {
  event(options) {
    return (options?.client ?? this._client).get.sse({
      url: "/global/event",
      ...options
    });
  }
}

class Project extends _HeyApiClient {
  list(options) {
    return (options?.client ?? this._client).get({
      url: "/project",
      ...options
    });
  }
  current(options) {
    return (options?.client ?? this._client).get({
      url: "/project/current",
      ...options
    });
  }
}

class Pty extends _HeyApiClient {
  list(options) {
    return (options?.client ?? this._client).get({
      url: "/pty",
      ...options
    });
  }
  create(options) {
    return (options?.client ?? this._client).post({
      url: "/pty",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers
      }
    });
  }
  remove(options) {
    return (options.client ?? this._client).delete({
      url: "/pty/{id}",
      ...options
    });
  }
  get(options) {
    return (options.client ?? this._client).get({
      url: "/pty/{id}",
      ...options
    });
  }
  update(options) {
    return (options.client ?? this._client).put({
      url: "/pty/{id}",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers
      }
    });
  }
  connect(options) {
    return (options.client ?? this._client).get({
      url: "/pty/{id}/connect",
      ...options
    });
  }
}

class Config extends _HeyApiClient {
  get(options) {
    return (options?.client ?? this._client).get({
      url: "/config",
      ...options
    });
  }
  update(options) {
    return (options?.client ?? this._client).patch({
      url: "/config",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers
      }
    });
  }
  providers(options) {
    return (options?.client ?? this._client).get({
      url: "/config/providers",
      ...options
    });
  }
}

class Tool extends _HeyApiClient {
  ids(options) {
    return (options?.client ?? this._client).get({
      url: "/experimental/tool/ids",
      ...options
    });
  }
  list(options) {
    return (options.client ?? this._client).get({
      url: "/experimental/tool",
      ...options
    });
  }
}

class Instance extends _HeyApiClient {
  dispose(options) {
    return (options?.client ?? this._client).post({
      url: "/instance/dispose",
      ...options
    });
  }
}

class Path extends _HeyApiClient {
  get(options) {
    return (options?.client ?? this._client).get({
      url: "/path",
      ...options
    });
  }
}

class Vcs extends _HeyApiClient {
  get(options) {
    return (options?.client ?? this._client).get({
      url: "/vcs",
      ...options
    });
  }
}

class Session extends _HeyApiClient {
  list(options) {
    return (options?.client ?? this._client).get({
      url: "/session",
      ...options
    });
  }
  create(options) {
    return (options?.client ?? this._client).post({
      url: "/session",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers
      }
    });
  }
  status(options) {
    return (options?.client ?? this._client).get({
      url: "/session/status",
      ...options
    });
  }
  delete(options) {
    return (options.client ?? this._client).delete({
      url: "/session/{id}",
      ...options
    });
  }
  get(options) {
    return (options.client ?? this._client).get({
      url: "/session/{id}",
      ...options
    });
  }
  update(options) {
    return (options.client ?? this._client).patch({
      url: "/session/{id}",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers
      }
    });
  }
  children(options) {
    return (options.client ?? this._client).get({
      url: "/session/{id}/children",
      ...options
    });
  }
  todo(options) {
    return (options.client ?? this._client).get({
      url: "/session/{id}/todo",
      ...options
    });
  }
  init(options) {
    return (options.client ?? this._client).post({
      url: "/session/{id}/init",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers
      }
    });
  }
  fork(options) {
    return (options.client ?? this._client).post({
      url: "/session/{id}/fork",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers
      }
    });
  }
  abort(options) {
    return (options.client ?? this._client).post({
      url: "/session/{id}/abort",
      ...options
    });
  }
  unshare(options) {
    return (options.client ?? this._client).delete({
      url: "/session/{id}/share",
      ...options
    });
  }
  share(options) {
    return (options.client ?? this._client).post({
      url: "/session/{id}/share",
      ...options
    });
  }
  diff(options) {
    return (options.client ?? this._client).get({
      url: "/session/{id}/diff",
      ...options
    });
  }
  summarize(options) {
    return (options.client ?? this._client).post({
      url: "/session/{id}/summarize",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers
      }
    });
  }
  messages(options) {
    return (options.client ?? this._client).get({
      url: "/session/{id}/message",
      ...options
    });
  }
  prompt(options) {
    return (options.client ?? this._client).post({
      url: "/session/{id}/message",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers
      }
    });
  }
  message(options) {
    return (options.client ?? this._client).get({
      url: "/session/{id}/message/{messageID}",
      ...options
    });
  }
  promptAsync(options) {
    return (options.client ?? this._client).post({
      url: "/session/{id}/prompt_async",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers
      }
    });
  }
  command(options) {
    return (options.client ?? this._client).post({
      url: "/session/{id}/command",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers
      }
    });
  }
  shell(options) {
    return (options.client ?? this._client).post({
      url: "/session/{id}/shell",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers
      }
    });
  }
  revert(options) {
    return (options.client ?? this._client).post({
      url: "/session/{id}/revert",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers
      }
    });
  }
  unrevert(options) {
    return (options.client ?? this._client).post({
      url: "/session/{id}/unrevert",
      ...options
    });
  }
}

class Command extends _HeyApiClient {
  list(options) {
    return (options?.client ?? this._client).get({
      url: "/command",
      ...options
    });
  }
}

class Oauth extends _HeyApiClient {
  authorize(options) {
    return (options.client ?? this._client).post({
      url: "/provider/{id}/oauth/authorize",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers
      }
    });
  }
  callback(options) {
    return (options.client ?? this._client).post({
      url: "/provider/{id}/oauth/callback",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers
      }
    });
  }
}

class Provider extends _HeyApiClient {
  list(options) {
    return (options?.client ?? this._client).get({
      url: "/provider",
      ...options
    });
  }
  auth(options) {
    return (options?.client ?? this._client).get({
      url: "/provider/auth",
      ...options
    });
  }
  oauth = new Oauth({ client: this._client });
}

class Find extends _HeyApiClient {
  text(options) {
    return (options.client ?? this._client).get({
      url: "/find",
      ...options
    });
  }
  files(options) {
    return (options.client ?? this._client).get({
      url: "/find/file",
      ...options
    });
  }
  symbols(options) {
    return (options.client ?? this._client).get({
      url: "/find/symbol",
      ...options
    });
  }
}

class File extends _HeyApiClient {
  list(options) {
    return (options.client ?? this._client).get({
      url: "/file",
      ...options
    });
  }
  read(options) {
    return (options.client ?? this._client).get({
      url: "/file/content",
      ...options
    });
  }
  status(options) {
    return (options?.client ?? this._client).get({
      url: "/file/status",
      ...options
    });
  }
}

class App extends _HeyApiClient {
  log(options) {
    return (options?.client ?? this._client).post({
      url: "/log",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers
      }
    });
  }
  agents(options) {
    return (options?.client ?? this._client).get({
      url: "/agent",
      ...options
    });
  }
}

class Auth extends _HeyApiClient {
  remove(options) {
    return (options.client ?? this._client).delete({
      url: "/mcp/{name}/auth",
      ...options
    });
  }
  start(options) {
    return (options.client ?? this._client).post({
      url: "/mcp/{name}/auth",
      ...options
    });
  }
  callback(options) {
    return (options.client ?? this._client).post({
      url: "/mcp/{name}/auth/callback",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers
      }
    });
  }
  authenticate(options) {
    return (options.client ?? this._client).post({
      url: "/mcp/{name}/auth/authenticate",
      ...options
    });
  }
  set(options) {
    return (options.client ?? this._client).put({
      url: "/auth/{id}",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers
      }
    });
  }
}

class Mcp extends _HeyApiClient {
  status(options) {
    return (options?.client ?? this._client).get({
      url: "/mcp",
      ...options
    });
  }
  add(options) {
    return (options?.client ?? this._client).post({
      url: "/mcp",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers
      }
    });
  }
  connect(options) {
    return (options.client ?? this._client).post({
      url: "/mcp/{name}/connect",
      ...options
    });
  }
  disconnect(options) {
    return (options.client ?? this._client).post({
      url: "/mcp/{name}/disconnect",
      ...options
    });
  }
  auth = new Auth({ client: this._client });
}

class Lsp extends _HeyApiClient {
  status(options) {
    return (options?.client ?? this._client).get({
      url: "/lsp",
      ...options
    });
  }
}

class Formatter extends _HeyApiClient {
  status(options) {
    return (options?.client ?? this._client).get({
      url: "/formatter",
      ...options
    });
  }
}

class Control extends _HeyApiClient {
  next(options) {
    return (options?.client ?? this._client).get({
      url: "/tui/control/next",
      ...options
    });
  }
  response(options) {
    return (options?.client ?? this._client).post({
      url: "/tui/control/response",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers
      }
    });
  }
}

class Tui extends _HeyApiClient {
  appendPrompt(options) {
    return (options?.client ?? this._client).post({
      url: "/tui/append-prompt",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers
      }
    });
  }
  openHelp(options) {
    return (options?.client ?? this._client).post({
      url: "/tui/open-help",
      ...options
    });
  }
  openSessions(options) {
    return (options?.client ?? this._client).post({
      url: "/tui/open-sessions",
      ...options
    });
  }
  openThemes(options) {
    return (options?.client ?? this._client).post({
      url: "/tui/open-themes",
      ...options
    });
  }
  openModels(options) {
    return (options?.client ?? this._client).post({
      url: "/tui/open-models",
      ...options
    });
  }
  submitPrompt(options) {
    return (options?.client ?? this._client).post({
      url: "/tui/submit-prompt",
      ...options
    });
  }
  clearPrompt(options) {
    return (options?.client ?? this._client).post({
      url: "/tui/clear-prompt",
      ...options
    });
  }
  executeCommand(options) {
    return (options?.client ?? this._client).post({
      url: "/tui/execute-command",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers
      }
    });
  }
  showToast(options) {
    return (options?.client ?? this._client).post({
      url: "/tui/show-toast",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers
      }
    });
  }
  publish(options) {
    return (options?.client ?? this._client).post({
      url: "/tui/publish",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers
      }
    });
  }
  control = new Control({ client: this._client });
}

class Event extends _HeyApiClient {
  subscribe(options) {
    return (options?.client ?? this._client).get.sse({
      url: "/event",
      ...options
    });
  }
}

class OpencodeClient extends _HeyApiClient {
  postSessionIdPermissionsPermissionId(options) {
    return (options.client ?? this._client).post({
      url: "/session/{id}/permissions/{permissionID}",
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options.headers
      }
    });
  }
  global = new Global({ client: this._client });
  project = new Project({ client: this._client });
  pty = new Pty({ client: this._client });
  config = new Config({ client: this._client });
  tool = new Tool({ client: this._client });
  instance = new Instance({ client: this._client });
  path = new Path({ client: this._client });
  vcs = new Vcs({ client: this._client });
  session = new Session({ client: this._client });
  command = new Command({ client: this._client });
  provider = new Provider({ client: this._client });
  find = new Find({ client: this._client });
  file = new File({ client: this._client });
  app = new App({ client: this._client });
  mcp = new Mcp({ client: this._client });
  lsp = new Lsp({ client: this._client });
  formatter = new Formatter({ client: this._client });
  tui = new Tui({ client: this._client });
  auth = new Auth({ client: this._client });
  event = new Event({ client: this._client });
}

// node_modules/@opencode-ai/sdk/dist/client.js
function createOpencodeClient(config) {
  if (!config?.fetch) {
    const customFetch = (req) => {
      req.timeout = false;
      return fetch(req);
    };
    config = {
      ...config,
      fetch: customFetch
    };
  }
  if (config?.directory) {
    config.headers = {
      ...config.headers,
      "x-opencode-directory": config.directory
    };
  }
  const client2 = createClient(config);
  return new OpencodeClient({ client: client2 });
}
// node_modules/@opencode-ai/sdk/dist/server.js
import { spawn } from "node:child_process";
async function createOpencodeServer(options) {
  options = Object.assign({
    hostname: "127.0.0.1",
    port: 4096,
    timeout: 5000
  }, options ?? {});
  const args = [`serve`, `--hostname=${options.hostname}`, `--port=${options.port}`];
  if (options.config?.logLevel)
    args.push(`--log-level=${options.config.logLevel}`);
  const proc = spawn(`opencode`, args, {
    signal: options.signal,
    env: {
      ...process.env,
      OPENCODE_CONFIG_CONTENT: JSON.stringify(options.config ?? {})
    }
  });
  const url = await new Promise((resolve, reject) => {
    const id = setTimeout(() => {
      reject(new Error(`Timeout waiting for server to start after ${options.timeout}ms`));
    }, options.timeout);
    let output = "";
    proc.stdout?.on("data", (chunk) => {
      output += chunk.toString();
      const lines = output.split(`
`);
      for (const line of lines) {
        if (line.startsWith("opencode server listening")) {
          const match = line.match(/on\s+(https?:\/\/[^\s]+)/);
          if (!match) {
            throw new Error(`Failed to parse server url from output: ${line}`);
          }
          clearTimeout(id);
          resolve(match[1]);
          return;
        }
      }
    });
    proc.stderr?.on("data", (chunk) => {
      output += chunk.toString();
    });
    proc.on("exit", (code) => {
      clearTimeout(id);
      let msg = `Server exited with code ${code}`;
      if (output.trim()) {
        msg += `
Server output: ${output}`;
      }
      reject(new Error(msg));
    });
    proc.on("error", (error) => {
      clearTimeout(id);
      reject(error);
    });
    if (options.signal) {
      options.signal.addEventListener("abort", () => {
        clearTimeout(id);
        reject(new Error("Aborted"));
      });
    }
  });
  return {
    url,
    close() {
      proc.kill();
    }
  };
}
// node_modules/@opencode-ai/sdk/dist/index.js
async function createOpencode(options) {
  const server2 = await createOpencodeServer({
    ...options
  });
  const client3 = createOpencodeClient({
    baseUrl: server2.url
  });
  return {
    client: client3,
    server: server2
  };
}

// src/backends/opencode/client.ts
var log = Log.create({ service: "opencode-client" });

class OpenCodeClient {
  client;
  timeout;
  retryAttempts;
  activeSessions;
  promptTimeout;
  directory = process.cwd();
  server = null;
  serverStartupTimeout;
  constructor(client3, server2, config = {}) {
    this.client = client3;
    this.server = server2;
    this.timeout = config.timeout || 30000;
    this.retryAttempts = config.retryAttempts || 3;
    const envPromptTimeout = Number.parseInt(process.env.OPENCODE_PROMPT_TIMEOUT_MS ?? "", 10);
    const resolvedPromptTimeout = Number.isFinite(envPromptTimeout) ? envPromptTimeout : undefined;
    this.promptTimeout = config.promptTimeout ?? resolvedPromptTimeout ?? 120000;
    this.directory = config.directory || process.env.OPENCODE_DIRECTORY || process.cwd();
    this.serverStartupTimeout = config.serverStartupTimeout || 1e4;
    this.activeSessions = new Map;
    log.debug("OpenCodeClient initialized", {
      hasOwnServer: !!this.server,
      timeout: this.timeout,
      serverStartupTimeout: this.serverStartupTimeout
    });
  }
  static async getAvailablePort() {
    try {
      const defaultPort = 4096;
      const isDefaultAvailable = await OpenCodeClient.isPortAvailable(defaultPort);
      if (!isDefaultAvailable) {
        log.info("Existing server detected on port 4096; spawning isolated server on dynamic port");
      } else {
        log.debug("Default port 4096 is available but avoiding it for isolation");
      }
      const dynamicPort = await OpenCodeClient.findAvailablePort();
      log.info(`Spawning isolated server on dynamic port: ${dynamicPort}`);
      return dynamicPort;
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      log.error("Failed to select OpenCode server port", {
        error: errorMsg
      });
      throw new Error(`Failed to select OpenCode server port: ${errorMsg}`);
    }
  }
  static async isPortAvailable(port) {
    return new Promise((resolve) => {
      const server2 = createServer();
      server2.listen(port, () => {
        server2.once("close", () => resolve(true));
        server2.close();
      });
      server2.on("error", () => resolve(false));
    });
  }
  static async findAvailablePort() {
    return new Promise((resolve, reject) => {
      const server2 = createServer();
      server2.listen(0, () => {
        const address = server2.address();
        if (address && typeof address === "object") {
          server2.once("close", () => resolve(address.port));
          server2.close();
        } else {
          reject(new Error("Failed to get server address"));
        }
      });
      server2.on("error", reject);
    });
  }
  static async create(config = {}) {
    try {
      if (config.client) {
        log.info("Creating OpenCodeClient with custom client instance");
        return new OpenCodeClient(config.client, null, config);
      }
      if (config.existingServerUrl) {
        log.info("Connecting to existing OpenCode server", {
          url: config.existingServerUrl
        });
        try {
          const client4 = createOpencodeClient({
            baseUrl: config.existingServerUrl
          });
          log.debug("Verifying connection to existing server...");
          return new OpenCodeClient(client4, null, config);
        } catch (error) {
          const errorMsg = error instanceof Error ? error.message : String(error);
          log.error("Failed to connect to existing server", {
            url: config.existingServerUrl,
            error: errorMsg
          });
          throw error;
        }
      }
      log.info("Spawning new OpenCode server...", {
        timeout: config.serverStartupTimeout || 1e4
      });
      const availablePort = await OpenCodeClient.getAvailablePort();
      const { client: client3, server: server2 } = await createOpencode({
        timeout: config.serverStartupTimeout || 1e4,
        port: availablePort
      });
      log.info("OpenCode server started successfully");
      return new OpenCodeClient(client3, server2, config);
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      log.error("Failed to create OpenCodeClient", { error: errorMsg });
      throw new Error(`Failed to create OpenCodeClient: ${errorMsg}`);
    }
  }
  async createSession(prompt) {
    try {
      const result = await this.client.session.create({
        body: {
          title: "ai-eng ralph session"
        }
      });
      if (!result.data) {
        throw new Error(`Failed to create OpenCode session: ${JSON.stringify(result.error)}`);
      }
      const sdkSession = result.data;
      let pendingInitialPrompt = prompt.trim();
      const buildFirstMessage = (message) => {
        if (!pendingInitialPrompt)
          return message;
        const combined = `${pendingInitialPrompt}

---

${message}`;
        pendingInitialPrompt = "";
        return combined;
      };
      const toolInvocations = [];
      const session = {
        id: sdkSession.id || this.generateSessionId(),
        _toolInvocations: toolInvocations,
        sendMessage: async (message) => {
          return this.handleSendMessage(sdkSession.id, buildFirstMessage(message));
        },
        sendMessageStream: async (message) => {
          return this.handleSendMessageStream(sdkSession.id, buildFirstMessage(message), toolInvocations);
        },
        close: async () => {
          return this.handleSessionClose(sdkSession.id);
        }
      };
      this.activeSessions.set(session.id, session);
      return session;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      throw new Error(`Failed to create OpenCode session: ${errorMessage}`);
    }
  }
  async sendMessage(sessionId, message) {
    const session = this.activeSessions.get(sessionId);
    if (!session) {
      throw new Error(`Session not found: ${sessionId}`);
    }
    return this.handleSendMessage(sessionId, message);
  }
  async closeSession(sessionId) {
    const session = this.activeSessions.get(sessionId);
    if (!session) {
      throw new Error(`Session not found: ${sessionId}`);
    }
    await this.handleSessionClose(sessionId);
    this.activeSessions.delete(sessionId);
  }
  getActiveSessions() {
    return Array.from(this.activeSessions.keys());
  }
  isSessionActive(sessionId) {
    return this.activeSessions.has(sessionId);
  }
  async closeAllSessions() {
    const closePromises = Array.from(this.activeSessions.keys()).map((sessionId) => this.handleSessionClose(sessionId).catch((error) => {
      const errorMsg = error instanceof Error ? error.message : String(error);
      log.warn("Error closing session", {
        sessionId,
        error: errorMsg
      });
    }));
    await Promise.all(closePromises);
    this.activeSessions.clear();
  }
  async handleSendMessageStream(sessionId, message, toolInvocations) {
    let lastError = null;
    const supportsEventStreaming = typeof this.client?.session?.promptAsync === "function" && typeof this.client?.event?.subscribe === "function";
    for (let attempt = 1;attempt <= this.retryAttempts; attempt++) {
      try {
        const stream = new TransformStream;
        const writer = stream.writable.getWriter();
        let finalized = false;
        const closeOnce = async () => {
          if (finalized)
            return;
          finalized = true;
          try {
            await writer.close();
          } catch {}
        };
        const abortOnce = async (err) => {
          if (finalized)
            return;
          finalized = true;
          try {
            await writer.abort(err);
          } catch {}
        };
        if (!supportsEventStreaming) {
          const promptPromise = this.client.session.prompt({
            body: {
              messageID: this.generateMessageId(),
              parts: [
                {
                  type: "text",
                  text: message
                }
              ]
            },
            path: {
              id: sessionId
            },
            query: {
              directory: this.directory
            }
          });
          const streamingTask2 = (async () => {
            try {
              const result = await promptPromise;
              if (!result.data) {
                throw new Error(`Invalid response from OpenCode: ${JSON.stringify(result.error)}`);
              }
              const response = result.data;
              const textPart = response.parts?.find((part) => part.type === "text");
              const finalContent = textPart?.text || "No content received";
              const chunks = this.splitIntoChunks(finalContent, 10);
              const encoder2 = new TextEncoder;
              for (const chunk of chunks) {
                await writer.write(encoder2.encode(chunk));
                await new Promise((resolve) => setTimeout(resolve, 50));
              }
              await closeOnce();
              return { content: finalContent };
            } catch (error) {
              await abortOnce(error);
              throw error;
            }
          })();
          return {
            stream: stream.readable,
            complete: streamingTask2
          };
        }
        const encoder = new TextEncoder;
        const idleTimeoutError = new Error(`Prompt idle timeout after ${this.promptTimeout}ms`);
        const hardTimeoutError = new Error(`Prompt hard timeout after ${this.promptTimeout * 5}ms`);
        const controller = new AbortController;
        let idleTimer;
        let hardTimer;
        let bytesWritten = 0;
        let lastProgressTime = Date.now();
        let idleTimedOut = false;
        const startHardTimer = () => {
          if (hardTimer)
            clearTimeout(hardTimer);
          hardTimer = setTimeout(() => {
            log.warn("Hard timeout reached, aborting", {
              sessionId,
              timeoutMs: this.promptTimeout * 5
            });
            try {
              controller.abort(hardTimeoutError);
            } catch {}
          }, this.promptTimeout * 5);
        };
        const resetIdleTimer = () => {
          if (idleTimer)
            clearTimeout(idleTimer);
          idleTimer = setTimeout(() => {
            idleTimedOut = true;
            log.warn("Idle timeout reached, aborting", {
              sessionId,
              timeoutMs: this.promptTimeout,
              bytesWritten,
              lastProgressMsAgo: Date.now() - lastProgressTime
            });
            try {
              controller.abort(idleTimeoutError);
            } catch {}
          }, this.promptTimeout);
        };
        const streamingTask = (async () => {
          try {
            startHardTimer();
            resetIdleTimer();
            const userMessageId = this.generateMessageId();
            log.debug("Sending prompt to OpenCode", {
              sessionId,
              messageLength: message.length,
              userMessageId
            });
            await this.client.session.promptAsync({
              body: {
                messageID: userMessageId,
                parts: [
                  {
                    type: "text",
                    text: message
                  }
                ]
              },
              path: {
                id: sessionId
              },
              query: {
                directory: this.directory
              },
              signal: controller.signal
            });
            log.debug("Subscribing to events", {
              sessionId,
              directory: this.directory
            });
            const eventsResult = await this.client.event.subscribe({
              query: {
                directory: this.directory
              },
              signal: controller.signal
            });
            let assistantMessageId2 = null;
            let content = "";
            let emittedText = "";
            let eventCount = 0;
            log.debug("Starting event stream processing", {
              sessionId
            });
            for await (const event of eventsResult.stream) {
              eventCount++;
              log.debug("Received event", {
                sessionId,
                eventType: event?.type,
                eventCount,
                hasProperties: !!event?.properties,
                controllerAborted: controller.signal.aborted
              });
              if (controller.signal.aborted) {
                log.debug("Controller aborted, breaking event loop", {
                  sessionId,
                  eventCount
                });
                break;
              }
              if (!event || typeof event !== "object") {
                log.debug("Skipping non-object event", {
                  sessionId,
                  eventCount
                });
                continue;
              }
              if (event.type === "message.updated") {
                const info = event.properties?.info;
                log.debug("Message updated event", {
                  sessionId,
                  eventCount,
                  infoRole: info?.role,
                  infoSessionId: info?.sessionID,
                  infoParentId: info?.parentID,
                  infoId: info?.id,
                  isRelevantSession: info?.sessionID === sessionId,
                  isAssistant: info?.role === "assistant",
                  isReplyToUser: info?.parentID === userMessageId
                });
                if (info?.role === "assistant" && info?.sessionID === sessionId && info?.parentID === userMessageId) {
                  assistantMessageId2 = info.id;
                  log.debug("Identified assistant message (exact parentID match)", {
                    sessionId,
                    assistantMessageId: assistantMessageId2
                  });
                } else if (!assistantMessageId2 && info?.role === "assistant" && info?.sessionID === sessionId) {
                  log.debug("Identified assistant message (fallback - no exact parentID match)", {
                    sessionId,
                    assistantMessageId: info.id,
                    infoParentId: info?.parentID,
                    userMessageId
                  });
                  assistantMessageId2 = info.id;
                }
                if (info?.role === "assistant" && info?.sessionID === sessionId) {
                  lastProgressTime = Date.now();
                  resetIdleTimer();
                }
                if (assistantMessageId2 && info?.id === assistantMessageId2) {
                  if (info?.error) {
                    const errName = info.error.name || "OpenCodeError";
                    const errMsg = info.error.data?.message || JSON.stringify(info.error.data || {});
                    log.error("Assistant error in message", {
                      sessionId,
                      errorName: errName,
                      errorMessage: errMsg
                    });
                    throw new Error(`${errName}: ${errMsg}`);
                  }
                  if (info?.time?.completed) {
                    log.debug("Assistant message completed", {
                      sessionId,
                      assistantMessageId: assistantMessageId2,
                      completedAt: info.time.completed
                    });
                    break;
                  }
                }
                continue;
              }
              if (event.type === "message.part.updated") {
                const part = event.properties?.part;
                log.debug("Message part updated", {
                  sessionId,
                  eventCount,
                  hasPart: !!part,
                  partType: part?.type,
                  partSessionId: part?.sessionID,
                  partMessageId: part?.messageID,
                  assistantMessageId: assistantMessageId2,
                  isRelevant: assistantMessageId2 && part?.sessionID === sessionId && part?.messageID === assistantMessageId2
                });
                if (!assistantMessageId2)
                  continue;
                if (part?.type === "tool" && toolInvocations) {
                  const toolId = part.toolId || part.id || `tool-${eventCount}`;
                  const toolName = part.toolName || part.name || "unknown";
                  const toolInput = part.input || part.parameters || {};
                  const existingToolIndex = toolInvocations.findIndex((t) => t.id === toolId);
                  const now = new Date().toISOString();
                  if (existingToolIndex >= 0) {
                    const existing = toolInvocations[existingToolIndex];
                    existing.output = part.result ?? part.output ?? existing.output;
                    existing.status = part.status === "error" ? "error" : "ok";
                    existing.error = part.error ?? existing.error;
                    existing.completedAt = part.completedAt ?? now;
                    log.debug("Tool invocation updated", {
                      sessionId,
                      toolId,
                      toolName,
                      status: existing.status
                    });
                  } else {
                    const toolInvocation = {
                      id: toolId,
                      name: toolName,
                      input: toolInput,
                      output: part.result ?? part.output,
                      status: part.status === "error" ? "error" : "ok",
                      error: part.error,
                      startedAt: part.startedAt ?? now,
                      completedAt: part.completedAt
                    };
                    toolInvocations.push(toolInvocation);
                    log.debug("Tool invocation started", {
                      sessionId,
                      toolId,
                      toolName,
                      input: JSON.stringify(toolInput).slice(0, 200)
                    });
                  }
                  if (part.sessionID !== sessionId || part.messageID !== assistantMessageId2) {} else {
                    lastProgressTime = Date.now();
                    resetIdleTimer();
                  }
                  continue;
                }
                if (!part || part.type !== "text")
                  continue;
                if (part.sessionID !== sessionId)
                  continue;
                if (part.messageID !== assistantMessageId2)
                  continue;
                const rawDelta = event.properties?.delta;
                let deltaText;
                if (typeof part.text === "string") {
                  const next = part.text;
                  if (next.startsWith(emittedText)) {
                    deltaText = next.slice(emittedText.length);
                    emittedText = next;
                  } else if (emittedText.startsWith(next)) {
                    deltaText = "";
                  } else {
                    deltaText = next;
                    emittedText += next;
                  }
                } else if (typeof rawDelta === "string") {
                  deltaText = rawDelta;
                  emittedText += rawDelta;
                }
                if (!deltaText)
                  continue;
                lastProgressTime = Date.now();
                bytesWritten += deltaText.length;
                resetIdleTimer();
                log.debug("Writing delta to stream", {
                  sessionId,
                  deltaLength: deltaText.length,
                  totalBytesWritten: bytesWritten,
                  contentLength: content.length
                });
                content += deltaText;
                await writer.write(encoder.encode(deltaText));
              }
            }
            log.debug("Event stream ended", {
              sessionId,
              eventCount,
              totalBytesWritten: bytesWritten,
              contentLength: content.length,
              controllerAborted: controller.signal.aborted,
              idleTimedOut,
              assistantMessageIdFound: !!assistantMessageId2
            });
            await closeOnce();
            return {
              content: content || "No content received",
              diagnostics: {
                bytesWritten,
                contentLength: content.length,
                idleTimedOut,
                assistantMessageIdFound: !!assistantMessageId2,
                eventCount
              }
            };
          } catch (error) {
            log.error("Streaming task error", {
              sessionId,
              error: error instanceof Error ? error.message : String(error),
              controllerAborted: controller.signal.aborted,
              bytesWritten,
              idleTimedOut,
              assistantMessageIdFound: !!assistantMessageId
            });
            if (controller.signal.aborted) {
              await abortOnce(idleTimeoutError);
              throw idleTimeoutError;
            }
            await abortOnce(error);
            throw error;
          } finally {
            if (idleTimer)
              clearTimeout(idleTimer);
            if (hardTimer)
              clearTimeout(hardTimer);
            try {
              if (!controller.signal.aborted)
                controller.abort();
            } catch {}
          }
        })();
        return {
          stream: stream.readable,
          complete: streamingTask
        };
      } catch (error) {
        lastError = error instanceof Error ? error : new Error(String(error));
        const isRateLimit = this.isRateLimitError(lastError);
        if (attempt === this.retryAttempts) {
          break;
        }
        const delay = this.getBackoffDelay(attempt, isRateLimit);
        log.warn("OpenCode attempt failed; retrying", {
          attempt,
          retryAttempts: this.retryAttempts,
          delayMs: delay,
          isRateLimit,
          error: lastError.message
        });
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }
    throw new Error(`Failed to stream message after ${this.retryAttempts} attempts: ${lastError?.message || "Unknown error"}`);
  }
  splitIntoChunks(text, chunkSize) {
    const chunks = [];
    for (let i = 0;i < text.length; i += chunkSize) {
      chunks.push(text.slice(i, i + chunkSize));
    }
    return chunks.length > 0 ? chunks : [text];
  }
  async handleSendMessage(sessionId, message) {
    let lastError = null;
    for (let attempt = 1;attempt <= this.retryAttempts; attempt++) {
      try {
        const timeoutError = new Error(`Prompt timeout after ${this.promptTimeout}ms`);
        const controller = new AbortController;
        const timer = setTimeout(() => {
          try {
            controller.abort(timeoutError);
          } catch {}
        }, this.promptTimeout);
        let result;
        try {
          result = await this.client.session.prompt({
            body: {
              messageID: this.generateMessageId(),
              parts: [
                {
                  type: "text",
                  text: message
                }
              ]
            },
            path: {
              id: sessionId
            },
            query: {
              directory: this.directory
            },
            signal: controller.signal
          });
        } catch (error) {
          if (controller.signal.aborted) {
            throw timeoutError;
          }
          throw error;
        } finally {
          clearTimeout(timer);
        }
        if (!result.data) {
          throw new Error(`Invalid response from OpenCode: ${JSON.stringify(result.error)}`);
        }
        const response = result.data;
        const textPart = response.parts?.find((part) => part.type === "text");
        return { content: textPart?.text || "No content received" };
      } catch (error) {
        lastError = error instanceof Error ? error : new Error(String(error));
        const isRateLimit = this.isRateLimitError(lastError);
        if (attempt === this.retryAttempts) {
          break;
        }
        const delay = this.getBackoffDelay(attempt, isRateLimit);
        log.warn("OpenCode attempt failed; retrying", {
          attempt,
          retryAttempts: this.retryAttempts,
          delayMs: delay,
          isRateLimit,
          error: lastError.message
        });
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }
    throw new Error(`Failed to send message after ${this.retryAttempts} attempts: ${lastError?.message || "Unknown error"}`);
  }
  isRateLimitError(error) {
    const err = error;
    return err.status === 429 || /rate limit|quota|overloaded|capacity/i.test(error.message);
  }
  getBackoffDelay(attempt, isRateLimit) {
    const base = isRateLimit ? 5000 : 1000;
    const exponential = base * 2 ** (attempt - 1);
    const jitter = Math.random() * 1000;
    return Math.min(exponential + jitter, 60000);
  }
  async handleSessionClose(sessionId) {
    try {
      log.debug("Session closed", { sessionId });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      log.warn("Failed to close session", {
        sessionId,
        error: errorMessage
      });
    }
  }
  generateSessionId() {
    return `session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }
  generateMessageId() {
    return `msg_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;
  }
  async cleanup() {
    try {
      log.debug("Starting cleanup...", {
        activeSessions: this.activeSessions.size,
        hasServer: !!this.server
      });
      await this.closeAllSessions();
      if (this.server) {
        log.info("Closing spawned OpenCode server");
        try {
          this.server.close();
          this.server = null;
          log.info("OpenCode server closed successfully");
        } catch (error) {
          const errorMsg = error instanceof Error ? error.message : String(error);
          log.error("Error closing OpenCode server", {
            error: errorMsg
          });
        }
      } else {
        log.debug("No spawned server to close (connected to existing server)");
      }
      log.info("Cleanup complete");
      return;
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      log.error("Error during OpenCode client cleanup", {
        error: errorMsg
      });
      return;
    }
  }
}

// src/execution/ralph-loop.ts
import { execSync } from "node:child_process";
import { createHash } from "node:crypto";
import { readFile as readFile2, readdir } from "node:fs/promises";
import { join as join3 } from "node:path";
init_ui();

// src/prompt-optimization/analyzer.ts
var COMPLEXITY_KEYWORDS = {
  debug: ["debug", "fix", "error", "bug", "issue", "problem", "troubleshoot"],
  design: [
    "design",
    "architecture",
    "architect",
    "structure",
    "pattern",
    "approach"
  ],
  optimize: [
    "optimize",
    "improve",
    "performance",
    "efficient",
    "fast",
    "scale"
  ],
  implement: ["implement", "build", "create", "develop", "write", "code"],
  complex: ["complex", "challenge", "difficult", "advanced", "sophisticated"]
};
var DOMAIN_KEYWORDS = {
  security: [
    "auth",
    "authentication",
    "jwt",
    "oauth",
    "password",
    "encrypt",
    "decrypt",
    "security",
    "token",
    "session",
    "csrf",
    "xss",
    "injection",
    "vulnerability",
    "hack",
    "attack"
  ],
  frontend: [
    "react",
    "vue",
    "angular",
    "component",
    "css",
    "html",
    "ui",
    "ux",
    "render",
    "state",
    "hook",
    "props",
    "dom",
    "frontend",
    "client"
  ],
  backend: [
    "api",
    "server",
    "endpoint",
    "database",
    "query",
    "backend",
    "service",
    "microservice",
    "rest",
    "graphql",
    "http",
    "request",
    "response"
  ],
  database: [
    "sql",
    "postgresql",
    "mysql",
    "mongodb",
    "redis",
    "query",
    "index",
    "schema",
    "migration",
    "database",
    "db",
    "join",
    "transaction",
    "orm"
  ],
  devops: [
    "deploy",
    "ci/cd",
    "docker",
    "kubernetes",
    "k8s",
    "pipeline",
    "infrastructure",
    "aws",
    "gcp",
    "azure",
    "terraform",
    "ansible",
    "jenkins",
    "devops",
    "ops"
  ],
  architecture: [
    "architecture",
    "design",
    "pattern",
    "microservices",
    "monolith",
    "scalability",
    "system",
    "distributed",
    "architect",
    "high-level"
  ],
  testing: [
    "test",
    "spec",
    "unit test",
    "integration test",
    "e2e",
    "jest",
    "cypress",
    "playwright",
    "testing",
    "tdd",
    "coverage",
    "mock",
    "stub"
  ],
  general: []
};
var SIMPLE_PATTERNS = [
  /^(hello|hi|hey|greetings|good morning|good evening)/i,
  /^(thanks|thank you|thx)/i,
  /^(yes|no|ok|sure|alright)/i,
  /^(what|how|why|when|where|who|which)\s+\w+\??$/i,
  /^(help|assist)\s*$/i
];
function calculateComplexityScore(prompt) {
  const words = prompt.split(/\s+/);
  const wordCount = words.length;
  let score = 0;
  if (wordCount < 5)
    score += 0;
  else if (wordCount < 10)
    score += 3;
  else if (wordCount < 20)
    score += 6;
  else
    score += 10;
  const lowerPrompt = prompt.toLowerCase();
  for (const category of Object.values(COMPLEXITY_KEYWORDS)) {
    for (const keyword of category) {
      if (lowerPrompt.includes(keyword)) {
        score += 2;
        break;
      }
    }
  }
  const questionMarks = (prompt.match(/\?/g) || []).length;
  score -= Math.min(questionMarks * 2, 5);
  const techTerms = words.filter((word) => {
    const lower = word.toLowerCase();
    return /\w{4,}/.test(word) && !["this", "that", "with", "from", "into"].includes(lower);
  });
  score += Math.min(techTerms.length * 0.5, 5);
  return Math.max(0, Math.min(20, score));
}
function scoreToComplexity(score) {
  if (score < 5)
    return "simple";
  if (score < 12)
    return "medium";
  return "complex";
}
function isSimplePrompt(prompt) {
  for (const pattern of SIMPLE_PATTERNS) {
    if (pattern.test(prompt.trim())) {
      return true;
    }
  }
  return false;
}
function detectDomain(prompt) {
  const lowerPrompt = prompt.toLowerCase();
  const scores = {
    security: 0,
    frontend: 0,
    backend: 0,
    database: 0,
    devops: 0,
    architecture: 0,
    testing: 0,
    general: 0
  };
  for (const [domain, keywords] of Object.entries(DOMAIN_KEYWORDS)) {
    for (const keyword of keywords) {
      if (lowerPrompt.includes(keyword)) {
        scores[domain]++;
      }
    }
  }
  let bestDomain = "general";
  let bestScore = 0;
  for (const [domain, score] of Object.entries(scores)) {
    if (score > bestScore) {
      bestScore = score;
      bestDomain = domain;
    }
  }
  return bestDomain;
}
function extractKeywords(prompt) {
  const keywords = [];
  const lowerPrompt = prompt.toLowerCase();
  for (const [category, terms] of Object.entries(COMPLEXITY_KEYWORDS)) {
    for (const term of terms) {
      if (lowerPrompt.includes(term) && !keywords.includes(term)) {
        keywords.push(term);
      }
    }
  }
  for (const [domain, terms] of Object.entries(DOMAIN_KEYWORDS)) {
    for (const term of terms) {
      if (lowerPrompt.includes(term) && !keywords.includes(term)) {
        keywords.push(term);
      }
    }
  }
  return keywords;
}
function identifyMissingContext(prompt, domain) {
  const missing = [];
  const lowerPrompt = prompt.toLowerCase();
  if (lowerPrompt.includes("fix") || lowerPrompt.includes("debug") || lowerPrompt.includes("error")) {
    if (!lowerPrompt.includes("error") && !lowerPrompt.includes("exception")) {
      missing.push("error message or stack trace");
    }
    if (!/\.(js|ts|py|go|java|rb|php)/i.test(prompt)) {
      missing.push("file or code location");
    }
  }
  const techKeywords = [
    "javascript",
    "typescript",
    "python",
    "go",
    "java",
    "rust",
    "react",
    "vue",
    "angular",
    "node",
    "express",
    "django",
    "flask"
  ];
  const hasTech = techKeywords.some((tech) => lowerPrompt.includes(tech));
  if (!hasTech && !/\.(js|ts|py|go|java|rb|php)/i.test(prompt)) {
    missing.push("technology stack");
  }
  if (domain === "security") {
    if (!lowerPrompt.includes("jwt") && !lowerPrompt.includes("oauth") && !lowerPrompt.includes("session")) {
      missing.push("authentication method (JWT, OAuth, session, etc.)");
    }
  }
  if (domain === "database") {
    if (!lowerPrompt.includes("sql") && !lowerPrompt.includes("mysql") && !lowerPrompt.includes("postgresql") && !lowerPrompt.includes("mongodb")) {
      missing.push("database type");
    }
    if (!lowerPrompt.includes("index")) {
      missing.push("index information");
    }
  }
  return missing;
}
function suggestTechniques(complexity, domain) {
  const techniques = [];
  techniques.push("analysis");
  if (complexity === "medium" || complexity === "complex") {
    techniques.push("expert_persona");
  }
  if (complexity === "medium" || complexity === "complex") {
    techniques.push("reasoning_chain");
  }
  if (complexity === "medium" || complexity === "complex") {
    techniques.push("stakes_language");
  }
  if (complexity === "complex") {
    techniques.push("challenge_framing");
  }
  if (complexity === "medium" || complexity === "complex") {
    techniques.push("self_evaluation");
  }
  return techniques;
}
function analyzePrompt(prompt) {
  if (isSimplePrompt(prompt)) {
    return {
      complexity: "simple",
      domain: "general",
      keywords: [],
      missingContext: [],
      suggestedTechniques: ["analysis"]
    };
  }
  const complexityScore = calculateComplexityScore(prompt);
  const complexity = scoreToComplexity(complexityScore);
  const domain = detectDomain(prompt);
  const keywords = extractKeywords(prompt);
  const missingContext = identifyMissingContext(prompt, domain);
  const suggestedTechniques = suggestTechniques(complexity, domain);
  return {
    complexity,
    domain,
    keywords,
    missingContext,
    suggestedTechniques
  };
}

// src/prompt-optimization/techniques.ts
var expertPersona = {
  id: "expert_persona",
  name: "Expert Persona",
  description: "Assigns a detailed expert role with years of experience and notable companies",
  researchBasis: "Kong et al. 2023: 24%  84% accuracy improvement",
  appliesTo: ["medium", "complex"],
  generate: (context) => {
    if (context.preferences.customPersonas[context.domain]) {
      return context.preferences.customPersonas[context.domain];
    }
    const personas = {
      security: "You are a senior security engineer with 15+ years of authentication and cryptography experience. You have worked at Auth0, Okta, and AWS IAM, building production-grade authentication systems handling millions of users.",
      frontend: "You are a senior frontend architect with 12+ years of React, Vue, and TypeScript experience. You have built large-scale applications at Vercel, Stripe, and Airbnb, focusing on performance, accessibility, and developer experience.",
      backend: "You are a senior backend engineer with 15+ years of distributed systems and API design experience. You have built microservices architectures at Netflix, Google, and Stripe, handling billions of requests.",
      database: "You are a senior database architect with 15+ years of PostgreSQL, MySQL, and distributed database experience. You have optimized databases at CockroachDB, PlanetScale, and AWS, handling petabytes of data.",
      devops: "You are a senior platform engineer with 12+ years of Kubernetes, CI/CD, and infrastructure experience. You have built deployment pipelines at GitLab, CircleCI, and AWS, managing thousands of services.",
      architecture: "You are a principal software architect with 20+ years of system design experience. You have architected large-scale systems at Amazon, Microsoft, and Google, handling complex requirements and constraints.",
      testing: "You are a senior QA architect with 12+ years of test automation and quality engineering experience. You have built testing frameworks at Selenium, Cypress, and Playwright, ensuring production quality.",
      general: "You are a senior software engineer with 15+ years of full-stack development experience. You have built production applications at top technology companies, following best practices and industry standards."
    };
    return personas[context.domain] || personas.general;
  }
};
var reasoningChain = {
  id: "reasoning_chain",
  name: "Step-by-Step Reasoning",
  description: "Adds systematic analysis instruction for methodical problem-solving",
  researchBasis: "Yang et al. 2023 (Google DeepMind): 34%  80% accuracy",
  appliesTo: ["medium", "complex"],
  generate: (context) => {
    const baseInstruction = "Take a deep breath and analyze this step by step.";
    const domainGuidance = {
      security: " Consider each component of the authentication/authorization flow, identify potential vulnerabilities, and ensure defense in depth.",
      frontend: " Consider component hierarchy, state management, performance implications, and accessibility requirements.",
      backend: " Consider API design, data flow, error handling, scalability, and edge cases.",
      database: " Consider query execution plans, indexing strategies, data consistency, and performance implications.",
      devops: " Consider infrastructure as code, deployment strategies, monitoring, and rollback procedures.",
      architecture: " Consider system constraints, trade-offs, scalability, reliability, and maintainability.",
      testing: " Consider test coverage, edge cases, integration points, and test maintainability.",
      general: " Consider each component systematically, identify dependencies, and ensure thorough coverage."
    };
    return baseInstruction + (domainGuidance[context.domain] || domainGuidance.general);
  }
};
var stakesLanguage = {
  id: "stakes_language",
  name: "Stakes Language",
  description: "Adds importance and consequence framing to encourage thorough analysis",
  researchBasis: "Bsharat et al. 2023 (MBZUAI): +45% quality improvement",
  appliesTo: ["medium", "complex"],
  generate: (context) => {
    const stakes = {
      security: "This is critical to production security. A thorough, secure solution is essential to protect users and data.",
      frontend: "This directly impacts user experience and business metrics. Quality, performance, and accessibility are essential.",
      backend: "This affects system reliability and scalability. A robust, performant solution is essential for production.",
      database: "This impacts data integrity and system performance. An optimized, reliable solution is essential.",
      devops: "This affects deployment reliability and system stability. A well-tested, safe solution is essential for production.",
      architecture: "This affects long-term system maintainability and scalability. A well-designed solution is essential.",
      testing: "This affects production quality and user experience. Comprehensive testing is essential to prevent regressions.",
      general: "This is important for the project's success. A thorough, complete solution is essential."
    };
    return stakes[context.domain] || stakes.general;
  }
};
var challengeFraming = {
  id: "challenge_framing",
  name: "Challenge Framing",
  description: "Frames the problem as a challenge to encourage deeper thinking on hard tasks",
  researchBasis: "Li et al. 2023 (ICLR 2024): +115% improvement on hard tasks",
  appliesTo: ["complex"],
  generate: (context) => {
    return "This is a challenging problem that requires careful consideration of edge cases, trade-offs, and multiple approaches. Don't settle for the first solution - explore alternatives and justify your choices.";
  }
};
var selfEvaluation = {
  id: "self_evaluation",
  name: "Self-Evaluation Request",
  description: "Requests confidence rating and assumption identification for quality assurance",
  researchBasis: "Improves response calibration and identifies uncertainties",
  appliesTo: ["medium", "complex"],
  generate: (context) => {
    let evaluation = "After providing your solution:";
    evaluation += `

1. Rate your confidence in this solution from 0-1.`;
    evaluation += `
2. Identify any assumptions you made.`;
    evaluation += `
3. Note any limitations or potential issues.`;
    if (context.domain === "security" || context.domain === "database" || context.domain === "devops") {
      evaluation += `
4. Suggest how to test or validate this solution.`;
    }
    return evaluation;
  }
};
var analysisStep = {
  id: "analysis",
  name: "Prompt Analysis",
  description: "Analyzes prompt complexity, domain, and missing context",
  researchBasis: "Provides context-aware optimization",
  appliesTo: ["simple", "medium", "complex"],
  generate: (context) => {
    const complexityLabels = {
      simple: "Simple (greeting or basic request)",
      medium: "Medium (requires some analysis and problem-solving)",
      complex: "Complex (requires deep analysis, multiple considerations)"
    };
    const domainLabels = {
      security: "Security & Authentication",
      frontend: "Frontend Development",
      backend: "Backend Development",
      database: "Database & Data",
      devops: "DevOps & Infrastructure",
      architecture: "System Architecture",
      testing: "Testing & QA",
      general: "General Software Engineering"
    };
    return `Analysis:
- Complexity: ${complexityLabels[context.complexity]}
- Domain: ${domainLabels[context.domain] || domainLabels.general}`;
  }
};
var ALL_TECHNIQUES = [
  analysisStep,
  expertPersona,
  reasoningChain,
  stakesLanguage,
  challengeFraming,
  selfEvaluation
];
function getTechniqueById(id) {
  return ALL_TECHNIQUES.find((t) => t.id === id);
}

// src/prompt-optimization/optimizer.ts
function generateId() {
  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}
var DEFAULT_CONFIG2 = {
  enabled: true,
  autoApprove: false,
  verbosity: "normal",
  defaultTechniques: [
    "analysis",
    "expert_persona",
    "reasoning_chain",
    "stakes_language",
    "self_evaluation"
  ],
  skipForSimplePrompts: false,
  escapePrefix: "!"
};
var DEFAULT_PREFERENCES = {
  skipTechniques: [],
  customPersonas: {
    security: "",
    frontend: "",
    backend: "",
    database: "",
    devops: "",
    architecture: "",
    testing: "",
    general: ""
  },
  autoApproveDefault: false,
  verbosityDefault: "normal"
};

class PromptOptimizer {
  config;
  preferences;
  constructor(config = {}, preferences = {}) {
    this.config = { ...DEFAULT_CONFIG2, ...config };
    this.preferences = { ...DEFAULT_PREFERENCES, ...preferences };
  }
  updateConfig(updates) {
    this.config = { ...this.config, ...updates };
  }
  updatePreferences(updates) {
    this.preferences = { ...this.preferences, ...updates };
  }
  getConfig() {
    return { ...this.config };
  }
  getPreferences() {
    return { ...this.preferences };
  }
  shouldSkipOptimization(prompt) {
    return prompt.startsWith(this.config.escapePrefix);
  }
  stripEscapePrefix(prompt) {
    return prompt.slice(this.config.escapePrefix.length).trim();
  }
  shouldSkipForComplexity(complexity) {
    if (!this.config.skipForSimplePrompts) {
      return false;
    }
    return complexity === "simple";
  }
  createSession(prompt) {
    if (this.shouldSkipOptimization(prompt)) {
      const stripped = this.stripEscapePrefix(prompt);
      return {
        id: generateId(),
        originalPrompt: stripped,
        complexity: "simple",
        domain: "general",
        steps: [],
        finalPrompt: stripped,
        verbosity: this.config.verbosity,
        autoApprove: this.config.autoApprove,
        preferences: this.preferences,
        createdAt: new Date
      };
    }
    const analysis = analyzePrompt(prompt);
    if (this.shouldSkipForComplexity(analysis.complexity)) {
      return {
        id: generateId(),
        originalPrompt: prompt,
        complexity: analysis.complexity,
        domain: analysis.domain,
        steps: [],
        finalPrompt: prompt,
        verbosity: this.config.verbosity,
        autoApprove: this.config.autoApprove,
        preferences: this.preferences,
        createdAt: new Date
      };
    }
    const steps = this.generateSteps(analysis);
    const finalPrompt = this.buildFinalPrompt(prompt, steps);
    return {
      id: generateId(),
      originalPrompt: prompt,
      complexity: analysis.complexity,
      domain: analysis.domain,
      steps,
      finalPrompt,
      verbosity: this.config.verbosity,
      autoApprove: this.config.autoApprove,
      preferences: this.preferences,
      createdAt: new Date
    };
  }
  generateSteps(analysis) {
    const steps = [];
    let stepId = 1;
    for (const techniqueId of analysis.suggestedTechniques) {
      if (this.preferences.skipTechniques.includes(techniqueId)) {
        continue;
      }
      const technique = getTechniqueById(techniqueId);
      if (!technique) {
        continue;
      }
      const context = {
        originalPrompt: "",
        complexity: analysis.complexity,
        domain: analysis.domain,
        previousSteps: steps,
        preferences: this.preferences
      };
      steps.push({
        id: stepId++,
        technique: techniqueId,
        name: technique.name,
        description: technique.description,
        content: technique.generate(context),
        status: "pending",
        skippable: techniqueId !== "analysis",
        appliesTo: technique.appliesTo,
        researchBasis: technique.researchBasis
      });
    }
    if (this.config.autoApprove) {
      for (const step of steps) {
        step.status = "approved";
      }
    }
    return steps;
  }
  buildFinalPrompt(originalPrompt, steps) {
    const approvedSteps = steps.filter((s) => s.status === "approved" || s.status === "modified");
    if (approvedSteps.length === 0) {
      return originalPrompt;
    }
    const parts = [];
    for (const step of approvedSteps) {
      const content = step.modifiedContent || step.content;
      if (content) {
        parts.push(content);
      }
    }
    parts.push(`

Task: ${originalPrompt}`);
    return parts.join(`

`);
  }
  updateFinalPrompt(session) {
    session.finalPrompt = this.buildFinalPrompt(session.originalPrompt, session.steps);
  }
  approveStep(session, stepId) {
    const step = session.steps.find((s) => s.id === stepId);
    if (step) {
      step.status = "approved";
      this.updateFinalPrompt(session);
    }
  }
  rejectStep(session, stepId) {
    const step = session.steps.find((s) => s.id === stepId);
    if (step) {
      step.status = "rejected";
      this.updateFinalPrompt(session);
    }
  }
  modifyStep(session, stepId, newContent) {
    const step = session.steps.find((s) => s.id === stepId);
    if (step) {
      step.modifiedContent = newContent;
      step.status = "modified";
      this.updateFinalPrompt(session);
    }
  }
  approveAll(session) {
    for (const step of session.steps) {
      if (step.status === "pending") {
        step.status = "approved";
      }
    }
    this.updateFinalPrompt(session);
  }
  skipOptimization(session) {
    for (const step of session.steps) {
      if (step.technique !== "analysis") {
        step.status = "rejected";
      }
    }
    this.updateFinalPrompt(session);
  }
  saveSkipPreference(techniqueId) {
    if (!this.preferences.skipTechniques.includes(techniqueId)) {
      this.preferences.skipTechniques.push(techniqueId);
    }
  }
  saveCustomPersona(domain, persona) {
    this.preferences.customPersonas[domain] = persona;
  }
  toggleAutoApprove(enabled) {
    this.config.autoApprove = enabled !== undefined ? enabled : !this.config.autoApprove;
  }
  setVerbosity(verbosity) {
    this.config.verbosity = verbosity;
  }
  calculateExpectedImprovement(session) {
    const approvedTechniques = session.steps.filter((s) => s.status === "approved" || s.status === "modified");
    const techniquesApplied = approvedTechniques.map((s) => s.technique);
    const improvementMap = {
      analysis: 5,
      expert_persona: 60,
      reasoning_chain: 46,
      stakes_language: 45,
      challenge_framing: 115,
      self_evaluation: 10
    };
    let totalImprovement = 0;
    for (const techniqueId of techniquesApplied) {
      totalImprovement += improvementMap[techniqueId] || 0;
    }
    const effectiveImprovement = Math.min(totalImprovement, 150);
    return {
      qualityImprovement: effectiveImprovement,
      techniquesApplied,
      researchBasis: "Combined research-backed techniques (MBZUAI, Google DeepMind, ICLR 2024)"
    };
  }
  getSessionSummary(session) {
    const improvement = this.calculateExpectedImprovement(session);
    const approvedCount = session.steps.filter((s) => s.status === "approved" || s.status === "modified").length;
    return `Optimization Session ${session.id}
` + `  Complexity: ${session.complexity}
` + `  Domain: ${session.domain}
` + `  Steps Applied: ${approvedCount}/${session.steps.length}
` + `  Expected Improvement: ~${improvement.qualityImprovement}%`;
  }
}

// src/util/discord-webhook.ts
var log2 = Log.create({ service: "discord-webhook" });

class DiscordWebhookClient {
  webhookUrl;
  username;
  avatarUrl;
  enabled = false;
  constructor(options) {
    this.webhookUrl = options.webhookUrl;
    this.username = options.username ?? "Ralph";
    this.avatarUrl = options.avatarUrl;
    this.enabled = true;
    if (!this.webhookUrl || !this.isValidWebhookUrl(this.webhookUrl)) {
      log2.warn("Invalid Discord webhook URL, notifications disabled", {
        webhookUrl: this.maskWebhookUrl(this.webhookUrl)
      });
      this.enabled = false;
    }
    log2.info("Discord webhook client initialized", {
      enabled: this.enabled,
      username: this.username
    });
  }
  isValidWebhookUrl(url) {
    return /^https:\/\/discord(?:app)?\.com\/api\/webhooks\/\d+\/[a-zA-Z0-9_-]+$/.test(url);
  }
  maskWebhookUrl(url) {
    if (!url)
      return "(not set)";
    return url.replace(/\/[a-zA-Z0-9_-]+$/, "/********");
  }
  async send(message) {
    if (!this.enabled) {
      log2.debug("Discord notifications disabled, skipping send");
      return false;
    }
    try {
      const payload = {
        content: message.content,
        username: message.username ?? this.username,
        avatarUrl: message.avatarUrl ?? this.avatarUrl,
        tts: message.tts ?? false,
        embeds: message.embeds
      };
      log2.debug("Sending Discord notification", {
        hasContent: !!message.content,
        embedCount: message.embeds?.length ?? 0
      });
      const response = await fetch(this.webhookUrl, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(payload)
      });
      if (!response.ok) {
        const errorText = await response.text();
        log2.error("Discord webhook request failed", {
          status: response.status,
          statusText: response.statusText,
          error: errorText
        });
        return false;
      }
      log2.debug("Discord notification sent successfully");
      return true;
    } catch (error) {
      log2.error("Failed to send Discord notification", {
        error: error instanceof Error ? error.message : String(error)
      });
      return false;
    }
  }
  async notify(content) {
    return this.send({ content });
  }
  async notifyWithEmbed(embed, content) {
    return this.send({
      content,
      embeds: [embed]
    });
  }
  async notifyCycleStart(cycleNumber, maxCycles, prompt) {
    const embed = {
      title: `\uD83D\uDD04 Cycle ${cycleNumber}/${maxCycles} Started`,
      description: `\`\`\`
${prompt.slice(0, 500)}${prompt.length > 500 ? "..." : ""}
\`\`\``,
      color: 5793266,
      timestamp: new Date().toISOString(),
      fields: [
        {
          name: "\uD83D\uDCCB Phase",
          value: "Research  Specify  Plan  Work  Review",
          inline: true
        },
        {
          name: " Status",
          value: "Running",
          inline: true
        }
      ]
    };
    return this.notifyWithEmbed(embed, `\uD83D\uDE80 **Ralph Cycle ${cycleNumber}/${maxCycles} Started**`);
  }
  async notifyCycleComplete(cycleNumber, completedCycles, summary, durationMs) {
    const durationMinutes = Math.floor(durationMs / 60000);
    const durationSeconds = Math.floor(durationMs % 60000 / 1000);
    const embed = {
      title: ` Cycle ${cycleNumber} Completed`,
      description: summary.slice(0, 2000) || "No summary available",
      color: 5763719,
      timestamp: new Date().toISOString(),
      fields: [
        {
          name: "\uD83D\uDCCA Progress",
          value: `${completedCycles} cycles completed`,
          inline: true
        },
        {
          name: " Duration",
          value: `${durationMinutes}m ${durationSeconds}s`,
          inline: true
        }
      ]
    };
    return this.notifyWithEmbed(embed, ` **Ralph Cycle ${cycleNumber} Complete**`);
  }
  async notifyPhaseComplete(cycleNumber, phase, summary) {
    const embed = {
      title: `\uD83D\uDCDD Phase Complete: ${phase}`,
      description: summary.slice(0, 1000),
      color: 16705372,
      timestamp: new Date().toISOString(),
      fields: [
        {
          name: "\uD83D\uDD04 Cycle",
          value: String(cycleNumber),
          inline: true
        }
      ]
    };
    return this.notifyWithEmbed(embed);
  }
  async notifyError(cycleNumber, phase, error) {
    const embed = {
      title: ` Error in Cycle ${cycleNumber}`,
      description: `**Phase:** ${phase}

**Error:**
\`\`\`
${error.slice(0, 1500)}
\`\`\``,
      color: 15548997,
      timestamp: new Date().toISOString()
    };
    return this.notifyWithEmbed(embed, "\uD83D\uDEA8 **Ralph Error**");
  }
  async notifyTimeout(cycleNumber, phase, timeoutMs) {
    const timeoutMinutes = Math.floor(timeoutMs / 60000);
    const embed = {
      title: ` Timeout in Cycle ${cycleNumber}`,
      description: `**Phase:** ${phase}
**Timeout:** ${timeoutMinutes} minutes`,
      color: 15418782,
      timestamp: new Date().toISOString()
    };
    return this.notifyWithEmbed(embed, " **Ralph Timeout**");
  }
  async notifyRunComplete(totalCycles, durationMs, finalSummary) {
    const durationHours = Math.floor(durationMs / 3600000);
    const durationMinutes = Math.floor(durationMs % 3600000 / 60000);
    const embed = {
      title: "\uD83C\uDFC1 Run Complete",
      description: finalSummary.slice(0, 2000),
      color: 5763719,
      timestamp: new Date().toISOString(),
      fields: [
        {
          name: "\uD83D\uDD04 Total Cycles",
          value: String(totalCycles),
          inline: true
        },
        {
          name: " Total Duration",
          value: durationHours > 0 ? `${durationHours}h ${durationMinutes}m` : `${durationMinutes}m`,
          inline: true
        }
      ]
    };
    return this.notifyWithEmbed(embed, "\uD83C\uDFC1 **Ralph Run Complete**");
  }
  async notifyStuckOrAborted(cycleNumber, reason) {
    const embed = {
      title: `\uD83D\uDED1 Run ${reason}`,
      description: `Cycle ${cycleNumber} reached stuck threshold or was aborted`,
      color: 5793266,
      timestamp: new Date().toISOString()
    };
    return this.notifyWithEmbed(embed, `\uD83D\uDED1 **Ralph ${reason}**`);
  }
}
function createDiscordWebhookFromEnv() {
  const webhookUrl = process.env.DISCORD_WEBHOOK_URL?.trim();
  if (!webhookUrl) {
    log2.debug("No DISCORD_WEBHOOK_URL env var set, Discord notifications disabled");
    return null;
  }
  return new DiscordWebhookClient({
    webhookUrl,
    username: process.env.DISCORD_BOT_USERNAME ?? "Ralph",
    avatarUrl: process.env.DISCORD_BOT_AVATAR_URL
  });
}

// src/execution/flow-store.ts
import { existsSync, mkdirSync, readFileSync, writeFileSync } from "node:fs";
import { join as join2 } from "node:path";

// src/execution/flow-types.ts
var FLOW_SCHEMA_VERSION = "1.0.0";

// src/execution/flow-store.ts
var log3 = Log.create({ service: "flow-store" });

class FlowStore {
  flowDir;
  runId;
  constructor(options) {
    this.flowDir = options.flowDir;
    this.runId = options.runId;
  }
  get basePath() {
    return join2(this.flowDir, this.runId, ".flow");
  }
  path(relPath) {
    return join2(this.basePath, relPath);
  }
  initialize() {
    const dirs = ["iterations", "contexts", "gates"];
    for (const dir of dirs) {
      const dirPath = this.path(dir);
      if (!existsSync(dirPath)) {
        mkdirSync(dirPath, { recursive: true });
        log3.debug("Created directory", { path: dirPath });
      }
    }
    log3.info("Flow store initialized", {
      runId: this.runId,
      basePath: this.basePath
    });
  }
  exists() {
    return existsSync(this.path("state.json"));
  }
  load() {
    const statePath = this.path("state.json");
    if (!existsSync(statePath)) {
      return null;
    }
    try {
      const content = readFileSync(statePath, "utf-8");
      const state = JSON.parse(content);
      if (state.schemaVersion !== FLOW_SCHEMA_VERSION) {
        log3.warn("Flow schema version mismatch", {
          expected: FLOW_SCHEMA_VERSION,
          found: state.schemaVersion
        });
      }
      log3.info("Loaded flow state", {
        runId: state.runId,
        status: state.status,
        currentCycle: state.currentCycle
      });
      return state;
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      log3.error("Failed to load flow state", { error: errorMsg });
      return null;
    }
  }
  createInitialState(options) {
    const now = new Date().toISOString();
    const state = {
      schemaVersion: FLOW_SCHEMA_VERSION,
      runId: this.runId,
      prompt: options.prompt,
      status: "pending" /* PENDING */,
      completionPromise: options.completionPromise,
      maxCycles: options.maxCycles,
      stuckThreshold: options.stuckThreshold,
      gates: options.gates,
      currentCycle: 0,
      completedCycles: 0,
      failedCycles: 0,
      stuckCount: 0,
      createdAt: now,
      updatedAt: now
    };
    this.saveState(state);
    return state;
  }
  saveState(state) {
    const statePath = this.path("state.json");
    state.updatedAt = new Date().toISOString();
    writeFileSync(statePath, JSON.stringify(state, null, 2));
    log3.debug("Saved flow state", { runId: state.runId });
  }
  saveCheckpoint(state, lastPhaseOutputs) {
    const checkpointPath = this.path("checkpoint.json");
    const checkpoint = {
      schemaVersion: FLOW_SCHEMA_VERSION,
      runId: state.runId,
      cycleNumber: state.currentCycle,
      timestamp: new Date().toISOString(),
      state,
      lastPhaseOutputs
    };
    writeFileSync(checkpointPath, JSON.stringify(checkpoint, null, 2));
    log3.debug("Saved checkpoint", {
      runId: state.runId,
      cycle: state.currentCycle
    });
  }
  loadCheckpoint() {
    const checkpointPath = this.path("checkpoint.json");
    if (!existsSync(checkpointPath)) {
      return null;
    }
    try {
      const content = readFileSync(checkpointPath, "utf-8");
      return JSON.parse(content);
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      log3.error("Failed to load checkpoint", { error: errorMsg });
      return null;
    }
  }
  saveIteration(cycle) {
    const cyclePath = this.path(`iterations/${cycle.cycleNumber}.json`);
    writeFileSync(cyclePath, JSON.stringify(cycle, null, 2));
    const contextPath = this.path(`contexts/${cycle.cycleNumber}.md`);
    const contextContent = this.generateContextContent(cycle);
    writeFileSync(contextPath, contextContent);
    log3.debug("Saved iteration", { cycle: cycle.cycleNumber });
  }
  saveGateResults(cycleNumber, results) {
    const gatePath = this.path(`gates/${cycleNumber}.json`);
    writeFileSync(gatePath, JSON.stringify(results, null, 2));
  }
  generateContextContent(cycle) {
    const lines = [
      `# Cycle ${cycle.cycleNumber} Context`,
      "",
      `**Timestamp:** ${cycle.startTime}`,
      `**Status:** ${cycle.status}`,
      `**Completion Promise Observed:** ${cycle.completionPromiseObserved}`,
      "",
      "## Phase Summaries",
      ""
    ];
    for (const [phase, output] of Object.entries(cycle.phases)) {
      if (output) {
        lines.push(`### ${phase.toUpperCase()}`);
        lines.push("");
        lines.push(output.summary || output.response.slice(0, 500));
        lines.push("");
      }
    }
    if (cycle.gateResults.length > 0) {
      lines.push("## Gate Results");
      lines.push("");
      for (const gate of cycle.gateResults) {
        const status = gate.passed ? " PASS" : " FAIL";
        lines.push(`- **${gate.gate}:** ${status} - ${gate.message}`);
      }
      lines.push("");
    }
    if (cycle.error) {
      lines.push("## Errors");
      lines.push("");
      lines.push(cycle.error);
      lines.push("");
    }
    return lines.join(`
`);
  }
  getIteration(cycleNumber) {
    const cyclePath = this.path(`iterations/${cycleNumber}.json`);
    if (!existsSync(cyclePath)) {
      return null;
    }
    try {
      const content = readFileSync(cyclePath, "utf-8");
      return JSON.parse(content);
    } catch {
      return null;
    }
  }
  getAllIterations() {
    const iterations = [];
    let n = 1;
    while (true) {
      const cycle = this.getIteration(n);
      if (!cycle)
        break;
      iterations.push(cycle);
      n++;
    }
    return iterations;
  }
  updateStatus(status, stopReason, error) {
    const state = this.load();
    if (!state) {
      throw new Error("No flow state to update");
    }
    state.status = status;
    if (stopReason)
      state.stopReason = stopReason;
    if (error)
      state.error = error;
    if (status === "completed" /* COMPLETED */ || status === "failed" /* FAILED */) {
      state.completedAt = new Date().toISOString();
    }
    this.saveState(state);
  }
  incrementCycle() {
    const state = this.load();
    if (!state) {
      throw new Error("No flow state to update");
    }
    state.currentCycle++;
    this.saveState(state);
    return state.currentCycle;
  }
  recordFailedCycle(cycle) {
    const state = this.load();
    if (!state) {
      throw new Error("No flow state to update");
    }
    state.failedCycles++;
    state.stuckCount++;
    this.saveIteration(cycle);
    this.saveState(state);
    log3.info("Cycle failed", {
      runId: this.runId,
      cycle: cycle.cycleNumber,
      failedCycles: state.failedCycles,
      stuckCount: state.stuckCount
    });
  }
  recordSuccessfulCycle(cycle, summary) {
    const state = this.load();
    if (!state) {
      throw new Error("No flow state to update");
    }
    state.completedCycles++;
    state.stuckCount = 0;
    state.lastCheckpoint = {
      cycleNumber: cycle.cycleNumber,
      summary,
      timestamp: new Date().toISOString()
    };
    this.saveIteration(cycle);
    this.saveState(state);
    log3.info("Cycle completed", {
      runId: this.runId,
      cycle: cycle.cycleNumber,
      completedCycles: state.completedCycles
    });
  }
  cleanup() {
    log3.info("Flow store cleanup requested", { runId: this.runId });
  }
}

// src/execution/ralph-loop.ts
var log4 = Log.create({ service: "ralph-loop" });
var DEFAULT_GATES = ["test", "lint", "acceptance"];
var DEFAULT_MAX_CYCLES = 50;
var DEFAULT_STUCK_THRESHOLD = 5;
var DEFAULT_CHECKPOINT_FREQUENCY = 1;
var DEFAULT_CYCLE_RETRIES = 2;
var SECRET_PATTERNS = [
  /api[_-]?key/i,
  /token/i,
  /secret/i,
  /password/i,
  /credential/i,
  /webhook/i,
  /auth/i,
  /bearer/i,
  /private[_-]?key/i
];
function redactSecrets(text) {
  let result = text;
  for (const pattern of SECRET_PATTERNS) {
    result = result.replace(new RegExp(`${pattern.source}["']?\\s*[:=]\\s*["']?([^"'",\\s]+)`, "gi"), `${pattern.source}="[REDACTED]"`);
  }
  return result;
}
function truncateOutput(text, maxLength = 1000) {
  if (text.length <= maxLength)
    return text;
  return `${text.substring(0, maxLength)}
... [truncated ${text.length - maxLength} chars]`;
}

class RalphLoopRunner {
  config;
  flowStore;
  flags;
  baseConfig;
  optimizer;
  discordWebhook;
  constructor(flags, baseConfig, optimizer) {
    this.flags = flags;
    this.baseConfig = baseConfig;
    this.optimizer = optimizer;
    this.config = this.buildLoopConfig();
    const flowStoreOptions = {
      flowDir: this.config.flowDir,
      runId: this.config.runId
    };
    this.flowStore = new FlowStore(flowStoreOptions);
    this.discordWebhook = createDiscordWebhookFromEnv();
  }
  buildLoopConfig() {
    let completionPromise = this.flags.completionPromise ?? "";
    if (this.flags.ship) {
      completionPromise = "<promise>SHIP</promise>";
    } else if (this.flags.draft) {
      completionPromise = "";
    } else if (!completionPromise) {
      completionPromise = "";
    }
    let runId = this.flags.runId;
    if (!runId) {
      const defaultRunId = this.generateRunId();
      const defaultFlowDir = this.getDefaultFlowDir(defaultRunId);
      const checkStore = new FlowStore({
        flowDir: this.flags.workingDir ? join3(this.flags.workingDir, ".ai-eng") : ".ai-eng",
        runId: defaultRunId
      });
      runId = defaultRunId;
    }
    return {
      runId,
      prompt: this.flags.workflow ?? "",
      completionPromise,
      maxCycles: this.flags.maxCycles ?? DEFAULT_MAX_CYCLES,
      stuckThreshold: this.flags.stuckThreshold ?? DEFAULT_STUCK_THRESHOLD,
      gates: this.flags.gates ?? DEFAULT_GATES,
      checkpointFrequency: this.flags.checkpointFrequency ?? DEFAULT_CHECKPOINT_FREQUENCY,
      flowDir: this.getDefaultFlowDir(runId),
      dryRun: this.flags.dryRun ?? false,
      cycleRetries: this.baseConfig.loop?.cycleRetries ?? DEFAULT_CYCLE_RETRIES,
      debugWork: this.flags.debugWork ?? this.baseConfig.debug?.work ?? false
    };
  }
  getDefaultFlowDir(runId) {
    const artifactsDir = this.baseConfig.runner.artifactsDir;
    if (this.flags.workingDir) {
      return join3(this.flags.workingDir, artifactsDir);
    }
    return join3(process.cwd(), artifactsDir);
  }
  generateRunId() {
    const timestamp = Date.now().toString(36);
    const random = Math.random().toString(36).substring(2, 8);
    return `run-${timestamp}-${random}`;
  }
  hashOutput(output) {
    return createHash("sha256").update(output).digest("hex").substring(0, 16);
  }
  async run() {
    UI.header("Ralph Loop Runner");
    if (this.flags.resume) {
      await this.resume();
      return;
    }
    await this.startFresh();
  }
  async startFresh() {
    log4.info("Starting fresh Ralph loop", {
      runId: this.config.runId,
      prompt: this.config.prompt.substring(0, 100),
      completionPromise: this.config.completionPromise,
      maxCycles: this.config.maxCycles
    });
    this.flowStore.initialize();
    const initialState = this.flowStore.createInitialState({
      prompt: this.config.prompt,
      completionPromise: this.config.completionPromise,
      maxCycles: this.config.maxCycles,
      stuckThreshold: this.config.stuckThreshold,
      gates: this.config.gates
    });
    this.flowStore.updateStatus("running" /* RUNNING */);
    await this.runLoop();
  }
  async resume() {
    log4.info("Resuming Ralph loop", { runId: this.config.runId });
    const state = this.flowStore.load();
    if (!state) {
      throw new Error(`No flow state found for run ID: ${this.config.runId}. Cannot resume.`);
    }
    if (state.status === "completed" /* COMPLETED */) {
      UI.warn("This run has already completed.");
      UI.info(`Stop reason: ${state.stopReason}`);
      return;
    }
    if (state.status === "failed" /* FAILED */) {
      UI.warn("This run previously failed.");
      UI.info(`Error: ${state.error}`);
    }
    await this.runLoop();
  }
  async runLoop() {
    const state = this.flowStore.load();
    if (!state) {
      throw new Error("No flow state found");
    }
    UI.info(`Run ID: ${this.config.runId}`);
    UI.info(`Flow directory: ${this.flowStore.basePath}`);
    UI.info(`Completion promise: ${this.config.completionPromise || "(none)"}`);
    UI.info(`Max cycles: ${this.config.maxCycles}`);
    UI.info(`Cycle retries: ${this.config.cycleRetries}`);
    UI.info(`Stuck threshold: ${this.config.stuckThreshold}`);
    UI.info(`Debug work: ${this.config.debugWork ? "enabled" : "disabled"}`);
    UI.println();
    for (let cycleNumber = state.currentCycle + 1;cycleNumber <= this.config.maxCycles; cycleNumber++) {
      UI.header(`Cycle ${cycleNumber}/${this.config.maxCycles}`);
      const runStartTime = Date.now();
      this.discordWebhook?.notifyCycleStart(cycleNumber, this.config.maxCycles, this.config.prompt);
      let attempt = 0;
      let result = null;
      let lastError = null;
      while (attempt <= this.config.cycleRetries) {
        attempt++;
        const isRetry = attempt > 1;
        if (isRetry) {
          UI.info(`Retry attempt ${attempt}/${this.config.cycleRetries + 1}`);
          log4.info("Retrying cycle", {
            cycleNumber,
            attempt,
            lastError
          });
        }
        const client3 = await OpenCodeClient.create({
          serverStartupTimeout: 1e4
        });
        try {
          const context = await this.buildReAnchoredContext(cycleNumber, isRetry ? lastError ?? undefined : undefined);
          result = await this.executeCycle(cycleNumber, client3, context);
          if (result.success) {
            this.flowStore.recordSuccessfulCycle(result.cycleState, result.summary);
            const durationMs = Date.now() - runStartTime;
            this.discordWebhook?.notifyCycleComplete(cycleNumber, this.flowStore.load()?.completedCycles ?? cycleNumber, result.summary, durationMs);
          } else {
            this.flowStore.recordFailedCycle(result.cycleState);
            this.discordWebhook?.notifyError(cycleNumber, result.cycleState.phases[Object.keys(result.cycleState.phases).pop()]?.phase ?? "unknown", result.cycleState.error ?? "Unknown error");
          }
          if (result.success) {
            break;
          }
          const shouldRetry = this.shouldRetryFailure(result);
          if (!shouldRetry) {
            break;
          }
          lastError = result.summary;
        } catch (error) {
          const errorMsg = error instanceof Error ? error.message : String(error);
          lastError = errorMsg;
          const shouldRetry = this.shouldRetryOnError(error);
          if (shouldRetry && attempt <= this.config.cycleRetries) {
            log4.warn("Cycle error, will retry", {
              cycleNumber,
              attempt,
              error: errorMsg
            });
          } else {
            break;
          }
        } finally {
          await client3.cleanup();
        }
      }
      if (!result) {
        this.discordWebhook?.notifyStuckOrAborted(cycleNumber, "FAILED_ALL_RETRIES");
        await this.handleStop("error" /* ERROR */, `Cycle ${cycleNumber} failed after ${this.config.cycleRetries + 1} attempts: ${lastError ?? "unknown error"}`);
        return;
      }
      if (result.stopReason) {
        await this.handleStop(result.stopReason, result.summary);
        return;
      }
      const currentState = this.flowStore.load();
      if (currentState && currentState.stuckCount >= this.config.stuckThreshold) {
        this.discordWebhook?.notifyStuckOrAborted(cycleNumber, "STUCK");
        await this.handleStop("stuck" /* STUCK */, `No progress for ${this.config.stuckThreshold} consecutive cycles`);
        return;
      }
      if (cycleNumber % this.config.checkpointFrequency === 0) {
        this.flowStore.saveCheckpoint(this.flowStore.load(), result.cycleState.phases);
      }
      UI.println();
    }
    this.discordWebhook?.notifyRunComplete(state.completedCycles, Date.now() - new Date(state.createdAt).getTime(), `Completed ${state.completedCycles} cycles (max ${this.config.maxCycles})`);
    await this.handleStop("max_cycles" /* MAX_CYCLES */, "Maximum cycles reached");
  }
  shouldRetryFailure(result) {
    const failedGates = result.cycleState.gateResults.filter((g2) => !g2.passed);
    if (failedGates.length > 0) {
      return true;
    }
    const workPhase = result.cycleState.phases["work" /* WORK */];
    if (workPhase && !workPhase.response.trim()) {
      return true;
    }
    return false;
  }
  shouldRetryOnError(error) {
    if (error instanceof Error) {
      if (error.message.includes("timeout")) {
        return true;
      }
      if (error.message.includes("stream")) {
        return true;
      }
      if (error.message.includes("OpenCode")) {
        return true;
      }
    }
    return false;
  }
  async buildReAnchoredContext(cycleNumber, retryFailure) {
    const contextParts = [];
    contextParts.push(`# Original Task

${this.config.prompt}
`);
    if (retryFailure) {
      contextParts.push(`# Previous Attempt Failed

The previous attempt had an issue:
${retryFailure}

Please analyze what went wrong and try a different approach.
`);
    }
    const previousCycle = this.flowStore.getIteration(cycleNumber - 1);
    if (previousCycle) {
      contextParts.push(`# Previous Cycle (${cycleNumber - 1}) Summary

`);
      contextParts.push(previousCycle.error ? `FAILED
` : `COMPLETED
`);
      if (previousCycle.error) {
        contextParts.push(`Error: ${previousCycle.error}
`);
      }
      if (previousCycle.gateResults.length > 0) {
        contextParts.push(`
## Gate Results

`);
        for (const gate of previousCycle.gateResults) {
          const status = gate.passed ? "" : "";
          contextParts.push(`- ${status} ${gate.gate}: ${gate.message}
`);
        }
      }
      const allTools = this.collectAllTools(previousCycle);
      if (allTools.length > 0) {
        contextParts.push(`
## Tool Usage in Previous Cycle

`);
        for (const tool of allTools.slice(0, 10)) {
          const statusIcon = tool.status === "ok" ? "" : "";
          contextParts.push(`${statusIcon} ${tool.name}: ${tool.status}
`);
        }
        if (allTools.length > 10) {
          contextParts.push(`... and ${allTools.length - 10} more tools
`);
        }
      }
    }
    const state = this.flowStore.load();
    if (state?.lastCheckpoint) {
      contextParts.push(`
# Last Checkpoint

Cycle ${state.lastCheckpoint.cycleNumber}: ${state.lastCheckpoint.summary}
`);
    }
    const specsContext = await this.loadRelevantSpecs();
    if (specsContext) {
      contextParts.push(specsContext);
    }
    try {
      const gitStatus = await this.getGitStatus();
      if (gitStatus) {
        contextParts.push(`
# Git Status

${gitStatus}
`);
      }
    } catch {}
    contextParts.push(`
# Completion Criteria

Loop exits when you output exactly: ${this.config.completionPromise || "(none - will run all cycles)"}
`);
    return contextParts.join(`
`);
  }
  collectAllTools(cycle) {
    const tools = [];
    for (const phase of Object.values(cycle.phases)) {
      if (phase?.tools) {
        tools.push(...phase.tools);
      }
    }
    return tools;
  }
  async loadRelevantSpecs() {
    const specsDir = join3(process.cwd(), "specs");
    let specs;
    try {
      specs = await readdir(specsDir);
    } catch {
      return null;
    }
    const promptLower = this.config.prompt.toLowerCase();
    const promptTokens = new Set(promptLower.split(/\W+/).filter((t) => t.length > 2));
    const matches = [];
    for (const specDir of specs) {
      if (specDir.startsWith("."))
        continue;
      const specPath = join3(specsDir, specDir, "spec.md");
      try {
        const specContent = await readFile2(specPath, "utf-8");
        const specContentLower = specContent.toLowerCase();
        const titleMatch = specContent.match(/^# (.+)$/m);
        const title = titleMatch?.[1];
        let score = 0;
        const specTokens = new Set(specContentLower.split(/\W+/).filter((t) => t.length > 2));
        for (const token of promptTokens) {
          if (specTokens.has(token)) {
            score++;
          }
        }
        const dirLower = specDir.toLowerCase();
        if (promptLower.includes(dirLower) || dirLower.includes("fleettools")) {
          score += 5;
        }
        if (score > 0) {
          matches.push({ dir: specDir, score, title });
        }
      } catch {}
    }
    matches.sort((a, b3) => b3.score - a.score);
    const topMatches = matches.slice(0, 2);
    if (topMatches.length === 0) {
      return null;
    }
    const result = [`
# Relevant Specifications
`];
    for (const match of topMatches) {
      const specPath = join3(specsDir, match.dir, "spec.md");
      try {
        const specContent = await readFile2(specPath, "utf-8");
        const overviewMatch = specContent.match(/^(# .+?)(?:\n\n## Overview\n\n)([\s\S]*?)(?=\n\n## |\n\n### )/m);
        const userStoriesMatch = specContent.match(/^(## User Stories\n\n)([\s\S]*?)(?=\n\n## |\n\n### )/m);
        result.push(`
## ${match.title || match.dir}
`);
        if (overviewMatch) {
          result.push(overviewMatch[2].trim());
          result.push(`
`);
        }
        if (userStoriesMatch) {
          const stories = userStoriesMatch[2].split(/\n### /).slice(0, 3);
          result.push(`
### Key User Stories
`);
          for (const story of stories) {
            if (story.trim()) {
              result.push(`
### ${story.trim()}
`);
            }
          }
        }
        log4.debug("Loaded spec for context", {
          spec: match.dir,
          score: match.score
        });
      } catch {
        log4.warn("Failed to read spec", { spec: match.dir });
      }
    }
    return result.join(`
`);
  }
  async getGitStatus() {
    try {
      const { execSync: execSync2 } = await import("node:child_process");
      const diff = execSync2("git diff --stat", {
        encoding: "utf-8",
        cwd: process.cwd()
      });
      const status = execSync2("git status --short", {
        encoding: "utf-8",
        cwd: process.cwd()
      });
      return `\`\`\`
${diff}
${status}
\`\`\``;
    } catch {
      return null;
    }
  }
  async executeCycle(cycleNumber, client3, context) {
    const startTime = new Date().toISOString();
    const cycleState = {
      cycleNumber,
      status: "running",
      startTime,
      phases: {},
      gateResults: [],
      completionPromiseObserved: false
    };
    try {
      const session = await client3.createSession(context);
      for (const phase of [
        "research" /* RESEARCH */,
        "specify" /* SPECIFY */,
        "plan" /* PLAN */,
        "work" /* WORK */,
        "review" /* REVIEW */
      ]) {
        const phaseResult = await this.executePhase(session, phase, cycleNumber);
        if (phaseResult.error) {
          cycleState.phases[phase] = {
            phase,
            prompt: phaseResult.prompt,
            response: "",
            summary: `Error: ${phaseResult.error}`,
            timestamp: new Date().toISOString()
          };
          throw new Error(`${phase} phase failed: ${phaseResult.error}`);
        }
        cycleState.phases[phase] = {
          phase,
          prompt: phaseResult.prompt,
          response: phaseResult.response,
          summary: phaseResult.summary,
          timestamp: new Date().toISOString(),
          tools: phaseResult.tools
        };
        if (this.config.completionPromise && phaseResult.response.includes(this.config.completionPromise)) {
          cycleState.completionPromiseObserved = true;
        }
        UI.println(`${UI.Style.TEXT_DIM}   ${phase}: done${UI.Style.TEXT_NORMAL}`);
      }
      UI.println(`${UI.Style.TEXT_DIM}Running quality gates...${UI.Style.TEXT_NORMAL}`);
      const gateResults = await this.runQualityGates(cycleNumber, cycleState);
      cycleState.gateResults = gateResults;
      const requiredFailed = gateResults.find((g2) => !g2.passed && this.config.gates.includes(g2.gate));
      let failedPhaseInfo = "";
      if (requiredFailed) {
        const phasesWithGates = Object.entries(cycleState.phases);
        const lastPhase = phasesWithGates[phasesWithGates.length - 1]?.[0] ?? "unknown";
        failedPhaseInfo = `${lastPhase} gate failed`;
      }
      cycleState.status = "completed";
      cycleState.endTime = new Date().toISOString();
      cycleState.durationMs = Date.now() - new Date(startTime).getTime();
      const summary = this.generateCycleSummary(cycleState);
      if (this.config.completionPromise && cycleState.completionPromiseObserved) {
        return {
          success: true,
          cycleState,
          summary,
          stopReason: "completion_promise" /* COMPLETION_PROMISE */
        };
      }
      if (requiredFailed) {
        return {
          success: false,
          cycleState,
          summary: `${failedPhaseInfo}: ${requiredFailed.message}`,
          stopReason: "gate_failure" /* GATE_FAILURE */
        };
      }
      cycleState.outputHash = this.hashOutput(Object.values(cycleState.phases).map((p2) => p2?.response ?? "").join("|"));
      return { success: true, cycleState, summary };
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      cycleState.status = "failed";
      cycleState.endTime = new Date().toISOString();
      cycleState.durationMs = Date.now() - new Date(startTime).getTime();
      cycleState.error = errorMsg;
      return {
        success: false,
        cycleState,
        summary: `Cycle failed: ${errorMsg}`,
        stopReason: "error" /* ERROR */
      };
    }
  }
  async executePhase(session, phase, cycleNumber) {
    const phasePrompts = {
      ["research" /* RESEARCH */]: `## Phase 1: Research

Research the codebase to understand the current state. Focus on:
- File structure and key modules
- Existing patterns and conventions
- Dependencies and configurations
- Any relevant documentation

Provide a concise summary of your findings.`,
      ["specify" /* SPECIFY */]: `## Phase 2: Specify

Based on the research, create a detailed specification for the task:
- Requirements and acceptance criteria
- Technical approach
- Potential challenges and mitigation strategies
- Dependencies on existing code

Output a structured specification.`,
      ["plan" /* PLAN */]: `## Phase 3: Plan

Create an implementation plan:
- Step-by-step tasks
- Files to modify/create
- Order of operations
- Testing strategy

Output a detailed plan.`,
      ["work" /* WORK */]: `## Phase 4: Work

Execute the implementation plan. Make concrete changes to the codebase.

IMPORTANT: You MUST:
1. Use tools (Read, Write, Edit, Bash) to make actual file changes
2. Report each file you modify as you go (e.g., "Creating file X...", "Modifying Y...")
3. Run actual tests and report results
4. Ensure the final summary lists:
   - All files created/modified (with paths) OR explicitly "NO CHANGES: <reason>" if no files needed
   - All test results (pass/fail)
   - Any errors encountered and how they were resolved

If no changes are needed, explicitly state "NO CHANGES: <reason>" and why.

Provide a comprehensive summary of concrete work completed.`,
      ["review" /* REVIEW */]: `## Phase 5: Review

Review the completed work:
- Verify all acceptance criteria are met
- Check code quality and consistency
- Ensure tests pass
- Identify any remaining issues

Output: <promise>SHIP</promise> if all criteria are met, or list remaining issues.`
    };
    const prompt = phasePrompts[phase];
    const streamingResponse = await session.sendMessageStream(prompt);
    let fullResponse = "";
    const tools = [];
    UI.println(`${UI.Style.TEXT_DIM}  [${phase}]${UI.Style.TEXT_NORMAL}`);
    const reader = streamingResponse.stream.getReader();
    const decoder = new TextDecoder;
    const phaseTimeoutMs = (this.config.phaseTimeoutMs ?? (this.config.promptTimeout ?? 300000) * 5) || 900000;
    let phaseTimedOut = false;
    const watchdogTimer = setTimeout(() => {
      phaseTimedOut = true;
      log4.warn("Phase watchdog triggered", {
        cycleNumber,
        phase,
        timeoutMs: phaseTimeoutMs
      });
      reader.cancel(`Phase timeout after ${phaseTimeoutMs}ms`);
    }, phaseTimeoutMs);
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (phaseTimedOut) {
          throw new Error(`Phase ${phase} timed out after ${phaseTimeoutMs}ms (watchdog)`);
        }
        if (done)
          break;
        if (value) {
          const text = decoder.decode(value, { stream: true });
          fullResponse += text;
          UI.print(text);
        }
      }
    } catch (error) {
      if (phaseTimedOut || error instanceof Error && error.message.includes("timeout")) {
        this.discordWebhook?.notifyTimeout(cycleNumber, phase, phaseTimeoutMs);
        throw new Error(`Phase ${phase} timed out after ${phaseTimeoutMs}ms - OpenCode stream did not complete`);
      }
      throw error;
    } finally {
      clearTimeout(watchdogTimer);
      reader.releaseLock();
    }
    await streamingResponse.complete;
    const sessionTools = session._toolInvocations;
    if (sessionTools && sessionTools.length > 0) {
      tools.push(...sessionTools);
      if (this.config.debugWork) {
        for (const tool of sessionTools) {
          const redactedInput = tool.input ? redactSecrets(JSON.stringify(tool.input)) : undefined;
          const redactedOutput = tool.output ? truncateOutput(redactSecrets(tool.output)) : undefined;
          UI.println(`${UI.Style.TEXT_DIM}  [TOOL] ${tool.name}: ${tool.status}${UI.Style.TEXT_NORMAL}`);
          log4.debug("Tool invocation", {
            phase,
            tool: tool.name,
            status: tool.status,
            input: redactedInput,
            output: redactedOutput
          });
        }
      }
    }
    const summary = this.generatePhaseSummary(fullResponse);
    this.discordWebhook?.notifyPhaseComplete(cycleNumber, phase, summary);
    return {
      prompt,
      response: fullResponse,
      summary,
      tools
    };
  }
  generatePhaseSummary(response) {
    const trimmed = response.trim();
    if (trimmed.length <= 200) {
      return trimmed;
    }
    return `${trimmed.substring(0, 200)}...`;
  }
  generateCycleSummary(cycle) {
    const parts = [];
    for (const [phase, output] of Object.entries(cycle.phases)) {
      if (output) {
        parts.push(`${phase}: ${output.summary}`);
      }
    }
    return parts.join(" | ");
  }
  async runQualityGates(cycleNumber, cycle) {
    const results = [];
    const now = new Date().toISOString();
    for (const gate of this.config.gates) {
      const result = await this.runGate(gate, cycle);
      results.push({
        gate,
        passed: result.passed,
        message: result.message,
        details: result.details,
        timestamp: now
      });
      this.flowStore.saveGateResults(cycleNumber, results);
    }
    return results;
  }
  async runGate(gate, cycle) {
    const gateConfig = this.getGateConfig(gate);
    switch (gate.toLowerCase()) {
      case "test":
      case "tests": {
        const result = await this.runGateCommand("test", gateConfig.command);
        return {
          passed: result.passed,
          message: result.passed ? "All tests passed" : "Some tests failed",
          details: result.details
        };
      }
      case "lint": {
        const result = await this.runGateCommand("lint", gateConfig.command);
        return {
          passed: result.passed,
          message: result.passed ? "Linting passed" : "Linting issues found",
          details: result.details
        };
      }
      case "acceptance": {
        const passed = await this.checkAcceptance(cycle);
        return {
          passed,
          message: passed ? "Acceptance criteria met" : "Acceptance criteria not fully met"
        };
      }
      default:
        return {
          passed: false,
          message: `Unknown gate: ${gate}`
        };
    }
  }
  getGateConfig(gate) {
    const normalizedGate = gate.toLowerCase() === "tests" ? "test" : gate.toLowerCase();
    const gateKey = normalizedGate;
    const configGate = this.baseConfig.gates[gateKey];
    if (configGate && typeof configGate === "object" && "command" in configGate) {
      return configGate;
    }
    return { command: String(configGate ?? "") };
  }
  async runGateCommand(gateName, command) {
    const startTime = Date.now();
    let exitCode = null;
    let stdout = "";
    let stderr = "";
    UI.info(`  Running ${gateName}: ${command}`);
    try {
      const result = execSync(command, {
        encoding: "utf-8",
        cwd: this.flags.workingDir ?? process.cwd(),
        timeout: 120000,
        maxBuffer: 10485760
      });
      stdout = result;
      exitCode = 0;
    } catch (error) {
      if (error instanceof Error && "status" in error) {
        exitCode = error.status ?? 1;
        stderr = error instanceof Error ? error.message : String(error);
        if ("stdout" in error && error.stdout) {
          stdout = String(error.stdout);
        }
        if ("stderr" in error && error.stderr) {
          stderr = String(error.stderr);
        }
      } else {
        stderr = error instanceof Error ? error.message : String(error);
      }
    }
    const durationMs = Date.now() - startTime;
    const passed = exitCode === 0;
    log4.debug("Gate command result", {
      gate: gateName,
      command,
      exitCode,
      durationMs,
      stdoutLength: stdout.length,
      stderrLength: stderr.length
    });
    return {
      passed,
      details: {
        command,
        exitCode,
        stdout: truncateOutput(stdout, 2000),
        stderr: truncateOutput(stderr, 1000),
        durationMs
      }
    };
  }
  async checkAcceptance(cycle) {
    log4.debug("Checking acceptance criteria", {
      cycleNumber: cycle.cycleNumber
    });
    const workPhase = cycle.phases["work" /* WORK */];
    if (!workPhase) {
      log4.warn("No work phase found in cycle");
      return false;
    }
    const workResponse = workPhase.response.trim();
    if (!workResponse) {
      log4.debug("Acceptance failed: empty work response");
      return false;
    }
    const hasNoChangesMarker = /NO\s*CHANGES?[:\s]/i.test(workResponse);
    const hasProgressSignal = this.hasProgressSignal(cycle);
    if (hasNoChangesMarker) {
      const hasReason = /NO\s*CHANGES?[:\s]+[A-Z]/.test(workResponse);
      if (hasReason) {
        log4.debug("Acceptance passed: NO CHANGES with reason");
        return true;
      }
    }
    if (hasProgressSignal) {
      log4.debug("Acceptance passed: progress signal detected");
      return true;
    }
    if (workResponse.length < 20) {
      log4.debug("Acceptance failed: response too short/fluffy");
      return false;
    }
    const willPattern = /\bI (will|need to|should|must|have to|am going to)\b/i;
    if (willPattern.test(workResponse)) {
      log4.debug("Acceptance failed: response contains 'I will' pattern (no action taken)");
      return false;
    }
    const mentionsChanges = /\b(change|modify|create|update|delete|add|fix|implement|refactor|write|run|test)\b/i.test(workResponse);
    if (mentionsChanges) {
      log4.debug("Acceptance passed: response mentions actionable changes");
      return true;
    }
    log4.debug("Acceptance failed: no valid progress signal");
    return false;
  }
  hasProgressSignal(cycle) {
    const allTools = this.collectAllTools(cycle);
    if (allTools.length > 0) {
      return true;
    }
    for (const gateResult of cycle.gateResults) {
      if (gateResult.details && "command" in gateResult.details && gateResult.details.command) {
        return true;
      }
    }
    return false;
  }
  async handleStop(reason, summary) {
    const state = this.flowStore.load();
    if (state) {
      let runStatus;
      switch (reason) {
        case "completion_promise" /* COMPLETION_PROMISE */:
          runStatus = "completed" /* COMPLETED */;
          break;
        case "stuck" /* STUCK */:
          runStatus = "stuck" /* STUCK */;
          this.discordWebhook?.notifyStuckOrAborted(state.currentCycle, "STUCK");
          break;
        case "user_abort" /* USER_ABORT */:
          runStatus = "aborted" /* ABORTED */;
          this.discordWebhook?.notifyStuckOrAborted(state.currentCycle, "ABORTED");
          break;
        case "error" /* ERROR */:
          runStatus = "failed" /* FAILED */;
          break;
        default:
          runStatus = "failed" /* FAILED */;
      }
      this.flowStore.updateStatus(runStatus, reason);
    }
    UI.header("Loop Complete");
    UI.info(`Stop reason: ${reason}`);
    UI.info(`Summary: ${summary}`);
    log4.info("Ralph loop stopped", { reason, summary });
  }
}
async function createRalphLoopRunner(flags, baseConfig) {
  const optimizer = new PromptOptimizer({
    autoApprove: flags.ci ?? false,
    verbosity: flags.verbose ? "verbose" : "normal"
  });
  return new RalphLoopRunner(flags, baseConfig, optimizer);
}

// src/cli/run-cli.ts
init_ui();
var log5 = Log.create({ service: "run-cli" });
var activeClient = null;
var cleanupHandlersRegistered = false;
async function setupCleanupHandlers() {
  if (cleanupHandlersRegistered)
    return;
  cleanupHandlersRegistered = true;
  const cleanupFn = async () => {
    if (activeClient) {
      try {
        log5.info("Cleanup signal received, closing OpenCode server...");
        await activeClient.cleanup();
        log5.info("OpenCode server closed successfully");
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        log5.error("Error during cleanup", { error: errorMsg });
      }
      activeClient = null;
    }
    process.exit(0);
  };
  process.on("SIGINT", cleanupFn);
  process.on("SIGTERM", cleanupFn);
  process.on("SIGHUP", cleanupFn);
  process.on("uncaughtException", async (error) => {
    const errorMsg = error instanceof Error ? error.message : String(error);
    log5.error("Uncaught exception", {
      error: errorMsg,
      stack: error instanceof Error ? error.stack : undefined
    });
    await cleanupFn();
  });
  process.on("unhandledRejection", async (reason) => {
    const errorMsg = reason instanceof Error ? reason.message : String(reason);
    log5.error("Unhandled rejection", {
      error: errorMsg,
      stack: reason instanceof Error ? reason.stack : undefined
    });
    await cleanupFn();
  });
}
async function runCli(config, flags) {
  await setupCleanupHandlers();
  log5.info("Starting CLI execution", { workflow: flags.workflow });
  const prompt = flags.workflow;
  if (!prompt) {
    UI.error("No prompt or workflow provided");
    process.exit(1);
  }
  const optimizer = new PromptOptimizer({
    autoApprove: flags.ci ?? false,
    verbosity: flags.verbose ? "verbose" : "normal"
  });
  UI.header("Prompt Optimization");
  const session = optimizer.createSession(prompt);
  log5.debug("Created optimization session", { steps: session.steps.length });
  if (!flags.ci) {
    for (const step of session.steps) {
      const action = await ve({
        message: `Apply "${step.name}"?
  ${step.description}`,
        options: [
          {
            value: "approve",
            label: "Approve",
            hint: "Apply this optimization"
          },
          {
            value: "reject",
            label: "Reject",
            hint: "Skip this optimization"
          },
          {
            value: "skip-all",
            label: "Skip all",
            hint: "Use original prompt"
          }
        ]
      });
      if (pD(action)) {
        log5.info("User cancelled");
        process.exit(0);
      }
      if (action === "skip-all") {
        optimizer.skipOptimization(session);
        break;
      }
      if (action === "approve") {
        optimizer.approveStep(session, step.id);
      } else {
        optimizer.rejectStep(session, step.id);
      }
    }
  }
  if (flags.loop !== false) {
    await runLoopMode(config, flags, session.finalPrompt);
  } else {
    await runSingleShotMode(config, flags, session.finalPrompt);
  }
}
async function runLoopMode(config, flags, _optimizedPrompt) {
  UI.header("Ralph Loop Mode");
  UI.info("Running with fresh OpenCode sessions per iteration");
  if (flags.ship) {
    UI.info("Mode: SHIP (auto-exit when agent outputs '<promise>SHIP</promise>')");
    UI.info("Completion promise: <promise>SHIP</promise>");
  } else if (flags.draft || !flags.ship && !flags.completionPromise) {
    UI.info("Mode: DRAFT (runs for max-cycles then stops for your review)");
    UI.info("Completion promise: none (will run all cycles)");
  } else {
    UI.info("Mode: Custom completion promise");
    UI.info(`Completion promise: ${flags.completionPromise}`);
  }
  UI.info(`Max cycles: ${flags.maxCycles ?? 50}`);
  UI.info(`Stuck threshold: ${flags.stuckThreshold ?? 5}`);
  UI.println();
  try {
    const runner = await createRalphLoopRunner(flags, config);
    await runner.run();
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    log5.error("Loop execution failed", { error: message });
    UI.error(message);
    process.exit(1);
  }
  Se("Done!");
}
async function runSingleShotMode(config, flags, optimizedPrompt) {
  UI.header("Execution");
  const s = Y2();
  s.start("Connecting to OpenCode...");
  try {
    activeClient = await OpenCodeClient.create({
      existingServerUrl: process.env.OPENCODE_URL,
      serverStartupTimeout: 1e4
    });
    const openSession = await activeClient.createSession(optimizedPrompt);
    log5.info("Created OpenCode session", { id: openSession.id });
    s.stop("Connected");
    UI.println();
    UI.println(`${UI.Style.TEXT_DIM}Executing task...${UI.Style.TEXT_NORMAL}`);
    let response;
    if (!flags.noStream) {
      const streamingResponse = await openSession.sendMessageStream("Execute this task and provide a detailed result summary.");
      UI.println();
      const reader = streamingResponse.stream.getReader();
      const decoder = new TextDecoder;
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done)
            break;
          if (value) {
            const text = decoder.decode(value, { stream: true });
            UI.print(text);
          }
        }
      } finally {
        reader.releaseLock();
      }
      response = await streamingResponse.complete;
    } else {
      UI.println();
      UI.println(`${UI.Style.TEXT_DIM}Buffering response...${UI.Style.TEXT_NORMAL}`);
      response = await openSession.sendMessage("Execute this task and provide a detailed result summary.");
      UI.println();
      UI.println(response.content);
    }
    UI.println();
    UI.success("Execution complete");
    if (activeClient) {
      await activeClient.cleanup();
      activeClient = null;
    }
    log5.info("Execution complete");
  } catch (error) {
    s.stop("Connection failed");
    const message = error instanceof Error ? error.message : String(error);
    log5.error("Execution failed", { error: message });
    UI.error(message);
    if (activeClient) {
      try {
        await activeClient.cleanup();
      } catch (cleanupError) {
        const cleanupMsg = cleanupError instanceof Error ? cleanupError.message : String(cleanupError);
        log5.error("Error during error cleanup", { error: cleanupMsg });
      }
      activeClient = null;
    }
    process.exit(1);
  }
  Se("Done!");
}

// src/cli/run.ts
init_ui();
var TOP_HELP_TEXT = `
ai-eng - AI Engineering System CLI

USAGE:
  ai-eng <command> [options]
  ai-eng "prompt" [options]          # Shortcut: defaults to 'ralph'

COMMANDS:
  init [options]                     # Initialize .ai-eng/config.yaml with defaults
  ralph <prompt|workflow> [options]  # Iteration loop runner
  install [options]                  # Install OpenCode/Claude assets

GLOBAL OPTIONS:
  -h, --help                         Show this help message
  -v, --verbose                      Verbose output (DEBUG level logs)

EXAMPLES:
  ai-eng init                    # Initialize config with defaults
  ai-eng init --interactive       # Interactive config setup
  ai-eng "implement user authentication"
  ai-eng ralph "fix bug" --print-logs --log-level DEBUG
  ai-eng install --scope project
  ai-eng ralph feature-spec.yml --max-iters 5
  ai-eng ralph --tui --resume
  ai-eng ralph "make fleettools usable" --ship --max-cycles 30
  ai-eng ralph "make fleettools usable" --draft --max-cycles 10 --ci
`;
var INIT_HELP_TEXT = `
ai-eng init - Initialize .ai-eng/config.yaml with defaults

USAGE:
  ai-eng init [options]

OPTIONS:
  -i, --interactive    Interactive configuration setup
  --overwrite           Overwrite existing config file
  -h, --help          Show this help message
  -v, --verbose         Verbose output

EXAMPLES:
  ai-eng init                    # Create config with defaults
  ai-eng init --interactive       # Interactive setup with prompts
  ai-eng init --overwrite          # Replace existing config
`;
var INSTALL_HELP_TEXT = `
ai-eng install - Install OpenCode/Claude assets

USAGE:
  ai-eng install [options]

OPTIONS:
  --scope project|global|auto        Where to install (default: auto-detect)
  --dry-run                          Show what would be done without writing
  --yes                              Skip confirmation prompts
  -v, --verbose                      Verbose output

EXAMPLES:
  ai-eng install                          # Auto-detect project vs global
  ai-eng install --scope project          # Install to project .opencode/
  ai-eng install --scope global           # Install to ~/.config/opencode/
  ai-eng install --dry-run                # Preview operations
`;
var RALPH_HELP_TEXT = `
ai-eng ralph - Iteration loop runner for ai-eng-system

USAGE:
  ai-eng ralph <prompt|workflow> [options]

POSITIONAL:
  prompt/workflow    Task prompt or path to workflow specification

OPTIONS:
  --max-iters <n>     Maximum iterations (default: from config)
  --gates <g1,g2>     Comma-separated list of quality gates
  --review <mode>     Review mode: none|opencode|anthropic|both
  --resume            Resume previous run
  --run-id <id>       Specific run ID to resume
  --dry-run           Show what would be done without executing
  --ci                Run in CI mode (no interactive prompts)

  --print-logs        Print detailed logs to stderr
  --log-level <lvl>   Log level: DEBUG|INFO|WARN|ERROR (default: INFO)
  -v, --verbose       Verbose output (same as --log-level DEBUG)
  --tui               Use TUI mode instead of CLI
  --no-stream         Disable streaming output (buffered mode)

  --no-loop           Run single iteration only (disable loop mode)
  --completion <tok>  Loop exit token (required, e.g., --completion "<promise>DONE</promise>")
  --ship              Auto-exit when agent outputs "<promise>SHIP</promise>"
  --draft             Run for max-cycles then stop for your review (default behavior)
  --max-cycles <n>    Maximum loop cycles (default: 50)
  --stuck-threshold <n> Abort after N cycles with no progress (default: 5)
  --checkpoint <n>    Save checkpoint every N cycles (default: 1)
  --debug-work        Print every tool invocation input/output to console and logs

  --help              Show this help message

EXAMPLES:
  ai-eng ralph "implement user authentication"
  ai-eng ralph feature-spec.yml --max-iters 5
  ai-eng ralph "fix the bug" --print-logs --log-level DEBUG
  ai-eng ralph --tui --resume
  ai-eng ralph "make fleettools usable" --ship --max-cycles 30
  ai-eng ralph "make fleettools usable" --draft --max-cycles 10 --ci
  ai-eng ralph --no-loop "single-shot task"
`;
async function runInit(args) {
  const { values, positionals } = parseArgs({
    args,
    options: {
      interactive: { type: "boolean", short: "i" },
      overwrite: { type: "boolean" },
      help: { type: "boolean" },
      verbose: { type: "boolean", short: "v" }
    },
    allowPositionals: true
  });
  const flags = {
    interactive: values.interactive,
    overwrite: values.overwrite,
    help: values.help,
    verbose: values.verbose
  };
  if (flags.help) {
    console.log(INIT_HELP_TEXT);
    return;
  }
  await Log.init({
    print: false,
    level: flags.verbose ? "DEBUG" : "INFO",
    logDir: ".ai-eng/logs"
  });
  const { initConfig: initConfig2 } = await Promise.resolve().then(() => (init_init(), exports_init));
  await initConfig2(flags);
}
async function runInstall(args) {
  const { values, positionals } = parseArgs({
    args,
    options: {
      scope: { type: "string" },
      "dry-run": { type: "boolean" },
      yes: { type: "boolean" },
      verbose: { type: "boolean", short: "v" },
      help: { type: "boolean" }
    },
    allowPositionals: true
  });
  const flags = {
    scope: values.scope,
    dryRun: values["dry-run"],
    yes: values.yes,
    verbose: values.verbose,
    help: values.help
  };
  if (flags.help) {
    console.log(INSTALL_HELP_TEXT);
    return;
  }
  const { runInstaller: runInstaller2 } = await Promise.resolve().then(() => (init_install(), exports_install));
  await runInstaller2(flags);
}
function parseRalphFlags(args) {
  const { values, positionals } = parseArgs({
    args,
    options: {
      "max-iters": { type: "string" },
      gates: { type: "string" },
      review: { type: "string" },
      resume: { type: "boolean" },
      "run-id": { type: "string" },
      "dry-run": { type: "boolean" },
      ci: { type: "boolean" },
      help: { type: "boolean" },
      "print-logs": { type: "boolean" },
      "log-level": { type: "string" },
      verbose: { type: "boolean", short: "v" },
      tui: { type: "boolean" },
      "no-stream": { type: "boolean" },
      "no-loop": { type: "boolean" },
      completion: { type: "string" },
      ship: { type: "boolean" },
      draft: { type: "boolean" },
      "max-cycles": { type: "string" },
      "stuck-threshold": { type: "string" },
      checkpoint: { type: "string" },
      "debug-work": { type: "boolean" }
    },
    allowPositionals: true
  });
  const flags = {
    workflow: positionals[0],
    maxIters: values["max-iters"] ? Number.parseInt(values["max-iters"]) : undefined,
    gates: values.gates ? values.gates.split(",").map((g2) => g2.trim()) : undefined,
    review: values.review,
    resume: values.resume,
    runId: values["run-id"],
    dryRun: values["dry-run"],
    ci: values.ci,
    help: values.help,
    printLogs: values["print-logs"],
    logLevel: values["log-level"] ?? (values.verbose ? "DEBUG" : undefined),
    verbose: values.verbose,
    tui: values.tui,
    noStream: values["no-stream"],
    loop: !values["no-loop"],
    noLoop: values["no-loop"],
    completionPromise: values.completion,
    ship: values.ship,
    draft: values.draft,
    maxCycles: values["max-cycles"] ? Number.parseInt(values["max-cycles"]) : undefined,
    stuckThreshold: values["stuck-threshold"] ? Number.parseInt(values["stuck-threshold"]) : undefined,
    checkpointFrequency: values.checkpoint ? Number.parseInt(values.checkpoint) : undefined,
    debugWork: values["debug-work"]
  };
  return { flags, remaining: positionals.slice(1) };
}
async function runRalph(args) {
  const { flags } = parseRalphFlags(args);
  if (flags.help) {
    console.log(RALPH_HELP_TEXT);
    return;
  }
  await Log.init({
    print: flags.printLogs ?? false,
    level: flags.logLevel ?? "INFO",
    logDir: ".ai-eng/logs"
  });
  Log.Default.info("ai-eng ralph starting", {
    flags: JSON.stringify(flags)
  });
  const config = await loadConfig(flags);
  if (flags.tui) {
    UI.info("TUI mode requested - falling back to CLI mode");
    UI.info("(TUI requires: bun run --watch or full TUI setup)");
  }
  await runCli(config, flags);
}
async function main() {
  try {
    const rawArgs = process.argv.slice(2);
    if (rawArgs.length === 0 || rawArgs[0] === "--help" || rawArgs[0] === "-h") {
      console.log(TOP_HELP_TEXT);
      process.exit(0);
    }
    const subcommand = rawArgs[0];
    const subcommandArgs = rawArgs.slice(1);
    switch (subcommand) {
      case "init":
        await runInit(subcommandArgs);
        break;
      case "install":
      case "i":
        await runInstall(subcommandArgs);
        break;
      case "ralph":
      case "r":
        await runRalph(subcommandArgs);
        break;
      case "--help":
      case "-h":
        console.log(TOP_HELP_TEXT);
        break;
      default:
        await runRalph(rawArgs);
        break;
    }
  } catch (error) {
    UI.error(error instanceof Error ? error.message : String(error));
    process.exit(1);
  }
}
export {
  main as runMain
};

//# debugId=ACFD8169EA040D1564756E2164756E21
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9ub2Rlcy9pZGVudGl0eS5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3Zpc2l0LmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3QvZG9jL2RpcmVjdGl2ZXMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9kb2MvYW5jaG9ycy5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L2RvYy9hcHBseVJldml2ZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9ub2Rlcy90b0pTLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3Qvbm9kZXMvTm9kZS5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L25vZGVzL0FsaWFzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3Qvbm9kZXMvU2NhbGFyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3QvZG9jL2NyZWF0ZU5vZGUuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9ub2Rlcy9Db2xsZWN0aW9uLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3Qvc3RyaW5naWZ5L3N0cmluZ2lmeUNvbW1lbnQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9zdHJpbmdpZnkvZm9sZEZsb3dMaW5lcy5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3N0cmluZ2lmeS9zdHJpbmdpZnlTdHJpbmcuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9zdHJpbmdpZnkvc3RyaW5naWZ5LmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3Qvc3RyaW5naWZ5L3N0cmluZ2lmeVBhaXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9sb2cuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9zY2hlbWEveWFtbC0xLjEvbWVyZ2UuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9ub2Rlcy9hZGRQYWlyVG9KU01hcC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L25vZGVzL1BhaXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9zdHJpbmdpZnkvc3RyaW5naWZ5Q29sbGVjdGlvbi5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L25vZGVzL1lBTUxNYXAuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9zY2hlbWEvY29tbW9uL21hcC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L25vZGVzL1lBTUxTZXEuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9zY2hlbWEvY29tbW9uL3NlcS5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3NjaGVtYS9jb21tb24vc3RyaW5nLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3Qvc2NoZW1hL2NvbW1vbi9udWxsLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3Qvc2NoZW1hL2NvcmUvYm9vbC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3N0cmluZ2lmeS9zdHJpbmdpZnlOdW1iZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9zY2hlbWEvY29yZS9mbG9hdC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3NjaGVtYS9jb3JlL2ludC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3NjaGVtYS9jb3JlL3NjaGVtYS5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3NjaGVtYS9qc29uL3NjaGVtYS5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3NjaGVtYS95YW1sLTEuMS9iaW5hcnkuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9zY2hlbWEveWFtbC0xLjEvcGFpcnMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9zY2hlbWEveWFtbC0xLjEvb21hcC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3NjaGVtYS95YW1sLTEuMS9ib29sLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3Qvc2NoZW1hL3lhbWwtMS4xL2Zsb2F0LmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3Qvc2NoZW1hL3lhbWwtMS4xL2ludC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3NjaGVtYS95YW1sLTEuMS9zZXQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9zY2hlbWEveWFtbC0xLjEvdGltZXN0YW1wLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3Qvc2NoZW1hL3lhbWwtMS4xL3NjaGVtYS5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3NjaGVtYS90YWdzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3Qvc2NoZW1hL1NjaGVtYS5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3N0cmluZ2lmeS9zdHJpbmdpZnlEb2N1bWVudC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L2RvYy9Eb2N1bWVudC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L2Vycm9ycy5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L2NvbXBvc2UvcmVzb2x2ZS1wcm9wcy5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L2NvbXBvc2UvdXRpbC1jb250YWlucy1uZXdsaW5lLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3QvY29tcG9zZS91dGlsLWZsb3ctaW5kZW50LWNoZWNrLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3QvY29tcG9zZS91dGlsLW1hcC1pbmNsdWRlcy5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L2NvbXBvc2UvcmVzb2x2ZS1ibG9jay1tYXAuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9jb21wb3NlL3Jlc29sdmUtYmxvY2stc2VxLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3QvY29tcG9zZS9yZXNvbHZlLWVuZC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L2NvbXBvc2UvcmVzb2x2ZS1mbG93LWNvbGxlY3Rpb24uanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9jb21wb3NlL2NvbXBvc2UtY29sbGVjdGlvbi5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L2NvbXBvc2UvcmVzb2x2ZS1ibG9jay1zY2FsYXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9jb21wb3NlL3Jlc29sdmUtZmxvdy1zY2FsYXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9jb21wb3NlL2NvbXBvc2Utc2NhbGFyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3QvY29tcG9zZS91dGlsLWVtcHR5LXNjYWxhci1wb3NpdGlvbi5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L2NvbXBvc2UvY29tcG9zZS1ub2RlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3QvY29tcG9zZS9jb21wb3NlLWRvYy5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L2NvbXBvc2UvY29tcG9zZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lhbWwvZGlzdC9wYXJzZS9jc3Qtc2NhbGFyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3QvcGFyc2UvY3N0LXN0cmluZ2lmeS5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3BhcnNlL2NzdC12aXNpdC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3BhcnNlL2NzdC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L3BhcnNlL2xleGVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3QvcGFyc2UvbGluZS1jb3VudGVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3QvcGFyc2UvcGFyc2VyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95YW1sL2Rpc3QvcHVibGljLWFwaS5qcyIsICIuLi9ub2RlX21vZHVsZXMveWFtbC9kaXN0L2luZGV4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9zaXN0ZXJhbnNpL3NyYy9pbmRleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvcGljb2NvbG9ycy9waWNvY29sb3JzLmpzIiwgIi4uL3NyYy9jbGkvdWkudHMiLCAiLi4vc3JjL2luc3RhbGwvaW5pdC50cyIsICIuLi9zcmMvaW5zdGFsbC9pbnN0YWxsLnRzIiwgIi4uL3NyYy9jbGkvcnVuLnRzIiwgIi4uL3NyYy9jb25maWcvbG9hZENvbmZpZy50cyIsICIuLi9zcmMvY29uZmlnL3NjaGVtYS50cyIsICIuLi9zcmMvdXRpbC9sb2cudHMiLCAiLi4vbm9kZV9tb2R1bGVzL0BjbGFjay9jb3JlL2Rpc3QvaW5kZXgubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9AY2xhY2svcHJvbXB0cy9kaXN0L2luZGV4Lm1qcyIsICIuLi9zcmMvYmFja2VuZHMvb3BlbmNvZGUvY2xpZW50LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9Ab3BlbmNvZGUtYWkvc2RrL2Rpc3QvZ2VuL2NvcmUvc2VydmVyU2VudEV2ZW50cy5nZW4uanMiLCAiLi4vbm9kZV9tb2R1bGVzL0BvcGVuY29kZS1haS9zZGsvZGlzdC9nZW4vY29yZS9hdXRoLmdlbi5qcyIsICIuLi9ub2RlX21vZHVsZXMvQG9wZW5jb2RlLWFpL3Nkay9kaXN0L2dlbi9jb3JlL2JvZHlTZXJpYWxpemVyLmdlbi5qcyIsICIuLi9ub2RlX21vZHVsZXMvQG9wZW5jb2RlLWFpL3Nkay9kaXN0L2dlbi9jb3JlL3BhdGhTZXJpYWxpemVyLmdlbi5qcyIsICIuLi9ub2RlX21vZHVsZXMvQG9wZW5jb2RlLWFpL3Nkay9kaXN0L2dlbi9jb3JlL3V0aWxzLmdlbi5qcyIsICIuLi9ub2RlX21vZHVsZXMvQG9wZW5jb2RlLWFpL3Nkay9kaXN0L2dlbi9jbGllbnQvdXRpbHMuZ2VuLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9Ab3BlbmNvZGUtYWkvc2RrL2Rpc3QvZ2VuL2NsaWVudC9jbGllbnQuZ2VuLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9Ab3BlbmNvZGUtYWkvc2RrL2Rpc3QvZ2VuL2NvcmUvcGFyYW1zLmdlbi5qcyIsICIuLi9ub2RlX21vZHVsZXMvQG9wZW5jb2RlLWFpL3Nkay9kaXN0L2dlbi9jbGllbnQuZ2VuLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9Ab3BlbmNvZGUtYWkvc2RrL2Rpc3QvZ2VuL3Nkay5nZW4uanMiLCAiLi4vbm9kZV9tb2R1bGVzL0BvcGVuY29kZS1haS9zZGsvZGlzdC9jbGllbnQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0BvcGVuY29kZS1haS9zZGsvZGlzdC9zZXJ2ZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0BvcGVuY29kZS1haS9zZGsvZGlzdC9pbmRleC5qcyIsICIuLi9zcmMvZXhlY3V0aW9uL3JhbHBoLWxvb3AudHMiLCAiLi4vc3JjL3Byb21wdC1vcHRpbWl6YXRpb24vYW5hbHl6ZXIudHMiLCAiLi4vc3JjL3Byb21wdC1vcHRpbWl6YXRpb24vdGVjaG5pcXVlcy50cyIsICIuLi9zcmMvcHJvbXB0LW9wdGltaXphdGlvbi9vcHRpbWl6ZXIudHMiLCAiLi4vc3JjL3V0aWwvZGlzY29yZC13ZWJob29rLnRzIiwgIi4uL3NyYy9leGVjdXRpb24vZmxvdy1zdG9yZS50cyIsICIuLi9zcmMvZXhlY3V0aW9uL2Zsb3ctdHlwZXMudHMiLCAiLi4vc3JjL2NsaS9ydW4tY2xpLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWwogICAgIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQUxJQVMgPSBTeW1ib2wuZm9yKCd5YW1sLmFsaWFzJyk7XG5jb25zdCBET0MgPSBTeW1ib2wuZm9yKCd5YW1sLmRvY3VtZW50Jyk7XG5jb25zdCBNQVAgPSBTeW1ib2wuZm9yKCd5YW1sLm1hcCcpO1xuY29uc3QgUEFJUiA9IFN5bWJvbC5mb3IoJ3lhbWwucGFpcicpO1xuY29uc3QgU0NBTEFSID0gU3ltYm9sLmZvcigneWFtbC5zY2FsYXInKTtcbmNvbnN0IFNFUSA9IFN5bWJvbC5mb3IoJ3lhbWwuc2VxJyk7XG5jb25zdCBOT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCd5YW1sLm5vZGUudHlwZScpO1xuY29uc3QgaXNBbGlhcyA9IChub2RlKSA9PiAhIW5vZGUgJiYgdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnICYmIG5vZGVbTk9ERV9UWVBFXSA9PT0gQUxJQVM7XG5jb25zdCBpc0RvY3VtZW50ID0gKG5vZGUpID0+ICEhbm9kZSAmJiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiYgbm9kZVtOT0RFX1RZUEVdID09PSBET0M7XG5jb25zdCBpc01hcCA9IChub2RlKSA9PiAhIW5vZGUgJiYgdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnICYmIG5vZGVbTk9ERV9UWVBFXSA9PT0gTUFQO1xuY29uc3QgaXNQYWlyID0gKG5vZGUpID0+ICEhbm9kZSAmJiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiYgbm9kZVtOT0RFX1RZUEVdID09PSBQQUlSO1xuY29uc3QgaXNTY2FsYXIgPSAobm9kZSkgPT4gISFub2RlICYmIHR5cGVvZiBub2RlID09PSAnb2JqZWN0JyAmJiBub2RlW05PREVfVFlQRV0gPT09IFNDQUxBUjtcbmNvbnN0IGlzU2VxID0gKG5vZGUpID0+ICEhbm9kZSAmJiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiYgbm9kZVtOT0RFX1RZUEVdID09PSBTRVE7XG5mdW5jdGlvbiBpc0NvbGxlY3Rpb24obm9kZSkge1xuICAgIGlmIChub2RlICYmIHR5cGVvZiBub2RlID09PSAnb2JqZWN0JylcbiAgICAgICAgc3dpdGNoIChub2RlW05PREVfVFlQRV0pIHtcbiAgICAgICAgICAgIGNhc2UgTUFQOlxuICAgICAgICAgICAgY2FzZSBTRVE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc05vZGUobm9kZSkge1xuICAgIGlmIChub2RlICYmIHR5cGVvZiBub2RlID09PSAnb2JqZWN0JylcbiAgICAgICAgc3dpdGNoIChub2RlW05PREVfVFlQRV0pIHtcbiAgICAgICAgICAgIGNhc2UgQUxJQVM6XG4gICAgICAgICAgICBjYXNlIE1BUDpcbiAgICAgICAgICAgIGNhc2UgU0NBTEFSOlxuICAgICAgICAgICAgY2FzZSBTRVE6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5jb25zdCBoYXNBbmNob3IgPSAobm9kZSkgPT4gKGlzU2NhbGFyKG5vZGUpIHx8IGlzQ29sbGVjdGlvbihub2RlKSkgJiYgISFub2RlLmFuY2hvcjtcblxuZXhwb3J0cy5BTElBUyA9IEFMSUFTO1xuZXhwb3J0cy5ET0MgPSBET0M7XG5leHBvcnRzLk1BUCA9IE1BUDtcbmV4cG9ydHMuTk9ERV9UWVBFID0gTk9ERV9UWVBFO1xuZXhwb3J0cy5QQUlSID0gUEFJUjtcbmV4cG9ydHMuU0NBTEFSID0gU0NBTEFSO1xuZXhwb3J0cy5TRVEgPSBTRVE7XG5leHBvcnRzLmhhc0FuY2hvciA9IGhhc0FuY2hvcjtcbmV4cG9ydHMuaXNBbGlhcyA9IGlzQWxpYXM7XG5leHBvcnRzLmlzQ29sbGVjdGlvbiA9IGlzQ29sbGVjdGlvbjtcbmV4cG9ydHMuaXNEb2N1bWVudCA9IGlzRG9jdW1lbnQ7XG5leHBvcnRzLmlzTWFwID0gaXNNYXA7XG5leHBvcnRzLmlzTm9kZSA9IGlzTm9kZTtcbmV4cG9ydHMuaXNQYWlyID0gaXNQYWlyO1xuZXhwb3J0cy5pc1NjYWxhciA9IGlzU2NhbGFyO1xuZXhwb3J0cy5pc1NlcSA9IGlzU2VxO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vbm9kZXMvaWRlbnRpdHkuanMnKTtcblxuY29uc3QgQlJFQUsgPSBTeW1ib2woJ2JyZWFrIHZpc2l0Jyk7XG5jb25zdCBTS0lQID0gU3ltYm9sKCdza2lwIGNoaWxkcmVuJyk7XG5jb25zdCBSRU1PVkUgPSBTeW1ib2woJ3JlbW92ZSBub2RlJyk7XG4vKipcbiAqIEFwcGx5IGEgdmlzaXRvciB0byBhbiBBU1Qgbm9kZSBvciBkb2N1bWVudC5cbiAqXG4gKiBXYWxrcyB0aHJvdWdoIHRoZSB0cmVlIChkZXB0aC1maXJzdCkgc3RhcnRpbmcgZnJvbSBgbm9kZWAsIGNhbGxpbmcgYVxuICogYHZpc2l0b3JgIGZ1bmN0aW9uIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICogICAtIGBrZXlgOiBGb3Igc2VxdWVuY2UgdmFsdWVzIGFuZCBtYXAgYFBhaXJgLCB0aGUgbm9kZSdzIGluZGV4IGluIHRoZVxuICogICAgIGNvbGxlY3Rpb24uIFdpdGhpbiBhIGBQYWlyYCwgYCdrZXknYCBvciBgJ3ZhbHVlJ2AsIGNvcnJlc3BvbmRpbmdseS5cbiAqICAgICBgbnVsbGAgZm9yIHRoZSByb290IG5vZGUuXG4gKiAgIC0gYG5vZGVgOiBUaGUgY3VycmVudCBub2RlLlxuICogICAtIGBwYXRoYDogVGhlIGFuY2VzdHJ5IG9mIHRoZSBjdXJyZW50IG5vZGUuXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgdmlzaXRvciBtYXkgYmUgdXNlZCB0byBjb250cm9sIHRoZSB0cmF2ZXJzYWw6XG4gKiAgIC0gYHVuZGVmaW5lZGAgKGRlZmF1bHQpOiBEbyBub3RoaW5nIGFuZCBjb250aW51ZVxuICogICAtIGB2aXNpdC5TS0lQYDogRG8gbm90IHZpc2l0IHRoZSBjaGlsZHJlbiBvZiB0aGlzIG5vZGUsIGNvbnRpbnVlIHdpdGggbmV4dFxuICogICAgIHNpYmxpbmdcbiAqICAgLSBgdmlzaXQuQlJFQUtgOiBUZXJtaW5hdGUgdHJhdmVyc2FsIGNvbXBsZXRlbHlcbiAqICAgLSBgdmlzaXQuUkVNT1ZFYDogUmVtb3ZlIHRoZSBjdXJyZW50IG5vZGUsIHRoZW4gY29udGludWUgd2l0aCB0aGUgbmV4dCBvbmVcbiAqICAgLSBgTm9kZWA6IFJlcGxhY2UgdGhlIGN1cnJlbnQgbm9kZSwgdGhlbiBjb250aW51ZSBieSB2aXNpdGluZyBpdFxuICogICAtIGBudW1iZXJgOiBXaGlsZSBpdGVyYXRpbmcgdGhlIGl0ZW1zIG9mIGEgc2VxdWVuY2Ugb3IgbWFwLCBzZXQgdGhlIGluZGV4XG4gKiAgICAgb2YgdGhlIG5leHQgc3RlcC4gVGhpcyBpcyB1c2VmdWwgZXNwZWNpYWxseSBpZiB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnRcbiAqICAgICBub2RlIGhhcyBjaGFuZ2VkLlxuICpcbiAqIElmIGB2aXNpdG9yYCBpcyBhIHNpbmdsZSBmdW5jdGlvbiwgaXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBhbGwgdmFsdWVzXG4gKiBlbmNvdW50ZXJlZCBpbiB0aGUgdHJlZSwgaW5jbHVkaW5nIGUuZy4gYG51bGxgIHZhbHVlcy4gQWx0ZXJuYXRpdmVseSxcbiAqIHNlcGFyYXRlIHZpc2l0b3IgZnVuY3Rpb25zIG1heSBiZSBkZWZpbmVkIGZvciBlYWNoIGBNYXBgLCBgUGFpcmAsIGBTZXFgLFxuICogYEFsaWFzYCBhbmQgYFNjYWxhcmAgbm9kZS4gVG8gZGVmaW5lIHRoZSBzYW1lIHZpc2l0b3IgZnVuY3Rpb24gZm9yIG1vcmUgdGhhblxuICogb25lIG5vZGUgdHlwZSwgdXNlIHRoZSBgQ29sbGVjdGlvbmAgKG1hcCBhbmQgc2VxKSwgYFZhbHVlYCAobWFwLCBzZXEgJiBzY2FsYXIpXG4gKiBhbmQgYE5vZGVgIChhbGlhcywgbWFwLCBzZXEgJiBzY2FsYXIpIHRhcmdldHMuIE9mIGFsbCB0aGVzZSwgb25seSB0aGUgbW9zdFxuICogc3BlY2lmaWMgZGVmaW5lZCBvbmUgd2lsbCBiZSB1c2VkIGZvciBlYWNoIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIHZpc2l0KG5vZGUsIHZpc2l0b3IpIHtcbiAgICBjb25zdCB2aXNpdG9yXyA9IGluaXRWaXNpdG9yKHZpc2l0b3IpO1xuICAgIGlmIChpZGVudGl0eS5pc0RvY3VtZW50KG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGNkID0gdmlzaXRfKG51bGwsIG5vZGUuY29udGVudHMsIHZpc2l0b3JfLCBPYmplY3QuZnJlZXplKFtub2RlXSkpO1xuICAgICAgICBpZiAoY2QgPT09IFJFTU9WRSlcbiAgICAgICAgICAgIG5vZGUuY29udGVudHMgPSBudWxsO1xuICAgIH1cbiAgICBlbHNlXG4gICAgICAgIHZpc2l0XyhudWxsLCBub2RlLCB2aXNpdG9yXywgT2JqZWN0LmZyZWV6ZShbXSkpO1xufVxuLy8gV2l0aG91dCB0aGUgYGFzIHN5bWJvbGAgY2FzdHMsIFRTIGRlY2xhcmVzIHRoZXNlIGluIHRoZSBgdmlzaXRgXG4vLyBuYW1lc3BhY2UgdXNpbmcgYHZhcmAsIGJ1dCB0aGVuIGNvbXBsYWlucyBhYm91dCB0aGF0IGJlY2F1c2Vcbi8vIGB1bmlxdWUgc3ltYm9sYCBtdXN0IGJlIGBjb25zdGAuXG4vKiogVGVybWluYXRlIHZpc2l0IHRyYXZlcnNhbCBjb21wbGV0ZWx5ICovXG52aXNpdC5CUkVBSyA9IEJSRUFLO1xuLyoqIERvIG5vdCB2aXNpdCB0aGUgY2hpbGRyZW4gb2YgdGhlIGN1cnJlbnQgbm9kZSAqL1xudmlzaXQuU0tJUCA9IFNLSVA7XG4vKiogUmVtb3ZlIHRoZSBjdXJyZW50IG5vZGUgKi9cbnZpc2l0LlJFTU9WRSA9IFJFTU9WRTtcbmZ1bmN0aW9uIHZpc2l0XyhrZXksIG5vZGUsIHZpc2l0b3IsIHBhdGgpIHtcbiAgICBjb25zdCBjdHJsID0gY2FsbFZpc2l0b3Ioa2V5LCBub2RlLCB2aXNpdG9yLCBwYXRoKTtcbiAgICBpZiAoaWRlbnRpdHkuaXNOb2RlKGN0cmwpIHx8IGlkZW50aXR5LmlzUGFpcihjdHJsKSkge1xuICAgICAgICByZXBsYWNlTm9kZShrZXksIHBhdGgsIGN0cmwpO1xuICAgICAgICByZXR1cm4gdmlzaXRfKGtleSwgY3RybCwgdmlzaXRvciwgcGF0aCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY3RybCAhPT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgaWYgKGlkZW50aXR5LmlzQ29sbGVjdGlvbihub2RlKSkge1xuICAgICAgICAgICAgcGF0aCA9IE9iamVjdC5mcmVlemUocGF0aC5jb25jYXQobm9kZSkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLml0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2kgPSB2aXNpdF8oaSwgbm9kZS5pdGVtc1tpXSwgdmlzaXRvciwgcGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgICAgIGkgPSBjaSAtIDE7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2kgPT09IEJSRUFLKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQlJFQUs7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2kgPT09IFJFTU9WRSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLml0ZW1zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpZGVudGl0eS5pc1BhaXIobm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGggPSBPYmplY3QuZnJlZXplKHBhdGguY29uY2F0KG5vZGUpKTtcbiAgICAgICAgICAgIGNvbnN0IGNrID0gdmlzaXRfKCdrZXknLCBub2RlLmtleSwgdmlzaXRvciwgcGF0aCk7XG4gICAgICAgICAgICBpZiAoY2sgPT09IEJSRUFLKVxuICAgICAgICAgICAgICAgIHJldHVybiBCUkVBSztcbiAgICAgICAgICAgIGVsc2UgaWYgKGNrID09PSBSRU1PVkUpXG4gICAgICAgICAgICAgICAgbm9kZS5rZXkgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgY3YgPSB2aXNpdF8oJ3ZhbHVlJywgbm9kZS52YWx1ZSwgdmlzaXRvciwgcGF0aCk7XG4gICAgICAgICAgICBpZiAoY3YgPT09IEJSRUFLKVxuICAgICAgICAgICAgICAgIHJldHVybiBCUkVBSztcbiAgICAgICAgICAgIGVsc2UgaWYgKGN2ID09PSBSRU1PVkUpXG4gICAgICAgICAgICAgICAgbm9kZS52YWx1ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGN0cmw7XG59XG4vKipcbiAqIEFwcGx5IGFuIGFzeW5jIHZpc2l0b3IgdG8gYW4gQVNUIG5vZGUgb3IgZG9jdW1lbnQuXG4gKlxuICogV2Fsa3MgdGhyb3VnaCB0aGUgdHJlZSAoZGVwdGgtZmlyc3QpIHN0YXJ0aW5nIGZyb20gYG5vZGVgLCBjYWxsaW5nIGFcbiAqIGB2aXNpdG9yYCBmdW5jdGlvbiB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAqICAgLSBga2V5YDogRm9yIHNlcXVlbmNlIHZhbHVlcyBhbmQgbWFwIGBQYWlyYCwgdGhlIG5vZGUncyBpbmRleCBpbiB0aGVcbiAqICAgICBjb2xsZWN0aW9uLiBXaXRoaW4gYSBgUGFpcmAsIGAna2V5J2Agb3IgYCd2YWx1ZSdgLCBjb3JyZXNwb25kaW5nbHkuXG4gKiAgICAgYG51bGxgIGZvciB0aGUgcm9vdCBub2RlLlxuICogICAtIGBub2RlYDogVGhlIGN1cnJlbnQgbm9kZS5cbiAqICAgLSBgcGF0aGA6IFRoZSBhbmNlc3RyeSBvZiB0aGUgY3VycmVudCBub2RlLlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHZpc2l0b3IgbWF5IGJlIHVzZWQgdG8gY29udHJvbCB0aGUgdHJhdmVyc2FsOlxuICogICAtIGBQcm9taXNlYDogTXVzdCByZXNvbHZlIHRvIG9uZSBvZiB0aGUgZm9sbG93aW5nIHZhbHVlc1xuICogICAtIGB1bmRlZmluZWRgIChkZWZhdWx0KTogRG8gbm90aGluZyBhbmQgY29udGludWVcbiAqICAgLSBgdmlzaXQuU0tJUGA6IERvIG5vdCB2aXNpdCB0aGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlLCBjb250aW51ZSB3aXRoIG5leHRcbiAqICAgICBzaWJsaW5nXG4gKiAgIC0gYHZpc2l0LkJSRUFLYDogVGVybWluYXRlIHRyYXZlcnNhbCBjb21wbGV0ZWx5XG4gKiAgIC0gYHZpc2l0LlJFTU9WRWA6IFJlbW92ZSB0aGUgY3VycmVudCBub2RlLCB0aGVuIGNvbnRpbnVlIHdpdGggdGhlIG5leHQgb25lXG4gKiAgIC0gYE5vZGVgOiBSZXBsYWNlIHRoZSBjdXJyZW50IG5vZGUsIHRoZW4gY29udGludWUgYnkgdmlzaXRpbmcgaXRcbiAqICAgLSBgbnVtYmVyYDogV2hpbGUgaXRlcmF0aW5nIHRoZSBpdGVtcyBvZiBhIHNlcXVlbmNlIG9yIG1hcCwgc2V0IHRoZSBpbmRleFxuICogICAgIG9mIHRoZSBuZXh0IHN0ZXAuIFRoaXMgaXMgdXNlZnVsIGVzcGVjaWFsbHkgaWYgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50XG4gKiAgICAgbm9kZSBoYXMgY2hhbmdlZC5cbiAqXG4gKiBJZiBgdmlzaXRvcmAgaXMgYSBzaW5nbGUgZnVuY3Rpb24sIGl0IHdpbGwgYmUgY2FsbGVkIHdpdGggYWxsIHZhbHVlc1xuICogZW5jb3VudGVyZWQgaW4gdGhlIHRyZWUsIGluY2x1ZGluZyBlLmcuIGBudWxsYCB2YWx1ZXMuIEFsdGVybmF0aXZlbHksXG4gKiBzZXBhcmF0ZSB2aXNpdG9yIGZ1bmN0aW9ucyBtYXkgYmUgZGVmaW5lZCBmb3IgZWFjaCBgTWFwYCwgYFBhaXJgLCBgU2VxYCxcbiAqIGBBbGlhc2AgYW5kIGBTY2FsYXJgIG5vZGUuIFRvIGRlZmluZSB0aGUgc2FtZSB2aXNpdG9yIGZ1bmN0aW9uIGZvciBtb3JlIHRoYW5cbiAqIG9uZSBub2RlIHR5cGUsIHVzZSB0aGUgYENvbGxlY3Rpb25gIChtYXAgYW5kIHNlcSksIGBWYWx1ZWAgKG1hcCwgc2VxICYgc2NhbGFyKVxuICogYW5kIGBOb2RlYCAoYWxpYXMsIG1hcCwgc2VxICYgc2NhbGFyKSB0YXJnZXRzLiBPZiBhbGwgdGhlc2UsIG9ubHkgdGhlIG1vc3RcbiAqIHNwZWNpZmljIGRlZmluZWQgb25lIHdpbGwgYmUgdXNlZCBmb3IgZWFjaCBub2RlLlxuICovXG5hc3luYyBmdW5jdGlvbiB2aXNpdEFzeW5jKG5vZGUsIHZpc2l0b3IpIHtcbiAgICBjb25zdCB2aXNpdG9yXyA9IGluaXRWaXNpdG9yKHZpc2l0b3IpO1xuICAgIGlmIChpZGVudGl0eS5pc0RvY3VtZW50KG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGNkID0gYXdhaXQgdmlzaXRBc3luY18obnVsbCwgbm9kZS5jb250ZW50cywgdmlzaXRvcl8sIE9iamVjdC5mcmVlemUoW25vZGVdKSk7XG4gICAgICAgIGlmIChjZCA9PT0gUkVNT1ZFKVxuICAgICAgICAgICAgbm9kZS5jb250ZW50cyA9IG51bGw7XG4gICAgfVxuICAgIGVsc2VcbiAgICAgICAgYXdhaXQgdmlzaXRBc3luY18obnVsbCwgbm9kZSwgdmlzaXRvcl8sIE9iamVjdC5mcmVlemUoW10pKTtcbn1cbi8vIFdpdGhvdXQgdGhlIGBhcyBzeW1ib2xgIGNhc3RzLCBUUyBkZWNsYXJlcyB0aGVzZSBpbiB0aGUgYHZpc2l0YFxuLy8gbmFtZXNwYWNlIHVzaW5nIGB2YXJgLCBidXQgdGhlbiBjb21wbGFpbnMgYWJvdXQgdGhhdCBiZWNhdXNlXG4vLyBgdW5pcXVlIHN5bWJvbGAgbXVzdCBiZSBgY29uc3RgLlxuLyoqIFRlcm1pbmF0ZSB2aXNpdCB0cmF2ZXJzYWwgY29tcGxldGVseSAqL1xudmlzaXRBc3luYy5CUkVBSyA9IEJSRUFLO1xuLyoqIERvIG5vdCB2aXNpdCB0aGUgY2hpbGRyZW4gb2YgdGhlIGN1cnJlbnQgbm9kZSAqL1xudmlzaXRBc3luYy5TS0lQID0gU0tJUDtcbi8qKiBSZW1vdmUgdGhlIGN1cnJlbnQgbm9kZSAqL1xudmlzaXRBc3luYy5SRU1PVkUgPSBSRU1PVkU7XG5hc3luYyBmdW5jdGlvbiB2aXNpdEFzeW5jXyhrZXksIG5vZGUsIHZpc2l0b3IsIHBhdGgpIHtcbiAgICBjb25zdCBjdHJsID0gYXdhaXQgY2FsbFZpc2l0b3Ioa2V5LCBub2RlLCB2aXNpdG9yLCBwYXRoKTtcbiAgICBpZiAoaWRlbnRpdHkuaXNOb2RlKGN0cmwpIHx8IGlkZW50aXR5LmlzUGFpcihjdHJsKSkge1xuICAgICAgICByZXBsYWNlTm9kZShrZXksIHBhdGgsIGN0cmwpO1xuICAgICAgICByZXR1cm4gdmlzaXRBc3luY18oa2V5LCBjdHJsLCB2aXNpdG9yLCBwYXRoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjdHJsICE9PSAnc3ltYm9sJykge1xuICAgICAgICBpZiAoaWRlbnRpdHkuaXNDb2xsZWN0aW9uKG5vZGUpKSB7XG4gICAgICAgICAgICBwYXRoID0gT2JqZWN0LmZyZWV6ZShwYXRoLmNvbmNhdChub2RlKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaSA9IGF3YWl0IHZpc2l0QXN5bmNfKGksIG5vZGUuaXRlbXNbaV0sIHZpc2l0b3IsIHBhdGgpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2kgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgICAgICBpID0gY2kgLSAxO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNpID09PSBCUkVBSylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJSRUFLO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNpID09PSBSRU1PVkUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5pdGVtcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaWRlbnRpdHkuaXNQYWlyKG5vZGUpKSB7XG4gICAgICAgICAgICBwYXRoID0gT2JqZWN0LmZyZWV6ZShwYXRoLmNvbmNhdChub2RlKSk7XG4gICAgICAgICAgICBjb25zdCBjayA9IGF3YWl0IHZpc2l0QXN5bmNfKCdrZXknLCBub2RlLmtleSwgdmlzaXRvciwgcGF0aCk7XG4gICAgICAgICAgICBpZiAoY2sgPT09IEJSRUFLKVxuICAgICAgICAgICAgICAgIHJldHVybiBCUkVBSztcbiAgICAgICAgICAgIGVsc2UgaWYgKGNrID09PSBSRU1PVkUpXG4gICAgICAgICAgICAgICAgbm9kZS5rZXkgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgY3YgPSBhd2FpdCB2aXNpdEFzeW5jXygndmFsdWUnLCBub2RlLnZhbHVlLCB2aXNpdG9yLCBwYXRoKTtcbiAgICAgICAgICAgIGlmIChjdiA9PT0gQlJFQUspXG4gICAgICAgICAgICAgICAgcmV0dXJuIEJSRUFLO1xuICAgICAgICAgICAgZWxzZSBpZiAoY3YgPT09IFJFTU9WRSlcbiAgICAgICAgICAgICAgICBub2RlLnZhbHVlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3RybDtcbn1cbmZ1bmN0aW9uIGluaXRWaXNpdG9yKHZpc2l0b3IpIHtcbiAgICBpZiAodHlwZW9mIHZpc2l0b3IgPT09ICdvYmplY3QnICYmXG4gICAgICAgICh2aXNpdG9yLkNvbGxlY3Rpb24gfHwgdmlzaXRvci5Ob2RlIHx8IHZpc2l0b3IuVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIEFsaWFzOiB2aXNpdG9yLk5vZGUsXG4gICAgICAgICAgICBNYXA6IHZpc2l0b3IuTm9kZSxcbiAgICAgICAgICAgIFNjYWxhcjogdmlzaXRvci5Ob2RlLFxuICAgICAgICAgICAgU2VxOiB2aXNpdG9yLk5vZGVcbiAgICAgICAgfSwgdmlzaXRvci5WYWx1ZSAmJiB7XG4gICAgICAgICAgICBNYXA6IHZpc2l0b3IuVmFsdWUsXG4gICAgICAgICAgICBTY2FsYXI6IHZpc2l0b3IuVmFsdWUsXG4gICAgICAgICAgICBTZXE6IHZpc2l0b3IuVmFsdWVcbiAgICAgICAgfSwgdmlzaXRvci5Db2xsZWN0aW9uICYmIHtcbiAgICAgICAgICAgIE1hcDogdmlzaXRvci5Db2xsZWN0aW9uLFxuICAgICAgICAgICAgU2VxOiB2aXNpdG9yLkNvbGxlY3Rpb25cbiAgICAgICAgfSwgdmlzaXRvcik7XG4gICAgfVxuICAgIHJldHVybiB2aXNpdG9yO1xufVxuZnVuY3Rpb24gY2FsbFZpc2l0b3Ioa2V5LCBub2RlLCB2aXNpdG9yLCBwYXRoKSB7XG4gICAgaWYgKHR5cGVvZiB2aXNpdG9yID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gdmlzaXRvcihrZXksIG5vZGUsIHBhdGgpO1xuICAgIGlmIChpZGVudGl0eS5pc01hcChub2RlKSlcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuTWFwPy4oa2V5LCBub2RlLCBwYXRoKTtcbiAgICBpZiAoaWRlbnRpdHkuaXNTZXEobm9kZSkpXG4gICAgICAgIHJldHVybiB2aXNpdG9yLlNlcT8uKGtleSwgbm9kZSwgcGF0aCk7XG4gICAgaWYgKGlkZW50aXR5LmlzUGFpcihub2RlKSlcbiAgICAgICAgcmV0dXJuIHZpc2l0b3IuUGFpcj8uKGtleSwgbm9kZSwgcGF0aCk7XG4gICAgaWYgKGlkZW50aXR5LmlzU2NhbGFyKG5vZGUpKVxuICAgICAgICByZXR1cm4gdmlzaXRvci5TY2FsYXI/LihrZXksIG5vZGUsIHBhdGgpO1xuICAgIGlmIChpZGVudGl0eS5pc0FsaWFzKG5vZGUpKVxuICAgICAgICByZXR1cm4gdmlzaXRvci5BbGlhcz8uKGtleSwgbm9kZSwgcGF0aCk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VOb2RlKGtleSwgcGF0aCwgbm9kZSkge1xuICAgIGNvbnN0IHBhcmVudCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICBpZiAoaWRlbnRpdHkuaXNDb2xsZWN0aW9uKHBhcmVudCkpIHtcbiAgICAgICAgcGFyZW50Lml0ZW1zW2tleV0gPSBub2RlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpZGVudGl0eS5pc1BhaXIocGFyZW50KSkge1xuICAgICAgICBpZiAoa2V5ID09PSAna2V5JylcbiAgICAgICAgICAgIHBhcmVudC5rZXkgPSBub2RlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBwYXJlbnQudmFsdWUgPSBub2RlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpZGVudGl0eS5pc0RvY3VtZW50KHBhcmVudCkpIHtcbiAgICAgICAgcGFyZW50LmNvbnRlbnRzID0gbm9kZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHB0ID0gaWRlbnRpdHkuaXNBbGlhcyhwYXJlbnQpID8gJ2FsaWFzJyA6ICdzY2FsYXInO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCByZXBsYWNlIG5vZGUgd2l0aCAke3B0fSBwYXJlbnRgKTtcbiAgICB9XG59XG5cbmV4cG9ydHMudmlzaXQgPSB2aXNpdDtcbmV4cG9ydHMudmlzaXRBc3luYyA9IHZpc2l0QXN5bmM7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi4vbm9kZXMvaWRlbnRpdHkuanMnKTtcbnZhciB2aXNpdCA9IHJlcXVpcmUoJy4uL3Zpc2l0LmpzJyk7XG5cbmNvbnN0IGVzY2FwZUNoYXJzID0ge1xuICAgICchJzogJyUyMScsXG4gICAgJywnOiAnJTJDJyxcbiAgICAnWyc6ICclNUInLFxuICAgICddJzogJyU1RCcsXG4gICAgJ3snOiAnJTdCJyxcbiAgICAnfSc6ICclN0QnXG59O1xuY29uc3QgZXNjYXBlVGFnTmFtZSA9ICh0bikgPT4gdG4ucmVwbGFjZSgvWyEsW1xcXXt9XS9nLCBjaCA9PiBlc2NhcGVDaGFyc1tjaF0pO1xuY2xhc3MgRGlyZWN0aXZlcyB7XG4gICAgY29uc3RydWN0b3IoeWFtbCwgdGFncykge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRpcmVjdGl2ZXMtZW5kL2RvYy1zdGFydCBtYXJrZXIgYC0tLWAuIElmIGBudWxsYCwgYSBtYXJrZXIgbWF5IHN0aWxsIGJlXG4gICAgICAgICAqIGluY2x1ZGVkIGluIHRoZSBkb2N1bWVudCdzIHN0cmluZ2lmaWVkIHJlcHJlc2VudGF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kb2NTdGFydCA9IG51bGw7XG4gICAgICAgIC8qKiBUaGUgZG9jLWVuZCBtYXJrZXIgYC4uLmAuICAqL1xuICAgICAgICB0aGlzLmRvY0VuZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnlhbWwgPSBPYmplY3QuYXNzaWduKHt9LCBEaXJlY3RpdmVzLmRlZmF1bHRZYW1sLCB5YW1sKTtcbiAgICAgICAgdGhpcy50YWdzID0gT2JqZWN0LmFzc2lnbih7fSwgRGlyZWN0aXZlcy5kZWZhdWx0VGFncywgdGFncyk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjb3B5ID0gbmV3IERpcmVjdGl2ZXModGhpcy55YW1sLCB0aGlzLnRhZ3MpO1xuICAgICAgICBjb3B5LmRvY1N0YXJ0ID0gdGhpcy5kb2NTdGFydDtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIER1cmluZyBwYXJzaW5nLCBnZXQgYSBEaXJlY3RpdmVzIGluc3RhbmNlIGZvciB0aGUgY3VycmVudCBkb2N1bWVudCBhbmRcbiAgICAgKiB1cGRhdGUgdGhlIHN0cmVhbSBzdGF0ZSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgdmVyc2lvbidzIHNwZWMuXG4gICAgICovXG4gICAgYXREb2N1bWVudCgpIHtcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IERpcmVjdGl2ZXModGhpcy55YW1sLCB0aGlzLnRhZ3MpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMueWFtbC52ZXJzaW9uKSB7XG4gICAgICAgICAgICBjYXNlICcxLjEnOlxuICAgICAgICAgICAgICAgIHRoaXMuYXROZXh0RG9jdW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnMS4yJzpcbiAgICAgICAgICAgICAgICB0aGlzLmF0TmV4dERvY3VtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy55YW1sID0ge1xuICAgICAgICAgICAgICAgICAgICBleHBsaWNpdDogRGlyZWN0aXZlcy5kZWZhdWx0WWFtbC5leHBsaWNpdCxcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogJzEuMidcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMudGFncyA9IE9iamVjdC5hc3NpZ24oe30sIERpcmVjdGl2ZXMuZGVmYXVsdFRhZ3MpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbkVycm9yIC0gTWF5IGJlIGNhbGxlZCBldmVuIGlmIHRoZSBhY3Rpb24gd2FzIHN1Y2Nlc3NmdWxcbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgb24gc3VjY2Vzc1xuICAgICAqL1xuICAgIGFkZChsaW5lLCBvbkVycm9yKSB7XG4gICAgICAgIGlmICh0aGlzLmF0TmV4dERvY3VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnlhbWwgPSB7IGV4cGxpY2l0OiBEaXJlY3RpdmVzLmRlZmF1bHRZYW1sLmV4cGxpY2l0LCB2ZXJzaW9uOiAnMS4xJyB9O1xuICAgICAgICAgICAgdGhpcy50YWdzID0gT2JqZWN0LmFzc2lnbih7fSwgRGlyZWN0aXZlcy5kZWZhdWx0VGFncyk7XG4gICAgICAgICAgICB0aGlzLmF0TmV4dERvY3VtZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnRyaW0oKS5zcGxpdCgvWyBcXHRdKy8pO1xuICAgICAgICBjb25zdCBuYW1lID0gcGFydHMuc2hpZnQoKTtcbiAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICBjYXNlICclVEFHJzoge1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcigwLCAnJVRBRyBkaXJlY3RpdmUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSB0d28gcGFydHMnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA8IDIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IFtoYW5kbGUsIHByZWZpeF0gPSBwYXJ0cztcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ3NbaGFuZGxlXSA9IHByZWZpeDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJyVZQU1MJzoge1xuICAgICAgICAgICAgICAgIHRoaXMueWFtbC5leHBsaWNpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKDAsICclWUFNTCBkaXJlY3RpdmUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgcGFydCcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IFt2ZXJzaW9uXSA9IHBhcnRzO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uID09PSAnMS4xJyB8fCB2ZXJzaW9uID09PSAnMS4yJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnlhbWwudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNWYWxpZCA9IC9eXFxkK1xcLlxcZCskLy50ZXN0KHZlcnNpb24pO1xuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKDYsIGBVbnN1cHBvcnRlZCBZQU1MIHZlcnNpb24gJHt2ZXJzaW9ufWAsIGlzVmFsaWQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBvbkVycm9yKDAsIGBVbmtub3duIGRpcmVjdGl2ZSAke25hbWV9YCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIGEgdGFnLCBtYXRjaGluZyBoYW5kbGVzIHRvIHRob3NlIGRlZmluZWQgaW4gJVRBRyBkaXJlY3RpdmVzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgUmVzb2x2ZWQgdGFnLCB3aGljaCBtYXkgYWxzbyBiZSB0aGUgbm9uLXNwZWNpZmljIHRhZyBgJyEnYCBvciBhXG4gICAgICogICBgJyFsb2NhbCdgIHRhZywgb3IgYG51bGxgIGlmIHVucmVzb2x2YWJsZS5cbiAgICAgKi9cbiAgICB0YWdOYW1lKHNvdXJjZSwgb25FcnJvcikge1xuICAgICAgICBpZiAoc291cmNlID09PSAnIScpXG4gICAgICAgICAgICByZXR1cm4gJyEnOyAvLyBub24tc3BlY2lmaWMgdGFnXG4gICAgICAgIGlmIChzb3VyY2VbMF0gIT09ICchJykge1xuICAgICAgICAgICAgb25FcnJvcihgTm90IGEgdmFsaWQgdGFnOiAke3NvdXJjZX1gKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2VbMV0gPT09ICc8Jykge1xuICAgICAgICAgICAgY29uc3QgdmVyYmF0aW0gPSBzb3VyY2Uuc2xpY2UoMiwgLTEpO1xuICAgICAgICAgICAgaWYgKHZlcmJhdGltID09PSAnIScgfHwgdmVyYmF0aW0gPT09ICchIScpIHtcbiAgICAgICAgICAgICAgICBvbkVycm9yKGBWZXJiYXRpbSB0YWdzIGFyZW4ndCByZXNvbHZlZCwgc28gJHtzb3VyY2V9IGlzIGludmFsaWQuYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc291cmNlW3NvdXJjZS5sZW5ndGggLSAxXSAhPT0gJz4nKVxuICAgICAgICAgICAgICAgIG9uRXJyb3IoJ1ZlcmJhdGltIHRhZ3MgbXVzdCBlbmQgd2l0aCBhID4nKTtcbiAgICAgICAgICAgIHJldHVybiB2ZXJiYXRpbTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbLCBoYW5kbGUsIHN1ZmZpeF0gPSBzb3VyY2UubWF0Y2goL14oLiohKShbXiFdKikkL3MpO1xuICAgICAgICBpZiAoIXN1ZmZpeClcbiAgICAgICAgICAgIG9uRXJyb3IoYFRoZSAke3NvdXJjZX0gdGFnIGhhcyBubyBzdWZmaXhgKTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gdGhpcy50YWdzW2hhbmRsZV07XG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWZpeCArIGRlY29kZVVSSUNvbXBvbmVudChzdWZmaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgb25FcnJvcihTdHJpbmcoZXJyb3IpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFuZGxlID09PSAnIScpXG4gICAgICAgICAgICByZXR1cm4gc291cmNlOyAvLyBsb2NhbCB0YWdcbiAgICAgICAgb25FcnJvcihgQ291bGQgbm90IHJlc29sdmUgdGFnOiAke3NvdXJjZX1gKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgZnVsbHkgcmVzb2x2ZWQgdGFnLCByZXR1cm5zIGl0cyBwcmludGFibGUgc3RyaW5nIGZvcm0sXG4gICAgICogdGFraW5nIGludG8gYWNjb3VudCBjdXJyZW50IHRhZyBwcmVmaXhlcyBhbmQgZGVmYXVsdHMuXG4gICAgICovXG4gICAgdGFnU3RyaW5nKHRhZykge1xuICAgICAgICBmb3IgKGNvbnN0IFtoYW5kbGUsIHByZWZpeF0gb2YgT2JqZWN0LmVudHJpZXModGhpcy50YWdzKSkge1xuICAgICAgICAgICAgaWYgKHRhZy5zdGFydHNXaXRoKHByZWZpeCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZSArIGVzY2FwZVRhZ05hbWUodGFnLnN1YnN0cmluZyhwcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhZ1swXSA9PT0gJyEnID8gdGFnIDogYCE8JHt0YWd9PmA7XG4gICAgfVxuICAgIHRvU3RyaW5nKGRvYykge1xuICAgICAgICBjb25zdCBsaW5lcyA9IHRoaXMueWFtbC5leHBsaWNpdFxuICAgICAgICAgICAgPyBbYCVZQU1MICR7dGhpcy55YW1sLnZlcnNpb24gfHwgJzEuMid9YF1cbiAgICAgICAgICAgIDogW107XG4gICAgICAgIGNvbnN0IHRhZ0VudHJpZXMgPSBPYmplY3QuZW50cmllcyh0aGlzLnRhZ3MpO1xuICAgICAgICBsZXQgdGFnTmFtZXM7XG4gICAgICAgIGlmIChkb2MgJiYgdGFnRW50cmllcy5sZW5ndGggPiAwICYmIGlkZW50aXR5LmlzTm9kZShkb2MuY29udGVudHMpKSB7XG4gICAgICAgICAgICBjb25zdCB0YWdzID0ge307XG4gICAgICAgICAgICB2aXNpdC52aXNpdChkb2MuY29udGVudHMsIChfa2V5LCBub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGlkZW50aXR5LmlzTm9kZShub2RlKSAmJiBub2RlLnRhZylcbiAgICAgICAgICAgICAgICAgICAgdGFnc1tub2RlLnRhZ10gPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0YWdOYW1lcyA9IE9iamVjdC5rZXlzKHRhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRhZ05hbWVzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgW2hhbmRsZSwgcHJlZml4XSBvZiB0YWdFbnRyaWVzKSB7XG4gICAgICAgICAgICBpZiAoaGFuZGxlID09PSAnISEnICYmIHByZWZpeCA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOicpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoIWRvYyB8fCB0YWdOYW1lcy5zb21lKHRuID0+IHRuLnN0YXJ0c1dpdGgocHJlZml4KSkpXG4gICAgICAgICAgICAgICAgbGluZXMucHVzaChgJVRBRyAke2hhbmRsZX0gJHtwcmVmaXh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xuICAgIH1cbn1cbkRpcmVjdGl2ZXMuZGVmYXVsdFlhbWwgPSB7IGV4cGxpY2l0OiBmYWxzZSwgdmVyc2lvbjogJzEuMicgfTtcbkRpcmVjdGl2ZXMuZGVmYXVsdFRhZ3MgPSB7ICchISc6ICd0YWc6eWFtbC5vcmcsMjAwMjonIH07XG5cbmV4cG9ydHMuRGlyZWN0aXZlcyA9IERpcmVjdGl2ZXM7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi4vbm9kZXMvaWRlbnRpdHkuanMnKTtcbnZhciB2aXNpdCA9IHJlcXVpcmUoJy4uL3Zpc2l0LmpzJyk7XG5cbi8qKlxuICogVmVyaWZ5IHRoYXQgdGhlIGlucHV0IHN0cmluZyBpcyBhIHZhbGlkIGFuY2hvci5cbiAqXG4gKiBXaWxsIHRocm93IG9uIGVycm9ycy5cbiAqL1xuZnVuY3Rpb24gYW5jaG9ySXNWYWxpZChhbmNob3IpIHtcbiAgICBpZiAoL1tcXHgwMC1cXHgxOVxccyxbXFxde31dLy50ZXN0KGFuY2hvcikpIHtcbiAgICAgICAgY29uc3Qgc2EgPSBKU09OLnN0cmluZ2lmeShhbmNob3IpO1xuICAgICAgICBjb25zdCBtc2cgPSBgQW5jaG9yIG11c3Qgbm90IGNvbnRhaW4gd2hpdGVzcGFjZSBvciBjb250cm9sIGNoYXJhY3RlcnM6ICR7c2F9YDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYW5jaG9yTmFtZXMocm9vdCkge1xuICAgIGNvbnN0IGFuY2hvcnMgPSBuZXcgU2V0KCk7XG4gICAgdmlzaXQudmlzaXQocm9vdCwge1xuICAgICAgICBWYWx1ZShfa2V5LCBub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5hbmNob3IpXG4gICAgICAgICAgICAgICAgYW5jaG9ycy5hZGQobm9kZS5hbmNob3IpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGFuY2hvcnM7XG59XG4vKiogRmluZCBhIG5ldyBhbmNob3IgbmFtZSB3aXRoIHRoZSBnaXZlbiBgcHJlZml4YCBhbmQgYSBvbmUtaW5kZXhlZCBzdWZmaXguICovXG5mdW5jdGlvbiBmaW5kTmV3QW5jaG9yKHByZWZpeCwgZXhjbHVkZSkge1xuICAgIGZvciAobGV0IGkgPSAxOyB0cnVlOyArK2kpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGAke3ByZWZpeH0ke2l9YDtcbiAgICAgICAgaWYgKCFleGNsdWRlLmhhcyhuYW1lKSlcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVBbmNob3JzKGRvYywgcHJlZml4KSB7XG4gICAgY29uc3QgYWxpYXNPYmplY3RzID0gW107XG4gICAgY29uc3Qgc291cmNlT2JqZWN0cyA9IG5ldyBNYXAoKTtcbiAgICBsZXQgcHJldkFuY2hvcnMgPSBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICAgIG9uQW5jaG9yOiAoc291cmNlKSA9PiB7XG4gICAgICAgICAgICBhbGlhc09iamVjdHMucHVzaChzb3VyY2UpO1xuICAgICAgICAgICAgcHJldkFuY2hvcnMgPz8gKHByZXZBbmNob3JzID0gYW5jaG9yTmFtZXMoZG9jKSk7XG4gICAgICAgICAgICBjb25zdCBhbmNob3IgPSBmaW5kTmV3QW5jaG9yKHByZWZpeCwgcHJldkFuY2hvcnMpO1xuICAgICAgICAgICAgcHJldkFuY2hvcnMuYWRkKGFuY2hvcik7XG4gICAgICAgICAgICByZXR1cm4gYW5jaG9yO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogV2l0aCBjaXJjdWxhciByZWZlcmVuY2VzLCB0aGUgc291cmNlIG5vZGUgaXMgb25seSByZXNvbHZlZCBhZnRlciBhbGxcbiAgICAgICAgICogb2YgaXRzIGNoaWxkIG5vZGVzIGFyZS4gVGhpcyBpcyB3aHkgYW5jaG9ycyBhcmUgc2V0IG9ubHkgYWZ0ZXIgYWxsIG9mXG4gICAgICAgICAqIHRoZSBub2RlcyBoYXZlIGJlZW4gY3JlYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHNldEFuY2hvcnM6ICgpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc291cmNlIG9mIGFsaWFzT2JqZWN0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZiA9IHNvdXJjZU9iamVjdHMuZ2V0KHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZWYgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgIHJlZi5hbmNob3IgJiZcbiAgICAgICAgICAgICAgICAgICAgKGlkZW50aXR5LmlzU2NhbGFyKHJlZi5ub2RlKSB8fCBpZGVudGl0eS5pc0NvbGxlY3Rpb24ocmVmLm5vZGUpKSkge1xuICAgICAgICAgICAgICAgICAgICByZWYubm9kZS5hbmNob3IgPSByZWYuYW5jaG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0ZhaWxlZCB0byByZXNvbHZlIHJlcGVhdGVkIG9iamVjdCAodGhpcyBzaG91bGQgbm90IGhhcHBlbiknKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3Iuc291cmNlID0gc291cmNlO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNvdXJjZU9iamVjdHNcbiAgICB9O1xufVxuXG5leHBvcnRzLmFuY2hvcklzVmFsaWQgPSBhbmNob3JJc1ZhbGlkO1xuZXhwb3J0cy5hbmNob3JOYW1lcyA9IGFuY2hvck5hbWVzO1xuZXhwb3J0cy5jcmVhdGVOb2RlQW5jaG9ycyA9IGNyZWF0ZU5vZGVBbmNob3JzO1xuZXhwb3J0cy5maW5kTmV3QW5jaG9yID0gZmluZE5ld0FuY2hvcjtcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEFwcGxpZXMgdGhlIEpTT04ucGFyc2UgcmV2aXZlciBhbGdvcml0aG0gYXMgZGVmaW5lZCBpbiB0aGUgRUNNQS0yNjIgc3BlYyxcbiAqIGluIHNlY3Rpb24gMjQuNS4xLjEgXCJSdW50aW1lIFNlbWFudGljczogSW50ZXJuYWxpemVKU09OUHJvcGVydHlcIiBvZiB0aGVcbiAqIDIwMjEgZWRpdGlvbjogaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1qc29uLnBhcnNlXG4gKlxuICogSW5jbHVkZXMgZXh0ZW5zaW9ucyBmb3IgaGFuZGxpbmcgTWFwIGFuZCBTZXQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gYXBwbHlSZXZpdmVyKHJldml2ZXIsIG9iaiwga2V5LCB2YWwpIHtcbiAgICBpZiAodmFsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2MCA9IHZhbFtpXTtcbiAgICAgICAgICAgICAgICBjb25zdCB2MSA9IGFwcGx5UmV2aXZlcihyZXZpdmVyLCB2YWwsIFN0cmluZyhpKSwgdjApO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tYXJyYXktZGVsZXRlXG4gICAgICAgICAgICAgICAgaWYgKHYxID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWxbaV07XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodjEgIT09IHYwKVxuICAgICAgICAgICAgICAgICAgICB2YWxbaV0gPSB2MTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgayBvZiBBcnJheS5mcm9tKHZhbC5rZXlzKCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdjAgPSB2YWwuZ2V0KGspO1xuICAgICAgICAgICAgICAgIGNvbnN0IHYxID0gYXBwbHlSZXZpdmVyKHJldml2ZXIsIHZhbCwgaywgdjApO1xuICAgICAgICAgICAgICAgIGlmICh2MSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICB2YWwuZGVsZXRlKGspO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHYxICE9PSB2MClcbiAgICAgICAgICAgICAgICAgICAgdmFsLnNldChrLCB2MSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHYwIG9mIEFycmF5LmZyb20odmFsKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYxID0gYXBwbHlSZXZpdmVyKHJldml2ZXIsIHZhbCwgdjAsIHYwKTtcbiAgICAgICAgICAgICAgICBpZiAodjEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgdmFsLmRlbGV0ZSh2MCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodjEgIT09IHYwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbC5kZWxldGUodjApO1xuICAgICAgICAgICAgICAgICAgICB2YWwuYWRkKHYxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2MF0gb2YgT2JqZWN0LmVudHJpZXModmFsKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYxID0gYXBwbHlSZXZpdmVyKHJldml2ZXIsIHZhbCwgaywgdjApO1xuICAgICAgICAgICAgICAgIGlmICh2MSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsW2tdO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHYxICE9PSB2MClcbiAgICAgICAgICAgICAgICAgICAgdmFsW2tdID0gdjE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldml2ZXIuY2FsbChvYmosIGtleSwgdmFsKTtcbn1cblxuZXhwb3J0cy5hcHBseVJldml2ZXIgPSBhcHBseVJldml2ZXI7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eS5qcycpO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgYW55IG5vZGUgb3IgaXRzIGNvbnRlbnRzIHRvIG5hdGl2ZSBKYXZhU2NyaXB0XG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGlucHV0IHZhbHVlXG4gKiBAcGFyYW0gYXJnIC0gSWYgYHZhbHVlYCBkZWZpbmVzIGEgYHRvSlNPTigpYCBtZXRob2QsIHVzZSB0aGlzXG4gKiAgIGFzIGl0cyBmaXJzdCBhcmd1bWVudFxuICogQHBhcmFtIGN0eCAtIENvbnZlcnNpb24gY29udGV4dCwgb3JpZ2luYWxseSBzZXQgaW4gRG9jdW1lbnQjdG9KUygpLiBJZlxuICogICBgeyBrZWVwOiB0cnVlIH1gIGlzIG5vdCBzZXQsIG91dHB1dCBzaG91bGQgYmUgc3VpdGFibGUgZm9yIEpTT05cbiAqICAgc3RyaW5naWZpY2F0aW9uLlxuICovXG5mdW5jdGlvbiB0b0pTKHZhbHVlLCBhcmcsIGN0eCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodiwgaSkgPT4gdG9KUyh2LCBTdHJpbmcoaSksIGN0eCkpO1xuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWNhbGxcbiAgICAgICAgaWYgKCFjdHggfHwgIWlkZW50aXR5Lmhhc0FuY2hvcih2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9KU09OKGFyZywgY3R4KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHsgYWxpYXNDb3VudDogMCwgY291bnQ6IDEsIHJlczogdW5kZWZpbmVkIH07XG4gICAgICAgIGN0eC5hbmNob3JzLnNldCh2YWx1ZSwgZGF0YSk7XG4gICAgICAgIGN0eC5vbkNyZWF0ZSA9IHJlcyA9PiB7XG4gICAgICAgICAgICBkYXRhLnJlcyA9IHJlcztcbiAgICAgICAgICAgIGRlbGV0ZSBjdHgub25DcmVhdGU7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlcyA9IHZhbHVlLnRvSlNPTihhcmcsIGN0eCk7XG4gICAgICAgIGlmIChjdHgub25DcmVhdGUpXG4gICAgICAgICAgICBjdHgub25DcmVhdGUocmVzKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcgJiYgIWN0eD8ua2VlcClcbiAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnRzLnRvSlMgPSB0b0pTO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBhcHBseVJldml2ZXIgPSByZXF1aXJlKCcuLi9kb2MvYXBwbHlSZXZpdmVyLmpzJyk7XG52YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5LmpzJyk7XG52YXIgdG9KUyA9IHJlcXVpcmUoJy4vdG9KUy5qcycpO1xuXG5jbGFzcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IodHlwZSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgaWRlbnRpdHkuTk9ERV9UWVBFLCB7IHZhbHVlOiB0eXBlIH0pO1xuICAgIH1cbiAgICAvKiogQ3JlYXRlIGEgY29weSBvZiB0aGlzIG5vZGUuICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHRoaXMpKTtcbiAgICAgICAgaWYgKHRoaXMucmFuZ2UpXG4gICAgICAgICAgICBjb3B5LnJhbmdlID0gdGhpcy5yYW5nZS5zbGljZSgpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLyoqIEEgcGxhaW4gSmF2YVNjcmlwdCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG5vZGUuICovXG4gICAgdG9KUyhkb2MsIHsgbWFwQXNNYXAsIG1heEFsaWFzQ291bnQsIG9uQW5jaG9yLCByZXZpdmVyIH0gPSB7fSkge1xuICAgICAgICBpZiAoIWlkZW50aXR5LmlzRG9jdW1lbnQoZG9jKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgZG9jdW1lbnQgYXJndW1lbnQgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgY29uc3QgY3R4ID0ge1xuICAgICAgICAgICAgYW5jaG9yczogbmV3IE1hcCgpLFxuICAgICAgICAgICAgZG9jLFxuICAgICAgICAgICAga2VlcDogdHJ1ZSxcbiAgICAgICAgICAgIG1hcEFzTWFwOiBtYXBBc01hcCA9PT0gdHJ1ZSxcbiAgICAgICAgICAgIG1hcEtleVdhcm5lZDogZmFsc2UsXG4gICAgICAgICAgICBtYXhBbGlhc0NvdW50OiB0eXBlb2YgbWF4QWxpYXNDb3VudCA9PT0gJ251bWJlcicgPyBtYXhBbGlhc0NvdW50IDogMTAwXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlcyA9IHRvSlMudG9KUyh0aGlzLCAnJywgY3R4KTtcbiAgICAgICAgaWYgKHR5cGVvZiBvbkFuY2hvciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBjb3VudCwgcmVzIH0gb2YgY3R4LmFuY2hvcnMudmFsdWVzKCkpXG4gICAgICAgICAgICAgICAgb25BbmNob3IocmVzLCBjb3VudCk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcmV2aXZlciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBhcHBseVJldml2ZXIuYXBwbHlSZXZpdmVyKHJldml2ZXIsIHsgJyc6IHJlcyB9LCAnJywgcmVzKVxuICAgICAgICAgICAgOiByZXM7XG4gICAgfVxufVxuXG5leHBvcnRzLk5vZGVCYXNlID0gTm9kZUJhc2U7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIGFuY2hvcnMgPSByZXF1aXJlKCcuLi9kb2MvYW5jaG9ycy5qcycpO1xudmFyIHZpc2l0ID0gcmVxdWlyZSgnLi4vdmlzaXQuanMnKTtcbnZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHkuanMnKTtcbnZhciBOb2RlID0gcmVxdWlyZSgnLi9Ob2RlLmpzJyk7XG52YXIgdG9KUyA9IHJlcXVpcmUoJy4vdG9KUy5qcycpO1xuXG5jbGFzcyBBbGlhcyBleHRlbmRzIE5vZGUuTm9kZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgICAgICBzdXBlcihpZGVudGl0eS5BTElBUyk7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3RhZycsIHtcbiAgICAgICAgICAgIHNldCgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsaWFzIG5vZGVzIGNhbm5vdCBoYXZlIHRhZ3MnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc29sdmUgdGhlIHZhbHVlIG9mIHRoaXMgYWxpYXMgd2l0aGluIGBkb2NgLCBmaW5kaW5nIHRoZSBsYXN0XG4gICAgICogaW5zdGFuY2Ugb2YgdGhlIGBzb3VyY2VgIGFuY2hvciBiZWZvcmUgdGhpcyBub2RlLlxuICAgICAqL1xuICAgIHJlc29sdmUoZG9jLCBjdHgpIHtcbiAgICAgICAgbGV0IG5vZGVzO1xuICAgICAgICBpZiAoY3R4Py5hbGlhc1Jlc29sdmVDYWNoZSkge1xuICAgICAgICAgICAgbm9kZXMgPSBjdHguYWxpYXNSZXNvbHZlQ2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub2RlcyA9IFtdO1xuICAgICAgICAgICAgdmlzaXQudmlzaXQoZG9jLCB7XG4gICAgICAgICAgICAgICAgTm9kZTogKF9rZXksIG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkZW50aXR5LmlzQWxpYXMobm9kZSkgfHwgaWRlbnRpdHkuaGFzQW5jaG9yKG5vZGUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjdHgpXG4gICAgICAgICAgICAgICAgY3R4LmFsaWFzUmVzb2x2ZUNhY2hlID0gbm9kZXM7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGZvdW5kID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChub2RlID09PSB0aGlzKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgaWYgKG5vZGUuYW5jaG9yID09PSB0aGlzLnNvdXJjZSlcbiAgICAgICAgICAgICAgICBmb3VuZCA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICB0b0pTT04oX2FyZywgY3R4KSB7XG4gICAgICAgIGlmICghY3R4KVxuICAgICAgICAgICAgcmV0dXJuIHsgc291cmNlOiB0aGlzLnNvdXJjZSB9O1xuICAgICAgICBjb25zdCB7IGFuY2hvcnMsIGRvYywgbWF4QWxpYXNDb3VudCB9ID0gY3R4O1xuICAgICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnJlc29sdmUoZG9jLCBjdHgpO1xuICAgICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gYFVucmVzb2x2ZWQgYWxpYXMgKHRoZSBhbmNob3IgbXVzdCBiZSBzZXQgYmVmb3JlIHRoZSBhbGlhcyk6ICR7dGhpcy5zb3VyY2V9YDtcbiAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhID0gYW5jaG9ycy5nZXQoc291cmNlKTtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAvLyBSZXNvbHZlIGFuY2hvcnMgZm9yIE5vZGUucHJvdG90eXBlLnRvSlMoKVxuICAgICAgICAgICAgdG9KUy50b0pTKHNvdXJjZSwgbnVsbCwgY3R4KTtcbiAgICAgICAgICAgIGRhdGEgPSBhbmNob3JzLmdldChzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoZGF0YT8ucmVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9ICdUaGlzIHNob3VsZCBub3QgaGFwcGVuOiBBbGlhcyBhbmNob3Igd2FzIG5vdCByZXNvbHZlZD8nO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heEFsaWFzQ291bnQgPj0gMCkge1xuICAgICAgICAgICAgZGF0YS5jb3VudCArPSAxO1xuICAgICAgICAgICAgaWYgKGRhdGEuYWxpYXNDb3VudCA9PT0gMClcbiAgICAgICAgICAgICAgICBkYXRhLmFsaWFzQ291bnQgPSBnZXRBbGlhc0NvdW50KGRvYywgc291cmNlLCBhbmNob3JzKTtcbiAgICAgICAgICAgIGlmIChkYXRhLmNvdW50ICogZGF0YS5hbGlhc0NvdW50ID4gbWF4QWxpYXNDb3VudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9ICdFeGNlc3NpdmUgYWxpYXMgY291bnQgaW5kaWNhdGVzIGEgcmVzb3VyY2UgZXhoYXVzdGlvbiBhdHRhY2snO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhLnJlcztcbiAgICB9XG4gICAgdG9TdHJpbmcoY3R4LCBfb25Db21tZW50LCBfb25DaG9tcEtlZXApIHtcbiAgICAgICAgY29uc3Qgc3JjID0gYCoke3RoaXMuc291cmNlfWA7XG4gICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIGFuY2hvcnMuYW5jaG9ySXNWYWxpZCh0aGlzLnNvdXJjZSk7XG4gICAgICAgICAgICBpZiAoY3R4Lm9wdGlvbnMudmVyaWZ5QWxpYXNPcmRlciAmJiAhY3R4LmFuY2hvcnMuaGFzKHRoaXMuc291cmNlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBVbnJlc29sdmVkIGFsaWFzICh0aGUgYW5jaG9yIG11c3QgYmUgc2V0IGJlZm9yZSB0aGUgYWxpYXMpOiAke3RoaXMuc291cmNlfWA7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3R4LmltcGxpY2l0S2V5KVxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtzcmN9IGA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNyYztcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRBbGlhc0NvdW50KGRvYywgbm9kZSwgYW5jaG9ycykge1xuICAgIGlmIChpZGVudGl0eS5pc0FsaWFzKG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IG5vZGUucmVzb2x2ZShkb2MpO1xuICAgICAgICBjb25zdCBhbmNob3IgPSBhbmNob3JzICYmIHNvdXJjZSAmJiBhbmNob3JzLmdldChzb3VyY2UpO1xuICAgICAgICByZXR1cm4gYW5jaG9yID8gYW5jaG9yLmNvdW50ICogYW5jaG9yLmFsaWFzQ291bnQgOiAwO1xuICAgIH1cbiAgICBlbHNlIGlmIChpZGVudGl0eS5pc0NvbGxlY3Rpb24obm9kZSkpIHtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIG5vZGUuaXRlbXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBnZXRBbGlhc0NvdW50KGRvYywgaXRlbSwgYW5jaG9ycyk7XG4gICAgICAgICAgICBpZiAoYyA+IGNvdW50KVxuICAgICAgICAgICAgICAgIGNvdW50ID0gYztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlkZW50aXR5LmlzUGFpcihub2RlKSkge1xuICAgICAgICBjb25zdCBrYyA9IGdldEFsaWFzQ291bnQoZG9jLCBub2RlLmtleSwgYW5jaG9ycyk7XG4gICAgICAgIGNvbnN0IHZjID0gZ2V0QWxpYXNDb3VudChkb2MsIG5vZGUudmFsdWUsIGFuY2hvcnMpO1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoa2MsIHZjKTtcbiAgICB9XG4gICAgcmV0dXJuIDE7XG59XG5cbmV4cG9ydHMuQWxpYXMgPSBBbGlhcztcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5LmpzJyk7XG52YXIgTm9kZSA9IHJlcXVpcmUoJy4vTm9kZS5qcycpO1xudmFyIHRvSlMgPSByZXF1aXJlKCcuL3RvSlMuanMnKTtcblxuY29uc3QgaXNTY2FsYXJWYWx1ZSA9ICh2YWx1ZSkgPT4gIXZhbHVlIHx8ICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jyk7XG5jbGFzcyBTY2FsYXIgZXh0ZW5kcyBOb2RlLk5vZGVCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcihpZGVudGl0eS5TQ0FMQVIpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHRvSlNPTihhcmcsIGN0eCkge1xuICAgICAgICByZXR1cm4gY3R4Py5rZWVwID8gdGhpcy52YWx1ZSA6IHRvSlMudG9KUyh0aGlzLnZhbHVlLCBhcmcsIGN0eCk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHRoaXMudmFsdWUpO1xuICAgIH1cbn1cblNjYWxhci5CTE9DS19GT0xERUQgPSAnQkxPQ0tfRk9MREVEJztcblNjYWxhci5CTE9DS19MSVRFUkFMID0gJ0JMT0NLX0xJVEVSQUwnO1xuU2NhbGFyLlBMQUlOID0gJ1BMQUlOJztcblNjYWxhci5RVU9URV9ET1VCTEUgPSAnUVVPVEVfRE9VQkxFJztcblNjYWxhci5RVU9URV9TSU5HTEUgPSAnUVVPVEVfU0lOR0xFJztcblxuZXhwb3J0cy5TY2FsYXIgPSBTY2FsYXI7XG5leHBvcnRzLmlzU2NhbGFyVmFsdWUgPSBpc1NjYWxhclZhbHVlO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBBbGlhcyA9IHJlcXVpcmUoJy4uL25vZGVzL0FsaWFzLmpzJyk7XG52YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuLi9ub2Rlcy9pZGVudGl0eS5qcycpO1xudmFyIFNjYWxhciA9IHJlcXVpcmUoJy4uL25vZGVzL1NjYWxhci5qcycpO1xuXG5jb25zdCBkZWZhdWx0VGFnUHJlZml4ID0gJ3RhZzp5YW1sLm9yZywyMDAyOic7XG5mdW5jdGlvbiBmaW5kVGFnT2JqZWN0KHZhbHVlLCB0YWdOYW1lLCB0YWdzKSB7XG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0YWdzLmZpbHRlcih0ID0+IHQudGFnID09PSB0YWdOYW1lKTtcbiAgICAgICAgY29uc3QgdGFnT2JqID0gbWF0Y2guZmluZCh0ID0+ICF0LmZvcm1hdCkgPz8gbWF0Y2hbMF07XG4gICAgICAgIGlmICghdGFnT2JqKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUYWcgJHt0YWdOYW1lfSBub3QgZm91bmRgKTtcbiAgICAgICAgcmV0dXJuIHRhZ09iajtcbiAgICB9XG4gICAgcmV0dXJuIHRhZ3MuZmluZCh0ID0+IHQuaWRlbnRpZnk/Lih2YWx1ZSkgJiYgIXQuZm9ybWF0KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU5vZGUodmFsdWUsIHRhZ05hbWUsIGN0eCkge1xuICAgIGlmIChpZGVudGl0eS5pc0RvY3VtZW50KHZhbHVlKSlcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5jb250ZW50cztcbiAgICBpZiAoaWRlbnRpdHkuaXNOb2RlKHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGlmIChpZGVudGl0eS5pc1BhaXIodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IG1hcCA9IGN0eC5zY2hlbWFbaWRlbnRpdHkuTUFQXS5jcmVhdGVOb2RlPy4oY3R4LnNjaGVtYSwgbnVsbCwgY3R4KTtcbiAgICAgICAgbWFwLml0ZW1zLnB1c2godmFsdWUpO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcgfHxcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIgfHxcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBCb29sZWFuIHx8XG4gICAgICAgICh0eXBlb2YgQmlnSW50ICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEJpZ0ludCkgLy8gbm90IHN1cHBvcnRlZCBldmVyeXdoZXJlXG4gICAgKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2VyaWFsaXplanNvbnByb3BlcnR5XG4gICAgICAgIHZhbHVlID0gdmFsdWUudmFsdWVPZigpO1xuICAgIH1cbiAgICBjb25zdCB7IGFsaWFzRHVwbGljYXRlT2JqZWN0cywgb25BbmNob3IsIG9uVGFnT2JqLCBzY2hlbWEsIHNvdXJjZU9iamVjdHMgfSA9IGN0eDtcbiAgICAvLyBEZXRlY3QgZHVwbGljYXRlIHJlZmVyZW5jZXMgdG8gdGhlIHNhbWUgb2JqZWN0ICYgdXNlIEFsaWFzIG5vZGVzIGZvciBhbGxcbiAgICAvLyBhZnRlciBmaXJzdC4gVGhlIGByZWZgIHdyYXBwZXIgYWxsb3dzIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIHRvIHJlc29sdmUuXG4gICAgbGV0IHJlZiA9IHVuZGVmaW5lZDtcbiAgICBpZiAoYWxpYXNEdXBsaWNhdGVPYmplY3RzICYmIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmVmID0gc291cmNlT2JqZWN0cy5nZXQodmFsdWUpO1xuICAgICAgICBpZiAocmVmKSB7XG4gICAgICAgICAgICByZWYuYW5jaG9yID8/IChyZWYuYW5jaG9yID0gb25BbmNob3IodmFsdWUpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWxpYXMuQWxpYXMocmVmLmFuY2hvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWYgPSB7IGFuY2hvcjogbnVsbCwgbm9kZTogbnVsbCB9O1xuICAgICAgICAgICAgc291cmNlT2JqZWN0cy5zZXQodmFsdWUsIHJlZik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhZ05hbWU/LnN0YXJ0c1dpdGgoJyEhJykpXG4gICAgICAgIHRhZ05hbWUgPSBkZWZhdWx0VGFnUHJlZml4ICsgdGFnTmFtZS5zbGljZSgyKTtcbiAgICBsZXQgdGFnT2JqID0gZmluZFRhZ09iamVjdCh2YWx1ZSwgdGFnTmFtZSwgc2NoZW1hLnRhZ3MpO1xuICAgIGlmICghdGFnT2JqKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBTY2FsYXIuU2NhbGFyKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChyZWYpXG4gICAgICAgICAgICAgICAgcmVmLm5vZGUgPSBub2RlO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgdGFnT2JqID1cbiAgICAgICAgICAgIHZhbHVlIGluc3RhbmNlb2YgTWFwXG4gICAgICAgICAgICAgICAgPyBzY2hlbWFbaWRlbnRpdHkuTUFQXVxuICAgICAgICAgICAgICAgIDogU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdCh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgPyBzY2hlbWFbaWRlbnRpdHkuU0VRXVxuICAgICAgICAgICAgICAgICAgICA6IHNjaGVtYVtpZGVudGl0eS5NQVBdO1xuICAgIH1cbiAgICBpZiAob25UYWdPYmopIHtcbiAgICAgICAgb25UYWdPYmoodGFnT2JqKTtcbiAgICAgICAgZGVsZXRlIGN0eC5vblRhZ09iajtcbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IHRhZ09iaj8uY3JlYXRlTm9kZVxuICAgICAgICA/IHRhZ09iai5jcmVhdGVOb2RlKGN0eC5zY2hlbWEsIHZhbHVlLCBjdHgpXG4gICAgICAgIDogdHlwZW9mIHRhZ09iaj8ubm9kZUNsYXNzPy5mcm9tID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IHRhZ09iai5ub2RlQ2xhc3MuZnJvbShjdHguc2NoZW1hLCB2YWx1ZSwgY3R4KVxuICAgICAgICAgICAgOiBuZXcgU2NhbGFyLlNjYWxhcih2YWx1ZSk7XG4gICAgaWYgKHRhZ05hbWUpXG4gICAgICAgIG5vZGUudGFnID0gdGFnTmFtZTtcbiAgICBlbHNlIGlmICghdGFnT2JqLmRlZmF1bHQpXG4gICAgICAgIG5vZGUudGFnID0gdGFnT2JqLnRhZztcbiAgICBpZiAocmVmKVxuICAgICAgICByZWYubm9kZSA9IG5vZGU7XG4gICAgcmV0dXJuIG5vZGU7XG59XG5cbmV4cG9ydHMuY3JlYXRlTm9kZSA9IGNyZWF0ZU5vZGU7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIGNyZWF0ZU5vZGUgPSByZXF1aXJlKCcuLi9kb2MvY3JlYXRlTm9kZS5qcycpO1xudmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eS5qcycpO1xudmFyIE5vZGUgPSByZXF1aXJlKCcuL05vZGUuanMnKTtcblxuZnVuY3Rpb24gY29sbGVjdGlvbkZyb21QYXRoKHNjaGVtYSwgcGF0aCwgdmFsdWUpIHtcbiAgICBsZXQgdiA9IHZhbHVlO1xuICAgIGZvciAobGV0IGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGNvbnN0IGsgPSBwYXRoW2ldO1xuICAgICAgICBpZiAodHlwZW9mIGsgPT09ICdudW1iZXInICYmIE51bWJlci5pc0ludGVnZXIoaykgJiYgayA+PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBhID0gW107XG4gICAgICAgICAgICBhW2tdID0gdjtcbiAgICAgICAgICAgIHYgPSBhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdiA9IG5ldyBNYXAoW1trLCB2XV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVOb2RlLmNyZWF0ZU5vZGUodiwgdW5kZWZpbmVkLCB7XG4gICAgICAgIGFsaWFzRHVwbGljYXRlT2JqZWN0czogZmFsc2UsXG4gICAgICAgIGtlZXBVbmRlZmluZWQ6IGZhbHNlLFxuICAgICAgICBvbkFuY2hvcjogKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIHNob3VsZCBub3QgaGFwcGVuLCBwbGVhc2UgcmVwb3J0IGEgYnVnLicpO1xuICAgICAgICB9LFxuICAgICAgICBzY2hlbWEsXG4gICAgICAgIHNvdXJjZU9iamVjdHM6IG5ldyBNYXAoKVxuICAgIH0pO1xufVxuLy8gVHlwZSBndWFyZCBpcyBpbnRlbnRpb25hbGx5IGEgbGl0dGxlIHdyb25nIHNvIGFzIHRvIGJlIG1vcmUgdXNlZnVsLFxuLy8gYXMgaXQgZG9lcyBub3QgY292ZXIgdW50eXBhYmxlIGVtcHR5IG5vbi1zdHJpbmcgaXRlcmFibGVzIChlLmcuIFtdKS5cbmNvbnN0IGlzRW1wdHlQYXRoID0gKHBhdGgpID0+IHBhdGggPT0gbnVsbCB8fFxuICAgICh0eXBlb2YgcGF0aCA9PT0gJ29iamVjdCcgJiYgISFwYXRoW1N5bWJvbC5pdGVyYXRvcl0oKS5uZXh0KCkuZG9uZSk7XG5jbGFzcyBDb2xsZWN0aW9uIGV4dGVuZHMgTm9kZS5Ob2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgc2NoZW1hKSB7XG4gICAgICAgIHN1cGVyKHR5cGUpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3NjaGVtYScsIHtcbiAgICAgICAgICAgIHZhbHVlOiBzY2hlbWEsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzY2hlbWEgLSBJZiBkZWZpbmVkLCBvdmVyd3JpdGVzIHRoZSBvcmlnaW5hbCdzIHNjaGVtYVxuICAgICAqL1xuICAgIGNsb25lKHNjaGVtYSkge1xuICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHRoaXMpKTtcbiAgICAgICAgaWYgKHNjaGVtYSlcbiAgICAgICAgICAgIGNvcHkuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgICBjb3B5Lml0ZW1zID0gY29weS5pdGVtcy5tYXAoaXQgPT4gaWRlbnRpdHkuaXNOb2RlKGl0KSB8fCBpZGVudGl0eS5pc1BhaXIoaXQpID8gaXQuY2xvbmUoc2NoZW1hKSA6IGl0KTtcbiAgICAgICAgaWYgKHRoaXMucmFuZ2UpXG4gICAgICAgICAgICBjb3B5LnJhbmdlID0gdGhpcy5yYW5nZS5zbGljZSgpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHZhbHVlIHRvIHRoZSBjb2xsZWN0aW9uLiBGb3IgYCEhbWFwYCBhbmQgYCEhb21hcGAgdGhlIHZhbHVlIG11c3RcbiAgICAgKiBiZSBhIFBhaXIgaW5zdGFuY2Ugb3IgYSBgeyBrZXksIHZhbHVlIH1gIG9iamVjdCwgd2hpY2ggbWF5IG5vdCBoYXZlIGEga2V5XG4gICAgICogdGhhdCBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgbWFwLlxuICAgICAqL1xuICAgIGFkZEluKHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0VtcHR5UGF0aChwYXRoKSlcbiAgICAgICAgICAgIHRoaXMuYWRkKHZhbHVlKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBba2V5LCAuLi5yZXN0XSA9IHBhdGg7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5nZXQoa2V5LCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChpZGVudGl0eS5pc0NvbGxlY3Rpb24obm9kZSkpXG4gICAgICAgICAgICAgICAgbm9kZS5hZGRJbihyZXN0LCB2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlID09PSB1bmRlZmluZWQgJiYgdGhpcy5zY2hlbWEpXG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCBjb2xsZWN0aW9uRnJvbVBhdGgodGhpcy5zY2hlbWEsIHJlc3QsIHZhbHVlKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBZQU1MIGNvbGxlY3Rpb24gYXQgJHtrZXl9LiBSZW1haW5pbmcgcGF0aDogJHtyZXN0fWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSB2YWx1ZSBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgaXRlbSB3YXMgZm91bmQgYW5kIHJlbW92ZWQuXG4gICAgICovXG4gICAgZGVsZXRlSW4ocGF0aCkge1xuICAgICAgICBjb25zdCBba2V5LCAuLi5yZXN0XSA9IHBhdGg7XG4gICAgICAgIGlmIChyZXN0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGV0ZShrZXkpO1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5nZXQoa2V5LCB0cnVlKTtcbiAgICAgICAgaWYgKGlkZW50aXR5LmlzQ29sbGVjdGlvbihub2RlKSlcbiAgICAgICAgICAgIHJldHVybiBub2RlLmRlbGV0ZUluKHJlc3QpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFlBTUwgY29sbGVjdGlvbiBhdCAke2tleX0uIFJlbWFpbmluZyBwYXRoOiAke3Jlc3R9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaXRlbSBhdCBga2V5YCwgb3IgYHVuZGVmaW5lZGAgaWYgbm90IGZvdW5kLiBCeSBkZWZhdWx0IHVud3JhcHNcbiAgICAgKiBzY2FsYXIgdmFsdWVzIGZyb20gdGhlaXIgc3Vycm91bmRpbmcgbm9kZTsgdG8gZGlzYWJsZSBzZXQgYGtlZXBTY2FsYXJgIHRvXG4gICAgICogYHRydWVgIChjb2xsZWN0aW9ucyBhcmUgYWx3YXlzIHJldHVybmVkIGludGFjdCkuXG4gICAgICovXG4gICAgZ2V0SW4ocGF0aCwga2VlcFNjYWxhcikge1xuICAgICAgICBjb25zdCBba2V5LCAuLi5yZXN0XSA9IHBhdGg7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldChrZXksIHRydWUpO1xuICAgICAgICBpZiAocmVzdC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gIWtlZXBTY2FsYXIgJiYgaWRlbnRpdHkuaXNTY2FsYXIobm9kZSkgPyBub2RlLnZhbHVlIDogbm9kZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGlkZW50aXR5LmlzQ29sbGVjdGlvbihub2RlKSA/IG5vZGUuZ2V0SW4ocmVzdCwga2VlcFNjYWxhcikgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGhhc0FsbE51bGxWYWx1ZXMoYWxsb3dTY2FsYXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuZXZlcnkobm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlkZW50aXR5LmlzUGFpcihub2RlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBuID0gbm9kZS52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiAobiA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgKGFsbG93U2NhbGFyICYmXG4gICAgICAgICAgICAgICAgICAgIGlkZW50aXR5LmlzU2NhbGFyKG4pICYmXG4gICAgICAgICAgICAgICAgICAgIG4udmFsdWUgPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAhbi5jb21tZW50QmVmb3JlICYmXG4gICAgICAgICAgICAgICAgICAgICFuLmNvbW1lbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgIW4udGFnKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGNvbGxlY3Rpb24gaW5jbHVkZXMgYSB2YWx1ZSB3aXRoIHRoZSBrZXkgYGtleWAuXG4gICAgICovXG4gICAgaGFzSW4ocGF0aCkge1xuICAgICAgICBjb25zdCBba2V5LCAuLi5yZXN0XSA9IHBhdGg7XG4gICAgICAgIGlmIChyZXN0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhcyhrZXkpO1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5nZXQoa2V5LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5LmlzQ29sbGVjdGlvbihub2RlKSA/IG5vZGUuaGFzSW4ocmVzdCkgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIHZhbHVlIGluIHRoaXMgY29sbGVjdGlvbi4gRm9yIGAhIXNldGAsIGB2YWx1ZWAgbmVlZHMgdG8gYmUgYVxuICAgICAqIGJvb2xlYW4gdG8gYWRkL3JlbW92ZSB0aGUgaXRlbSBmcm9tIHRoZSBzZXQuXG4gICAgICovXG4gICAgc2V0SW4ocGF0aCwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgW2tleSwgLi4ucmVzdF0gPSBwYXRoO1xuICAgICAgICBpZiAocmVzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0KGtleSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoaWRlbnRpdHkuaXNDb2xsZWN0aW9uKG5vZGUpKVxuICAgICAgICAgICAgICAgIG5vZGUuc2V0SW4ocmVzdCwgdmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAobm9kZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuc2NoZW1hKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgY29sbGVjdGlvbkZyb21QYXRoKHRoaXMuc2NoZW1hLCByZXN0LCB2YWx1ZSkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgWUFNTCBjb2xsZWN0aW9uIGF0ICR7a2V5fS4gUmVtYWluaW5nIHBhdGg6ICR7cmVzdH1gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0cy5Db2xsZWN0aW9uID0gQ29sbGVjdGlvbjtcbmV4cG9ydHMuY29sbGVjdGlvbkZyb21QYXRoID0gY29sbGVjdGlvbkZyb21QYXRoO1xuZXhwb3J0cy5pc0VtcHR5UGF0aCA9IGlzRW1wdHlQYXRoO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU3RyaW5naWZpZXMgYSBjb21tZW50LlxuICpcbiAqIEVtcHR5IGNvbW1lbnQgbGluZXMgYXJlIGxlZnQgZW1wdHksXG4gKiBsaW5lcyBjb25zaXN0aW5nIG9mIGEgc2luZ2xlIHNwYWNlIGFyZSByZXBsYWNlZCBieSBgI2AsXG4gKiBhbmQgYWxsIG90aGVyIGxpbmVzIGFyZSBwcmVmaXhlZCB3aXRoIGEgYCNgLlxuICovXG5jb25zdCBzdHJpbmdpZnlDb21tZW50ID0gKHN0cikgPT4gc3RyLnJlcGxhY2UoL14oPyEkKSg/OiAkKT8vZ20sICcjJyk7XG5mdW5jdGlvbiBpbmRlbnRDb21tZW50KGNvbW1lbnQsIGluZGVudCkge1xuICAgIGlmICgvXlxcbiskLy50ZXN0KGNvbW1lbnQpKVxuICAgICAgICByZXR1cm4gY29tbWVudC5zdWJzdHJpbmcoMSk7XG4gICAgcmV0dXJuIGluZGVudCA/IGNvbW1lbnQucmVwbGFjZSgvXig/ISAqJCkvZ20sIGluZGVudCkgOiBjb21tZW50O1xufVxuY29uc3QgbGluZUNvbW1lbnQgPSAoc3RyLCBpbmRlbnQsIGNvbW1lbnQpID0+IHN0ci5lbmRzV2l0aCgnXFxuJylcbiAgICA/IGluZGVudENvbW1lbnQoY29tbWVudCwgaW5kZW50KVxuICAgIDogY29tbWVudC5pbmNsdWRlcygnXFxuJylcbiAgICAgICAgPyAnXFxuJyArIGluZGVudENvbW1lbnQoY29tbWVudCwgaW5kZW50KVxuICAgICAgICA6IChzdHIuZW5kc1dpdGgoJyAnKSA/ICcnIDogJyAnKSArIGNvbW1lbnQ7XG5cbmV4cG9ydHMuaW5kZW50Q29tbWVudCA9IGluZGVudENvbW1lbnQ7XG5leHBvcnRzLmxpbmVDb21tZW50ID0gbGluZUNvbW1lbnQ7XG5leHBvcnRzLnN0cmluZ2lmeUNvbW1lbnQgPSBzdHJpbmdpZnlDb21tZW50O1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEZPTERfRkxPVyA9ICdmbG93JztcbmNvbnN0IEZPTERfQkxPQ0sgPSAnYmxvY2snO1xuY29uc3QgRk9MRF9RVU9URUQgPSAncXVvdGVkJztcbi8qKlxuICogVHJpZXMgdG8ga2VlcCBpbnB1dCBhdCB1cCB0byBgbGluZVdpZHRoYCBjaGFyYWN0ZXJzLCBzcGxpdHRpbmcgb25seSBvbiBzcGFjZXNcbiAqIG5vdCBmb2xsb3dlZCBieSBuZXdsaW5lcyBvciBzcGFjZXMgdW5sZXNzIGBtb2RlYCBpcyBgJ3F1b3RlZCdgLiBMaW5lcyBhcmVcbiAqIHRlcm1pbmF0ZWQgd2l0aCBgXFxuYCBhbmQgc3RhcnRlZCB3aXRoIGBpbmRlbnRgLlxuICovXG5mdW5jdGlvbiBmb2xkRmxvd0xpbmVzKHRleHQsIGluZGVudCwgbW9kZSA9ICdmbG93JywgeyBpbmRlbnRBdFN0YXJ0LCBsaW5lV2lkdGggPSA4MCwgbWluQ29udGVudFdpZHRoID0gMjAsIG9uRm9sZCwgb25PdmVyZmxvdyB9ID0ge30pIHtcbiAgICBpZiAoIWxpbmVXaWR0aCB8fCBsaW5lV2lkdGggPCAwKVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICBpZiAobGluZVdpZHRoIDwgbWluQ29udGVudFdpZHRoKVxuICAgICAgICBtaW5Db250ZW50V2lkdGggPSAwO1xuICAgIGNvbnN0IGVuZFN0ZXAgPSBNYXRoLm1heCgxICsgbWluQ29udGVudFdpZHRoLCAxICsgbGluZVdpZHRoIC0gaW5kZW50Lmxlbmd0aCk7XG4gICAgaWYgKHRleHQubGVuZ3RoIDw9IGVuZFN0ZXApXG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIGNvbnN0IGZvbGRzID0gW107XG4gICAgY29uc3QgZXNjYXBlZEZvbGRzID0ge307XG4gICAgbGV0IGVuZCA9IGxpbmVXaWR0aCAtIGluZGVudC5sZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBpbmRlbnRBdFN0YXJ0ID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoaW5kZW50QXRTdGFydCA+IGxpbmVXaWR0aCAtIE1hdGgubWF4KDIsIG1pbkNvbnRlbnRXaWR0aCkpXG4gICAgICAgICAgICBmb2xkcy5wdXNoKDApO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBlbmQgPSBsaW5lV2lkdGggLSBpbmRlbnRBdFN0YXJ0O1xuICAgIH1cbiAgICBsZXQgc3BsaXQgPSB1bmRlZmluZWQ7XG4gICAgbGV0IHByZXYgPSB1bmRlZmluZWQ7XG4gICAgbGV0IG92ZXJmbG93ID0gZmFsc2U7XG4gICAgbGV0IGkgPSAtMTtcbiAgICBsZXQgZXNjU3RhcnQgPSAtMTtcbiAgICBsZXQgZXNjRW5kID0gLTE7XG4gICAgaWYgKG1vZGUgPT09IEZPTERfQkxPQ0spIHtcbiAgICAgICAgaSA9IGNvbnN1bWVNb3JlSW5kZW50ZWRMaW5lcyh0ZXh0LCBpLCBpbmRlbnQubGVuZ3RoKTtcbiAgICAgICAgaWYgKGkgIT09IC0xKVxuICAgICAgICAgICAgZW5kID0gaSArIGVuZFN0ZXA7XG4gICAgfVxuICAgIGZvciAobGV0IGNoOyAoY2ggPSB0ZXh0WyhpICs9IDEpXSk7KSB7XG4gICAgICAgIGlmIChtb2RlID09PSBGT0xEX1FVT1RFRCAmJiBjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICBlc2NTdGFydCA9IGk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRleHRbaSArIDFdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gNTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnVSc6XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gOTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXNjRW5kID0gaTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ggPT09ICdcXG4nKSB7XG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gRk9MRF9CTE9DSylcbiAgICAgICAgICAgICAgICBpID0gY29uc3VtZU1vcmVJbmRlbnRlZExpbmVzKHRleHQsIGksIGluZGVudC5sZW5ndGgpO1xuICAgICAgICAgICAgZW5kID0gaSArIGluZGVudC5sZW5ndGggKyBlbmRTdGVwO1xuICAgICAgICAgICAgc3BsaXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICcgJyAmJlxuICAgICAgICAgICAgICAgIHByZXYgJiZcbiAgICAgICAgICAgICAgICBwcmV2ICE9PSAnICcgJiZcbiAgICAgICAgICAgICAgICBwcmV2ICE9PSAnXFxuJyAmJlxuICAgICAgICAgICAgICAgIHByZXYgIT09ICdcXHQnKSB7XG4gICAgICAgICAgICAgICAgLy8gc3BhY2Ugc3Vycm91bmRlZCBieSBub24tc3BhY2UgY2FuIGJlIHJlcGxhY2VkIHdpdGggbmV3bGluZSArIGluZGVudFxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSB0ZXh0W2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0ICE9PSAnICcgJiYgbmV4dCAhPT0gJ1xcbicgJiYgbmV4dCAhPT0gJ1xcdCcpXG4gICAgICAgICAgICAgICAgICAgIHNwbGl0ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID49IGVuZCkge1xuICAgICAgICAgICAgICAgIGlmIChzcGxpdCkge1xuICAgICAgICAgICAgICAgICAgICBmb2xkcy5wdXNoKHNwbGl0KTtcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gc3BsaXQgKyBlbmRTdGVwO1xuICAgICAgICAgICAgICAgICAgICBzcGxpdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobW9kZSA9PT0gRk9MRF9RVU9URUQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hpdGUtc3BhY2UgY29sbGVjdGVkIGF0IGVuZCBtYXkgc3RyZXRjaCBwYXN0IGxpbmVXaWR0aFxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocHJldiA9PT0gJyAnIHx8IHByZXYgPT09ICdcXHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ID0gY2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaCA9IHRleHRbKGkgKz0gMSldO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEFjY291bnQgZm9yIG5ld2xpbmUgZXNjYXBlLCBidXQgZG9uJ3QgYnJlYWsgcHJlY2VkaW5nIGVzY2FwZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBqID0gaSA+IGVzY0VuZCArIDEgPyBpIC0gMiA6IGVzY1N0YXJ0IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQmFpbCBvdXQgaWYgbGluZVdpZHRoICYgbWluQ29udGVudFdpZHRoIGFyZSBzaG9ydGVyIHRoYW4gYW4gZXNjYXBlIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXNjYXBlZEZvbGRzW2pdKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgICAgICAgICAgICAgIGZvbGRzLnB1c2goaik7XG4gICAgICAgICAgICAgICAgICAgIGVzY2FwZWRGb2xkc1tqXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IGogKyBlbmRTdGVwO1xuICAgICAgICAgICAgICAgICAgICBzcGxpdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJldiA9IGNoO1xuICAgIH1cbiAgICBpZiAob3ZlcmZsb3cgJiYgb25PdmVyZmxvdylcbiAgICAgICAgb25PdmVyZmxvdygpO1xuICAgIGlmIChmb2xkcy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIGlmIChvbkZvbGQpXG4gICAgICAgIG9uRm9sZCgpO1xuICAgIGxldCByZXMgPSB0ZXh0LnNsaWNlKDAsIGZvbGRzWzBdKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZvbGRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGZvbGQgPSBmb2xkc1tpXTtcbiAgICAgICAgY29uc3QgZW5kID0gZm9sZHNbaSArIDFdIHx8IHRleHQubGVuZ3RoO1xuICAgICAgICBpZiAoZm9sZCA9PT0gMClcbiAgICAgICAgICAgIHJlcyA9IGBcXG4ke2luZGVudH0ke3RleHQuc2xpY2UoMCwgZW5kKX1gO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtb2RlID09PSBGT0xEX1FVT1RFRCAmJiBlc2NhcGVkRm9sZHNbZm9sZF0pXG4gICAgICAgICAgICAgICAgcmVzICs9IGAke3RleHRbZm9sZF19XFxcXGA7XG4gICAgICAgICAgICByZXMgKz0gYFxcbiR7aW5kZW50fSR7dGV4dC5zbGljZShmb2xkICsgMSwgZW5kKX1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIFByZXN1bWVzIGBpICsgMWAgaXMgYXQgdGhlIHN0YXJ0IG9mIGEgbGluZVxuICogQHJldHVybnMgaW5kZXggb2YgbGFzdCBuZXdsaW5lIGluIG1vcmUtaW5kZW50ZWQgYmxvY2tcbiAqL1xuZnVuY3Rpb24gY29uc3VtZU1vcmVJbmRlbnRlZExpbmVzKHRleHQsIGksIGluZGVudCkge1xuICAgIGxldCBlbmQgPSBpO1xuICAgIGxldCBzdGFydCA9IGkgKyAxO1xuICAgIGxldCBjaCA9IHRleHRbc3RhcnRdO1xuICAgIHdoaWxlIChjaCA9PT0gJyAnIHx8IGNoID09PSAnXFx0Jykge1xuICAgICAgICBpZiAoaSA8IHN0YXJ0ICsgaW5kZW50KSB7XG4gICAgICAgICAgICBjaCA9IHRleHRbKytpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBjaCA9IHRleHRbKytpXTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGNoICYmIGNoICE9PSAnXFxuJyk7XG4gICAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgIGNoID0gdGV4dFtzdGFydF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVuZDtcbn1cblxuZXhwb3J0cy5GT0xEX0JMT0NLID0gRk9MRF9CTE9DSztcbmV4cG9ydHMuRk9MRF9GTE9XID0gRk9MRF9GTE9XO1xuZXhwb3J0cy5GT0xEX1FVT1RFRCA9IEZPTERfUVVPVEVEO1xuZXhwb3J0cy5mb2xkRmxvd0xpbmVzID0gZm9sZEZsb3dMaW5lcztcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgU2NhbGFyID0gcmVxdWlyZSgnLi4vbm9kZXMvU2NhbGFyLmpzJyk7XG52YXIgZm9sZEZsb3dMaW5lcyA9IHJlcXVpcmUoJy4vZm9sZEZsb3dMaW5lcy5qcycpO1xuXG5jb25zdCBnZXRGb2xkT3B0aW9ucyA9IChjdHgsIGlzQmxvY2spID0+ICh7XG4gICAgaW5kZW50QXRTdGFydDogaXNCbG9jayA/IGN0eC5pbmRlbnQubGVuZ3RoIDogY3R4LmluZGVudEF0U3RhcnQsXG4gICAgbGluZVdpZHRoOiBjdHgub3B0aW9ucy5saW5lV2lkdGgsXG4gICAgbWluQ29udGVudFdpZHRoOiBjdHgub3B0aW9ucy5taW5Db250ZW50V2lkdGhcbn0pO1xuLy8gQWxzbyBjaGVja3MgZm9yIGxpbmVzIHN0YXJ0aW5nIHdpdGggJSwgYXMgcGFyc2luZyB0aGUgb3V0cHV0IGFzIFlBTUwgMS4xIHdpbGxcbi8vIHByZXN1bWUgdGhhdCdzIHN0YXJ0aW5nIGEgbmV3IGRvY3VtZW50LlxuY29uc3QgY29udGFpbnNEb2N1bWVudE1hcmtlciA9IChzdHIpID0+IC9eKCV8LS0tfFxcLlxcLlxcLikvbS50ZXN0KHN0cik7XG5mdW5jdGlvbiBsaW5lTGVuZ3RoT3ZlckxpbWl0KHN0ciwgbGluZVdpZHRoLCBpbmRlbnRMZW5ndGgpIHtcbiAgICBpZiAoIWxpbmVXaWR0aCB8fCBsaW5lV2lkdGggPCAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgbGltaXQgPSBsaW5lV2lkdGggLSBpbmRlbnRMZW5ndGg7XG4gICAgY29uc3Qgc3RyTGVuID0gc3RyLmxlbmd0aDtcbiAgICBpZiAoc3RyTGVuIDw9IGxpbWl0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDAsIHN0YXJ0ID0gMDsgaSA8IHN0ckxlbjsgKytpKSB7XG4gICAgICAgIGlmIChzdHJbaV0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICBpZiAoaSAtIHN0YXJ0ID4gbGltaXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgaWYgKHN0ckxlbiAtIHN0YXJ0IDw9IGxpbWl0KVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGRvdWJsZVF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KSB7XG4gICAgY29uc3QganNvbiA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICBpZiAoY3R4Lm9wdGlvbnMuZG91YmxlUXVvdGVkQXNKU09OKVxuICAgICAgICByZXR1cm4ganNvbjtcbiAgICBjb25zdCB7IGltcGxpY2l0S2V5IH0gPSBjdHg7XG4gICAgY29uc3QgbWluTXVsdGlMaW5lTGVuZ3RoID0gY3R4Lm9wdGlvbnMuZG91YmxlUXVvdGVkTWluTXVsdGlMaW5lTGVuZ3RoO1xuICAgIGNvbnN0IGluZGVudCA9IGN0eC5pbmRlbnQgfHwgKGNvbnRhaW5zRG9jdW1lbnRNYXJrZXIodmFsdWUpID8gJyAgJyA6ICcnKTtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgY2ggPSBqc29uW2ldOyBjaDsgY2ggPSBqc29uWysraV0pIHtcbiAgICAgICAgaWYgKGNoID09PSAnICcgJiYganNvbltpICsgMV0gPT09ICdcXFxcJyAmJiBqc29uW2kgKyAyXSA9PT0gJ24nKSB7XG4gICAgICAgICAgICAvLyBzcGFjZSBiZWZvcmUgbmV3bGluZSBuZWVkcyB0byBiZSBlc2NhcGVkIHRvIG5vdCBiZSBmb2xkZWRcbiAgICAgICAgICAgIHN0ciArPSBqc29uLnNsaWNlKHN0YXJ0LCBpKSArICdcXFxcICc7XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICBzdGFydCA9IGk7XG4gICAgICAgICAgICBjaCA9ICdcXFxcJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ggPT09ICdcXFxcJylcbiAgICAgICAgICAgIHN3aXRjaCAoanNvbltpICsgMV0pIHtcbiAgICAgICAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGpzb24uc2xpY2Uoc3RhcnQsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IGpzb24uc3Vic3RyKGkgKyAyLCA0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzAwMDAnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFwwJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnMDAwNyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXGEnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcwMDBiJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcdic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzAwMWInOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFxlJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnMDA4NSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXE4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcwMGEwJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcXyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzIwMjgnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFxMJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnMjAyOSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXFAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5zdWJzdHIoMCwgMikgPT09ICcwMCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFx4JyArIGNvZGUuc3Vic3RyKDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0ganNvbi5zdWJzdHIoaSwgNik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgICAgICAgICBpZiAoaW1wbGljaXRLZXkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb25baSArIDJdID09PSAnXCInIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uLmxlbmd0aCA8IG1pbk11bHRpTGluZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9sZGluZyB3aWxsIGVhdCBmaXJzdCBuZXdsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0ganNvbi5zbGljZShzdGFydCwgaSkgKyAnXFxuXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChqc29uW2kgKyAyXSA9PT0gJ1xcXFwnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbltpICsgM10gPT09ICduJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25baSArIDRdICE9PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBpbmRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGFjZSBhZnRlciBuZXdsaW5lIG5lZWRzIHRvIGJlIGVzY2FwZWQgdG8gbm90IGJlIGZvbGRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25baSArIDJdID09PSAnICcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBzdHIgPSBzdGFydCA/IHN0ciArIGpzb24uc2xpY2Uoc3RhcnQpIDoganNvbjtcbiAgICByZXR1cm4gaW1wbGljaXRLZXlcbiAgICAgICAgPyBzdHJcbiAgICAgICAgOiBmb2xkRmxvd0xpbmVzLmZvbGRGbG93TGluZXMoc3RyLCBpbmRlbnQsIGZvbGRGbG93TGluZXMuRk9MRF9RVU9URUQsIGdldEZvbGRPcHRpb25zKGN0eCwgZmFsc2UpKTtcbn1cbmZ1bmN0aW9uIHNpbmdsZVF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KSB7XG4gICAgaWYgKGN0eC5vcHRpb25zLnNpbmdsZVF1b3RlID09PSBmYWxzZSB8fFxuICAgICAgICAoY3R4LmltcGxpY2l0S2V5ICYmIHZhbHVlLmluY2x1ZGVzKCdcXG4nKSkgfHxcbiAgICAgICAgL1sgXFx0XVxcbnxcXG5bIFxcdF0vLnRlc3QodmFsdWUpIC8vIHNpbmdsZSBxdW90ZWQgc3RyaW5nIGNhbid0IGhhdmUgbGVhZGluZyBvciB0cmFpbGluZyB3aGl0ZXNwYWNlIGFyb3VuZCBuZXdsaW5lXG4gICAgKVxuICAgICAgICByZXR1cm4gZG91YmxlUXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpO1xuICAgIGNvbnN0IGluZGVudCA9IGN0eC5pbmRlbnQgfHwgKGNvbnRhaW5zRG9jdW1lbnRNYXJrZXIodmFsdWUpID8gJyAgJyA6ICcnKTtcbiAgICBjb25zdCByZXMgPSBcIidcIiArIHZhbHVlLnJlcGxhY2UoLycvZywgXCInJ1wiKS5yZXBsYWNlKC9cXG4rL2csIGAkJlxcbiR7aW5kZW50fWApICsgXCInXCI7XG4gICAgcmV0dXJuIGN0eC5pbXBsaWNpdEtleVxuICAgICAgICA/IHJlc1xuICAgICAgICA6IGZvbGRGbG93TGluZXMuZm9sZEZsb3dMaW5lcyhyZXMsIGluZGVudCwgZm9sZEZsb3dMaW5lcy5GT0xEX0ZMT1csIGdldEZvbGRPcHRpb25zKGN0eCwgZmFsc2UpKTtcbn1cbmZ1bmN0aW9uIHF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KSB7XG4gICAgY29uc3QgeyBzaW5nbGVRdW90ZSB9ID0gY3R4Lm9wdGlvbnM7XG4gICAgbGV0IHFzO1xuICAgIGlmIChzaW5nbGVRdW90ZSA9PT0gZmFsc2UpXG4gICAgICAgIHFzID0gZG91YmxlUXVvdGVkU3RyaW5nO1xuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBoYXNEb3VibGUgPSB2YWx1ZS5pbmNsdWRlcygnXCInKTtcbiAgICAgICAgY29uc3QgaGFzU2luZ2xlID0gdmFsdWUuaW5jbHVkZXMoXCInXCIpO1xuICAgICAgICBpZiAoaGFzRG91YmxlICYmICFoYXNTaW5nbGUpXG4gICAgICAgICAgICBxcyA9IHNpbmdsZVF1b3RlZFN0cmluZztcbiAgICAgICAgZWxzZSBpZiAoaGFzU2luZ2xlICYmICFoYXNEb3VibGUpXG4gICAgICAgICAgICBxcyA9IGRvdWJsZVF1b3RlZFN0cmluZztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcXMgPSBzaW5nbGVRdW90ZSA/IHNpbmdsZVF1b3RlZFN0cmluZyA6IGRvdWJsZVF1b3RlZFN0cmluZztcbiAgICB9XG4gICAgcmV0dXJuIHFzKHZhbHVlLCBjdHgpO1xufVxuLy8gVGhlIG5lZ2F0aXZlIGxvb2tiZWhpbmQgYXZvaWRzIGEgcG9seW5vbWlhbCBzZWFyY2gsXG4vLyBidXQgaXNuJ3Qgc3VwcG9ydGVkIHlldCBvbiBTYWZhcmk6IGh0dHBzOi8vY2FuaXVzZS5jb20vanMtcmVnZXhwLWxvb2tiZWhpbmRcbmxldCBibG9ja0VuZE5ld2xpbmVzO1xudHJ5IHtcbiAgICBibG9ja0VuZE5ld2xpbmVzID0gbmV3IFJlZ0V4cCgnKF58KD88IVxcbikpXFxuKyg/IVxcbnwkKScsICdnJyk7XG59XG5jYXRjaCB7XG4gICAgYmxvY2tFbmROZXdsaW5lcyA9IC9cXG4rKD8hXFxufCQpL2c7XG59XG5mdW5jdGlvbiBibG9ja1N0cmluZyh7IGNvbW1lbnQsIHR5cGUsIHZhbHVlIH0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgIGNvbnN0IHsgYmxvY2tRdW90ZSwgY29tbWVudFN0cmluZywgbGluZVdpZHRoIH0gPSBjdHgub3B0aW9ucztcbiAgICAvLyAxLiBCbG9jayBjYW4ndCBlbmQgaW4gd2hpdGVzcGFjZSB1bmxlc3MgdGhlIGxhc3QgbGluZSBpcyBub24tZW1wdHkuXG4gICAgLy8gMi4gU3RyaW5ncyBjb25zaXN0aW5nIG9mIG9ubHkgd2hpdGVzcGFjZSBhcmUgYmVzdCByZW5kZXJlZCBleHBsaWNpdGx5LlxuICAgIGlmICghYmxvY2tRdW90ZSB8fCAvXFxuW1xcdCBdKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBxdW90ZWRTdHJpbmcodmFsdWUsIGN0eCk7XG4gICAgfVxuICAgIGNvbnN0IGluZGVudCA9IGN0eC5pbmRlbnQgfHxcbiAgICAgICAgKGN0eC5mb3JjZUJsb2NrSW5kZW50IHx8IGNvbnRhaW5zRG9jdW1lbnRNYXJrZXIodmFsdWUpID8gJyAgJyA6ICcnKTtcbiAgICBjb25zdCBsaXRlcmFsID0gYmxvY2tRdW90ZSA9PT0gJ2xpdGVyYWwnXG4gICAgICAgID8gdHJ1ZVxuICAgICAgICA6IGJsb2NrUXVvdGUgPT09ICdmb2xkZWQnIHx8IHR5cGUgPT09IFNjYWxhci5TY2FsYXIuQkxPQ0tfRk9MREVEXG4gICAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgICA6IHR5cGUgPT09IFNjYWxhci5TY2FsYXIuQkxPQ0tfTElURVJBTFxuICAgICAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgICAgIDogIWxpbmVMZW5ndGhPdmVyTGltaXQodmFsdWUsIGxpbmVXaWR0aCwgaW5kZW50Lmxlbmd0aCk7XG4gICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgcmV0dXJuIGxpdGVyYWwgPyAnfFxcbicgOiAnPlxcbic7XG4gICAgLy8gZGV0ZXJtaW5lIGNob21waW5nIGZyb20gd2hpdGVzcGFjZSBhdCB2YWx1ZSBlbmRcbiAgICBsZXQgY2hvbXA7XG4gICAgbGV0IGVuZFN0YXJ0O1xuICAgIGZvciAoZW5kU3RhcnQgPSB2YWx1ZS5sZW5ndGg7IGVuZFN0YXJ0ID4gMDsgLS1lbmRTdGFydCkge1xuICAgICAgICBjb25zdCBjaCA9IHZhbHVlW2VuZFN0YXJ0IC0gMV07XG4gICAgICAgIGlmIChjaCAhPT0gJ1xcbicgJiYgY2ggIT09ICdcXHQnICYmIGNoICE9PSAnICcpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgbGV0IGVuZCA9IHZhbHVlLnN1YnN0cmluZyhlbmRTdGFydCk7XG4gICAgY29uc3QgZW5kTmxQb3MgPSBlbmQuaW5kZXhPZignXFxuJyk7XG4gICAgaWYgKGVuZE5sUG9zID09PSAtMSkge1xuICAgICAgICBjaG9tcCA9ICctJzsgLy8gc3RyaXBcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgPT09IGVuZCB8fCBlbmRObFBvcyAhPT0gZW5kLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgY2hvbXAgPSAnKyc7IC8vIGtlZXBcbiAgICAgICAgaWYgKG9uQ2hvbXBLZWVwKVxuICAgICAgICAgICAgb25DaG9tcEtlZXAoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNob21wID0gJyc7IC8vIGNsaXBcbiAgICB9XG4gICAgaWYgKGVuZCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDAsIC1lbmQubGVuZ3RoKTtcbiAgICAgICAgaWYgKGVuZFtlbmQubGVuZ3RoIC0gMV0gPT09ICdcXG4nKVxuICAgICAgICAgICAgZW5kID0gZW5kLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgZW5kID0gZW5kLnJlcGxhY2UoYmxvY2tFbmROZXdsaW5lcywgYCQmJHtpbmRlbnR9YCk7XG4gICAgfVxuICAgIC8vIGRldGVybWluZSBpbmRlbnQgaW5kaWNhdG9yIGZyb20gd2hpdGVzcGFjZSBhdCB2YWx1ZSBzdGFydFxuICAgIGxldCBzdGFydFdpdGhTcGFjZSA9IGZhbHNlO1xuICAgIGxldCBzdGFydEVuZDtcbiAgICBsZXQgc3RhcnRObFBvcyA9IC0xO1xuICAgIGZvciAoc3RhcnRFbmQgPSAwOyBzdGFydEVuZCA8IHZhbHVlLmxlbmd0aDsgKytzdGFydEVuZCkge1xuICAgICAgICBjb25zdCBjaCA9IHZhbHVlW3N0YXJ0RW5kXTtcbiAgICAgICAgaWYgKGNoID09PSAnICcpXG4gICAgICAgICAgICBzdGFydFdpdGhTcGFjZSA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAnXFxuJylcbiAgICAgICAgICAgIHN0YXJ0TmxQb3MgPSBzdGFydEVuZDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxldCBzdGFydCA9IHZhbHVlLnN1YnN0cmluZygwLCBzdGFydE5sUG9zIDwgc3RhcnRFbmQgPyBzdGFydE5sUG9zICsgMSA6IHN0YXJ0RW5kKTtcbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoc3RhcnQubGVuZ3RoKTtcbiAgICAgICAgc3RhcnQgPSBzdGFydC5yZXBsYWNlKC9cXG4rL2csIGAkJiR7aW5kZW50fWApO1xuICAgIH1cbiAgICBjb25zdCBpbmRlbnRTaXplID0gaW5kZW50ID8gJzInIDogJzEnOyAvLyByb290IGlzIGF0IC0xXG4gICAgLy8gTGVhZGluZyB8IG9yID4gaXMgYWRkZWQgbGF0ZXJcbiAgICBsZXQgaGVhZGVyID0gKHN0YXJ0V2l0aFNwYWNlID8gaW5kZW50U2l6ZSA6ICcnKSArIGNob21wO1xuICAgIGlmIChjb21tZW50KSB7XG4gICAgICAgIGhlYWRlciArPSAnICcgKyBjb21tZW50U3RyaW5nKGNvbW1lbnQucmVwbGFjZSgvID9bXFxyXFxuXSsvZywgJyAnKSk7XG4gICAgICAgIGlmIChvbkNvbW1lbnQpXG4gICAgICAgICAgICBvbkNvbW1lbnQoKTtcbiAgICB9XG4gICAgaWYgKCFsaXRlcmFsKSB7XG4gICAgICAgIGNvbnN0IGZvbGRlZFZhbHVlID0gdmFsdWVcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXG4rL2csICdcXG4kJicpXG4gICAgICAgICAgICAucmVwbGFjZSgvKD86XnxcXG4pKFtcXHQgXS4qKSg/OihbXFxuXFx0IF0qKVxcbig/IVtcXG5cXHQgXSkpPy9nLCAnJDEkMicpIC8vIG1vcmUtaW5kZW50ZWQgbGluZXMgYXJlbid0IGZvbGRlZFxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgXiBtb3JlLWluZC4gXiBlbXB0eSAgICAgXiBjYXB0dXJlIG5leHQgZW1wdHkgbGluZXMgb25seSBhdCBlbmQgb2YgaW5kZW50XG4gICAgICAgICAgICAucmVwbGFjZSgvXFxuKy9nLCBgJCYke2luZGVudH1gKTtcbiAgICAgICAgbGV0IGxpdGVyYWxGYWxsYmFjayA9IGZhbHNlO1xuICAgICAgICBjb25zdCBmb2xkT3B0aW9ucyA9IGdldEZvbGRPcHRpb25zKGN0eCwgdHJ1ZSk7XG4gICAgICAgIGlmIChibG9ja1F1b3RlICE9PSAnZm9sZGVkJyAmJiB0eXBlICE9PSBTY2FsYXIuU2NhbGFyLkJMT0NLX0ZPTERFRCkge1xuICAgICAgICAgICAgZm9sZE9wdGlvbnMub25PdmVyZmxvdyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBsaXRlcmFsRmFsbGJhY2sgPSB0cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBib2R5ID0gZm9sZEZsb3dMaW5lcy5mb2xkRmxvd0xpbmVzKGAke3N0YXJ0fSR7Zm9sZGVkVmFsdWV9JHtlbmR9YCwgaW5kZW50LCBmb2xkRmxvd0xpbmVzLkZPTERfQkxPQ0ssIGZvbGRPcHRpb25zKTtcbiAgICAgICAgaWYgKCFsaXRlcmFsRmFsbGJhY2spXG4gICAgICAgICAgICByZXR1cm4gYD4ke2hlYWRlcn1cXG4ke2luZGVudH0ke2JvZHl9YDtcbiAgICB9XG4gICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXG4rL2csIGAkJiR7aW5kZW50fWApO1xuICAgIHJldHVybiBgfCR7aGVhZGVyfVxcbiR7aW5kZW50fSR7c3RhcnR9JHt2YWx1ZX0ke2VuZH1gO1xufVxuZnVuY3Rpb24gcGxhaW5TdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgY29uc3QgeyB0eXBlLCB2YWx1ZSB9ID0gaXRlbTtcbiAgICBjb25zdCB7IGFjdHVhbFN0cmluZywgaW1wbGljaXRLZXksIGluZGVudCwgaW5kZW50U3RlcCwgaW5GbG93IH0gPSBjdHg7XG4gICAgaWYgKChpbXBsaWNpdEtleSAmJiB2YWx1ZS5pbmNsdWRlcygnXFxuJykpIHx8XG4gICAgICAgIChpbkZsb3cgJiYgL1tbXFxde30sXS8udGVzdCh2YWx1ZSkpKSB7XG4gICAgICAgIHJldHVybiBxdW90ZWRTdHJpbmcodmFsdWUsIGN0eCk7XG4gICAgfVxuICAgIGlmICgvXltcXG5cXHQgLFtcXF17fSMmKiF8PidcIiVAYF18Xls/LV0kfF5bPy1dWyBcXHRdfFtcXG46XVsgXFx0XXxbIFxcdF1cXG58W1xcblxcdCBdI3xbXFxuXFx0IDpdJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgLy8gbm90IGFsbG93ZWQ6XG4gICAgICAgIC8vIC0gJy0nIG9yICc/J1xuICAgICAgICAvLyAtIHN0YXJ0IHdpdGggYW4gaW5kaWNhdG9yIGNoYXJhY3RlciAoZXhjZXB0IFs/Oi1dKSBvciAvWz8tXSAvXG4gICAgICAgIC8vIC0gJ1xcbiAnLCAnOiAnIG9yICcgXFxuJyBhbnl3aGVyZVxuICAgICAgICAvLyAtICcjJyBub3QgcHJlY2VkZWQgYnkgYSBub24tc3BhY2UgY2hhclxuICAgICAgICAvLyAtIGVuZCB3aXRoICcgJyBvciAnOidcbiAgICAgICAgcmV0dXJuIGltcGxpY2l0S2V5IHx8IGluRmxvdyB8fCAhdmFsdWUuaW5jbHVkZXMoJ1xcbicpXG4gICAgICAgICAgICA/IHF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KVxuICAgICAgICAgICAgOiBibG9ja1N0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgIH1cbiAgICBpZiAoIWltcGxpY2l0S2V5ICYmXG4gICAgICAgICFpbkZsb3cgJiZcbiAgICAgICAgdHlwZSAhPT0gU2NhbGFyLlNjYWxhci5QTEFJTiAmJlxuICAgICAgICB2YWx1ZS5pbmNsdWRlcygnXFxuJykpIHtcbiAgICAgICAgLy8gV2hlcmUgYWxsb3dlZCAmIHR5cGUgbm90IHNldCBleHBsaWNpdGx5LCBwcmVmZXIgYmxvY2sgc3R5bGUgZm9yIG11bHRpbGluZSBzdHJpbmdzXG4gICAgICAgIHJldHVybiBibG9ja1N0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgIH1cbiAgICBpZiAoY29udGFpbnNEb2N1bWVudE1hcmtlcih2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGluZGVudCA9PT0gJycpIHtcbiAgICAgICAgICAgIGN0eC5mb3JjZUJsb2NrSW5kZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBibG9ja1N0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGltcGxpY2l0S2V5ICYmIGluZGVudCA9PT0gaW5kZW50U3RlcCkge1xuICAgICAgICAgICAgcmV0dXJuIHF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzdHIgPSB2YWx1ZS5yZXBsYWNlKC9cXG4rL2csIGAkJlxcbiR7aW5kZW50fWApO1xuICAgIC8vIFZlcmlmeSB0aGF0IG91dHB1dCB3aWxsIGJlIHBhcnNlZCBhcyBhIHN0cmluZywgYXMgZS5nLiBwbGFpbiBudW1iZXJzIGFuZFxuICAgIC8vIGJvb2xlYW5zIGdldCBwYXJzZWQgd2l0aCB0aG9zZSB0eXBlcyBpbiB2MS4yIChlLmcuICc0MicsICd0cnVlJyAmICcwLjllLTMnKSxcbiAgICAvLyBhbmQgb3RoZXJzIGluIHYxLjEuXG4gICAgaWYgKGFjdHVhbFN0cmluZykge1xuICAgICAgICBjb25zdCB0ZXN0ID0gKHRhZykgPT4gdGFnLmRlZmF1bHQgJiYgdGFnLnRhZyAhPT0gJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicgJiYgdGFnLnRlc3Q/LnRlc3Qoc3RyKTtcbiAgICAgICAgY29uc3QgeyBjb21wYXQsIHRhZ3MgfSA9IGN0eC5kb2Muc2NoZW1hO1xuICAgICAgICBpZiAodGFncy5zb21lKHRlc3QpIHx8IGNvbXBhdD8uc29tZSh0ZXN0KSlcbiAgICAgICAgICAgIHJldHVybiBxdW90ZWRTdHJpbmcodmFsdWUsIGN0eCk7XG4gICAgfVxuICAgIHJldHVybiBpbXBsaWNpdEtleVxuICAgICAgICA/IHN0clxuICAgICAgICA6IGZvbGRGbG93TGluZXMuZm9sZEZsb3dMaW5lcyhzdHIsIGluZGVudCwgZm9sZEZsb3dMaW5lcy5GT0xEX0ZMT1csIGdldEZvbGRPcHRpb25zKGN0eCwgZmFsc2UpKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVN0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICBjb25zdCB7IGltcGxpY2l0S2V5LCBpbkZsb3cgfSA9IGN0eDtcbiAgICBjb25zdCBzcyA9IHR5cGVvZiBpdGVtLnZhbHVlID09PSAnc3RyaW5nJ1xuICAgICAgICA/IGl0ZW1cbiAgICAgICAgOiBPYmplY3QuYXNzaWduKHt9LCBpdGVtLCB7IHZhbHVlOiBTdHJpbmcoaXRlbS52YWx1ZSkgfSk7XG4gICAgbGV0IHsgdHlwZSB9ID0gaXRlbTtcbiAgICBpZiAodHlwZSAhPT0gU2NhbGFyLlNjYWxhci5RVU9URV9ET1VCTEUpIHtcbiAgICAgICAgLy8gZm9yY2UgZG91YmxlIHF1b3RlcyBvbiBjb250cm9sIGNoYXJhY3RlcnMgJiB1bnBhaXJlZCBzdXJyb2dhdGVzXG4gICAgICAgIGlmICgvW1xceDAwLVxceDA4XFx4MGItXFx4MWZcXHg3Zi1cXHg5ZlxcdXtEODAwfS1cXHV7REZGRn1dL3UudGVzdChzcy52YWx1ZSkpXG4gICAgICAgICAgICB0eXBlID0gU2NhbGFyLlNjYWxhci5RVU9URV9ET1VCTEU7XG4gICAgfVxuICAgIGNvbnN0IF9zdHJpbmdpZnkgPSAoX3R5cGUpID0+IHtcbiAgICAgICAgc3dpdGNoIChfdHlwZSkge1xuICAgICAgICAgICAgY2FzZSBTY2FsYXIuU2NhbGFyLkJMT0NLX0ZPTERFRDpcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyLlNjYWxhci5CTE9DS19MSVRFUkFMOlxuICAgICAgICAgICAgICAgIHJldHVybiBpbXBsaWNpdEtleSB8fCBpbkZsb3dcbiAgICAgICAgICAgICAgICAgICAgPyBxdW90ZWRTdHJpbmcoc3MudmFsdWUsIGN0eCkgLy8gYmxvY2tzIGFyZSBub3QgdmFsaWQgaW5zaWRlIGZsb3cgY29udGFpbmVyc1xuICAgICAgICAgICAgICAgICAgICA6IGJsb2NrU3RyaW5nKHNzLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXIuU2NhbGFyLlFVT1RFX0RPVUJMRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gZG91YmxlUXVvdGVkU3RyaW5nKHNzLnZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXIuU2NhbGFyLlFVT1RFX1NJTkdMRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gc2luZ2xlUXVvdGVkU3RyaW5nKHNzLnZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXIuU2NhbGFyLlBMQUlOOlxuICAgICAgICAgICAgICAgIHJldHVybiBwbGFpblN0cmluZyhzcywgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGxldCByZXMgPSBfc3RyaW5naWZ5KHR5cGUpO1xuICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgeyBkZWZhdWx0S2V5VHlwZSwgZGVmYXVsdFN0cmluZ1R5cGUgfSA9IGN0eC5vcHRpb25zO1xuICAgICAgICBjb25zdCB0ID0gKGltcGxpY2l0S2V5ICYmIGRlZmF1bHRLZXlUeXBlKSB8fCBkZWZhdWx0U3RyaW5nVHlwZTtcbiAgICAgICAgcmVzID0gX3N0cmluZ2lmeSh0KTtcbiAgICAgICAgaWYgKHJlcyA9PT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGVmYXVsdCBzdHJpbmcgdHlwZSAke3R9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmV4cG9ydHMuc3RyaW5naWZ5U3RyaW5nID0gc3RyaW5naWZ5U3RyaW5nO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBhbmNob3JzID0gcmVxdWlyZSgnLi4vZG9jL2FuY2hvcnMuanMnKTtcbnZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4uL25vZGVzL2lkZW50aXR5LmpzJyk7XG52YXIgc3RyaW5naWZ5Q29tbWVudCA9IHJlcXVpcmUoJy4vc3RyaW5naWZ5Q29tbWVudC5qcycpO1xudmFyIHN0cmluZ2lmeVN0cmluZyA9IHJlcXVpcmUoJy4vc3RyaW5naWZ5U3RyaW5nLmpzJyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0cmluZ2lmeUNvbnRleHQoZG9jLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0ID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGJsb2NrUXVvdGU6IHRydWUsXG4gICAgICAgIGNvbW1lbnRTdHJpbmc6IHN0cmluZ2lmeUNvbW1lbnQuc3RyaW5naWZ5Q29tbWVudCxcbiAgICAgICAgZGVmYXVsdEtleVR5cGU6IG51bGwsXG4gICAgICAgIGRlZmF1bHRTdHJpbmdUeXBlOiAnUExBSU4nLFxuICAgICAgICBkaXJlY3RpdmVzOiBudWxsLFxuICAgICAgICBkb3VibGVRdW90ZWRBc0pTT046IGZhbHNlLFxuICAgICAgICBkb3VibGVRdW90ZWRNaW5NdWx0aUxpbmVMZW5ndGg6IDQwLFxuICAgICAgICBmYWxzZVN0cjogJ2ZhbHNlJyxcbiAgICAgICAgZmxvd0NvbGxlY3Rpb25QYWRkaW5nOiB0cnVlLFxuICAgICAgICBpbmRlbnRTZXE6IHRydWUsXG4gICAgICAgIGxpbmVXaWR0aDogODAsXG4gICAgICAgIG1pbkNvbnRlbnRXaWR0aDogMjAsXG4gICAgICAgIG51bGxTdHI6ICdudWxsJyxcbiAgICAgICAgc2ltcGxlS2V5czogZmFsc2UsXG4gICAgICAgIHNpbmdsZVF1b3RlOiBudWxsLFxuICAgICAgICB0cnVlU3RyOiAndHJ1ZScsXG4gICAgICAgIHZlcmlmeUFsaWFzT3JkZXI6IHRydWVcbiAgICB9LCBkb2Muc2NoZW1hLnRvU3RyaW5nT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgbGV0IGluRmxvdztcbiAgICBzd2l0Y2ggKG9wdC5jb2xsZWN0aW9uU3R5bGUpIHtcbiAgICAgICAgY2FzZSAnYmxvY2snOlxuICAgICAgICAgICAgaW5GbG93ID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZmxvdyc6XG4gICAgICAgICAgICBpbkZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpbkZsb3cgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBhbmNob3JzOiBuZXcgU2V0KCksXG4gICAgICAgIGRvYyxcbiAgICAgICAgZmxvd0NvbGxlY3Rpb25QYWRkaW5nOiBvcHQuZmxvd0NvbGxlY3Rpb25QYWRkaW5nID8gJyAnIDogJycsXG4gICAgICAgIGluZGVudDogJycsXG4gICAgICAgIGluZGVudFN0ZXA6IHR5cGVvZiBvcHQuaW5kZW50ID09PSAnbnVtYmVyJyA/ICcgJy5yZXBlYXQob3B0LmluZGVudCkgOiAnICAnLFxuICAgICAgICBpbkZsb3csXG4gICAgICAgIG9wdGlvbnM6IG9wdFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRUYWdPYmplY3QodGFncywgaXRlbSkge1xuICAgIGlmIChpdGVtLnRhZykge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHRhZ3MuZmlsdGVyKHQgPT4gdC50YWcgPT09IGl0ZW0udGFnKTtcbiAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA+IDApXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2guZmluZCh0ID0+IHQuZm9ybWF0ID09PSBpdGVtLmZvcm1hdCkgPz8gbWF0Y2hbMF07XG4gICAgfVxuICAgIGxldCB0YWdPYmogPSB1bmRlZmluZWQ7XG4gICAgbGV0IG9iajtcbiAgICBpZiAoaWRlbnRpdHkuaXNTY2FsYXIoaXRlbSkpIHtcbiAgICAgICAgb2JqID0gaXRlbS52YWx1ZTtcbiAgICAgICAgbGV0IG1hdGNoID0gdGFncy5maWx0ZXIodCA9PiB0LmlkZW50aWZ5Py4ob2JqKSk7XG4gICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXN0TWF0Y2ggPSBtYXRjaC5maWx0ZXIodCA9PiB0LnRlc3QpO1xuICAgICAgICAgICAgaWYgKHRlc3RNYXRjaC5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgIG1hdGNoID0gdGVzdE1hdGNoO1xuICAgICAgICB9XG4gICAgICAgIHRhZ09iaiA9XG4gICAgICAgICAgICBtYXRjaC5maW5kKHQgPT4gdC5mb3JtYXQgPT09IGl0ZW0uZm9ybWF0KSA/PyBtYXRjaC5maW5kKHQgPT4gIXQuZm9ybWF0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9iaiA9IGl0ZW07XG4gICAgICAgIHRhZ09iaiA9IHRhZ3MuZmluZCh0ID0+IHQubm9kZUNsYXNzICYmIG9iaiBpbnN0YW5jZW9mIHQubm9kZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKCF0YWdPYmopIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IG9iaj8uY29uc3RydWN0b3I/Lm5hbWUgPz8gKG9iaiA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiBvYmopO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRhZyBub3QgcmVzb2x2ZWQgZm9yICR7bmFtZX0gdmFsdWVgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhZ09iajtcbn1cbi8vIG5lZWRzIHRvIGJlIGNhbGxlZCBiZWZvcmUgdmFsdWUgc3RyaW5naWZpZXIgdG8gYWxsb3cgZm9yIGNpcmN1bGFyIGFuY2hvciByZWZzXG5mdW5jdGlvbiBzdHJpbmdpZnlQcm9wcyhub2RlLCB0YWdPYmosIHsgYW5jaG9yczogYW5jaG9ycyQxLCBkb2MgfSkge1xuICAgIGlmICghZG9jLmRpcmVjdGl2ZXMpXG4gICAgICAgIHJldHVybiAnJztcbiAgICBjb25zdCBwcm9wcyA9IFtdO1xuICAgIGNvbnN0IGFuY2hvciA9IChpZGVudGl0eS5pc1NjYWxhcihub2RlKSB8fCBpZGVudGl0eS5pc0NvbGxlY3Rpb24obm9kZSkpICYmIG5vZGUuYW5jaG9yO1xuICAgIGlmIChhbmNob3IgJiYgYW5jaG9ycy5hbmNob3JJc1ZhbGlkKGFuY2hvcikpIHtcbiAgICAgICAgYW5jaG9ycyQxLmFkZChhbmNob3IpO1xuICAgICAgICBwcm9wcy5wdXNoKGAmJHthbmNob3J9YCk7XG4gICAgfVxuICAgIGNvbnN0IHRhZyA9IG5vZGUudGFnID8/ICh0YWdPYmouZGVmYXVsdCA/IG51bGwgOiB0YWdPYmoudGFnKTtcbiAgICBpZiAodGFnKVxuICAgICAgICBwcm9wcy5wdXNoKGRvYy5kaXJlY3RpdmVzLnRhZ1N0cmluZyh0YWcpKTtcbiAgICByZXR1cm4gcHJvcHMuam9pbignICcpO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5KGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgIGlmIChpZGVudGl0eS5pc1BhaXIoaXRlbSkpXG4gICAgICAgIHJldHVybiBpdGVtLnRvU3RyaW5nKGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG4gICAgaWYgKGlkZW50aXR5LmlzQWxpYXMoaXRlbSkpIHtcbiAgICAgICAgaWYgKGN0eC5kb2MuZGlyZWN0aXZlcylcbiAgICAgICAgICAgIHJldHVybiBpdGVtLnRvU3RyaW5nKGN0eCk7XG4gICAgICAgIGlmIChjdHgucmVzb2x2ZWRBbGlhc2VzPy5oYXMoaXRlbSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbm5vdCBzdHJpbmdpZnkgY2lyY3VsYXIgc3RydWN0dXJlIHdpdGhvdXQgYWxpYXMgbm9kZXNgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjdHgucmVzb2x2ZWRBbGlhc2VzKVxuICAgICAgICAgICAgICAgIGN0eC5yZXNvbHZlZEFsaWFzZXMuYWRkKGl0ZW0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGN0eC5yZXNvbHZlZEFsaWFzZXMgPSBuZXcgU2V0KFtpdGVtXSk7XG4gICAgICAgICAgICBpdGVtID0gaXRlbS5yZXNvbHZlKGN0eC5kb2MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCB0YWdPYmogPSB1bmRlZmluZWQ7XG4gICAgY29uc3Qgbm9kZSA9IGlkZW50aXR5LmlzTm9kZShpdGVtKVxuICAgICAgICA/IGl0ZW1cbiAgICAgICAgOiBjdHguZG9jLmNyZWF0ZU5vZGUoaXRlbSwgeyBvblRhZ09iajogbyA9PiAodGFnT2JqID0gbykgfSk7XG4gICAgdGFnT2JqID8/ICh0YWdPYmogPSBnZXRUYWdPYmplY3QoY3R4LmRvYy5zY2hlbWEudGFncywgbm9kZSkpO1xuICAgIGNvbnN0IHByb3BzID0gc3RyaW5naWZ5UHJvcHMobm9kZSwgdGFnT2JqLCBjdHgpO1xuICAgIGlmIChwcm9wcy5sZW5ndGggPiAwKVxuICAgICAgICBjdHguaW5kZW50QXRTdGFydCA9IChjdHguaW5kZW50QXRTdGFydCA/PyAwKSArIHByb3BzLmxlbmd0aCArIDE7XG4gICAgY29uc3Qgc3RyID0gdHlwZW9mIHRhZ09iai5zdHJpbmdpZnkgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyB0YWdPYmouc3RyaW5naWZ5KG5vZGUsIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcClcbiAgICAgICAgOiBpZGVudGl0eS5pc1NjYWxhcihub2RlKVxuICAgICAgICAgICAgPyBzdHJpbmdpZnlTdHJpbmcuc3RyaW5naWZ5U3RyaW5nKG5vZGUsIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcClcbiAgICAgICAgICAgIDogbm9kZS50b1N0cmluZyhjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgIGlmICghcHJvcHMpXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgcmV0dXJuIGlkZW50aXR5LmlzU2NhbGFyKG5vZGUpIHx8IHN0clswXSA9PT0gJ3snIHx8IHN0clswXSA9PT0gJ1snXG4gICAgICAgID8gYCR7cHJvcHN9ICR7c3RyfWBcbiAgICAgICAgOiBgJHtwcm9wc31cXG4ke2N0eC5pbmRlbnR9JHtzdHJ9YDtcbn1cblxuZXhwb3J0cy5jcmVhdGVTdHJpbmdpZnlDb250ZXh0ID0gY3JlYXRlU3RyaW5naWZ5Q29udGV4dDtcbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4uL25vZGVzL2lkZW50aXR5LmpzJyk7XG52YXIgU2NhbGFyID0gcmVxdWlyZSgnLi4vbm9kZXMvU2NhbGFyLmpzJyk7XG52YXIgc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9zdHJpbmdpZnkuanMnKTtcbnZhciBzdHJpbmdpZnlDb21tZW50ID0gcmVxdWlyZSgnLi9zdHJpbmdpZnlDb21tZW50LmpzJyk7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVBhaXIoeyBrZXksIHZhbHVlIH0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgIGNvbnN0IHsgYWxsTnVsbFZhbHVlcywgZG9jLCBpbmRlbnQsIGluZGVudFN0ZXAsIG9wdGlvbnM6IHsgY29tbWVudFN0cmluZywgaW5kZW50U2VxLCBzaW1wbGVLZXlzIH0gfSA9IGN0eDtcbiAgICBsZXQga2V5Q29tbWVudCA9IChpZGVudGl0eS5pc05vZGUoa2V5KSAmJiBrZXkuY29tbWVudCkgfHwgbnVsbDtcbiAgICBpZiAoc2ltcGxlS2V5cykge1xuICAgICAgICBpZiAoa2V5Q29tbWVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaXRoIHNpbXBsZSBrZXlzLCBrZXkgbm9kZXMgY2Fubm90IGhhdmUgY29tbWVudHMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWRlbnRpdHkuaXNDb2xsZWN0aW9uKGtleSkgfHwgKCFpZGVudGl0eS5pc05vZGUoa2V5KSAmJiB0eXBlb2Yga2V5ID09PSAnb2JqZWN0JykpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9ICdXaXRoIHNpbXBsZSBrZXlzLCBjb2xsZWN0aW9uIGNhbm5vdCBiZSB1c2VkIGFzIGEga2V5IHZhbHVlJztcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBleHBsaWNpdEtleSA9ICFzaW1wbGVLZXlzICYmXG4gICAgICAgICgha2V5IHx8XG4gICAgICAgICAgICAoa2V5Q29tbWVudCAmJiB2YWx1ZSA9PSBudWxsICYmICFjdHguaW5GbG93KSB8fFxuICAgICAgICAgICAgaWRlbnRpdHkuaXNDb2xsZWN0aW9uKGtleSkgfHxcbiAgICAgICAgICAgIChpZGVudGl0eS5pc1NjYWxhcihrZXkpXG4gICAgICAgICAgICAgICAgPyBrZXkudHlwZSA9PT0gU2NhbGFyLlNjYWxhci5CTE9DS19GT0xERUQgfHwga2V5LnR5cGUgPT09IFNjYWxhci5TY2FsYXIuQkxPQ0tfTElURVJBTFxuICAgICAgICAgICAgICAgIDogdHlwZW9mIGtleSA9PT0gJ29iamVjdCcpKTtcbiAgICBjdHggPSBPYmplY3QuYXNzaWduKHt9LCBjdHgsIHtcbiAgICAgICAgYWxsTnVsbFZhbHVlczogZmFsc2UsXG4gICAgICAgIGltcGxpY2l0S2V5OiAhZXhwbGljaXRLZXkgJiYgKHNpbXBsZUtleXMgfHwgIWFsbE51bGxWYWx1ZXMpLFxuICAgICAgICBpbmRlbnQ6IGluZGVudCArIGluZGVudFN0ZXBcbiAgICB9KTtcbiAgICBsZXQga2V5Q29tbWVudERvbmUgPSBmYWxzZTtcbiAgICBsZXQgY2hvbXBLZWVwID0gZmFsc2U7XG4gICAgbGV0IHN0ciA9IHN0cmluZ2lmeS5zdHJpbmdpZnkoa2V5LCBjdHgsICgpID0+IChrZXlDb21tZW50RG9uZSA9IHRydWUpLCAoKSA9PiAoY2hvbXBLZWVwID0gdHJ1ZSkpO1xuICAgIGlmICghZXhwbGljaXRLZXkgJiYgIWN0eC5pbkZsb3cgJiYgc3RyLmxlbmd0aCA+IDEwMjQpIHtcbiAgICAgICAgaWYgKHNpbXBsZUtleXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dpdGggc2ltcGxlIGtleXMsIHNpbmdsZSBsaW5lIHNjYWxhciBtdXN0IG5vdCBzcGFuIG1vcmUgdGhhbiAxMDI0IGNoYXJhY3RlcnMnKTtcbiAgICAgICAgZXhwbGljaXRLZXkgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY3R4LmluRmxvdykge1xuICAgICAgICBpZiAoYWxsTnVsbFZhbHVlcyB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoa2V5Q29tbWVudERvbmUgJiYgb25Db21tZW50KVxuICAgICAgICAgICAgICAgIG9uQ29tbWVudCgpO1xuICAgICAgICAgICAgcmV0dXJuIHN0ciA9PT0gJycgPyAnPycgOiBleHBsaWNpdEtleSA/IGA/ICR7c3RyfWAgOiBzdHI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoKGFsbE51bGxWYWx1ZXMgJiYgIXNpbXBsZUtleXMpIHx8ICh2YWx1ZSA9PSBudWxsICYmIGV4cGxpY2l0S2V5KSkge1xuICAgICAgICBzdHIgPSBgPyAke3N0cn1gO1xuICAgICAgICBpZiAoa2V5Q29tbWVudCAmJiAha2V5Q29tbWVudERvbmUpIHtcbiAgICAgICAgICAgIHN0ciArPSBzdHJpbmdpZnlDb21tZW50LmxpbmVDb21tZW50KHN0ciwgY3R4LmluZGVudCwgY29tbWVudFN0cmluZyhrZXlDb21tZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hvbXBLZWVwICYmIG9uQ2hvbXBLZWVwKVxuICAgICAgICAgICAgb25DaG9tcEtlZXAoKTtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgaWYgKGtleUNvbW1lbnREb25lKVxuICAgICAgICBrZXlDb21tZW50ID0gbnVsbDtcbiAgICBpZiAoZXhwbGljaXRLZXkpIHtcbiAgICAgICAgaWYgKGtleUNvbW1lbnQpXG4gICAgICAgICAgICBzdHIgKz0gc3RyaW5naWZ5Q29tbWVudC5saW5lQ29tbWVudChzdHIsIGN0eC5pbmRlbnQsIGNvbW1lbnRTdHJpbmcoa2V5Q29tbWVudCkpO1xuICAgICAgICBzdHIgPSBgPyAke3N0cn1cXG4ke2luZGVudH06YDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0ciA9IGAke3N0cn06YDtcbiAgICAgICAgaWYgKGtleUNvbW1lbnQpXG4gICAgICAgICAgICBzdHIgKz0gc3RyaW5naWZ5Q29tbWVudC5saW5lQ29tbWVudChzdHIsIGN0eC5pbmRlbnQsIGNvbW1lbnRTdHJpbmcoa2V5Q29tbWVudCkpO1xuICAgIH1cbiAgICBsZXQgdnNiLCB2Y2IsIHZhbHVlQ29tbWVudDtcbiAgICBpZiAoaWRlbnRpdHkuaXNOb2RlKHZhbHVlKSkge1xuICAgICAgICB2c2IgPSAhIXZhbHVlLnNwYWNlQmVmb3JlO1xuICAgICAgICB2Y2IgPSB2YWx1ZS5jb21tZW50QmVmb3JlO1xuICAgICAgICB2YWx1ZUNvbW1lbnQgPSB2YWx1ZS5jb21tZW50O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdnNiID0gZmFsc2U7XG4gICAgICAgIHZjYiA9IG51bGw7XG4gICAgICAgIHZhbHVlQ29tbWVudCA9IG51bGw7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgdmFsdWUgPSBkb2MuY3JlYXRlTm9kZSh2YWx1ZSk7XG4gICAgfVxuICAgIGN0eC5pbXBsaWNpdEtleSA9IGZhbHNlO1xuICAgIGlmICghZXhwbGljaXRLZXkgJiYgIWtleUNvbW1lbnQgJiYgaWRlbnRpdHkuaXNTY2FsYXIodmFsdWUpKVxuICAgICAgICBjdHguaW5kZW50QXRTdGFydCA9IHN0ci5sZW5ndGggKyAxO1xuICAgIGNob21wS2VlcCA9IGZhbHNlO1xuICAgIGlmICghaW5kZW50U2VxICYmXG4gICAgICAgIGluZGVudFN0ZXAubGVuZ3RoID49IDIgJiZcbiAgICAgICAgIWN0eC5pbkZsb3cgJiZcbiAgICAgICAgIWV4cGxpY2l0S2V5ICYmXG4gICAgICAgIGlkZW50aXR5LmlzU2VxKHZhbHVlKSAmJlxuICAgICAgICAhdmFsdWUuZmxvdyAmJlxuICAgICAgICAhdmFsdWUudGFnICYmXG4gICAgICAgICF2YWx1ZS5hbmNob3IpIHtcbiAgICAgICAgLy8gSWYgaW5kZW50U2VxID09PSBmYWxzZSwgY29uc2lkZXIgJy0gJyBhcyBwYXJ0IG9mIGluZGVudGF0aW9uIHdoZXJlIHBvc3NpYmxlXG4gICAgICAgIGN0eC5pbmRlbnQgPSBjdHguaW5kZW50LnN1YnN0cmluZygyKTtcbiAgICB9XG4gICAgbGV0IHZhbHVlQ29tbWVudERvbmUgPSBmYWxzZTtcbiAgICBjb25zdCB2YWx1ZVN0ciA9IHN0cmluZ2lmeS5zdHJpbmdpZnkodmFsdWUsIGN0eCwgKCkgPT4gKHZhbHVlQ29tbWVudERvbmUgPSB0cnVlKSwgKCkgPT4gKGNob21wS2VlcCA9IHRydWUpKTtcbiAgICBsZXQgd3MgPSAnICc7XG4gICAgaWYgKGtleUNvbW1lbnQgfHwgdnNiIHx8IHZjYikge1xuICAgICAgICB3cyA9IHZzYiA/ICdcXG4nIDogJyc7XG4gICAgICAgIGlmICh2Y2IpIHtcbiAgICAgICAgICAgIGNvbnN0IGNzID0gY29tbWVudFN0cmluZyh2Y2IpO1xuICAgICAgICAgICAgd3MgKz0gYFxcbiR7c3RyaW5naWZ5Q29tbWVudC5pbmRlbnRDb21tZW50KGNzLCBjdHguaW5kZW50KX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZVN0ciA9PT0gJycgJiYgIWN0eC5pbkZsb3cpIHtcbiAgICAgICAgICAgIGlmICh3cyA9PT0gJ1xcbicgJiYgdmFsdWVDb21tZW50KVxuICAgICAgICAgICAgICAgIHdzID0gJ1xcblxcbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3cyArPSBgXFxuJHtjdHguaW5kZW50fWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoIWV4cGxpY2l0S2V5ICYmIGlkZW50aXR5LmlzQ29sbGVjdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgdnMwID0gdmFsdWVTdHJbMF07XG4gICAgICAgIGNvbnN0IG5sMCA9IHZhbHVlU3RyLmluZGV4T2YoJ1xcbicpO1xuICAgICAgICBjb25zdCBoYXNOZXdsaW5lID0gbmwwICE9PSAtMTtcbiAgICAgICAgY29uc3QgZmxvdyA9IGN0eC5pbkZsb3cgPz8gdmFsdWUuZmxvdyA/PyB2YWx1ZS5pdGVtcy5sZW5ndGggPT09IDA7XG4gICAgICAgIGlmIChoYXNOZXdsaW5lIHx8ICFmbG93KSB7XG4gICAgICAgICAgICBsZXQgaGFzUHJvcHNMaW5lID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoaGFzTmV3bGluZSAmJiAodnMwID09PSAnJicgfHwgdnMwID09PSAnIScpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNwMCA9IHZhbHVlU3RyLmluZGV4T2YoJyAnKTtcbiAgICAgICAgICAgICAgICBpZiAodnMwID09PSAnJicgJiZcbiAgICAgICAgICAgICAgICAgICAgc3AwICE9PSAtMSAmJlxuICAgICAgICAgICAgICAgICAgICBzcDAgPCBubDAgJiZcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVTdHJbc3AwICsgMV0gPT09ICchJykge1xuICAgICAgICAgICAgICAgICAgICBzcDAgPSB2YWx1ZVN0ci5pbmRleE9mKCcgJywgc3AwICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzcDAgPT09IC0xIHx8IG5sMCA8IHNwMClcbiAgICAgICAgICAgICAgICAgICAgaGFzUHJvcHNMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGFzUHJvcHNMaW5lKVxuICAgICAgICAgICAgICAgIHdzID0gYFxcbiR7Y3R4LmluZGVudH1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlU3RyID09PSAnJyB8fCB2YWx1ZVN0clswXSA9PT0gJ1xcbicpIHtcbiAgICAgICAgd3MgPSAnJztcbiAgICB9XG4gICAgc3RyICs9IHdzICsgdmFsdWVTdHI7XG4gICAgaWYgKGN0eC5pbkZsb3cpIHtcbiAgICAgICAgaWYgKHZhbHVlQ29tbWVudERvbmUgJiYgb25Db21tZW50KVxuICAgICAgICAgICAgb25Db21tZW50KCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlQ29tbWVudCAmJiAhdmFsdWVDb21tZW50RG9uZSkge1xuICAgICAgICBzdHIgKz0gc3RyaW5naWZ5Q29tbWVudC5saW5lQ29tbWVudChzdHIsIGN0eC5pbmRlbnQsIGNvbW1lbnRTdHJpbmcodmFsdWVDb21tZW50KSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNob21wS2VlcCAmJiBvbkNob21wS2VlcCkge1xuICAgICAgICBvbkNob21wS2VlcCgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuXG5leHBvcnRzLnN0cmluZ2lmeVBhaXIgPSBzdHJpbmdpZnlQYWlyO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBub2RlX3Byb2Nlc3MgPSByZXF1aXJlKCdwcm9jZXNzJyk7XG5cbmZ1bmN0aW9uIGRlYnVnKGxvZ0xldmVsLCAuLi5tZXNzYWdlcykge1xuICAgIGlmIChsb2dMZXZlbCA9PT0gJ2RlYnVnJylcbiAgICAgICAgY29uc29sZS5sb2coLi4ubWVzc2FnZXMpO1xufVxuZnVuY3Rpb24gd2Fybihsb2dMZXZlbCwgd2FybmluZykge1xuICAgIGlmIChsb2dMZXZlbCA9PT0gJ2RlYnVnJyB8fCBsb2dMZXZlbCA9PT0gJ3dhcm4nKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZV9wcm9jZXNzLmVtaXRXYXJuaW5nID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgbm9kZV9wcm9jZXNzLmVtaXRXYXJuaW5nKHdhcm5pbmcpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjb25zb2xlLndhcm4od2FybmluZyk7XG4gICAgfVxufVxuXG5leHBvcnRzLmRlYnVnID0gZGVidWc7XG5leHBvcnRzLndhcm4gPSB3YXJuO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4uLy4uL25vZGVzL2lkZW50aXR5LmpzJyk7XG52YXIgU2NhbGFyID0gcmVxdWlyZSgnLi4vLi4vbm9kZXMvU2NhbGFyLmpzJyk7XG5cbi8vIElmIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggYSBtZXJnZSBrZXkgaXMgYSBzaW5nbGUgbWFwcGluZyBub2RlLCBlYWNoIG9mXG4vLyBpdHMga2V5L3ZhbHVlIHBhaXJzIGlzIGluc2VydGVkIGludG8gdGhlIGN1cnJlbnQgbWFwcGluZywgdW5sZXNzIHRoZSBrZXlcbi8vIGFscmVhZHkgZXhpc3RzIGluIGl0LiBJZiB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBtZXJnZSBrZXkgaXMgYVxuLy8gc2VxdWVuY2UsIHRoZW4gdGhpcyBzZXF1ZW5jZSBpcyBleHBlY3RlZCB0byBjb250YWluIG1hcHBpbmcgbm9kZXMgYW5kIGVhY2hcbi8vIG9mIHRoZXNlIG5vZGVzIGlzIG1lcmdlZCBpbiB0dXJuIGFjY29yZGluZyB0byBpdHMgb3JkZXIgaW4gdGhlIHNlcXVlbmNlLlxuLy8gS2V5cyBpbiBtYXBwaW5nIG5vZGVzIGVhcmxpZXIgaW4gdGhlIHNlcXVlbmNlIG92ZXJyaWRlIGtleXMgc3BlY2lmaWVkIGluXG4vLyBsYXRlciBtYXBwaW5nIG5vZGVzLiAtLSBodHRwOi8veWFtbC5vcmcvdHlwZS9tZXJnZS5odG1sXG5jb25zdCBNRVJHRV9LRVkgPSAnPDwnO1xuY29uc3QgbWVyZ2UgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlID09PSBNRVJHRV9LRVkgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcgJiYgdmFsdWUuZGVzY3JpcHRpb24gPT09IE1FUkdFX0tFWSksXG4gICAgZGVmYXVsdDogJ2tleScsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6bWVyZ2UnLFxuICAgIHRlc3Q6IC9ePDwkLyxcbiAgICByZXNvbHZlOiAoKSA9PiBPYmplY3QuYXNzaWduKG5ldyBTY2FsYXIuU2NhbGFyKFN5bWJvbChNRVJHRV9LRVkpKSwge1xuICAgICAgICBhZGRUb0pTTWFwOiBhZGRNZXJnZVRvSlNNYXBcbiAgICB9KSxcbiAgICBzdHJpbmdpZnk6ICgpID0+IE1FUkdFX0tFWVxufTtcbmNvbnN0IGlzTWVyZ2VLZXkgPSAoY3R4LCBrZXkpID0+IChtZXJnZS5pZGVudGlmeShrZXkpIHx8XG4gICAgKGlkZW50aXR5LmlzU2NhbGFyKGtleSkgJiZcbiAgICAgICAgKCFrZXkudHlwZSB8fCBrZXkudHlwZSA9PT0gU2NhbGFyLlNjYWxhci5QTEFJTikgJiZcbiAgICAgICAgbWVyZ2UuaWRlbnRpZnkoa2V5LnZhbHVlKSkpICYmXG4gICAgY3R4Py5kb2Muc2NoZW1hLnRhZ3Muc29tZSh0YWcgPT4gdGFnLnRhZyA9PT0gbWVyZ2UudGFnICYmIHRhZy5kZWZhdWx0KTtcbmZ1bmN0aW9uIGFkZE1lcmdlVG9KU01hcChjdHgsIG1hcCwgdmFsdWUpIHtcbiAgICB2YWx1ZSA9IGN0eCAmJiBpZGVudGl0eS5pc0FsaWFzKHZhbHVlKSA/IHZhbHVlLnJlc29sdmUoY3R4LmRvYykgOiB2YWx1ZTtcbiAgICBpZiAoaWRlbnRpdHkuaXNTZXEodmFsdWUpKVxuICAgICAgICBmb3IgKGNvbnN0IGl0IG9mIHZhbHVlLml0ZW1zKVxuICAgICAgICAgICAgbWVyZ2VWYWx1ZShjdHgsIG1hcCwgaXQpO1xuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICBmb3IgKGNvbnN0IGl0IG9mIHZhbHVlKVxuICAgICAgICAgICAgbWVyZ2VWYWx1ZShjdHgsIG1hcCwgaXQpO1xuICAgIGVsc2VcbiAgICAgICAgbWVyZ2VWYWx1ZShjdHgsIG1hcCwgdmFsdWUpO1xufVxuZnVuY3Rpb24gbWVyZ2VWYWx1ZShjdHgsIG1hcCwgdmFsdWUpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBjdHggJiYgaWRlbnRpdHkuaXNBbGlhcyh2YWx1ZSkgPyB2YWx1ZS5yZXNvbHZlKGN0eC5kb2MpIDogdmFsdWU7XG4gICAgaWYgKCFpZGVudGl0eS5pc01hcChzb3VyY2UpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01lcmdlIHNvdXJjZXMgbXVzdCBiZSBtYXBzIG9yIG1hcCBhbGlhc2VzJyk7XG4gICAgY29uc3Qgc3JjTWFwID0gc291cmNlLnRvSlNPTihudWxsLCBjdHgsIE1hcCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc3JjTWFwKSB7XG4gICAgICAgIGlmIChtYXAgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgIGlmICghbWFwLmhhcyhrZXkpKVxuICAgICAgICAgICAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWFwIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICBtYXAuYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIGtleSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtYXAsIGtleSwge1xuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFwO1xufVxuXG5leHBvcnRzLmFkZE1lcmdlVG9KU01hcCA9IGFkZE1lcmdlVG9KU01hcDtcbmV4cG9ydHMuaXNNZXJnZUtleSA9IGlzTWVyZ2VLZXk7XG5leHBvcnRzLm1lcmdlID0gbWVyZ2U7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIGxvZyA9IHJlcXVpcmUoJy4uL2xvZy5qcycpO1xudmFyIG1lcmdlID0gcmVxdWlyZSgnLi4vc2NoZW1hL3lhbWwtMS4xL21lcmdlLmpzJyk7XG52YXIgc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi4vc3RyaW5naWZ5L3N0cmluZ2lmeS5qcycpO1xudmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eS5qcycpO1xudmFyIHRvSlMgPSByZXF1aXJlKCcuL3RvSlMuanMnKTtcblxuZnVuY3Rpb24gYWRkUGFpclRvSlNNYXAoY3R4LCBtYXAsIHsga2V5LCB2YWx1ZSB9KSB7XG4gICAgaWYgKGlkZW50aXR5LmlzTm9kZShrZXkpICYmIGtleS5hZGRUb0pTTWFwKVxuICAgICAgICBrZXkuYWRkVG9KU01hcChjdHgsIG1hcCwgdmFsdWUpO1xuICAgIC8vIFRPRE86IFNob3VsZCBkcm9wIHRoaXMgc3BlY2lhbCBjYXNlIGZvciBiYXJlIDw8IGhhbmRsaW5nXG4gICAgZWxzZSBpZiAobWVyZ2UuaXNNZXJnZUtleShjdHgsIGtleSkpXG4gICAgICAgIG1lcmdlLmFkZE1lcmdlVG9KU01hcChjdHgsIG1hcCwgdmFsdWUpO1xuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBqc0tleSA9IHRvSlMudG9KUyhrZXksICcnLCBjdHgpO1xuICAgICAgICBpZiAobWFwIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICBtYXAuc2V0KGpzS2V5LCB0b0pTLnRvSlModmFsdWUsIGpzS2V5LCBjdHgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtYXAgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgIG1hcC5hZGQoanNLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc3RyaW5nS2V5ID0gc3RyaW5naWZ5S2V5KGtleSwganNLZXksIGN0eCk7XG4gICAgICAgICAgICBjb25zdCBqc1ZhbHVlID0gdG9KUy50b0pTKHZhbHVlLCBzdHJpbmdLZXksIGN0eCk7XG4gICAgICAgICAgICBpZiAoc3RyaW5nS2V5IGluIG1hcClcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWFwLCBzdHJpbmdLZXksIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGpzVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtYXBbc3RyaW5nS2V5XSA9IGpzVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeUtleShrZXksIGpzS2V5LCBjdHgpIHtcbiAgICBpZiAoanNLZXkgPT09IG51bGwpXG4gICAgICAgIHJldHVybiAnJztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWJhc2UtdG8tc3RyaW5nXG4gICAgaWYgKHR5cGVvZiBqc0tleSAhPT0gJ29iamVjdCcpXG4gICAgICAgIHJldHVybiBTdHJpbmcoanNLZXkpO1xuICAgIGlmIChpZGVudGl0eS5pc05vZGUoa2V5KSAmJiBjdHg/LmRvYykge1xuICAgICAgICBjb25zdCBzdHJDdHggPSBzdHJpbmdpZnkuY3JlYXRlU3RyaW5naWZ5Q29udGV4dChjdHguZG9jLCB7fSk7XG4gICAgICAgIHN0ckN0eC5hbmNob3JzID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgY3R4LmFuY2hvcnMua2V5cygpKVxuICAgICAgICAgICAgc3RyQ3R4LmFuY2hvcnMuYWRkKG5vZGUuYW5jaG9yKTtcbiAgICAgICAgc3RyQ3R4LmluRmxvdyA9IHRydWU7XG4gICAgICAgIHN0ckN0eC5pblN0cmluZ2lmeUtleSA9IHRydWU7XG4gICAgICAgIGNvbnN0IHN0cktleSA9IGtleS50b1N0cmluZyhzdHJDdHgpO1xuICAgICAgICBpZiAoIWN0eC5tYXBLZXlXYXJuZWQpIHtcbiAgICAgICAgICAgIGxldCBqc29uU3RyID0gSlNPTi5zdHJpbmdpZnkoc3RyS2V5KTtcbiAgICAgICAgICAgIGlmIChqc29uU3RyLmxlbmd0aCA+IDQwKVxuICAgICAgICAgICAgICAgIGpzb25TdHIgPSBqc29uU3RyLnN1YnN0cmluZygwLCAzNikgKyAnLi4uXCInO1xuICAgICAgICAgICAgbG9nLndhcm4oY3R4LmRvYy5vcHRpb25zLmxvZ0xldmVsLCBgS2V5cyB3aXRoIGNvbGxlY3Rpb24gdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWQgZHVlIHRvIEpTIE9iamVjdCByZXN0cmljdGlvbnM6ICR7anNvblN0cn0uIFNldCBtYXBBc01hcDogdHJ1ZSB0byB1c2Ugb2JqZWN0IGtleXMuYCk7XG4gICAgICAgICAgICBjdHgubWFwS2V5V2FybmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyS2V5O1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoanNLZXkpO1xufVxuXG5leHBvcnRzLmFkZFBhaXJUb0pTTWFwID0gYWRkUGFpclRvSlNNYXA7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIGNyZWF0ZU5vZGUgPSByZXF1aXJlKCcuLi9kb2MvY3JlYXRlTm9kZS5qcycpO1xudmFyIHN0cmluZ2lmeVBhaXIgPSByZXF1aXJlKCcuLi9zdHJpbmdpZnkvc3RyaW5naWZ5UGFpci5qcycpO1xudmFyIGFkZFBhaXJUb0pTTWFwID0gcmVxdWlyZSgnLi9hZGRQYWlyVG9KU01hcC5qcycpO1xudmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eS5qcycpO1xuXG5mdW5jdGlvbiBjcmVhdGVQYWlyKGtleSwgdmFsdWUsIGN0eCkge1xuICAgIGNvbnN0IGsgPSBjcmVhdGVOb2RlLmNyZWF0ZU5vZGUoa2V5LCB1bmRlZmluZWQsIGN0eCk7XG4gICAgY29uc3QgdiA9IGNyZWF0ZU5vZGUuY3JlYXRlTm9kZSh2YWx1ZSwgdW5kZWZpbmVkLCBjdHgpO1xuICAgIHJldHVybiBuZXcgUGFpcihrLCB2KTtcbn1cbmNsYXNzIFBhaXIge1xuICAgIGNvbnN0cnVjdG9yKGtleSwgdmFsdWUgPSBudWxsKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpZGVudGl0eS5OT0RFX1RZUEUsIHsgdmFsdWU6IGlkZW50aXR5LlBBSVIgfSk7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGNsb25lKHNjaGVtYSkge1xuICAgICAgICBsZXQgeyBrZXksIHZhbHVlIH0gPSB0aGlzO1xuICAgICAgICBpZiAoaWRlbnRpdHkuaXNOb2RlKGtleSkpXG4gICAgICAgICAgICBrZXkgPSBrZXkuY2xvbmUoc2NoZW1hKTtcbiAgICAgICAgaWYgKGlkZW50aXR5LmlzTm9kZSh2YWx1ZSkpXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmNsb25lKHNjaGVtYSk7XG4gICAgICAgIHJldHVybiBuZXcgUGFpcihrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgdG9KU09OKF8sIGN0eCkge1xuICAgICAgICBjb25zdCBwYWlyID0gY3R4Py5tYXBBc01hcCA/IG5ldyBNYXAoKSA6IHt9O1xuICAgICAgICByZXR1cm4gYWRkUGFpclRvSlNNYXAuYWRkUGFpclRvSlNNYXAoY3R4LCBwYWlyLCB0aGlzKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgICAgIHJldHVybiBjdHg/LmRvY1xuICAgICAgICAgICAgPyBzdHJpbmdpZnlQYWlyLnN0cmluZ2lmeVBhaXIodGhpcywgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKVxuICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICB9XG59XG5cbmV4cG9ydHMuUGFpciA9IFBhaXI7XG5leHBvcnRzLmNyZWF0ZVBhaXIgPSBjcmVhdGVQYWlyO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4uL25vZGVzL2lkZW50aXR5LmpzJyk7XG52YXIgc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9zdHJpbmdpZnkuanMnKTtcbnZhciBzdHJpbmdpZnlDb21tZW50ID0gcmVxdWlyZSgnLi9zdHJpbmdpZnlDb21tZW50LmpzJyk7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUNvbGxlY3Rpb24oY29sbGVjdGlvbiwgY3R4LCBvcHRpb25zKSB7XG4gICAgY29uc3QgZmxvdyA9IGN0eC5pbkZsb3cgPz8gY29sbGVjdGlvbi5mbG93O1xuICAgIGNvbnN0IHN0cmluZ2lmeSA9IGZsb3cgPyBzdHJpbmdpZnlGbG93Q29sbGVjdGlvbiA6IHN0cmluZ2lmeUJsb2NrQ29sbGVjdGlvbjtcbiAgICByZXR1cm4gc3RyaW5naWZ5KGNvbGxlY3Rpb24sIGN0eCwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlCbG9ja0NvbGxlY3Rpb24oeyBjb21tZW50LCBpdGVtcyB9LCBjdHgsIHsgYmxvY2tJdGVtUHJlZml4LCBmbG93Q2hhcnMsIGl0ZW1JbmRlbnQsIG9uQ2hvbXBLZWVwLCBvbkNvbW1lbnQgfSkge1xuICAgIGNvbnN0IHsgaW5kZW50LCBvcHRpb25zOiB7IGNvbW1lbnRTdHJpbmcgfSB9ID0gY3R4O1xuICAgIGNvbnN0IGl0ZW1DdHggPSBPYmplY3QuYXNzaWduKHt9LCBjdHgsIHsgaW5kZW50OiBpdGVtSW5kZW50LCB0eXBlOiBudWxsIH0pO1xuICAgIGxldCBjaG9tcEtlZXAgPSBmYWxzZTsgLy8gZmxhZyBmb3IgdGhlIHByZWNlZGluZyBub2RlJ3Mgc3RhdHVzXG4gICAgY29uc3QgbGluZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgbGV0IGNvbW1lbnQgPSBudWxsO1xuICAgICAgICBpZiAoaWRlbnRpdHkuaXNOb2RlKGl0ZW0pKSB7XG4gICAgICAgICAgICBpZiAoIWNob21wS2VlcCAmJiBpdGVtLnNwYWNlQmVmb3JlKVxuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goJycpO1xuICAgICAgICAgICAgYWRkQ29tbWVudEJlZm9yZShjdHgsIGxpbmVzLCBpdGVtLmNvbW1lbnRCZWZvcmUsIGNob21wS2VlcCk7XG4gICAgICAgICAgICBpZiAoaXRlbS5jb21tZW50KVxuICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBpdGVtLmNvbW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaWRlbnRpdHkuaXNQYWlyKGl0ZW0pKSB7XG4gICAgICAgICAgICBjb25zdCBpayA9IGlkZW50aXR5LmlzTm9kZShpdGVtLmtleSkgPyBpdGVtLmtleSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoaWspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNob21wS2VlcCAmJiBpay5zcGFjZUJlZm9yZSlcbiAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaCgnJyk7XG4gICAgICAgICAgICAgICAgYWRkQ29tbWVudEJlZm9yZShjdHgsIGxpbmVzLCBpay5jb21tZW50QmVmb3JlLCBjaG9tcEtlZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNob21wS2VlcCA9IGZhbHNlO1xuICAgICAgICBsZXQgc3RyID0gc3RyaW5naWZ5LnN0cmluZ2lmeShpdGVtLCBpdGVtQ3R4LCAoKSA9PiAoY29tbWVudCA9IG51bGwpLCAoKSA9PiAoY2hvbXBLZWVwID0gdHJ1ZSkpO1xuICAgICAgICBpZiAoY29tbWVudClcbiAgICAgICAgICAgIHN0ciArPSBzdHJpbmdpZnlDb21tZW50LmxpbmVDb21tZW50KHN0ciwgaXRlbUluZGVudCwgY29tbWVudFN0cmluZyhjb21tZW50KSk7XG4gICAgICAgIGlmIChjaG9tcEtlZXAgJiYgY29tbWVudClcbiAgICAgICAgICAgIGNob21wS2VlcCA9IGZhbHNlO1xuICAgICAgICBsaW5lcy5wdXNoKGJsb2NrSXRlbVByZWZpeCArIHN0cik7XG4gICAgfVxuICAgIGxldCBzdHI7XG4gICAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzdHIgPSBmbG93Q2hhcnMuc3RhcnQgKyBmbG93Q2hhcnMuZW5kO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RyID0gbGluZXNbMF07XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgICAgICAgIHN0ciArPSBsaW5lID8gYFxcbiR7aW5kZW50fSR7bGluZX1gIDogJ1xcbic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgICAgc3RyICs9ICdcXG4nICsgc3RyaW5naWZ5Q29tbWVudC5pbmRlbnRDb21tZW50KGNvbW1lbnRTdHJpbmcoY29tbWVudCksIGluZGVudCk7XG4gICAgICAgIGlmIChvbkNvbW1lbnQpXG4gICAgICAgICAgICBvbkNvbW1lbnQoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hvbXBLZWVwICYmIG9uQ2hvbXBLZWVwKVxuICAgICAgICBvbkNob21wS2VlcCgpO1xuICAgIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlGbG93Q29sbGVjdGlvbih7IGl0ZW1zIH0sIGN0eCwgeyBmbG93Q2hhcnMsIGl0ZW1JbmRlbnQgfSkge1xuICAgIGNvbnN0IHsgaW5kZW50LCBpbmRlbnRTdGVwLCBmbG93Q29sbGVjdGlvblBhZGRpbmc6IGZjUGFkZGluZywgb3B0aW9uczogeyBjb21tZW50U3RyaW5nIH0gfSA9IGN0eDtcbiAgICBpdGVtSW5kZW50ICs9IGluZGVudFN0ZXA7XG4gICAgY29uc3QgaXRlbUN0eCA9IE9iamVjdC5hc3NpZ24oe30sIGN0eCwge1xuICAgICAgICBpbmRlbnQ6IGl0ZW1JbmRlbnQsXG4gICAgICAgIGluRmxvdzogdHJ1ZSxcbiAgICAgICAgdHlwZTogbnVsbFxuICAgIH0pO1xuICAgIGxldCByZXFOZXdsaW5lID0gZmFsc2U7XG4gICAgbGV0IGxpbmVzQXRWYWx1ZSA9IDA7XG4gICAgY29uc3QgbGluZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgbGV0IGNvbW1lbnQgPSBudWxsO1xuICAgICAgICBpZiAoaWRlbnRpdHkuaXNOb2RlKGl0ZW0pKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5zcGFjZUJlZm9yZSlcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICAgICAgICAgIGFkZENvbW1lbnRCZWZvcmUoY3R4LCBsaW5lcywgaXRlbS5jb21tZW50QmVmb3JlLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoaXRlbS5jb21tZW50KVxuICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBpdGVtLmNvbW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaWRlbnRpdHkuaXNQYWlyKGl0ZW0pKSB7XG4gICAgICAgICAgICBjb25zdCBpayA9IGlkZW50aXR5LmlzTm9kZShpdGVtLmtleSkgPyBpdGVtLmtleSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoaWspIHtcbiAgICAgICAgICAgICAgICBpZiAoaWsuc3BhY2VCZWZvcmUpXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goJycpO1xuICAgICAgICAgICAgICAgIGFkZENvbW1lbnRCZWZvcmUoY3R4LCBsaW5lcywgaWsuY29tbWVudEJlZm9yZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmIChpay5jb21tZW50KVxuICAgICAgICAgICAgICAgICAgICByZXFOZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGl2ID0gaWRlbnRpdHkuaXNOb2RlKGl0ZW0udmFsdWUpID8gaXRlbS52YWx1ZSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoaXYpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXYuY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IGl2LmNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgaWYgKGl2LmNvbW1lbnRCZWZvcmUpXG4gICAgICAgICAgICAgICAgICAgIHJlcU5ld2xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbS52YWx1ZSA9PSBudWxsICYmIGlrPy5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgY29tbWVudCA9IGlrLmNvbW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbW1lbnQpXG4gICAgICAgICAgICByZXFOZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgbGV0IHN0ciA9IHN0cmluZ2lmeS5zdHJpbmdpZnkoaXRlbSwgaXRlbUN0eCwgKCkgPT4gKGNvbW1lbnQgPSBudWxsKSk7XG4gICAgICAgIGlmIChpIDwgaXRlbXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgIHN0ciArPSAnLCc7XG4gICAgICAgIGlmIChjb21tZW50KVxuICAgICAgICAgICAgc3RyICs9IHN0cmluZ2lmeUNvbW1lbnQubGluZUNvbW1lbnQoc3RyLCBpdGVtSW5kZW50LCBjb21tZW50U3RyaW5nKGNvbW1lbnQpKTtcbiAgICAgICAgaWYgKCFyZXFOZXdsaW5lICYmIChsaW5lcy5sZW5ndGggPiBsaW5lc0F0VmFsdWUgfHwgc3RyLmluY2x1ZGVzKCdcXG4nKSkpXG4gICAgICAgICAgICByZXFOZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgbGluZXMucHVzaChzdHIpO1xuICAgICAgICBsaW5lc0F0VmFsdWUgPSBsaW5lcy5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gZmxvd0NoYXJzO1xuICAgIGlmIChsaW5lcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHN0YXJ0ICsgZW5kO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFyZXFOZXdsaW5lKSB7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBsaW5lcy5yZWR1Y2UoKHN1bSwgbGluZSkgPT4gc3VtICsgbGluZS5sZW5ndGggKyAyLCAyKTtcbiAgICAgICAgICAgIHJlcU5ld2xpbmUgPSBjdHgub3B0aW9ucy5saW5lV2lkdGggPiAwICYmIGxlbiA+IGN0eC5vcHRpb25zLmxpbmVXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxTmV3bGluZSkge1xuICAgICAgICAgICAgbGV0IHN0ciA9IHN0YXJ0O1xuICAgICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKVxuICAgICAgICAgICAgICAgIHN0ciArPSBsaW5lID8gYFxcbiR7aW5kZW50U3RlcH0ke2luZGVudH0ke2xpbmV9YCA6ICdcXG4nO1xuICAgICAgICAgICAgcmV0dXJuIGAke3N0cn1cXG4ke2luZGVudH0ke2VuZH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGAke3N0YXJ0fSR7ZmNQYWRkaW5nfSR7bGluZXMuam9pbignICcpfSR7ZmNQYWRkaW5nfSR7ZW5kfWA7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBhZGRDb21tZW50QmVmb3JlKHsgaW5kZW50LCBvcHRpb25zOiB7IGNvbW1lbnRTdHJpbmcgfSB9LCBsaW5lcywgY29tbWVudCwgY2hvbXBLZWVwKSB7XG4gICAgaWYgKGNvbW1lbnQgJiYgY2hvbXBLZWVwKVxuICAgICAgICBjb21tZW50ID0gY29tbWVudC5yZXBsYWNlKC9eXFxuKy8sICcnKTtcbiAgICBpZiAoY29tbWVudCkge1xuICAgICAgICBjb25zdCBpYyA9IHN0cmluZ2lmeUNvbW1lbnQuaW5kZW50Q29tbWVudChjb21tZW50U3RyaW5nKGNvbW1lbnQpLCBpbmRlbnQpO1xuICAgICAgICBsaW5lcy5wdXNoKGljLnRyaW1TdGFydCgpKTsgLy8gQXZvaWQgZG91YmxlIGluZGVudCBvbiBmaXJzdCBsaW5lXG4gICAgfVxufVxuXG5leHBvcnRzLnN0cmluZ2lmeUNvbGxlY3Rpb24gPSBzdHJpbmdpZnlDb2xsZWN0aW9uO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vc3RyaW5naWZ5L3N0cmluZ2lmeUNvbGxlY3Rpb24uanMnKTtcbnZhciBhZGRQYWlyVG9KU01hcCA9IHJlcXVpcmUoJy4vYWRkUGFpclRvSlNNYXAuanMnKTtcbnZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi9Db2xsZWN0aW9uLmpzJyk7XG52YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5LmpzJyk7XG52YXIgUGFpciA9IHJlcXVpcmUoJy4vUGFpci5qcycpO1xudmFyIFNjYWxhciA9IHJlcXVpcmUoJy4vU2NhbGFyLmpzJyk7XG5cbmZ1bmN0aW9uIGZpbmRQYWlyKGl0ZW1zLCBrZXkpIHtcbiAgICBjb25zdCBrID0gaWRlbnRpdHkuaXNTY2FsYXIoa2V5KSA/IGtleS52YWx1ZSA6IGtleTtcbiAgICBmb3IgKGNvbnN0IGl0IG9mIGl0ZW1zKSB7XG4gICAgICAgIGlmIChpZGVudGl0eS5pc1BhaXIoaXQpKSB7XG4gICAgICAgICAgICBpZiAoaXQua2V5ID09PSBrZXkgfHwgaXQua2V5ID09PSBrKVxuICAgICAgICAgICAgICAgIHJldHVybiBpdDtcbiAgICAgICAgICAgIGlmIChpZGVudGl0eS5pc1NjYWxhcihpdC5rZXkpICYmIGl0LmtleS52YWx1ZSA9PT0gaylcbiAgICAgICAgICAgICAgICByZXR1cm4gaXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmNsYXNzIFlBTUxNYXAgZXh0ZW5kcyBDb2xsZWN0aW9uLkNvbGxlY3Rpb24ge1xuICAgIHN0YXRpYyBnZXQgdGFnTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICd0YWc6eWFtbC5vcmcsMjAwMjptYXAnO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEpIHtcbiAgICAgICAgc3VwZXIoaWRlbnRpdHkuTUFQLCBzY2hlbWEpO1xuICAgICAgICB0aGlzLml0ZW1zID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgZ2VuZXJpYyBjb2xsZWN0aW9uIHBhcnNpbmcgbWV0aG9kIHRoYXQgY2FuIGJlIGV4dGVuZGVkXG4gICAgICogdG8gb3RoZXIgbm9kZSBjbGFzc2VzIHRoYXQgaW5oZXJpdCBmcm9tIFlBTUxNYXBcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShzY2hlbWEsIG9iaiwgY3R4KSB7XG4gICAgICAgIGNvbnN0IHsga2VlcFVuZGVmaW5lZCwgcmVwbGFjZXIgfSA9IGN0eDtcbiAgICAgICAgY29uc3QgbWFwID0gbmV3IHRoaXMoc2NoZW1hKTtcbiAgICAgICAgY29uc3QgYWRkID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSByZXBsYWNlci5jYWxsKG9iaiwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlcGxhY2VyKSAmJiAhcmVwbGFjZXIuaW5jbHVkZXMoa2V5KSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCB8fCBrZWVwVW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKFBhaXIuY3JlYXRlUGFpcihrZXksIHZhbHVlLCBjdHgpKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygb2JqKVxuICAgICAgICAgICAgICAgIGFkZChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpXG4gICAgICAgICAgICAgICAgYWRkKGtleSwgb2JqW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLnNvcnRNYXBFbnRyaWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtYXAuaXRlbXMuc29ydChzY2hlbWEuc29ydE1hcEVudHJpZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSB2YWx1ZSB0byB0aGUgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvdmVyd3JpdGUgLSBJZiBub3Qgc2V0IGB0cnVlYCwgdXNpbmcgYSBrZXkgdGhhdCBpcyBhbHJlYWR5IGluIHRoZVxuICAgICAqICAgY29sbGVjdGlvbiB3aWxsIHRocm93LiBPdGhlcndpc2UsIG92ZXJ3cml0ZXMgdGhlIHByZXZpb3VzIHZhbHVlLlxuICAgICAqL1xuICAgIGFkZChwYWlyLCBvdmVyd3JpdGUpIHtcbiAgICAgICAgbGV0IF9wYWlyO1xuICAgICAgICBpZiAoaWRlbnRpdHkuaXNQYWlyKHBhaXIpKVxuICAgICAgICAgICAgX3BhaXIgPSBwYWlyO1xuICAgICAgICBlbHNlIGlmICghcGFpciB8fCB0eXBlb2YgcGFpciAhPT0gJ29iamVjdCcgfHwgISgna2V5JyBpbiBwYWlyKSkge1xuICAgICAgICAgICAgLy8gSW4gVHlwZVNjcmlwdCwgdGhpcyBuZXZlciBoYXBwZW5zLlxuICAgICAgICAgICAgX3BhaXIgPSBuZXcgUGFpci5QYWlyKHBhaXIsIHBhaXI/LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBfcGFpciA9IG5ldyBQYWlyLlBhaXIocGFpci5rZXksIHBhaXIudmFsdWUpO1xuICAgICAgICBjb25zdCBwcmV2ID0gZmluZFBhaXIodGhpcy5pdGVtcywgX3BhaXIua2V5KTtcbiAgICAgICAgY29uc3Qgc29ydEVudHJpZXMgPSB0aGlzLnNjaGVtYT8uc29ydE1hcEVudHJpZXM7XG4gICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICBpZiAoIW92ZXJ3cml0ZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleSAke19wYWlyLmtleX0gYWxyZWFkeSBzZXRgKTtcbiAgICAgICAgICAgIC8vIEZvciBzY2FsYXJzLCBrZWVwIHRoZSBvbGQgbm9kZSAmIGl0cyBjb21tZW50cyBhbmQgYW5jaG9yc1xuICAgICAgICAgICAgaWYgKGlkZW50aXR5LmlzU2NhbGFyKHByZXYudmFsdWUpICYmIFNjYWxhci5pc1NjYWxhclZhbHVlKF9wYWlyLnZhbHVlKSlcbiAgICAgICAgICAgICAgICBwcmV2LnZhbHVlLnZhbHVlID0gX3BhaXIudmFsdWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcHJldi52YWx1ZSA9IF9wYWlyLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNvcnRFbnRyaWVzKSB7XG4gICAgICAgICAgICBjb25zdCBpID0gdGhpcy5pdGVtcy5maW5kSW5kZXgoaXRlbSA9PiBzb3J0RW50cmllcyhfcGFpciwgaXRlbSkgPCAwKTtcbiAgICAgICAgICAgIGlmIChpID09PSAtMSlcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW1zLnB1c2goX3BhaXIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuaXRlbXMuc3BsaWNlKGksIDAsIF9wYWlyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXMucHVzaChfcGFpcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICBjb25zdCBpdCA9IGZpbmRQYWlyKHRoaXMuaXRlbXMsIGtleSk7XG4gICAgICAgIGlmICghaXQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGRlbCA9IHRoaXMuaXRlbXMuc3BsaWNlKHRoaXMuaXRlbXMuaW5kZXhPZihpdCksIDEpO1xuICAgICAgICByZXR1cm4gZGVsLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIGdldChrZXksIGtlZXBTY2FsYXIpIHtcbiAgICAgICAgY29uc3QgaXQgPSBmaW5kUGFpcih0aGlzLml0ZW1zLCBrZXkpO1xuICAgICAgICBjb25zdCBub2RlID0gaXQ/LnZhbHVlO1xuICAgICAgICByZXR1cm4gKCFrZWVwU2NhbGFyICYmIGlkZW50aXR5LmlzU2NhbGFyKG5vZGUpID8gbm9kZS52YWx1ZSA6IG5vZGUpID8/IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gISFmaW5kUGFpcih0aGlzLml0ZW1zLCBrZXkpO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmFkZChuZXcgUGFpci5QYWlyKGtleSwgdmFsdWUpLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGN0eCAtIENvbnZlcnNpb24gY29udGV4dCwgb3JpZ2luYWxseSBzZXQgaW4gRG9jdW1lbnQjdG9KUygpXG4gICAgICogQHBhcmFtIHtDbGFzc30gVHlwZSAtIElmIHNldCwgZm9yY2VzIHRoZSByZXR1cm5lZCBjb2xsZWN0aW9uIHR5cGVcbiAgICAgKiBAcmV0dXJucyBJbnN0YW5jZSBvZiBUeXBlLCBNYXAsIG9yIE9iamVjdFxuICAgICAqL1xuICAgIHRvSlNPTihfLCBjdHgsIFR5cGUpIHtcbiAgICAgICAgY29uc3QgbWFwID0gVHlwZSA/IG5ldyBUeXBlKCkgOiBjdHg/Lm1hcEFzTWFwID8gbmV3IE1hcCgpIDoge307XG4gICAgICAgIGlmIChjdHg/Lm9uQ3JlYXRlKVxuICAgICAgICAgICAgY3R4Lm9uQ3JlYXRlKG1hcCk7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLml0ZW1zKVxuICAgICAgICAgICAgYWRkUGFpclRvSlNNYXAuYWRkUGFpclRvSlNNYXAoY3R4LCBtYXAsIGl0ZW0pO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICB0b1N0cmluZyhjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICAgICAgaWYgKCFjdHgpXG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLml0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoIWlkZW50aXR5LmlzUGFpcihpdGVtKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1hcCBpdGVtcyBtdXN0IGFsbCBiZSBwYWlyczsgZm91bmQgJHtKU09OLnN0cmluZ2lmeShpdGVtKX0gaW5zdGVhZGApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY3R4LmFsbE51bGxWYWx1ZXMgJiYgdGhpcy5oYXNBbGxOdWxsVmFsdWVzKGZhbHNlKSlcbiAgICAgICAgICAgIGN0eCA9IE9iamVjdC5hc3NpZ24oe30sIGN0eCwgeyBhbGxOdWxsVmFsdWVzOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4gc3RyaW5naWZ5Q29sbGVjdGlvbi5zdHJpbmdpZnlDb2xsZWN0aW9uKHRoaXMsIGN0eCwge1xuICAgICAgICAgICAgYmxvY2tJdGVtUHJlZml4OiAnJyxcbiAgICAgICAgICAgIGZsb3dDaGFyczogeyBzdGFydDogJ3snLCBlbmQ6ICd9JyB9LFxuICAgICAgICAgICAgaXRlbUluZGVudDogY3R4LmluZGVudCB8fCAnJyxcbiAgICAgICAgICAgIG9uQ2hvbXBLZWVwLFxuICAgICAgICAgICAgb25Db21tZW50XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZXhwb3J0cy5ZQU1MTWFwID0gWUFNTE1hcDtcbmV4cG9ydHMuZmluZFBhaXIgPSBmaW5kUGFpcjtcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuLi8uLi9ub2Rlcy9pZGVudGl0eS5qcycpO1xudmFyIFlBTUxNYXAgPSByZXF1aXJlKCcuLi8uLi9ub2Rlcy9ZQU1MTWFwLmpzJyk7XG5cbmNvbnN0IG1hcCA9IHtcbiAgICBjb2xsZWN0aW9uOiAnbWFwJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIG5vZGVDbGFzczogWUFNTE1hcC5ZQU1MTWFwLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOm1hcCcsXG4gICAgcmVzb2x2ZShtYXAsIG9uRXJyb3IpIHtcbiAgICAgICAgaWYgKCFpZGVudGl0eS5pc01hcChtYXApKVxuICAgICAgICAgICAgb25FcnJvcignRXhwZWN0ZWQgYSBtYXBwaW5nIGZvciB0aGlzIHRhZycpO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH0sXG4gICAgY3JlYXRlTm9kZTogKHNjaGVtYSwgb2JqLCBjdHgpID0+IFlBTUxNYXAuWUFNTE1hcC5mcm9tKHNjaGVtYSwgb2JqLCBjdHgpXG59O1xuXG5leHBvcnRzLm1hcCA9IG1hcDtcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlTm9kZSA9IHJlcXVpcmUoJy4uL2RvYy9jcmVhdGVOb2RlLmpzJyk7XG52YXIgc3RyaW5naWZ5Q29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uL3N0cmluZ2lmeS9zdHJpbmdpZnlDb2xsZWN0aW9uLmpzJyk7XG52YXIgQ29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vQ29sbGVjdGlvbi5qcycpO1xudmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eS5qcycpO1xudmFyIFNjYWxhciA9IHJlcXVpcmUoJy4vU2NhbGFyLmpzJyk7XG52YXIgdG9KUyA9IHJlcXVpcmUoJy4vdG9KUy5qcycpO1xuXG5jbGFzcyBZQU1MU2VxIGV4dGVuZHMgQ29sbGVjdGlvbi5Db2xsZWN0aW9uIHtcbiAgICBzdGF0aWMgZ2V0IHRhZ05hbWUoKSB7XG4gICAgICAgIHJldHVybiAndGFnOnlhbWwub3JnLDIwMDI6c2VxJztcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc2NoZW1hKSB7XG4gICAgICAgIHN1cGVyKGlkZW50aXR5LlNFUSwgc2NoZW1hKTtcbiAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgIH1cbiAgICBhZGQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5pdGVtcy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHZhbHVlIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBga2V5YCBtdXN0IGNvbnRhaW4gYSByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnRlZ2VyIGZvciB0aGlzIHRvIHN1Y2NlZWQuXG4gICAgICogSXQgbWF5IGJlIHdyYXBwZWQgaW4gYSBgU2NhbGFyYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgaXRlbSB3YXMgZm91bmQgYW5kIHJlbW92ZWQuXG4gICAgICovXG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICBjb25zdCBpZHggPSBhc0l0ZW1JbmRleChrZXkpO1xuICAgICAgICBpZiAodHlwZW9mIGlkeCAhPT0gJ251bWJlcicpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGRlbCA9IHRoaXMuaXRlbXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIHJldHVybiBkZWwubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgZ2V0KGtleSwga2VlcFNjYWxhcikge1xuICAgICAgICBjb25zdCBpZHggPSBhc0l0ZW1JbmRleChrZXkpO1xuICAgICAgICBpZiAodHlwZW9mIGlkeCAhPT0gJ251bWJlcicpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBpdCA9IHRoaXMuaXRlbXNbaWR4XTtcbiAgICAgICAgcmV0dXJuICFrZWVwU2NhbGFyICYmIGlkZW50aXR5LmlzU2NhbGFyKGl0KSA/IGl0LnZhbHVlIDogaXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgY29sbGVjdGlvbiBpbmNsdWRlcyBhIHZhbHVlIHdpdGggdGhlIGtleSBga2V5YC5cbiAgICAgKlxuICAgICAqIGBrZXlgIG11c3QgY29udGFpbiBhIHJlcHJlc2VudGF0aW9uIG9mIGFuIGludGVnZXIgZm9yIHRoaXMgdG8gc3VjY2VlZC5cbiAgICAgKiBJdCBtYXkgYmUgd3JhcHBlZCBpbiBhIGBTY2FsYXJgLlxuICAgICAqL1xuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gYXNJdGVtSW5kZXgoa2V5KTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBpZHggPT09ICdudW1iZXInICYmIGlkeCA8IHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgdmFsdWUgaW4gdGhpcyBjb2xsZWN0aW9uLiBGb3IgYCEhc2V0YCwgYHZhbHVlYCBuZWVkcyB0byBiZSBhXG4gICAgICogYm9vbGVhbiB0byBhZGQvcmVtb3ZlIHRoZSBpdGVtIGZyb20gdGhlIHNldC5cbiAgICAgKlxuICAgICAqIElmIGBrZXlgIGRvZXMgbm90IGNvbnRhaW4gYSByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnRlZ2VyLCB0aGlzIHdpbGwgdGhyb3cuXG4gICAgICogSXQgbWF5IGJlIHdyYXBwZWQgaW4gYSBgU2NhbGFyYC5cbiAgICAgKi9cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBpZHggPSBhc0l0ZW1JbmRleChrZXkpO1xuICAgICAgICBpZiAodHlwZW9mIGlkeCAhPT0gJ251bWJlcicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgdmFsaWQgaW5kZXgsIG5vdCAke2tleX0uYCk7XG4gICAgICAgIGNvbnN0IHByZXYgPSB0aGlzLml0ZW1zW2lkeF07XG4gICAgICAgIGlmIChpZGVudGl0eS5pc1NjYWxhcihwcmV2KSAmJiBTY2FsYXIuaXNTY2FsYXJWYWx1ZSh2YWx1ZSkpXG4gICAgICAgICAgICBwcmV2LnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuaXRlbXNbaWR4XSA9IHZhbHVlO1xuICAgIH1cbiAgICB0b0pTT04oXywgY3R4KSB7XG4gICAgICAgIGNvbnN0IHNlcSA9IFtdO1xuICAgICAgICBpZiAoY3R4Py5vbkNyZWF0ZSlcbiAgICAgICAgICAgIGN0eC5vbkNyZWF0ZShzZXEpO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLml0ZW1zKVxuICAgICAgICAgICAgc2VxLnB1c2godG9KUy50b0pTKGl0ZW0sIFN0cmluZyhpKyspLCBjdHgpKTtcbiAgICAgICAgcmV0dXJuIHNlcTtcbiAgICB9XG4gICAgdG9TdHJpbmcoY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgICAgIGlmICghY3R4KVxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgICAgICByZXR1cm4gc3RyaW5naWZ5Q29sbGVjdGlvbi5zdHJpbmdpZnlDb2xsZWN0aW9uKHRoaXMsIGN0eCwge1xuICAgICAgICAgICAgYmxvY2tJdGVtUHJlZml4OiAnLSAnLFxuICAgICAgICAgICAgZmxvd0NoYXJzOiB7IHN0YXJ0OiAnWycsIGVuZDogJ10nIH0sXG4gICAgICAgICAgICBpdGVtSW5kZW50OiAoY3R4LmluZGVudCB8fCAnJykgKyAnICAnLFxuICAgICAgICAgICAgb25DaG9tcEtlZXAsXG4gICAgICAgICAgICBvbkNvbW1lbnRcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHNjaGVtYSwgb2JqLCBjdHgpIHtcbiAgICAgICAgY29uc3QgeyByZXBsYWNlciB9ID0gY3R4O1xuICAgICAgICBjb25zdCBzZXEgPSBuZXcgdGhpcyhzY2hlbWEpO1xuICAgICAgICBpZiAob2JqICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3Qob2JqKSkge1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaXQgb2Ygb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBvYmogaW5zdGFuY2VvZiBTZXQgPyBpdCA6IFN0cmluZyhpKyspO1xuICAgICAgICAgICAgICAgICAgICBpdCA9IHJlcGxhY2VyLmNhbGwob2JqLCBrZXksIGl0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VxLml0ZW1zLnB1c2goY3JlYXRlTm9kZS5jcmVhdGVOb2RlKGl0LCB1bmRlZmluZWQsIGN0eCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXE7XG4gICAgfVxufVxuZnVuY3Rpb24gYXNJdGVtSW5kZXgoa2V5KSB7XG4gICAgbGV0IGlkeCA9IGlkZW50aXR5LmlzU2NhbGFyKGtleSkgPyBrZXkudmFsdWUgOiBrZXk7XG4gICAgaWYgKGlkeCAmJiB0eXBlb2YgaWR4ID09PSAnc3RyaW5nJylcbiAgICAgICAgaWR4ID0gTnVtYmVyKGlkeCk7XG4gICAgcmV0dXJuIHR5cGVvZiBpZHggPT09ICdudW1iZXInICYmIE51bWJlci5pc0ludGVnZXIoaWR4KSAmJiBpZHggPj0gMFxuICAgICAgICA/IGlkeFxuICAgICAgICA6IG51bGw7XG59XG5cbmV4cG9ydHMuWUFNTFNlcSA9IFlBTUxTZXE7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi4vLi4vbm9kZXMvaWRlbnRpdHkuanMnKTtcbnZhciBZQU1MU2VxID0gcmVxdWlyZSgnLi4vLi4vbm9kZXMvWUFNTFNlcS5qcycpO1xuXG5jb25zdCBzZXEgPSB7XG4gICAgY29sbGVjdGlvbjogJ3NlcScsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICBub2RlQ2xhc3M6IFlBTUxTZXEuWUFNTFNlcSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpzZXEnLFxuICAgIHJlc29sdmUoc2VxLCBvbkVycm9yKSB7XG4gICAgICAgIGlmICghaWRlbnRpdHkuaXNTZXEoc2VxKSlcbiAgICAgICAgICAgIG9uRXJyb3IoJ0V4cGVjdGVkIGEgc2VxdWVuY2UgZm9yIHRoaXMgdGFnJyk7XG4gICAgICAgIHJldHVybiBzZXE7XG4gICAgfSxcbiAgICBjcmVhdGVOb2RlOiAoc2NoZW1hLCBvYmosIGN0eCkgPT4gWUFNTFNlcS5ZQU1MU2VxLmZyb20oc2NoZW1hLCBvYmosIGN0eClcbn07XG5cbmV4cG9ydHMuc2VxID0gc2VxO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlTdHJpbmcgPSByZXF1aXJlKCcuLi8uLi9zdHJpbmdpZnkvc3RyaW5naWZ5U3RyaW5nLmpzJyk7XG5cbmNvbnN0IHN0cmluZyA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsXG4gICAgcmVzb2x2ZTogc3RyID0+IHN0cixcbiAgICBzdHJpbmdpZnkoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgICAgIGN0eCA9IE9iamVjdC5hc3NpZ24oeyBhY3R1YWxTdHJpbmc6IHRydWUgfSwgY3R4KTtcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeVN0cmluZy5zdHJpbmdpZnlTdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICB9XG59O1xuXG5leHBvcnRzLnN0cmluZyA9IHN0cmluZztcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgU2NhbGFyID0gcmVxdWlyZSgnLi4vLi4vbm9kZXMvU2NhbGFyLmpzJyk7XG5cbmNvbnN0IG51bGxUYWcgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlID09IG51bGwsXG4gICAgY3JlYXRlTm9kZTogKCkgPT4gbmV3IFNjYWxhci5TY2FsYXIobnVsbCksXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpudWxsJyxcbiAgICB0ZXN0OiAvXig/On58W05uXXVsbHxOVUxMKT8kLyxcbiAgICByZXNvbHZlOiAoKSA9PiBuZXcgU2NhbGFyLlNjYWxhcihudWxsKSxcbiAgICBzdHJpbmdpZnk6ICh7IHNvdXJjZSB9LCBjdHgpID0+IHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnICYmIG51bGxUYWcudGVzdC50ZXN0KHNvdXJjZSlcbiAgICAgICAgPyBzb3VyY2VcbiAgICAgICAgOiBjdHgub3B0aW9ucy5udWxsU3RyXG59O1xuXG5leHBvcnRzLm51bGxUYWcgPSBudWxsVGFnO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBTY2FsYXIgPSByZXF1aXJlKCcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnKTtcblxuY29uc3QgYm9vbFRhZyA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpib29sJyxcbiAgICB0ZXN0OiAvXig/OltUdF1ydWV8VFJVRXxbRmZdYWxzZXxGQUxTRSkkLyxcbiAgICByZXNvbHZlOiBzdHIgPT4gbmV3IFNjYWxhci5TY2FsYXIoc3RyWzBdID09PSAndCcgfHwgc3RyWzBdID09PSAnVCcpLFxuICAgIHN0cmluZ2lmeSh7IHNvdXJjZSwgdmFsdWUgfSwgY3R4KSB7XG4gICAgICAgIGlmIChzb3VyY2UgJiYgYm9vbFRhZy50ZXN0LnRlc3Qoc291cmNlKSkge1xuICAgICAgICAgICAgY29uc3Qgc3YgPSBzb3VyY2VbMF0gPT09ICd0JyB8fCBzb3VyY2VbMF0gPT09ICdUJztcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gc3YpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUgPyBjdHgub3B0aW9ucy50cnVlU3RyIDogY3R4Lm9wdGlvbnMuZmFsc2VTdHI7XG4gICAgfVxufTtcblxuZXhwb3J0cy5ib29sVGFnID0gYm9vbFRhZztcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBzdHJpbmdpZnlOdW1iZXIoeyBmb3JtYXQsIG1pbkZyYWN0aW9uRGlnaXRzLCB0YWcsIHZhbHVlIH0pIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JylcbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgY29uc3QgbnVtID0gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IHZhbHVlIDogTnVtYmVyKHZhbHVlKTtcbiAgICBpZiAoIWlzRmluaXRlKG51bSkpXG4gICAgICAgIHJldHVybiBpc05hTihudW0pID8gJy5uYW4nIDogbnVtIDwgMCA/ICctLmluZicgOiAnLmluZic7XG4gICAgbGV0IG4gPSBPYmplY3QuaXModmFsdWUsIC0wKSA/ICctMCcgOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgaWYgKCFmb3JtYXQgJiZcbiAgICAgICAgbWluRnJhY3Rpb25EaWdpdHMgJiZcbiAgICAgICAgKCF0YWcgfHwgdGFnID09PSAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnKSAmJlxuICAgICAgICAvXlxcZC8udGVzdChuKSkge1xuICAgICAgICBsZXQgaSA9IG4uaW5kZXhPZignLicpO1xuICAgICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgICAgIGkgPSBuLmxlbmd0aDtcbiAgICAgICAgICAgIG4gKz0gJy4nO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkID0gbWluRnJhY3Rpb25EaWdpdHMgLSAobi5sZW5ndGggLSBpIC0gMSk7XG4gICAgICAgIHdoaWxlIChkLS0gPiAwKVxuICAgICAgICAgICAgbiArPSAnMCc7XG4gICAgfVxuICAgIHJldHVybiBuO1xufVxuXG5leHBvcnRzLnN0cmluZ2lmeU51bWJlciA9IHN0cmluZ2lmeU51bWJlcjtcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgU2NhbGFyID0gcmVxdWlyZSgnLi4vLi4vbm9kZXMvU2NhbGFyLmpzJyk7XG52YXIgc3RyaW5naWZ5TnVtYmVyID0gcmVxdWlyZSgnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeU51bWJlci5qcycpO1xuXG5jb25zdCBmbG9hdE5hTiA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgICB0ZXN0OiAvXig/OlstK10/XFwuKD86aW5mfEluZnxJTkYpfFxcLm5hbnxcXC5OYU58XFwuTkFOKSQvLFxuICAgIHJlc29sdmU6IHN0ciA9PiBzdHIuc2xpY2UoLTMpLnRvTG93ZXJDYXNlKCkgPT09ICduYW4nXG4gICAgICAgID8gTmFOXG4gICAgICAgIDogc3RyWzBdID09PSAnLSdcbiAgICAgICAgICAgID8gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXG4gICAgICAgICAgICA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeU51bWJlci5zdHJpbmdpZnlOdW1iZXJcbn07XG5jb25zdCBmbG9hdEV4cCA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgICBmb3JtYXQ6ICdFWFAnLFxuICAgIHRlc3Q6IC9eWy0rXT8oPzpcXC5bMC05XSt8WzAtOV0rKD86XFwuWzAtOV0qKT8pW2VFXVstK10/WzAtOV0rJC8sXG4gICAgcmVzb2x2ZTogc3RyID0+IHBhcnNlRmxvYXQoc3RyKSxcbiAgICBzdHJpbmdpZnkobm9kZSkge1xuICAgICAgICBjb25zdCBudW0gPSBOdW1iZXIobm9kZS52YWx1ZSk7XG4gICAgICAgIHJldHVybiBpc0Zpbml0ZShudW0pID8gbnVtLnRvRXhwb25lbnRpYWwoKSA6IHN0cmluZ2lmeU51bWJlci5zdHJpbmdpZnlOdW1iZXIobm9kZSk7XG4gICAgfVxufTtcbmNvbnN0IGZsb2F0ID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICAgIHRlc3Q6IC9eWy0rXT8oPzpcXC5bMC05XSt8WzAtOV0rXFwuWzAtOV0qKSQvLFxuICAgIHJlc29sdmUoc3RyKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgU2NhbGFyLlNjYWxhcihwYXJzZUZsb2F0KHN0cikpO1xuICAgICAgICBjb25zdCBkb3QgPSBzdHIuaW5kZXhPZignLicpO1xuICAgICAgICBpZiAoZG90ICE9PSAtMSAmJiBzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnMCcpXG4gICAgICAgICAgICBub2RlLm1pbkZyYWN0aW9uRGlnaXRzID0gc3RyLmxlbmd0aCAtIGRvdCAtIDE7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG4gICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlOdW1iZXIuc3RyaW5naWZ5TnVtYmVyXG59O1xuXG5leHBvcnRzLmZsb2F0ID0gZmxvYXQ7XG5leHBvcnRzLmZsb2F0RXhwID0gZmxvYXRFeHA7XG5leHBvcnRzLmZsb2F0TmFOID0gZmxvYXROYU47XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeU51bWJlciA9IHJlcXVpcmUoJy4uLy4uL3N0cmluZ2lmeS9zdHJpbmdpZnlOdW1iZXIuanMnKTtcblxuY29uc3QgaW50SWRlbnRpZnkgPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcgfHwgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSk7XG5jb25zdCBpbnRSZXNvbHZlID0gKHN0ciwgb2Zmc2V0LCByYWRpeCwgeyBpbnRBc0JpZ0ludCB9KSA9PiAoaW50QXNCaWdJbnQgPyBCaWdJbnQoc3RyKSA6IHBhcnNlSW50KHN0ci5zdWJzdHJpbmcob2Zmc2V0KSwgcmFkaXgpKTtcbmZ1bmN0aW9uIGludFN0cmluZ2lmeShub2RlLCByYWRpeCwgcHJlZml4KSB7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gbm9kZTtcbiAgICBpZiAoaW50SWRlbnRpZnkodmFsdWUpICYmIHZhbHVlID49IDApXG4gICAgICAgIHJldHVybiBwcmVmaXggKyB2YWx1ZS50b1N0cmluZyhyYWRpeCk7XG4gICAgcmV0dXJuIHN0cmluZ2lmeU51bWJlci5zdHJpbmdpZnlOdW1iZXIobm9kZSk7XG59XG5jb25zdCBpbnRPY3QgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IGludElkZW50aWZ5KHZhbHVlKSAmJiB2YWx1ZSA+PSAwLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICBmb3JtYXQ6ICdPQ1QnLFxuICAgIHRlc3Q6IC9eMG9bMC03XSskLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgb3B0KSA9PiBpbnRSZXNvbHZlKHN0ciwgMiwgOCwgb3B0KSxcbiAgICBzdHJpbmdpZnk6IG5vZGUgPT4gaW50U3RyaW5naWZ5KG5vZGUsIDgsICcwbycpXG59O1xuY29uc3QgaW50ID0ge1xuICAgIGlkZW50aWZ5OiBpbnRJZGVudGlmeSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gICAgdGVzdDogL15bLStdP1swLTldKyQvLFxuICAgIHJlc29sdmU6IChzdHIsIF9vbkVycm9yLCBvcHQpID0+IGludFJlc29sdmUoc3RyLCAwLCAxMCwgb3B0KSxcbiAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeU51bWJlci5zdHJpbmdpZnlOdW1iZXJcbn07XG5jb25zdCBpbnRIZXggPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IGludElkZW50aWZ5KHZhbHVlKSAmJiB2YWx1ZSA+PSAwLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICBmb3JtYXQ6ICdIRVgnLFxuICAgIHRlc3Q6IC9eMHhbMC05YS1mQS1GXSskLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgb3B0KSA9PiBpbnRSZXNvbHZlKHN0ciwgMiwgMTYsIG9wdCksXG4gICAgc3RyaW5naWZ5OiBub2RlID0+IGludFN0cmluZ2lmeShub2RlLCAxNiwgJzB4Jylcbn07XG5cbmV4cG9ydHMuaW50ID0gaW50O1xuZXhwb3J0cy5pbnRIZXggPSBpbnRIZXg7XG5leHBvcnRzLmludE9jdCA9IGludE9jdDtcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWFwID0gcmVxdWlyZSgnLi4vY29tbW9uL21hcC5qcycpO1xudmFyIF9udWxsID0gcmVxdWlyZSgnLi4vY29tbW9uL251bGwuanMnKTtcbnZhciBzZXEgPSByZXF1aXJlKCcuLi9jb21tb24vc2VxLmpzJyk7XG52YXIgc3RyaW5nID0gcmVxdWlyZSgnLi4vY29tbW9uL3N0cmluZy5qcycpO1xudmFyIGJvb2wgPSByZXF1aXJlKCcuL2Jvb2wuanMnKTtcbnZhciBmbG9hdCA9IHJlcXVpcmUoJy4vZmxvYXQuanMnKTtcbnZhciBpbnQgPSByZXF1aXJlKCcuL2ludC5qcycpO1xuXG5jb25zdCBzY2hlbWEgPSBbXG4gICAgbWFwLm1hcCxcbiAgICBzZXEuc2VxLFxuICAgIHN0cmluZy5zdHJpbmcsXG4gICAgX251bGwubnVsbFRhZyxcbiAgICBib29sLmJvb2xUYWcsXG4gICAgaW50LmludE9jdCxcbiAgICBpbnQuaW50LFxuICAgIGludC5pbnRIZXgsXG4gICAgZmxvYXQuZmxvYXROYU4sXG4gICAgZmxvYXQuZmxvYXRFeHAsXG4gICAgZmxvYXQuZmxvYXRcbl07XG5cbmV4cG9ydHMuc2NoZW1hID0gc2NoZW1hO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBTY2FsYXIgPSByZXF1aXJlKCcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnKTtcbnZhciBtYXAgPSByZXF1aXJlKCcuLi9jb21tb24vbWFwLmpzJyk7XG52YXIgc2VxID0gcmVxdWlyZSgnLi4vY29tbW9uL3NlcS5qcycpO1xuXG5mdW5jdGlvbiBpbnRJZGVudGlmeSh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnIHx8IE51bWJlci5pc0ludGVnZXIodmFsdWUpO1xufVxuY29uc3Qgc3RyaW5naWZ5SlNPTiA9ICh7IHZhbHVlIH0pID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbmNvbnN0IGpzb25TY2FsYXJzID0gW1xuICAgIHtcbiAgICAgICAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycsXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsXG4gICAgICAgIHJlc29sdmU6IHN0ciA9PiBzdHIsXG4gICAgICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5SlNPTlxuICAgIH0sXG4gICAge1xuICAgICAgICBpZGVudGlmeTogdmFsdWUgPT4gdmFsdWUgPT0gbnVsbCxcbiAgICAgICAgY3JlYXRlTm9kZTogKCkgPT4gbmV3IFNjYWxhci5TY2FsYXIobnVsbCksXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOm51bGwnLFxuICAgICAgICB0ZXN0OiAvXm51bGwkLyxcbiAgICAgICAgcmVzb2x2ZTogKCkgPT4gbnVsbCxcbiAgICAgICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlKU09OXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6Ym9vbCcsXG4gICAgICAgIHRlc3Q6IC9edHJ1ZSR8XmZhbHNlJC8sXG4gICAgICAgIHJlc29sdmU6IHN0ciA9PiBzdHIgPT09ICd0cnVlJyxcbiAgICAgICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlKU09OXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlkZW50aWZ5OiBpbnRJZGVudGlmeSxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICAgICAgdGVzdDogL14tPyg/OjB8WzEtOV1bMC05XSopJC8sXG4gICAgICAgIHJlc29sdmU6IChzdHIsIF9vbkVycm9yLCB7IGludEFzQmlnSW50IH0pID0+IGludEFzQmlnSW50ID8gQmlnSW50KHN0cikgOiBwYXJzZUludChzdHIsIDEwKSxcbiAgICAgICAgc3RyaW5naWZ5OiAoeyB2YWx1ZSB9KSA9PiBpbnRJZGVudGlmeSh2YWx1ZSkgPyB2YWx1ZS50b1N0cmluZygpIDogSlNPTi5zdHJpbmdpZnkodmFsdWUpXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsXG4gICAgICAgIHRlc3Q6IC9eLT8oPzowfFsxLTldWzAtOV0qKSg/OlxcLlswLTldKik/KD86W2VFXVstK10/WzAtOV0rKT8kLyxcbiAgICAgICAgcmVzb2x2ZTogc3RyID0+IHBhcnNlRmxvYXQoc3RyKSxcbiAgICAgICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlKU09OXG4gICAgfVxuXTtcbmNvbnN0IGpzb25FcnJvciA9IHtcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJycsXG4gICAgdGVzdDogL14vLFxuICAgIHJlc29sdmUoc3RyLCBvbkVycm9yKSB7XG4gICAgICAgIG9uRXJyb3IoYFVucmVzb2x2ZWQgcGxhaW4gc2NhbGFyICR7SlNPTi5zdHJpbmdpZnkoc3RyKX1gKTtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG59O1xuY29uc3Qgc2NoZW1hID0gW21hcC5tYXAsIHNlcS5zZXFdLmNvbmNhdChqc29uU2NhbGFycywganNvbkVycm9yKTtcblxuZXhwb3J0cy5zY2hlbWEgPSBzY2hlbWE7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIG5vZGVfYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJyk7XG52YXIgU2NhbGFyID0gcmVxdWlyZSgnLi4vLi4vbm9kZXMvU2NhbGFyLmpzJyk7XG52YXIgc3RyaW5naWZ5U3RyaW5nID0gcmVxdWlyZSgnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeVN0cmluZy5qcycpO1xuXG5jb25zdCBiaW5hcnkgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSwgLy8gQnVmZmVyIGluaGVyaXRzIGZyb20gVWludDhBcnJheVxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJpbmFyeScsXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEJ1ZmZlciBpbiBub2RlIGFuZCBhbiBVaW50OEFycmF5IGluIGJyb3dzZXJzXG4gICAgICpcbiAgICAgKiBUbyB1c2UgdGhlIHJlc3VsdGluZyBidWZmZXIgYXMgYW4gaW1hZ2UsIHlvdSdsbCB3YW50IHRvIGRvIHNvbWV0aGluZyBsaWtlOlxuICAgICAqXG4gICAgICogICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2J1ZmZlcl0sIHsgdHlwZTogJ2ltYWdlL2pwZWcnIH0pXG4gICAgICogICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcGhvdG8nKS5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpXG4gICAgICovXG4gICAgcmVzb2x2ZShzcmMsIG9uRXJyb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlX2J1ZmZlci5CdWZmZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlX2J1ZmZlci5CdWZmZXIuZnJvbShzcmMsICdiYXNlNjQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXRvYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gT24gSUUgMTEsIGF0b2IoKSBjYW4ndCBoYW5kbGUgbmV3bGluZXNcbiAgICAgICAgICAgIGNvbnN0IHN0ciA9IGF0b2Ioc3JjLnJlcGxhY2UoL1tcXG5cXHJdL2csICcnKSk7XG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIGJ1ZmZlcltpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9uRXJyb3IoJ1RoaXMgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCByZWFkaW5nIGJpbmFyeSB0YWdzOyBlaXRoZXIgQnVmZmVyIG9yIGF0b2IgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIHJldHVybiBzcmM7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHN0cmluZ2lmeSh7IGNvbW1lbnQsIHR5cGUsIHZhbHVlIH0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgICAgICBpZiAoIXZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICBjb25zdCBidWYgPSB2YWx1ZTsgLy8gY2hlY2tlZCBlYXJsaWVyIGJ5IGJpbmFyeS5pZGVudGlmeSgpXG4gICAgICAgIGxldCBzdHI7XG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZV9idWZmZXIuQnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzdHIgPVxuICAgICAgICAgICAgICAgIGJ1ZiBpbnN0YW5jZW9mIG5vZGVfYnVmZmVyLkJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICA/IGJ1Zi50b1N0cmluZygnYmFzZTY0JylcbiAgICAgICAgICAgICAgICAgICAgOiBub2RlX2J1ZmZlci5CdWZmZXIuZnJvbShidWYuYnVmZmVyKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGxldCBzID0gJyc7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgICAgICAgICAgIHN0ciA9IGJ0b2Eocyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCB3cml0aW5nIGJpbmFyeSB0YWdzOyBlaXRoZXIgQnVmZmVyIG9yIGJ0b2EgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0eXBlID8/ICh0eXBlID0gU2NhbGFyLlNjYWxhci5CTE9DS19MSVRFUkFMKTtcbiAgICAgICAgaWYgKHR5cGUgIT09IFNjYWxhci5TY2FsYXIuUVVPVEVfRE9VQkxFKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lV2lkdGggPSBNYXRoLm1heChjdHgub3B0aW9ucy5saW5lV2lkdGggLSBjdHguaW5kZW50Lmxlbmd0aCwgY3R4Lm9wdGlvbnMubWluQ29udGVudFdpZHRoKTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBNYXRoLmNlaWwoc3RyLmxlbmd0aCAvIGxpbmVXaWR0aCk7XG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IG5ldyBBcnJheShuKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBvID0gMDsgaSA8IG47ICsraSwgbyArPSBsaW5lV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBsaW5lc1tpXSA9IHN0ci5zdWJzdHIobywgbGluZVdpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0ciA9IGxpbmVzLmpvaW4odHlwZSA9PT0gU2NhbGFyLlNjYWxhci5CTE9DS19MSVRFUkFMID8gJ1xcbicgOiAnICcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlTdHJpbmcuc3RyaW5naWZ5U3RyaW5nKHsgY29tbWVudCwgdHlwZSwgdmFsdWU6IHN0ciB9LCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgIH1cbn07XG5cbmV4cG9ydHMuYmluYXJ5ID0gYmluYXJ5O1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4uLy4uL25vZGVzL2lkZW50aXR5LmpzJyk7XG52YXIgUGFpciA9IHJlcXVpcmUoJy4uLy4uL25vZGVzL1BhaXIuanMnKTtcbnZhciBTY2FsYXIgPSByZXF1aXJlKCcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnKTtcbnZhciBZQU1MU2VxID0gcmVxdWlyZSgnLi4vLi4vbm9kZXMvWUFNTFNlcS5qcycpO1xuXG5mdW5jdGlvbiByZXNvbHZlUGFpcnMoc2VxLCBvbkVycm9yKSB7XG4gICAgaWYgKGlkZW50aXR5LmlzU2VxKHNlcSkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXEuaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGxldCBpdGVtID0gc2VxLml0ZW1zW2ldO1xuICAgICAgICAgICAgaWYgKGlkZW50aXR5LmlzUGFpcihpdGVtKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlkZW50aXR5LmlzTWFwKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uaXRlbXMubGVuZ3RoID4gMSlcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcignRWFjaCBwYWlyIG11c3QgaGF2ZSBpdHMgb3duIHNlcXVlbmNlIGluZGljYXRvcicpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhaXIgPSBpdGVtLml0ZW1zWzBdIHx8IG5ldyBQYWlyLlBhaXIobmV3IFNjYWxhci5TY2FsYXIobnVsbCkpO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmNvbW1lbnRCZWZvcmUpXG4gICAgICAgICAgICAgICAgICAgIHBhaXIua2V5LmNvbW1lbnRCZWZvcmUgPSBwYWlyLmtleS5jb21tZW50QmVmb3JlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGAke2l0ZW0uY29tbWVudEJlZm9yZX1cXG4ke3BhaXIua2V5LmNvbW1lbnRCZWZvcmV9YFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBpdGVtLmNvbW1lbnRCZWZvcmU7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uY29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbiA9IHBhaXIudmFsdWUgPz8gcGFpci5rZXk7XG4gICAgICAgICAgICAgICAgICAgIGNuLmNvbW1lbnQgPSBjbi5jb21tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICA/IGAke2l0ZW0uY29tbWVudH1cXG4ke2NuLmNvbW1lbnR9YFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBpdGVtLmNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGl0ZW0gPSBwYWlyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VxLml0ZW1zW2ldID0gaWRlbnRpdHkuaXNQYWlyKGl0ZW0pID8gaXRlbSA6IG5ldyBQYWlyLlBhaXIoaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZVxuICAgICAgICBvbkVycm9yKCdFeHBlY3RlZCBhIHNlcXVlbmNlIGZvciB0aGlzIHRhZycpO1xuICAgIHJldHVybiBzZXE7XG59XG5mdW5jdGlvbiBjcmVhdGVQYWlycyhzY2hlbWEsIGl0ZXJhYmxlLCBjdHgpIHtcbiAgICBjb25zdCB7IHJlcGxhY2VyIH0gPSBjdHg7XG4gICAgY29uc3QgcGFpcnMgPSBuZXcgWUFNTFNlcS5ZQU1MU2VxKHNjaGVtYSk7XG4gICAgcGFpcnMudGFnID0gJ3RhZzp5YW1sLm9yZywyMDAyOnBhaXJzJztcbiAgICBsZXQgaSA9IDA7XG4gICAgaWYgKGl0ZXJhYmxlICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcmFibGUpKVxuICAgICAgICBmb3IgKGxldCBpdCBvZiBpdGVyYWJsZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICBpdCA9IHJlcGxhY2VyLmNhbGwoaXRlcmFibGUsIFN0cmluZyhpKyspLCBpdCk7XG4gICAgICAgICAgICBsZXQga2V5LCB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0KSkge1xuICAgICAgICAgICAgICAgIGlmIChpdC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gaXRbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaXRbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgW2tleSwgdmFsdWVdIHR1cGxlOiAke2l0fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXQgJiYgaXQgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaXQpO1xuICAgICAgICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBrZXlzWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGl0W2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCB0dXBsZSB3aXRoIG9uZSBrZXksIG5vdCAke2tleXMubGVuZ3RofSBrZXlzYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAga2V5ID0gaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYWlycy5pdGVtcy5wdXNoKFBhaXIuY3JlYXRlUGFpcihrZXksIHZhbHVlLCBjdHgpKTtcbiAgICAgICAgfVxuICAgIHJldHVybiBwYWlycztcbn1cbmNvbnN0IHBhaXJzID0ge1xuICAgIGNvbGxlY3Rpb246ICdzZXEnLFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOnBhaXJzJyxcbiAgICByZXNvbHZlOiByZXNvbHZlUGFpcnMsXG4gICAgY3JlYXRlTm9kZTogY3JlYXRlUGFpcnNcbn07XG5cbmV4cG9ydHMuY3JlYXRlUGFpcnMgPSBjcmVhdGVQYWlycztcbmV4cG9ydHMucGFpcnMgPSBwYWlycztcbmV4cG9ydHMucmVzb2x2ZVBhaXJzID0gcmVzb2x2ZVBhaXJzO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4uLy4uL25vZGVzL2lkZW50aXR5LmpzJyk7XG52YXIgdG9KUyA9IHJlcXVpcmUoJy4uLy4uL25vZGVzL3RvSlMuanMnKTtcbnZhciBZQU1MTWFwID0gcmVxdWlyZSgnLi4vLi4vbm9kZXMvWUFNTE1hcC5qcycpO1xudmFyIFlBTUxTZXEgPSByZXF1aXJlKCcuLi8uLi9ub2Rlcy9ZQU1MU2VxLmpzJyk7XG52YXIgcGFpcnMgPSByZXF1aXJlKCcuL3BhaXJzLmpzJyk7XG5cbmNsYXNzIFlBTUxPTWFwIGV4dGVuZHMgWUFNTFNlcS5ZQU1MU2VxIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hZGQgPSBZQU1MTWFwLllBTUxNYXAucHJvdG90eXBlLmFkZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRlbGV0ZSA9IFlBTUxNYXAuWUFNTE1hcC5wcm90b3R5cGUuZGVsZXRlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0ID0gWUFNTE1hcC5ZQU1MTWFwLnByb3RvdHlwZS5nZXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYXMgPSBZQU1MTWFwLllBTUxNYXAucHJvdG90eXBlLmhhcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldCA9IFlBTUxNYXAuWUFNTE1hcC5wcm90b3R5cGUuc2V0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudGFnID0gWUFNTE9NYXAudGFnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiBgY3R4YCBpcyBnaXZlbiwgdGhlIHJldHVybiB0eXBlIGlzIGFjdHVhbGx5IGBNYXA8dW5rbm93biwgdW5rbm93bj5gLFxuICAgICAqIGJ1dCBUeXBlU2NyaXB0IHdvbid0IGFsbG93IHdpZGVuaW5nIHRoZSBzaWduYXR1cmUgb2YgYSBjaGlsZCBtZXRob2QuXG4gICAgICovXG4gICAgdG9KU09OKF8sIGN0eCkge1xuICAgICAgICBpZiAoIWN0eClcbiAgICAgICAgICAgIHJldHVybiBzdXBlci50b0pTT04oXyk7XG4gICAgICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKGN0eD8ub25DcmVhdGUpXG4gICAgICAgICAgICBjdHgub25DcmVhdGUobWFwKTtcbiAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHRoaXMuaXRlbXMpIHtcbiAgICAgICAgICAgIGxldCBrZXksIHZhbHVlO1xuICAgICAgICAgICAgaWYgKGlkZW50aXR5LmlzUGFpcihwYWlyKSkge1xuICAgICAgICAgICAgICAgIGtleSA9IHRvSlMudG9KUyhwYWlyLmtleSwgJycsIGN0eCk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b0pTLnRvSlMocGFpci52YWx1ZSwga2V5LCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAga2V5ID0gdG9KUy50b0pTKHBhaXIsICcnLCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hcC5oYXMoa2V5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09yZGVyZWQgbWFwcyBtdXN0IG5vdCBpbmNsdWRlIGR1cGxpY2F0ZSBrZXlzJyk7XG4gICAgICAgICAgICBtYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHNjaGVtYSwgaXRlcmFibGUsIGN0eCkge1xuICAgICAgICBjb25zdCBwYWlycyQxID0gcGFpcnMuY3JlYXRlUGFpcnMoc2NoZW1hLCBpdGVyYWJsZSwgY3R4KTtcbiAgICAgICAgY29uc3Qgb21hcCA9IG5ldyB0aGlzKCk7XG4gICAgICAgIG9tYXAuaXRlbXMgPSBwYWlycyQxLml0ZW1zO1xuICAgICAgICByZXR1cm4gb21hcDtcbiAgICB9XG59XG5ZQU1MT01hcC50YWcgPSAndGFnOnlhbWwub3JnLDIwMDI6b21hcCc7XG5jb25zdCBvbWFwID0ge1xuICAgIGNvbGxlY3Rpb246ICdzZXEnLFxuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB2YWx1ZSBpbnN0YW5jZW9mIE1hcCxcbiAgICBub2RlQ2xhc3M6IFlBTUxPTWFwLFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOm9tYXAnLFxuICAgIHJlc29sdmUoc2VxLCBvbkVycm9yKSB7XG4gICAgICAgIGNvbnN0IHBhaXJzJDEgPSBwYWlycy5yZXNvbHZlUGFpcnMoc2VxLCBvbkVycm9yKTtcbiAgICAgICAgY29uc3Qgc2VlbktleXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB7IGtleSB9IG9mIHBhaXJzJDEuaXRlbXMpIHtcbiAgICAgICAgICAgIGlmIChpZGVudGl0eS5pc1NjYWxhcihrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlZW5LZXlzLmluY2x1ZGVzKGtleS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihgT3JkZXJlZCBtYXBzIG11c3Qgbm90IGluY2x1ZGUgZHVwbGljYXRlIGtleXM6ICR7a2V5LnZhbHVlfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VlbktleXMucHVzaChrZXkudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgWUFNTE9NYXAoKSwgcGFpcnMkMSk7XG4gICAgfSxcbiAgICBjcmVhdGVOb2RlOiAoc2NoZW1hLCBpdGVyYWJsZSwgY3R4KSA9PiBZQU1MT01hcC5mcm9tKHNjaGVtYSwgaXRlcmFibGUsIGN0eClcbn07XG5cbmV4cG9ydHMuWUFNTE9NYXAgPSBZQU1MT01hcDtcbmV4cG9ydHMub21hcCA9IG9tYXA7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIFNjYWxhciA9IHJlcXVpcmUoJy4uLy4uL25vZGVzL1NjYWxhci5qcycpO1xuXG5mdW5jdGlvbiBib29sU3RyaW5naWZ5KHsgdmFsdWUsIHNvdXJjZSB9LCBjdHgpIHtcbiAgICBjb25zdCBib29sT2JqID0gdmFsdWUgPyB0cnVlVGFnIDogZmFsc2VUYWc7XG4gICAgaWYgKHNvdXJjZSAmJiBib29sT2JqLnRlc3QudGVzdChzb3VyY2UpKVxuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIHJldHVybiB2YWx1ZSA/IGN0eC5vcHRpb25zLnRydWVTdHIgOiBjdHgub3B0aW9ucy5mYWxzZVN0cjtcbn1cbmNvbnN0IHRydWVUYWcgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlID09PSB0cnVlLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6Ym9vbCcsXG4gICAgdGVzdDogL14oPzpZfHl8W1l5XWVzfFlFU3xbVHRdcnVlfFRSVUV8W09vXW58T04pJC8sXG4gICAgcmVzb2x2ZTogKCkgPT4gbmV3IFNjYWxhci5TY2FsYXIodHJ1ZSksXG4gICAgc3RyaW5naWZ5OiBib29sU3RyaW5naWZ5XG59O1xuY29uc3QgZmFsc2VUYWcgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlID09PSBmYWxzZSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLFxuICAgIHRlc3Q6IC9eKD86TnxufFtObl1vfE5PfFtGZl1hbHNlfEZBTFNFfFtPb11mZnxPRkYpJC8sXG4gICAgcmVzb2x2ZTogKCkgPT4gbmV3IFNjYWxhci5TY2FsYXIoZmFsc2UpLFxuICAgIHN0cmluZ2lmeTogYm9vbFN0cmluZ2lmeVxufTtcblxuZXhwb3J0cy5mYWxzZVRhZyA9IGZhbHNlVGFnO1xuZXhwb3J0cy50cnVlVGFnID0gdHJ1ZVRhZztcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgU2NhbGFyID0gcmVxdWlyZSgnLi4vLi4vbm9kZXMvU2NhbGFyLmpzJyk7XG52YXIgc3RyaW5naWZ5TnVtYmVyID0gcmVxdWlyZSgnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeU51bWJlci5qcycpO1xuXG5jb25zdCBmbG9hdE5hTiA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgICB0ZXN0OiAvXig/OlstK10/XFwuKD86aW5mfEluZnxJTkYpfFxcLm5hbnxcXC5OYU58XFwuTkFOKSQvLFxuICAgIHJlc29sdmU6IChzdHIpID0+IHN0ci5zbGljZSgtMykudG9Mb3dlckNhc2UoKSA9PT0gJ25hbidcbiAgICAgICAgPyBOYU5cbiAgICAgICAgOiBzdHJbMF0gPT09ICctJ1xuICAgICAgICAgICAgPyBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFlcbiAgICAgICAgICAgIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5TnVtYmVyLnN0cmluZ2lmeU51bWJlclxufTtcbmNvbnN0IGZsb2F0RXhwID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICAgIGZvcm1hdDogJ0VYUCcsXG4gICAgdGVzdDogL15bLStdPyg/OlswLTldWzAtOV9dKik/KD86XFwuWzAtOV9dKik/W2VFXVstK10/WzAtOV0rJC8sXG4gICAgcmVzb2x2ZTogKHN0cikgPT4gcGFyc2VGbG9hdChzdHIucmVwbGFjZSgvXy9nLCAnJykpLFxuICAgIHN0cmluZ2lmeShub2RlKSB7XG4gICAgICAgIGNvbnN0IG51bSA9IE51bWJlcihub2RlLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGlzRmluaXRlKG51bSkgPyBudW0udG9FeHBvbmVudGlhbCgpIDogc3RyaW5naWZ5TnVtYmVyLnN0cmluZ2lmeU51bWJlcihub2RlKTtcbiAgICB9XG59O1xuY29uc3QgZmxvYXQgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsXG4gICAgdGVzdDogL15bLStdPyg/OlswLTldWzAtOV9dKik/XFwuWzAtOV9dKiQvLFxuICAgIHJlc29sdmUoc3RyKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgU2NhbGFyLlNjYWxhcihwYXJzZUZsb2F0KHN0ci5yZXBsYWNlKC9fL2csICcnKSkpO1xuICAgICAgICBjb25zdCBkb3QgPSBzdHIuaW5kZXhPZignLicpO1xuICAgICAgICBpZiAoZG90ICE9PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgZiA9IHN0ci5zdWJzdHJpbmcoZG90ICsgMSkucmVwbGFjZSgvXy9nLCAnJyk7XG4gICAgICAgICAgICBpZiAoZltmLmxlbmd0aCAtIDFdID09PSAnMCcpXG4gICAgICAgICAgICAgICAgbm9kZS5taW5GcmFjdGlvbkRpZ2l0cyA9IGYubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG4gICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlOdW1iZXIuc3RyaW5naWZ5TnVtYmVyXG59O1xuXG5leHBvcnRzLmZsb2F0ID0gZmxvYXQ7XG5leHBvcnRzLmZsb2F0RXhwID0gZmxvYXRFeHA7XG5leHBvcnRzLmZsb2F0TmFOID0gZmxvYXROYU47XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeU51bWJlciA9IHJlcXVpcmUoJy4uLy4uL3N0cmluZ2lmeS9zdHJpbmdpZnlOdW1iZXIuanMnKTtcblxuY29uc3QgaW50SWRlbnRpZnkgPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcgfHwgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSk7XG5mdW5jdGlvbiBpbnRSZXNvbHZlKHN0ciwgb2Zmc2V0LCByYWRpeCwgeyBpbnRBc0JpZ0ludCB9KSB7XG4gICAgY29uc3Qgc2lnbiA9IHN0clswXTtcbiAgICBpZiAoc2lnbiA9PT0gJy0nIHx8IHNpZ24gPT09ICcrJylcbiAgICAgICAgb2Zmc2V0ICs9IDE7XG4gICAgc3RyID0gc3RyLnN1YnN0cmluZyhvZmZzZXQpLnJlcGxhY2UoL18vZywgJycpO1xuICAgIGlmIChpbnRBc0JpZ0ludCkge1xuICAgICAgICBzd2l0Y2ggKHJhZGl4KSB7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgc3RyID0gYDBiJHtzdHJ9YDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICBzdHIgPSBgMG8ke3N0cn1gO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgICBzdHIgPSBgMHgke3N0cn1gO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG4gPSBCaWdJbnQoc3RyKTtcbiAgICAgICAgcmV0dXJuIHNpZ24gPT09ICctJyA/IEJpZ0ludCgtMSkgKiBuIDogbjtcbiAgICB9XG4gICAgY29uc3QgbiA9IHBhcnNlSW50KHN0ciwgcmFkaXgpO1xuICAgIHJldHVybiBzaWduID09PSAnLScgPyAtMSAqIG4gOiBuO1xufVxuZnVuY3Rpb24gaW50U3RyaW5naWZ5KG5vZGUsIHJhZGl4LCBwcmVmaXgpIHtcbiAgICBjb25zdCB7IHZhbHVlIH0gPSBub2RlO1xuICAgIGlmIChpbnRJZGVudGlmeSh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3Qgc3RyID0gdmFsdWUudG9TdHJpbmcocmFkaXgpO1xuICAgICAgICByZXR1cm4gdmFsdWUgPCAwID8gJy0nICsgcHJlZml4ICsgc3RyLnN1YnN0cigxKSA6IHByZWZpeCArIHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZ2lmeU51bWJlci5zdHJpbmdpZnlOdW1iZXIobm9kZSk7XG59XG5jb25zdCBpbnRCaW4gPSB7XG4gICAgaWRlbnRpZnk6IGludElkZW50aWZ5LFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICBmb3JtYXQ6ICdCSU4nLFxuICAgIHRlc3Q6IC9eWy0rXT8wYlswLTFfXSskLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgb3B0KSA9PiBpbnRSZXNvbHZlKHN0ciwgMiwgMiwgb3B0KSxcbiAgICBzdHJpbmdpZnk6IG5vZGUgPT4gaW50U3RyaW5naWZ5KG5vZGUsIDIsICcwYicpXG59O1xuY29uc3QgaW50T2N0ID0ge1xuICAgIGlkZW50aWZ5OiBpbnRJZGVudGlmeSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gICAgZm9ybWF0OiAnT0NUJyxcbiAgICB0ZXN0OiAvXlstK10/MFswLTdfXSskLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgb3B0KSA9PiBpbnRSZXNvbHZlKHN0ciwgMSwgOCwgb3B0KSxcbiAgICBzdHJpbmdpZnk6IG5vZGUgPT4gaW50U3RyaW5naWZ5KG5vZGUsIDgsICcwJylcbn07XG5jb25zdCBpbnQgPSB7XG4gICAgaWRlbnRpZnk6IGludElkZW50aWZ5LFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICB0ZXN0OiAvXlstK10/WzAtOV1bMC05X10qJC8sXG4gICAgcmVzb2x2ZTogKHN0ciwgX29uRXJyb3IsIG9wdCkgPT4gaW50UmVzb2x2ZShzdHIsIDAsIDEwLCBvcHQpLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5TnVtYmVyLnN0cmluZ2lmeU51bWJlclxufTtcbmNvbnN0IGludEhleCA9IHtcbiAgICBpZGVudGlmeTogaW50SWRlbnRpZnksXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICAgIGZvcm1hdDogJ0hFWCcsXG4gICAgdGVzdDogL15bLStdPzB4WzAtOWEtZkEtRl9dKyQvLFxuICAgIHJlc29sdmU6IChzdHIsIF9vbkVycm9yLCBvcHQpID0+IGludFJlc29sdmUoc3RyLCAyLCAxNiwgb3B0KSxcbiAgICBzdHJpbmdpZnk6IG5vZGUgPT4gaW50U3RyaW5naWZ5KG5vZGUsIDE2LCAnMHgnKVxufTtcblxuZXhwb3J0cy5pbnQgPSBpbnQ7XG5leHBvcnRzLmludEJpbiA9IGludEJpbjtcbmV4cG9ydHMuaW50SGV4ID0gaW50SGV4O1xuZXhwb3J0cy5pbnRPY3QgPSBpbnRPY3Q7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi4vLi4vbm9kZXMvaWRlbnRpdHkuanMnKTtcbnZhciBQYWlyID0gcmVxdWlyZSgnLi4vLi4vbm9kZXMvUGFpci5qcycpO1xudmFyIFlBTUxNYXAgPSByZXF1aXJlKCcuLi8uLi9ub2Rlcy9ZQU1MTWFwLmpzJyk7XG5cbmNsYXNzIFlBTUxTZXQgZXh0ZW5kcyBZQU1MTWFwLllBTUxNYXAge1xuICAgIGNvbnN0cnVjdG9yKHNjaGVtYSkge1xuICAgICAgICBzdXBlcihzY2hlbWEpO1xuICAgICAgICB0aGlzLnRhZyA9IFlBTUxTZXQudGFnO1xuICAgIH1cbiAgICBhZGQoa2V5KSB7XG4gICAgICAgIGxldCBwYWlyO1xuICAgICAgICBpZiAoaWRlbnRpdHkuaXNQYWlyKGtleSkpXG4gICAgICAgICAgICBwYWlyID0ga2V5O1xuICAgICAgICBlbHNlIGlmIChrZXkgJiZcbiAgICAgICAgICAgIHR5cGVvZiBrZXkgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAna2V5JyBpbiBrZXkgJiZcbiAgICAgICAgICAgICd2YWx1ZScgaW4ga2V5ICYmXG4gICAgICAgICAgICBrZXkudmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICBwYWlyID0gbmV3IFBhaXIuUGFpcihrZXkua2V5LCBudWxsKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcGFpciA9IG5ldyBQYWlyLlBhaXIoa2V5LCBudWxsKTtcbiAgICAgICAgY29uc3QgcHJldiA9IFlBTUxNYXAuZmluZFBhaXIodGhpcy5pdGVtcywgcGFpci5rZXkpO1xuICAgICAgICBpZiAoIXByZXYpXG4gICAgICAgICAgICB0aGlzLml0ZW1zLnB1c2gocGFpcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIGBrZWVwUGFpcmAgaXMgYHRydWVgLCByZXR1cm5zIHRoZSBQYWlyIG1hdGNoaW5nIGBrZXlgLlxuICAgICAqIE90aGVyd2lzZSwgcmV0dXJucyB0aGUgdmFsdWUgb2YgdGhhdCBQYWlyJ3Mga2V5LlxuICAgICAqL1xuICAgIGdldChrZXksIGtlZXBQYWlyKSB7XG4gICAgICAgIGNvbnN0IHBhaXIgPSBZQU1MTWFwLmZpbmRQYWlyKHRoaXMuaXRlbXMsIGtleSk7XG4gICAgICAgIHJldHVybiAha2VlcFBhaXIgJiYgaWRlbnRpdHkuaXNQYWlyKHBhaXIpXG4gICAgICAgICAgICA/IGlkZW50aXR5LmlzU2NhbGFyKHBhaXIua2V5KVxuICAgICAgICAgICAgICAgID8gcGFpci5rZXkudmFsdWVcbiAgICAgICAgICAgICAgICA6IHBhaXIua2V5XG4gICAgICAgICAgICA6IHBhaXI7XG4gICAgfVxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiB2YWx1ZSBmb3Igc2V0KGtleSwgdmFsdWUpIGluIGEgWUFNTCBzZXQsIG5vdCAke3R5cGVvZiB2YWx1ZX1gKTtcbiAgICAgICAgY29uc3QgcHJldiA9IFlBTUxNYXAuZmluZFBhaXIodGhpcy5pdGVtcywga2V5KTtcbiAgICAgICAgaWYgKHByZXYgJiYgIXZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zLnNwbGljZSh0aGlzLml0ZW1zLmluZGV4T2YocHJldiksIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFwcmV2ICYmIHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zLnB1c2gobmV3IFBhaXIuUGFpcihrZXkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0pTT04oXywgY3R4KSB7XG4gICAgICAgIHJldHVybiBzdXBlci50b0pTT04oXywgY3R4LCBTZXQpO1xuICAgIH1cbiAgICB0b1N0cmluZyhjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICAgICAgaWYgKCFjdHgpXG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmhhc0FsbE51bGxWYWx1ZXModHJ1ZSkpXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIudG9TdHJpbmcoT2JqZWN0LmFzc2lnbih7fSwgY3R4LCB7IGFsbE51bGxWYWx1ZXM6IHRydWUgfSksIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NldCBpdGVtcyBtdXN0IGFsbCBoYXZlIG51bGwgdmFsdWVzJyk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHNjaGVtYSwgaXRlcmFibGUsIGN0eCkge1xuICAgICAgICBjb25zdCB7IHJlcGxhY2VyIH0gPSBjdHg7XG4gICAgICAgIGNvbnN0IHNldCA9IG5ldyB0aGlzKHNjaGVtYSk7XG4gICAgICAgIGlmIChpdGVyYWJsZSAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXJhYmxlKSlcbiAgICAgICAgICAgIGZvciAobGV0IHZhbHVlIG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZXBsYWNlci5jYWxsKGl0ZXJhYmxlLCB2YWx1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHNldC5pdGVtcy5wdXNoKFBhaXIuY3JlYXRlUGFpcih2YWx1ZSwgbnVsbCwgY3R4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxufVxuWUFNTFNldC50YWcgPSAndGFnOnlhbWwub3JnLDIwMDI6c2V0JztcbmNvbnN0IHNldCA9IHtcbiAgICBjb2xsZWN0aW9uOiAnbWFwJyxcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdmFsdWUgaW5zdGFuY2VvZiBTZXQsXG4gICAgbm9kZUNsYXNzOiBZQU1MU2V0LFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOnNldCcsXG4gICAgY3JlYXRlTm9kZTogKHNjaGVtYSwgaXRlcmFibGUsIGN0eCkgPT4gWUFNTFNldC5mcm9tKHNjaGVtYSwgaXRlcmFibGUsIGN0eCksXG4gICAgcmVzb2x2ZShtYXAsIG9uRXJyb3IpIHtcbiAgICAgICAgaWYgKGlkZW50aXR5LmlzTWFwKG1hcCkpIHtcbiAgICAgICAgICAgIGlmIChtYXAuaGFzQWxsTnVsbFZhbHVlcyh0cnVlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgWUFNTFNldCgpLCBtYXApO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG9uRXJyb3IoJ1NldCBpdGVtcyBtdXN0IGFsbCBoYXZlIG51bGwgdmFsdWVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgb25FcnJvcignRXhwZWN0ZWQgYSBtYXBwaW5nIGZvciB0aGlzIHRhZycpO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH1cbn07XG5cbmV4cG9ydHMuWUFNTFNldCA9IFlBTUxTZXQ7XG5leHBvcnRzLnNldCA9IHNldDtcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5TnVtYmVyID0gcmVxdWlyZSgnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeU51bWJlci5qcycpO1xuXG4vKiogSW50ZXJuYWwgdHlwZXMgaGFuZGxlIGJpZ2ludCBhcyBudW1iZXIsIGJlY2F1c2UgVFMgY2FuJ3QgZmlndXJlIGl0IG91dC4gKi9cbmZ1bmN0aW9uIHBhcnNlU2V4YWdlc2ltYWwoc3RyLCBhc0JpZ0ludCkge1xuICAgIGNvbnN0IHNpZ24gPSBzdHJbMF07XG4gICAgY29uc3QgcGFydHMgPSBzaWduID09PSAnLScgfHwgc2lnbiA9PT0gJysnID8gc3RyLnN1YnN0cmluZygxKSA6IHN0cjtcbiAgICBjb25zdCBudW0gPSAobikgPT4gYXNCaWdJbnQgPyBCaWdJbnQobikgOiBOdW1iZXIobik7XG4gICAgY29uc3QgcmVzID0gcGFydHNcbiAgICAgICAgLnJlcGxhY2UoL18vZywgJycpXG4gICAgICAgIC5zcGxpdCgnOicpXG4gICAgICAgIC5yZWR1Y2UoKHJlcywgcCkgPT4gcmVzICogbnVtKDYwKSArIG51bShwKSwgbnVtKDApKTtcbiAgICByZXR1cm4gKHNpZ24gPT09ICctJyA/IG51bSgtMSkgKiByZXMgOiByZXMpO1xufVxuLyoqXG4gKiBoaGhoOm1tOnNzLnNzc1xuICpcbiAqIEludGVybmFsIHR5cGVzIGhhbmRsZSBiaWdpbnQgYXMgbnVtYmVyLCBiZWNhdXNlIFRTIGNhbid0IGZpZ3VyZSBpdCBvdXQuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeVNleGFnZXNpbWFsKG5vZGUpIHtcbiAgICBsZXQgeyB2YWx1ZSB9ID0gbm9kZTtcbiAgICBsZXQgbnVtID0gKG4pID0+IG47XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpXG4gICAgICAgIG51bSA9IG4gPT4gQmlnSW50KG4pO1xuICAgIGVsc2UgaWYgKGlzTmFOKHZhbHVlKSB8fCAhaXNGaW5pdGUodmFsdWUpKVxuICAgICAgICByZXR1cm4gc3RyaW5naWZ5TnVtYmVyLnN0cmluZ2lmeU51bWJlcihub2RlKTtcbiAgICBsZXQgc2lnbiA9ICcnO1xuICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgICAgc2lnbiA9ICctJztcbiAgICAgICAgdmFsdWUgKj0gbnVtKC0xKTtcbiAgICB9XG4gICAgY29uc3QgXzYwID0gbnVtKDYwKTtcbiAgICBjb25zdCBwYXJ0cyA9IFt2YWx1ZSAlIF82MF07IC8vIHNlY29uZHMsIGluY2x1ZGluZyBtc1xuICAgIGlmICh2YWx1ZSA8IDYwKSB7XG4gICAgICAgIHBhcnRzLnVuc2hpZnQoMCk7IC8vIGF0IGxlYXN0IG9uZSA6IGlzIHJlcXVpcmVkXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSAtIHBhcnRzWzBdKSAvIF82MDtcbiAgICAgICAgcGFydHMudW5zaGlmdCh2YWx1ZSAlIF82MCk7IC8vIG1pbnV0ZXNcbiAgICAgICAgaWYgKHZhbHVlID49IDYwKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICh2YWx1ZSAtIHBhcnRzWzBdKSAvIF82MDtcbiAgICAgICAgICAgIHBhcnRzLnVuc2hpZnQodmFsdWUpOyAvLyBob3Vyc1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoc2lnbiArXG4gICAgICAgIHBhcnRzXG4gICAgICAgICAgICAubWFwKG4gPT4gU3RyaW5nKG4pLnBhZFN0YXJ0KDIsICcwJykpXG4gICAgICAgICAgICAuam9pbignOicpXG4gICAgICAgICAgICAucmVwbGFjZSgvMDAwMDAwXFxkKiQvLCAnJykgLy8gJSA2MCBtYXkgaW50cm9kdWNlIGVycm9yXG4gICAgKTtcbn1cbmNvbnN0IGludFRpbWUgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcgfHwgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSksXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICAgIGZvcm1hdDogJ1RJTUUnLFxuICAgIHRlc3Q6IC9eWy0rXT9bMC05XVswLTlfXSooPzo6WzAtNV0/WzAtOV0pKyQvLFxuICAgIHJlc29sdmU6IChzdHIsIF9vbkVycm9yLCB7IGludEFzQmlnSW50IH0pID0+IHBhcnNlU2V4YWdlc2ltYWwoc3RyLCBpbnRBc0JpZ0ludCksXG4gICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlTZXhhZ2VzaW1hbFxufTtcbmNvbnN0IGZsb2F0VGltZSA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgICBmb3JtYXQ6ICdUSU1FJyxcbiAgICB0ZXN0OiAvXlstK10/WzAtOV1bMC05X10qKD86OlswLTVdP1swLTldKStcXC5bMC05X10qJC8sXG4gICAgcmVzb2x2ZTogc3RyID0+IHBhcnNlU2V4YWdlc2ltYWwoc3RyLCBmYWxzZSksXG4gICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlTZXhhZ2VzaW1hbFxufTtcbmNvbnN0IHRpbWVzdGFtcCA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6dGltZXN0YW1wJyxcbiAgICAvLyBJZiB0aGUgdGltZSB6b25lIGlzIG9taXR0ZWQsIHRoZSB0aW1lc3RhbXAgaXMgYXNzdW1lZCB0byBiZSBzcGVjaWZpZWQgaW4gVVRDLiBUaGUgdGltZSBwYXJ0XG4gICAgLy8gbWF5IGJlIG9taXR0ZWQgYWx0b2dldGhlciwgcmVzdWx0aW5nIGluIGEgZGF0ZSBmb3JtYXQuIEluIHN1Y2ggYSBjYXNlLCB0aGUgdGltZSBwYXJ0IGlzXG4gICAgLy8gYXNzdW1lZCB0byBiZSAwMDowMDowMFogKHN0YXJ0IG9mIGRheSwgVVRDKS5cbiAgICB0ZXN0OiBSZWdFeHAoJ14oWzAtOV17NH0pLShbMC05XXsxLDJ9KS0oWzAtOV17MSwyfSknICsgLy8gWVlZWS1NbS1EZFxuICAgICAgICAnKD86JyArIC8vIHRpbWUgaXMgb3B0aW9uYWxcbiAgICAgICAgJyg/OnR8VHxbIFxcXFx0XSspJyArIC8vIHQgfCBUIHwgd2hpdGVzcGFjZVxuICAgICAgICAnKFswLTldezEsMn0pOihbMC05XXsxLDJ9KTooWzAtOV17MSwyfShcXFxcLlswLTldKyk/KScgKyAvLyBIaDpNbTpTcyguc3MpP1xuICAgICAgICAnKD86WyBcXFxcdF0qKFp8Wy0rXVswMTJdP1swLTldKD86OlswLTldezJ9KT8pKT8nICsgLy8gWiB8ICs1IHwgLTAzOjMwXG4gICAgICAgICcpPyQnKSxcbiAgICByZXNvbHZlKHN0cikge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHN0ci5tYXRjaCh0aW1lc3RhbXAudGVzdCk7XG4gICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJyEhdGltZXN0YW1wIGV4cGVjdHMgYSBkYXRlLCBzdGFydGluZyB3aXRoIHl5eXktbW0tZGQnKTtcbiAgICAgICAgY29uc3QgWywgeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmRdID0gbWF0Y2gubWFwKE51bWJlcik7XG4gICAgICAgIGNvbnN0IG1pbGxpc2VjID0gbWF0Y2hbN10gPyBOdW1iZXIoKG1hdGNoWzddICsgJzAwJykuc3Vic3RyKDEsIDMpKSA6IDA7XG4gICAgICAgIGxldCBkYXRlID0gRGF0ZS5VVEMoeWVhciwgbW9udGggLSAxLCBkYXksIGhvdXIgfHwgMCwgbWludXRlIHx8IDAsIHNlY29uZCB8fCAwLCBtaWxsaXNlYyk7XG4gICAgICAgIGNvbnN0IHR6ID0gbWF0Y2hbOF07XG4gICAgICAgIGlmICh0eiAmJiB0eiAhPT0gJ1onKSB7XG4gICAgICAgICAgICBsZXQgZCA9IHBhcnNlU2V4YWdlc2ltYWwodHosIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkKSA8IDMwKVxuICAgICAgICAgICAgICAgIGQgKj0gNjA7XG4gICAgICAgICAgICBkYXRlIC09IDYwMDAwICogZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERhdGUoZGF0ZSk7XG4gICAgfSxcbiAgICBzdHJpbmdpZnk6ICh7IHZhbHVlIH0pID0+IHZhbHVlPy50b0lTT1N0cmluZygpLnJlcGxhY2UoLyhUMDA6MDA6MDApP1xcLjAwMFokLywgJycpID8/ICcnXG59O1xuXG5leHBvcnRzLmZsb2F0VGltZSA9IGZsb2F0VGltZTtcbmV4cG9ydHMuaW50VGltZSA9IGludFRpbWU7XG5leHBvcnRzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgbWFwID0gcmVxdWlyZSgnLi4vY29tbW9uL21hcC5qcycpO1xudmFyIF9udWxsID0gcmVxdWlyZSgnLi4vY29tbW9uL251bGwuanMnKTtcbnZhciBzZXEgPSByZXF1aXJlKCcuLi9jb21tb24vc2VxLmpzJyk7XG52YXIgc3RyaW5nID0gcmVxdWlyZSgnLi4vY29tbW9uL3N0cmluZy5qcycpO1xudmFyIGJpbmFyeSA9IHJlcXVpcmUoJy4vYmluYXJ5LmpzJyk7XG52YXIgYm9vbCA9IHJlcXVpcmUoJy4vYm9vbC5qcycpO1xudmFyIGZsb2F0ID0gcmVxdWlyZSgnLi9mbG9hdC5qcycpO1xudmFyIGludCA9IHJlcXVpcmUoJy4vaW50LmpzJyk7XG52YXIgbWVyZ2UgPSByZXF1aXJlKCcuL21lcmdlLmpzJyk7XG52YXIgb21hcCA9IHJlcXVpcmUoJy4vb21hcC5qcycpO1xudmFyIHBhaXJzID0gcmVxdWlyZSgnLi9wYWlycy5qcycpO1xudmFyIHNldCA9IHJlcXVpcmUoJy4vc2V0LmpzJyk7XG52YXIgdGltZXN0YW1wID0gcmVxdWlyZSgnLi90aW1lc3RhbXAuanMnKTtcblxuY29uc3Qgc2NoZW1hID0gW1xuICAgIG1hcC5tYXAsXG4gICAgc2VxLnNlcSxcbiAgICBzdHJpbmcuc3RyaW5nLFxuICAgIF9udWxsLm51bGxUYWcsXG4gICAgYm9vbC50cnVlVGFnLFxuICAgIGJvb2wuZmFsc2VUYWcsXG4gICAgaW50LmludEJpbixcbiAgICBpbnQuaW50T2N0LFxuICAgIGludC5pbnQsXG4gICAgaW50LmludEhleCxcbiAgICBmbG9hdC5mbG9hdE5hTixcbiAgICBmbG9hdC5mbG9hdEV4cCxcbiAgICBmbG9hdC5mbG9hdCxcbiAgICBiaW5hcnkuYmluYXJ5LFxuICAgIG1lcmdlLm1lcmdlLFxuICAgIG9tYXAub21hcCxcbiAgICBwYWlycy5wYWlycyxcbiAgICBzZXQuc2V0LFxuICAgIHRpbWVzdGFtcC5pbnRUaW1lLFxuICAgIHRpbWVzdGFtcC5mbG9hdFRpbWUsXG4gICAgdGltZXN0YW1wLnRpbWVzdGFtcFxuXTtcblxuZXhwb3J0cy5zY2hlbWEgPSBzY2hlbWE7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIG1hcCA9IHJlcXVpcmUoJy4vY29tbW9uL21hcC5qcycpO1xudmFyIF9udWxsID0gcmVxdWlyZSgnLi9jb21tb24vbnVsbC5qcycpO1xudmFyIHNlcSA9IHJlcXVpcmUoJy4vY29tbW9uL3NlcS5qcycpO1xudmFyIHN0cmluZyA9IHJlcXVpcmUoJy4vY29tbW9uL3N0cmluZy5qcycpO1xudmFyIGJvb2wgPSByZXF1aXJlKCcuL2NvcmUvYm9vbC5qcycpO1xudmFyIGZsb2F0ID0gcmVxdWlyZSgnLi9jb3JlL2Zsb2F0LmpzJyk7XG52YXIgaW50ID0gcmVxdWlyZSgnLi9jb3JlL2ludC5qcycpO1xudmFyIHNjaGVtYSA9IHJlcXVpcmUoJy4vY29yZS9zY2hlbWEuanMnKTtcbnZhciBzY2hlbWEkMSA9IHJlcXVpcmUoJy4vanNvbi9zY2hlbWEuanMnKTtcbnZhciBiaW5hcnkgPSByZXF1aXJlKCcuL3lhbWwtMS4xL2JpbmFyeS5qcycpO1xudmFyIG1lcmdlID0gcmVxdWlyZSgnLi95YW1sLTEuMS9tZXJnZS5qcycpO1xudmFyIG9tYXAgPSByZXF1aXJlKCcuL3lhbWwtMS4xL29tYXAuanMnKTtcbnZhciBwYWlycyA9IHJlcXVpcmUoJy4veWFtbC0xLjEvcGFpcnMuanMnKTtcbnZhciBzY2hlbWEkMiA9IHJlcXVpcmUoJy4veWFtbC0xLjEvc2NoZW1hLmpzJyk7XG52YXIgc2V0ID0gcmVxdWlyZSgnLi95YW1sLTEuMS9zZXQuanMnKTtcbnZhciB0aW1lc3RhbXAgPSByZXF1aXJlKCcuL3lhbWwtMS4xL3RpbWVzdGFtcC5qcycpO1xuXG5jb25zdCBzY2hlbWFzID0gbmV3IE1hcChbXG4gICAgWydjb3JlJywgc2NoZW1hLnNjaGVtYV0sXG4gICAgWydmYWlsc2FmZScsIFttYXAubWFwLCBzZXEuc2VxLCBzdHJpbmcuc3RyaW5nXV0sXG4gICAgWydqc29uJywgc2NoZW1hJDEuc2NoZW1hXSxcbiAgICBbJ3lhbWwxMScsIHNjaGVtYSQyLnNjaGVtYV0sXG4gICAgWyd5YW1sLTEuMScsIHNjaGVtYSQyLnNjaGVtYV1cbl0pO1xuY29uc3QgdGFnc0J5TmFtZSA9IHtcbiAgICBiaW5hcnk6IGJpbmFyeS5iaW5hcnksXG4gICAgYm9vbDogYm9vbC5ib29sVGFnLFxuICAgIGZsb2F0OiBmbG9hdC5mbG9hdCxcbiAgICBmbG9hdEV4cDogZmxvYXQuZmxvYXRFeHAsXG4gICAgZmxvYXROYU46IGZsb2F0LmZsb2F0TmFOLFxuICAgIGZsb2F0VGltZTogdGltZXN0YW1wLmZsb2F0VGltZSxcbiAgICBpbnQ6IGludC5pbnQsXG4gICAgaW50SGV4OiBpbnQuaW50SGV4LFxuICAgIGludE9jdDogaW50LmludE9jdCxcbiAgICBpbnRUaW1lOiB0aW1lc3RhbXAuaW50VGltZSxcbiAgICBtYXA6IG1hcC5tYXAsXG4gICAgbWVyZ2U6IG1lcmdlLm1lcmdlLFxuICAgIG51bGw6IF9udWxsLm51bGxUYWcsXG4gICAgb21hcDogb21hcC5vbWFwLFxuICAgIHBhaXJzOiBwYWlycy5wYWlycyxcbiAgICBzZXE6IHNlcS5zZXEsXG4gICAgc2V0OiBzZXQuc2V0LFxuICAgIHRpbWVzdGFtcDogdGltZXN0YW1wLnRpbWVzdGFtcFxufTtcbmNvbnN0IGNvcmVLbm93blRhZ3MgPSB7XG4gICAgJ3RhZzp5YW1sLm9yZywyMDAyOmJpbmFyeSc6IGJpbmFyeS5iaW5hcnksXG4gICAgJ3RhZzp5YW1sLm9yZywyMDAyOm1lcmdlJzogbWVyZ2UubWVyZ2UsXG4gICAgJ3RhZzp5YW1sLm9yZywyMDAyOm9tYXAnOiBvbWFwLm9tYXAsXG4gICAgJ3RhZzp5YW1sLm9yZywyMDAyOnBhaXJzJzogcGFpcnMucGFpcnMsXG4gICAgJ3RhZzp5YW1sLm9yZywyMDAyOnNldCc6IHNldC5zZXQsXG4gICAgJ3RhZzp5YW1sLm9yZywyMDAyOnRpbWVzdGFtcCc6IHRpbWVzdGFtcC50aW1lc3RhbXBcbn07XG5mdW5jdGlvbiBnZXRUYWdzKGN1c3RvbVRhZ3MsIHNjaGVtYU5hbWUsIGFkZE1lcmdlVGFnKSB7XG4gICAgY29uc3Qgc2NoZW1hVGFncyA9IHNjaGVtYXMuZ2V0KHNjaGVtYU5hbWUpO1xuICAgIGlmIChzY2hlbWFUYWdzICYmICFjdXN0b21UYWdzKSB7XG4gICAgICAgIHJldHVybiBhZGRNZXJnZVRhZyAmJiAhc2NoZW1hVGFncy5pbmNsdWRlcyhtZXJnZS5tZXJnZSlcbiAgICAgICAgICAgID8gc2NoZW1hVGFncy5jb25jYXQobWVyZ2UubWVyZ2UpXG4gICAgICAgICAgICA6IHNjaGVtYVRhZ3Muc2xpY2UoKTtcbiAgICB9XG4gICAgbGV0IHRhZ3MgPSBzY2hlbWFUYWdzO1xuICAgIGlmICghdGFncykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXN0b21UYWdzKSlcbiAgICAgICAgICAgIHRhZ3MgPSBbXTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gQXJyYXkuZnJvbShzY2hlbWFzLmtleXMoKSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGtleSA9PiBrZXkgIT09ICd5YW1sMTEnKVxuICAgICAgICAgICAgICAgIC5tYXAoa2V5ID0+IEpTT04uc3RyaW5naWZ5KGtleSkpXG4gICAgICAgICAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc2NoZW1hIFwiJHtzY2hlbWFOYW1lfVwiOyB1c2Ugb25lIG9mICR7a2V5c30gb3IgZGVmaW5lIGN1c3RvbVRhZ3MgYXJyYXlgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjdXN0b21UYWdzKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHRhZyBvZiBjdXN0b21UYWdzKVxuICAgICAgICAgICAgdGFncyA9IHRhZ3MuY29uY2F0KHRhZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBjdXN0b21UYWdzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRhZ3MgPSBjdXN0b21UYWdzKHRhZ3Muc2xpY2UoKSk7XG4gICAgfVxuICAgIGlmIChhZGRNZXJnZVRhZylcbiAgICAgICAgdGFncyA9IHRhZ3MuY29uY2F0KG1lcmdlLm1lcmdlKTtcbiAgICByZXR1cm4gdGFncy5yZWR1Y2UoKHRhZ3MsIHRhZykgPT4ge1xuICAgICAgICBjb25zdCB0YWdPYmogPSB0eXBlb2YgdGFnID09PSAnc3RyaW5nJyA/IHRhZ3NCeU5hbWVbdGFnXSA6IHRhZztcbiAgICAgICAgaWYgKCF0YWdPYmopIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZ05hbWUgPSBKU09OLnN0cmluZ2lmeSh0YWcpO1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRhZ3NCeU5hbWUpXG4gICAgICAgICAgICAgICAgLm1hcChrZXkgPT4gSlNPTi5zdHJpbmdpZnkoa2V5KSlcbiAgICAgICAgICAgICAgICAuam9pbignLCAnKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBjdXN0b20gdGFnICR7dGFnTmFtZX07IHVzZSBvbmUgb2YgJHtrZXlzfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGFncy5pbmNsdWRlcyh0YWdPYmopKVxuICAgICAgICAgICAgdGFncy5wdXNoKHRhZ09iaik7XG4gICAgICAgIHJldHVybiB0YWdzO1xuICAgIH0sIFtdKTtcbn1cblxuZXhwb3J0cy5jb3JlS25vd25UYWdzID0gY29yZUtub3duVGFncztcbmV4cG9ydHMuZ2V0VGFncyA9IGdldFRhZ3M7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi4vbm9kZXMvaWRlbnRpdHkuanMnKTtcbnZhciBtYXAgPSByZXF1aXJlKCcuL2NvbW1vbi9tYXAuanMnKTtcbnZhciBzZXEgPSByZXF1aXJlKCcuL2NvbW1vbi9zZXEuanMnKTtcbnZhciBzdHJpbmcgPSByZXF1aXJlKCcuL2NvbW1vbi9zdHJpbmcuanMnKTtcbnZhciB0YWdzID0gcmVxdWlyZSgnLi90YWdzLmpzJyk7XG5cbmNvbnN0IHNvcnRNYXBFbnRyaWVzQnlLZXkgPSAoYSwgYikgPT4gYS5rZXkgPCBiLmtleSA/IC0xIDogYS5rZXkgPiBiLmtleSA/IDEgOiAwO1xuY2xhc3MgU2NoZW1hIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGNvbXBhdCwgY3VzdG9tVGFncywgbWVyZ2UsIHJlc29sdmVLbm93blRhZ3MsIHNjaGVtYSwgc29ydE1hcEVudHJpZXMsIHRvU3RyaW5nRGVmYXVsdHMgfSkge1xuICAgICAgICB0aGlzLmNvbXBhdCA9IEFycmF5LmlzQXJyYXkoY29tcGF0KVxuICAgICAgICAgICAgPyB0YWdzLmdldFRhZ3MoY29tcGF0LCAnY29tcGF0JylcbiAgICAgICAgICAgIDogY29tcGF0XG4gICAgICAgICAgICAgICAgPyB0YWdzLmdldFRhZ3MobnVsbCwgY29tcGF0KVxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgdGhpcy5uYW1lID0gKHR5cGVvZiBzY2hlbWEgPT09ICdzdHJpbmcnICYmIHNjaGVtYSkgfHwgJ2NvcmUnO1xuICAgICAgICB0aGlzLmtub3duVGFncyA9IHJlc29sdmVLbm93blRhZ3MgPyB0YWdzLmNvcmVLbm93blRhZ3MgOiB7fTtcbiAgICAgICAgdGhpcy50YWdzID0gdGFncy5nZXRUYWdzKGN1c3RvbVRhZ3MsIHRoaXMubmFtZSwgbWVyZ2UpO1xuICAgICAgICB0aGlzLnRvU3RyaW5nT3B0aW9ucyA9IHRvU3RyaW5nRGVmYXVsdHMgPz8gbnVsbDtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGlkZW50aXR5Lk1BUCwgeyB2YWx1ZTogbWFwLm1hcCB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGlkZW50aXR5LlNDQUxBUiwgeyB2YWx1ZTogc3RyaW5nLnN0cmluZyB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGlkZW50aXR5LlNFUSwgeyB2YWx1ZTogc2VxLnNlcSB9KTtcbiAgICAgICAgLy8gVXNlZCBieSBjcmVhdGVNYXAoKVxuICAgICAgICB0aGlzLnNvcnRNYXBFbnRyaWVzID1cbiAgICAgICAgICAgIHR5cGVvZiBzb3J0TWFwRW50cmllcyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgID8gc29ydE1hcEVudHJpZXNcbiAgICAgICAgICAgICAgICA6IHNvcnRNYXBFbnRyaWVzID09PSB0cnVlXG4gICAgICAgICAgICAgICAgICAgID8gc29ydE1hcEVudHJpZXNCeUtleVxuICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmNyZWF0ZShTY2hlbWEucHJvdG90eXBlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0aGlzKSk7XG4gICAgICAgIGNvcHkudGFncyA9IHRoaXMudGFncy5zbGljZSgpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG59XG5cbmV4cG9ydHMuU2NoZW1hID0gU2NoZW1hO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4uL25vZGVzL2lkZW50aXR5LmpzJyk7XG52YXIgc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9zdHJpbmdpZnkuanMnKTtcbnZhciBzdHJpbmdpZnlDb21tZW50ID0gcmVxdWlyZSgnLi9zdHJpbmdpZnlDb21tZW50LmpzJyk7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeURvY3VtZW50KGRvYywgb3B0aW9ucykge1xuICAgIGNvbnN0IGxpbmVzID0gW107XG4gICAgbGV0IGhhc0RpcmVjdGl2ZXMgPSBvcHRpb25zLmRpcmVjdGl2ZXMgPT09IHRydWU7XG4gICAgaWYgKG9wdGlvbnMuZGlyZWN0aXZlcyAhPT0gZmFsc2UgJiYgZG9jLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgY29uc3QgZGlyID0gZG9jLmRpcmVjdGl2ZXMudG9TdHJpbmcoZG9jKTtcbiAgICAgICAgaWYgKGRpcikge1xuICAgICAgICAgICAgbGluZXMucHVzaChkaXIpO1xuICAgICAgICAgICAgaGFzRGlyZWN0aXZlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZG9jLmRpcmVjdGl2ZXMuZG9jU3RhcnQpXG4gICAgICAgICAgICBoYXNEaXJlY3RpdmVzID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGhhc0RpcmVjdGl2ZXMpXG4gICAgICAgIGxpbmVzLnB1c2goJy0tLScpO1xuICAgIGNvbnN0IGN0eCA9IHN0cmluZ2lmeS5jcmVhdGVTdHJpbmdpZnlDb250ZXh0KGRvYywgb3B0aW9ucyk7XG4gICAgY29uc3QgeyBjb21tZW50U3RyaW5nIH0gPSBjdHgub3B0aW9ucztcbiAgICBpZiAoZG9jLmNvbW1lbnRCZWZvcmUpIHtcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCAhPT0gMSlcbiAgICAgICAgICAgIGxpbmVzLnVuc2hpZnQoJycpO1xuICAgICAgICBjb25zdCBjcyA9IGNvbW1lbnRTdHJpbmcoZG9jLmNvbW1lbnRCZWZvcmUpO1xuICAgICAgICBsaW5lcy51bnNoaWZ0KHN0cmluZ2lmeUNvbW1lbnQuaW5kZW50Q29tbWVudChjcywgJycpKTtcbiAgICB9XG4gICAgbGV0IGNob21wS2VlcCA9IGZhbHNlO1xuICAgIGxldCBjb250ZW50Q29tbWVudCA9IG51bGw7XG4gICAgaWYgKGRvYy5jb250ZW50cykge1xuICAgICAgICBpZiAoaWRlbnRpdHkuaXNOb2RlKGRvYy5jb250ZW50cykpIHtcbiAgICAgICAgICAgIGlmIChkb2MuY29udGVudHMuc3BhY2VCZWZvcmUgJiYgaGFzRGlyZWN0aXZlcylcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICAgICAgICAgIGlmIChkb2MuY29udGVudHMuY29tbWVudEJlZm9yZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNzID0gY29tbWVudFN0cmluZyhkb2MuY29udGVudHMuY29tbWVudEJlZm9yZSk7XG4gICAgICAgICAgICAgICAgbGluZXMucHVzaChzdHJpbmdpZnlDb21tZW50LmluZGVudENvbW1lbnQoY3MsICcnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0b3AtbGV2ZWwgYmxvY2sgc2NhbGFycyBuZWVkIHRvIGJlIGluZGVudGVkIGlmIGZvbGxvd2VkIGJ5IGEgY29tbWVudFxuICAgICAgICAgICAgY3R4LmZvcmNlQmxvY2tJbmRlbnQgPSAhIWRvYy5jb21tZW50O1xuICAgICAgICAgICAgY29udGVudENvbW1lbnQgPSBkb2MuY29udGVudHMuY29tbWVudDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbkNob21wS2VlcCA9IGNvbnRlbnRDb21tZW50ID8gdW5kZWZpbmVkIDogKCkgPT4gKGNob21wS2VlcCA9IHRydWUpO1xuICAgICAgICBsZXQgYm9keSA9IHN0cmluZ2lmeS5zdHJpbmdpZnkoZG9jLmNvbnRlbnRzLCBjdHgsICgpID0+IChjb250ZW50Q29tbWVudCA9IG51bGwpLCBvbkNob21wS2VlcCk7XG4gICAgICAgIGlmIChjb250ZW50Q29tbWVudClcbiAgICAgICAgICAgIGJvZHkgKz0gc3RyaW5naWZ5Q29tbWVudC5saW5lQ29tbWVudChib2R5LCAnJywgY29tbWVudFN0cmluZyhjb250ZW50Q29tbWVudCkpO1xuICAgICAgICBpZiAoKGJvZHlbMF0gPT09ICd8JyB8fCBib2R5WzBdID09PSAnPicpICYmXG4gICAgICAgICAgICBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSA9PT0gJy0tLScpIHtcbiAgICAgICAgICAgIC8vIFRvcC1sZXZlbCBibG9jayBzY2FsYXJzIHdpdGggYSBwcmVjZWRpbmcgZG9jIG1hcmtlciBvdWdodCB0byB1c2UgdGhlXG4gICAgICAgICAgICAvLyBzYW1lIGxpbmUgZm9yIHRoZWlyIGhlYWRlci5cbiAgICAgICAgICAgIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdID0gYC0tLSAke2JvZHl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBsaW5lcy5wdXNoKGJvZHkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGluZXMucHVzaChzdHJpbmdpZnkuc3RyaW5naWZ5KGRvYy5jb250ZW50cywgY3R4KSk7XG4gICAgfVxuICAgIGlmIChkb2MuZGlyZWN0aXZlcz8uZG9jRW5kKSB7XG4gICAgICAgIGlmIChkb2MuY29tbWVudCkge1xuICAgICAgICAgICAgY29uc3QgY3MgPSBjb21tZW50U3RyaW5nKGRvYy5jb21tZW50KTtcbiAgICAgICAgICAgIGlmIChjcy5pbmNsdWRlcygnXFxuJykpIHtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKCcuLi4nKTtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKHN0cmluZ2lmeUNvbW1lbnQuaW5kZW50Q29tbWVudChjcywgJycpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goYC4uLiAke2NzfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGluZXMucHVzaCgnLi4uJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBkYyA9IGRvYy5jb21tZW50O1xuICAgICAgICBpZiAoZGMgJiYgY2hvbXBLZWVwKVxuICAgICAgICAgICAgZGMgPSBkYy5yZXBsYWNlKC9eXFxuKy8sICcnKTtcbiAgICAgICAgaWYgKGRjKSB7XG4gICAgICAgICAgICBpZiAoKCFjaG9tcEtlZXAgfHwgY29udGVudENvbW1lbnQpICYmIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdICE9PSAnJylcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICAgICAgICAgIGxpbmVzLnB1c2goc3RyaW5naWZ5Q29tbWVudC5pbmRlbnRDb21tZW50KGNvbW1lbnRTdHJpbmcoZGMpLCAnJykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsaW5lcy5qb2luKCdcXG4nKSArICdcXG4nO1xufVxuXG5leHBvcnRzLnN0cmluZ2lmeURvY3VtZW50ID0gc3RyaW5naWZ5RG9jdW1lbnQ7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIEFsaWFzID0gcmVxdWlyZSgnLi4vbm9kZXMvQWxpYXMuanMnKTtcbnZhciBDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vbm9kZXMvQ29sbGVjdGlvbi5qcycpO1xudmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi4vbm9kZXMvaWRlbnRpdHkuanMnKTtcbnZhciBQYWlyID0gcmVxdWlyZSgnLi4vbm9kZXMvUGFpci5qcycpO1xudmFyIHRvSlMgPSByZXF1aXJlKCcuLi9ub2Rlcy90b0pTLmpzJyk7XG52YXIgU2NoZW1hID0gcmVxdWlyZSgnLi4vc2NoZW1hL1NjaGVtYS5qcycpO1xudmFyIHN0cmluZ2lmeURvY3VtZW50ID0gcmVxdWlyZSgnLi4vc3RyaW5naWZ5L3N0cmluZ2lmeURvY3VtZW50LmpzJyk7XG52YXIgYW5jaG9ycyA9IHJlcXVpcmUoJy4vYW5jaG9ycy5qcycpO1xudmFyIGFwcGx5UmV2aXZlciA9IHJlcXVpcmUoJy4vYXBwbHlSZXZpdmVyLmpzJyk7XG52YXIgY3JlYXRlTm9kZSA9IHJlcXVpcmUoJy4vY3JlYXRlTm9kZS5qcycpO1xudmFyIGRpcmVjdGl2ZXMgPSByZXF1aXJlKCcuL2RpcmVjdGl2ZXMuanMnKTtcblxuY2xhc3MgRG9jdW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCByZXBsYWNlciwgb3B0aW9ucykge1xuICAgICAgICAvKiogQSBjb21tZW50IGJlZm9yZSB0aGlzIERvY3VtZW50ICovXG4gICAgICAgIHRoaXMuY29tbWVudEJlZm9yZSA9IG51bGw7XG4gICAgICAgIC8qKiBBIGNvbW1lbnQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhpcyBEb2N1bWVudCAqL1xuICAgICAgICB0aGlzLmNvbW1lbnQgPSBudWxsO1xuICAgICAgICAvKiogRXJyb3JzIGVuY291bnRlcmVkIGR1cmluZyBwYXJzaW5nLiAqL1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICAvKiogV2FybmluZ3MgZW5jb3VudGVyZWQgZHVyaW5nIHBhcnNpbmcuICovXG4gICAgICAgIHRoaXMud2FybmluZ3MgPSBbXTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGlkZW50aXR5Lk5PREVfVFlQRSwgeyB2YWx1ZTogaWRlbnRpdHkuRE9DIH0pO1xuICAgICAgICBsZXQgX3JlcGxhY2VyID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJyB8fCBBcnJheS5pc0FycmF5KHJlcGxhY2VyKSkge1xuICAgICAgICAgICAgX3JlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkICYmIHJlcGxhY2VyKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gcmVwbGFjZXI7XG4gICAgICAgICAgICByZXBsYWNlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHQgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGludEFzQmlnSW50OiBmYWxzZSxcbiAgICAgICAgICAgIGtlZXBTb3VyY2VUb2tlbnM6IGZhbHNlLFxuICAgICAgICAgICAgbG9nTGV2ZWw6ICd3YXJuJyxcbiAgICAgICAgICAgIHByZXR0eUVycm9yczogdHJ1ZSxcbiAgICAgICAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgICAgICAgIHN0cmluZ0tleXM6IGZhbHNlLFxuICAgICAgICAgICAgdW5pcXVlS2V5czogdHJ1ZSxcbiAgICAgICAgICAgIHZlcnNpb246ICcxLjInXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHQ7XG4gICAgICAgIGxldCB7IHZlcnNpb24gfSA9IG9wdDtcbiAgICAgICAgaWYgKG9wdGlvbnM/Ll9kaXJlY3RpdmVzKSB7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBvcHRpb25zLl9kaXJlY3RpdmVzLmF0RG9jdW1lbnQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpcmVjdGl2ZXMueWFtbC5leHBsaWNpdClcbiAgICAgICAgICAgICAgICB2ZXJzaW9uID0gdGhpcy5kaXJlY3RpdmVzLnlhbWwudmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBuZXcgZGlyZWN0aXZlcy5EaXJlY3RpdmVzKHsgdmVyc2lvbiB9KTtcbiAgICAgICAgdGhpcy5zZXRTY2hlbWEodmVyc2lvbiwgb3B0aW9ucyk7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgV2UgY2FuJ3QgcmVhbGx5IGtub3cgdGhhdCB0aGlzIG1hdGNoZXMgQ29udGVudHMuXG4gICAgICAgIHRoaXMuY29udGVudHMgPVxuICAgICAgICAgICAgdmFsdWUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiB0aGlzLmNyZWF0ZU5vZGUodmFsdWUsIF9yZXBsYWNlciwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGRlZXAgY29weSBvZiB0aGlzIERvY3VtZW50IGFuZCBpdHMgY29udGVudHMuXG4gICAgICpcbiAgICAgKiBDdXN0b20gTm9kZSB2YWx1ZXMgdGhhdCBpbmhlcml0IGZyb20gYE9iamVjdGAgc3RpbGwgcmVmZXIgdG8gdGhlaXIgb3JpZ2luYWwgaW5zdGFuY2VzLlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmNyZWF0ZShEb2N1bWVudC5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgIFtpZGVudGl0eS5OT0RFX1RZUEVdOiB7IHZhbHVlOiBpZGVudGl0eS5ET0MgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29weS5jb21tZW50QmVmb3JlID0gdGhpcy5jb21tZW50QmVmb3JlO1xuICAgICAgICBjb3B5LmNvbW1lbnQgPSB0aGlzLmNvbW1lbnQ7XG4gICAgICAgIGNvcHkuZXJyb3JzID0gdGhpcy5lcnJvcnMuc2xpY2UoKTtcbiAgICAgICAgY29weS53YXJuaW5ncyA9IHRoaXMud2FybmluZ3Muc2xpY2UoKTtcbiAgICAgICAgY29weS5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMuZGlyZWN0aXZlcylcbiAgICAgICAgICAgIGNvcHkuZGlyZWN0aXZlcyA9IHRoaXMuZGlyZWN0aXZlcy5jbG9uZSgpO1xuICAgICAgICBjb3B5LnNjaGVtYSA9IHRoaXMuc2NoZW1hLmNsb25lKCk7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgV2UgY2FuJ3QgcmVhbGx5IGtub3cgdGhhdCB0aGlzIG1hdGNoZXMgQ29udGVudHMuXG4gICAgICAgIGNvcHkuY29udGVudHMgPSBpZGVudGl0eS5pc05vZGUodGhpcy5jb250ZW50cylcbiAgICAgICAgICAgID8gdGhpcy5jb250ZW50cy5jbG9uZShjb3B5LnNjaGVtYSlcbiAgICAgICAgICAgIDogdGhpcy5jb250ZW50cztcbiAgICAgICAgaWYgKHRoaXMucmFuZ2UpXG4gICAgICAgICAgICBjb3B5LnJhbmdlID0gdGhpcy5yYW5nZS5zbGljZSgpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLyoqIEFkZHMgYSB2YWx1ZSB0byB0aGUgZG9jdW1lbnQuICovXG4gICAgYWRkKHZhbHVlKSB7XG4gICAgICAgIGlmIChhc3NlcnRDb2xsZWN0aW9uKHRoaXMuY29udGVudHMpKVxuICAgICAgICAgICAgdGhpcy5jb250ZW50cy5hZGQodmFsdWUpO1xuICAgIH1cbiAgICAvKiogQWRkcyBhIHZhbHVlIHRvIHRoZSBkb2N1bWVudC4gKi9cbiAgICBhZGRJbihwYXRoLCB2YWx1ZSkge1xuICAgICAgICBpZiAoYXNzZXJ0Q29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKSlcbiAgICAgICAgICAgIHRoaXMuY29udGVudHMuYWRkSW4ocGF0aCwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgYEFsaWFzYCBub2RlLCBlbnN1cmluZyB0aGF0IHRoZSB0YXJnZXQgYG5vZGVgIGhhcyB0aGUgcmVxdWlyZWQgYW5jaG9yLlxuICAgICAqXG4gICAgICogSWYgYG5vZGVgIGFscmVhZHkgaGFzIGFuIGFuY2hvciwgYG5hbWVgIGlzIGlnbm9yZWQuXG4gICAgICogT3RoZXJ3aXNlLCB0aGUgYG5vZGUuYW5jaG9yYCB2YWx1ZSB3aWxsIGJlIHNldCB0byBgbmFtZWAsXG4gICAgICogb3IgaWYgYW4gYW5jaG9yIHdpdGggdGhhdCBuYW1lIGlzIGFscmVhZHkgcHJlc2VudCBpbiB0aGUgZG9jdW1lbnQsXG4gICAgICogYG5hbWVgIHdpbGwgYmUgdXNlZCBhcyBhIHByZWZpeCBmb3IgYSBuZXcgdW5pcXVlIGFuY2hvci5cbiAgICAgKiBJZiBgbmFtZWAgaXMgdW5kZWZpbmVkLCB0aGUgZ2VuZXJhdGVkIGFuY2hvciB3aWxsIHVzZSAnYScgYXMgYSBwcmVmaXguXG4gICAgICovXG4gICAgY3JlYXRlQWxpYXMobm9kZSwgbmFtZSkge1xuICAgICAgICBpZiAoIW5vZGUuYW5jaG9yKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gYW5jaG9ycy5hbmNob3JOYW1lcyh0aGlzKTtcbiAgICAgICAgICAgIG5vZGUuYW5jaG9yID1cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1udWxsaXNoLWNvYWxlc2NpbmdcbiAgICAgICAgICAgICAgICAhbmFtZSB8fCBwcmV2LmhhcyhuYW1lKSA/IGFuY2hvcnMuZmluZE5ld0FuY2hvcihuYW1lIHx8ICdhJywgcHJldikgOiBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQWxpYXMuQWxpYXMobm9kZS5hbmNob3IpO1xuICAgIH1cbiAgICBjcmVhdGVOb2RlKHZhbHVlLCByZXBsYWNlciwgb3B0aW9ucykge1xuICAgICAgICBsZXQgX3JlcGxhY2VyID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodHlwZW9mIHJlcGxhY2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHJlcGxhY2VyLmNhbGwoeyAnJzogdmFsdWUgfSwgJycsIHZhbHVlKTtcbiAgICAgICAgICAgIF9yZXBsYWNlciA9IHJlcGxhY2VyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVwbGFjZXIpKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlUb1N0ciA9ICh2KSA9PiB0eXBlb2YgdiA9PT0gJ251bWJlcicgfHwgdiBpbnN0YW5jZW9mIFN0cmluZyB8fCB2IGluc3RhbmNlb2YgTnVtYmVyO1xuICAgICAgICAgICAgY29uc3QgYXNTdHIgPSByZXBsYWNlci5maWx0ZXIoa2V5VG9TdHIpLm1hcChTdHJpbmcpO1xuICAgICAgICAgICAgaWYgKGFzU3RyLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgcmVwbGFjZXIgPSByZXBsYWNlci5jb25jYXQoYXNTdHIpO1xuICAgICAgICAgICAgX3JlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkICYmIHJlcGxhY2VyKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gcmVwbGFjZXI7XG4gICAgICAgICAgICByZXBsYWNlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGFsaWFzRHVwbGljYXRlT2JqZWN0cywgYW5jaG9yUHJlZml4LCBmbG93LCBrZWVwVW5kZWZpbmVkLCBvblRhZ09iaiwgdGFnIH0gPSBvcHRpb25zID8/IHt9O1xuICAgICAgICBjb25zdCB7IG9uQW5jaG9yLCBzZXRBbmNob3JzLCBzb3VyY2VPYmplY3RzIH0gPSBhbmNob3JzLmNyZWF0ZU5vZGVBbmNob3JzKHRoaXMsIFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1udWxsaXNoLWNvYWxlc2NpbmdcbiAgICAgICAgYW5jaG9yUHJlZml4IHx8ICdhJyk7XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIGFsaWFzRHVwbGljYXRlT2JqZWN0czogYWxpYXNEdXBsaWNhdGVPYmplY3RzID8/IHRydWUsXG4gICAgICAgICAgICBrZWVwVW5kZWZpbmVkOiBrZWVwVW5kZWZpbmVkID8/IGZhbHNlLFxuICAgICAgICAgICAgb25BbmNob3IsXG4gICAgICAgICAgICBvblRhZ09iaixcbiAgICAgICAgICAgIHJlcGxhY2VyOiBfcmVwbGFjZXIsXG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgICAgICAgc291cmNlT2JqZWN0c1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBub2RlID0gY3JlYXRlTm9kZS5jcmVhdGVOb2RlKHZhbHVlLCB0YWcsIGN0eCk7XG4gICAgICAgIGlmIChmbG93ICYmIGlkZW50aXR5LmlzQ29sbGVjdGlvbihub2RlKSlcbiAgICAgICAgICAgIG5vZGUuZmxvdyA9IHRydWU7XG4gICAgICAgIHNldEFuY2hvcnMoKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSBrZXkgYW5kIGEgdmFsdWUgaW50byBhIGBQYWlyYCB1c2luZyB0aGUgY3VycmVudCBzY2hlbWEsXG4gICAgICogcmVjdXJzaXZlbHkgd3JhcHBpbmcgYWxsIHZhbHVlcyBhcyBgU2NhbGFyYCBvciBgQ29sbGVjdGlvbmAgbm9kZXMuXG4gICAgICovXG4gICAgY3JlYXRlUGFpcihrZXksIHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgayA9IHRoaXMuY3JlYXRlTm9kZShrZXksIG51bGwsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB2ID0gdGhpcy5jcmVhdGVOb2RlKHZhbHVlLCBudWxsLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQYWlyLlBhaXIoaywgdik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSB2YWx1ZSBmcm9tIHRoZSBkb2N1bWVudC5cbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGl0ZW0gd2FzIGZvdW5kIGFuZCByZW1vdmVkLlxuICAgICAqL1xuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgcmV0dXJuIGFzc2VydENvbGxlY3Rpb24odGhpcy5jb250ZW50cykgPyB0aGlzLmNvbnRlbnRzLmRlbGV0ZShrZXkpIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSB2YWx1ZSBmcm9tIHRoZSBkb2N1bWVudC5cbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGl0ZW0gd2FzIGZvdW5kIGFuZCByZW1vdmVkLlxuICAgICAqL1xuICAgIGRlbGV0ZUluKHBhdGgpIHtcbiAgICAgICAgaWYgKENvbGxlY3Rpb24uaXNFbXB0eVBhdGgocGF0aCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnRzID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBQcmVzdW1lZCBpbXBvc3NpYmxlIGlmIFN0cmljdCBleHRlbmRzIGZhbHNlXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRzID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3NlcnRDb2xsZWN0aW9uKHRoaXMuY29udGVudHMpXG4gICAgICAgICAgICA/IHRoaXMuY29udGVudHMuZGVsZXRlSW4ocGF0aClcbiAgICAgICAgICAgIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaXRlbSBhdCBga2V5YCwgb3IgYHVuZGVmaW5lZGAgaWYgbm90IGZvdW5kLiBCeSBkZWZhdWx0IHVud3JhcHNcbiAgICAgKiBzY2FsYXIgdmFsdWVzIGZyb20gdGhlaXIgc3Vycm91bmRpbmcgbm9kZTsgdG8gZGlzYWJsZSBzZXQgYGtlZXBTY2FsYXJgIHRvXG4gICAgICogYHRydWVgIChjb2xsZWN0aW9ucyBhcmUgYWx3YXlzIHJldHVybmVkIGludGFjdCkuXG4gICAgICovXG4gICAgZ2V0KGtleSwga2VlcFNjYWxhcikge1xuICAgICAgICByZXR1cm4gaWRlbnRpdHkuaXNDb2xsZWN0aW9uKHRoaXMuY29udGVudHMpXG4gICAgICAgICAgICA/IHRoaXMuY29udGVudHMuZ2V0KGtleSwga2VlcFNjYWxhcilcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGl0ZW0gYXQgYHBhdGhgLCBvciBgdW5kZWZpbmVkYCBpZiBub3QgZm91bmQuIEJ5IGRlZmF1bHQgdW53cmFwc1xuICAgICAqIHNjYWxhciB2YWx1ZXMgZnJvbSB0aGVpciBzdXJyb3VuZGluZyBub2RlOyB0byBkaXNhYmxlIHNldCBga2VlcFNjYWxhcmAgdG9cbiAgICAgKiBgdHJ1ZWAgKGNvbGxlY3Rpb25zIGFyZSBhbHdheXMgcmV0dXJuZWQgaW50YWN0KS5cbiAgICAgKi9cbiAgICBnZXRJbihwYXRoLCBrZWVwU2NhbGFyKSB7XG4gICAgICAgIGlmIChDb2xsZWN0aW9uLmlzRW1wdHlQYXRoKHBhdGgpKVxuICAgICAgICAgICAgcmV0dXJuICFrZWVwU2NhbGFyICYmIGlkZW50aXR5LmlzU2NhbGFyKHRoaXMuY29udGVudHMpXG4gICAgICAgICAgICAgICAgPyB0aGlzLmNvbnRlbnRzLnZhbHVlXG4gICAgICAgICAgICAgICAgOiB0aGlzLmNvbnRlbnRzO1xuICAgICAgICByZXR1cm4gaWRlbnRpdHkuaXNDb2xsZWN0aW9uKHRoaXMuY29udGVudHMpXG4gICAgICAgICAgICA/IHRoaXMuY29udGVudHMuZ2V0SW4ocGF0aCwga2VlcFNjYWxhcilcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGRvY3VtZW50IGluY2x1ZGVzIGEgdmFsdWUgd2l0aCB0aGUga2V5IGBrZXlgLlxuICAgICAqL1xuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5LmlzQ29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKSA/IHRoaXMuY29udGVudHMuaGFzKGtleSkgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBkb2N1bWVudCBpbmNsdWRlcyBhIHZhbHVlIGF0IGBwYXRoYC5cbiAgICAgKi9cbiAgICBoYXNJbihwYXRoKSB7XG4gICAgICAgIGlmIChDb2xsZWN0aW9uLmlzRW1wdHlQYXRoKHBhdGgpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudHMgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5LmlzQ29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKSA/IHRoaXMuY29udGVudHMuaGFzSW4ocGF0aCkgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIHZhbHVlIGluIHRoaXMgZG9jdW1lbnQuIEZvciBgISFzZXRgLCBgdmFsdWVgIG5lZWRzIHRvIGJlIGFcbiAgICAgKiBib29sZWFuIHRvIGFkZC9yZW1vdmUgdGhlIGl0ZW0gZnJvbSB0aGUgc2V0LlxuICAgICAqL1xuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRzID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgV2UgY2FuJ3QgcmVhbGx5IGtub3cgdGhhdCB0aGlzIG1hdGNoZXMgQ29udGVudHMuXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRzID0gQ29sbGVjdGlvbi5jb2xsZWN0aW9uRnJvbVBhdGgodGhpcy5zY2hlbWEsIFtrZXldLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXNzZXJ0Q29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKSkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50cy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIHZhbHVlIGluIHRoaXMgZG9jdW1lbnQuIEZvciBgISFzZXRgLCBgdmFsdWVgIG5lZWRzIHRvIGJlIGFcbiAgICAgKiBib29sZWFuIHRvIGFkZC9yZW1vdmUgdGhlIGl0ZW0gZnJvbSB0aGUgc2V0LlxuICAgICAqL1xuICAgIHNldEluKHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIGlmIChDb2xsZWN0aW9uLmlzRW1wdHlQYXRoKHBhdGgpKSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFdlIGNhbid0IHJlYWxseSBrbm93IHRoYXQgdGhpcyBtYXRjaGVzIENvbnRlbnRzLlxuICAgICAgICAgICAgdGhpcy5jb250ZW50cyA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY29udGVudHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBXZSBjYW4ndCByZWFsbHkga25vdyB0aGF0IHRoaXMgbWF0Y2hlcyBDb250ZW50cy5cbiAgICAgICAgICAgIHRoaXMuY29udGVudHMgPSBDb2xsZWN0aW9uLmNvbGxlY3Rpb25Gcm9tUGF0aCh0aGlzLnNjaGVtYSwgQXJyYXkuZnJvbShwYXRoKSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFzc2VydENvbGxlY3Rpb24odGhpcy5jb250ZW50cykpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudHMuc2V0SW4ocGF0aCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZSB0aGUgWUFNTCB2ZXJzaW9uIGFuZCBzY2hlbWEgdXNlZCBieSB0aGUgZG9jdW1lbnQuXG4gICAgICogQSBgbnVsbGAgdmVyc2lvbiBkaXNhYmxlcyBzdXBwb3J0IGZvciBkaXJlY3RpdmVzLCBleHBsaWNpdCB0YWdzLCBhbmNob3JzLCBhbmQgYWxpYXNlcy5cbiAgICAgKiBJdCBhbHNvIHJlcXVpcmVzIHRoZSBgc2NoZW1hYCBvcHRpb24gdG8gYmUgZ2l2ZW4gYXMgYSBgU2NoZW1hYCBpbnN0YW5jZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIE92ZXJyaWRlcyBhbGwgcHJldmlvdXNseSBzZXQgc2NoZW1hIG9wdGlvbnMuXG4gICAgICovXG4gICAgc2V0U2NoZW1hKHZlcnNpb24sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdudW1iZXInKVxuICAgICAgICAgICAgdmVyc2lvbiA9IFN0cmluZyh2ZXJzaW9uKTtcbiAgICAgICAgbGV0IG9wdDtcbiAgICAgICAgc3dpdGNoICh2ZXJzaW9uKSB7XG4gICAgICAgICAgICBjYXNlICcxLjEnOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRpcmVjdGl2ZXMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcy55YW1sLnZlcnNpb24gPSAnMS4xJztcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IG5ldyBkaXJlY3RpdmVzLkRpcmVjdGl2ZXMoeyB2ZXJzaW9uOiAnMS4xJyB9KTtcbiAgICAgICAgICAgICAgICBvcHQgPSB7IHJlc29sdmVLbm93blRhZ3M6IGZhbHNlLCBzY2hlbWE6ICd5YW1sLTEuMScgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJzEuMic6XG4gICAgICAgICAgICBjYXNlICduZXh0JzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kaXJlY3RpdmVzKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMueWFtbC52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IG5ldyBkaXJlY3RpdmVzLkRpcmVjdGl2ZXMoeyB2ZXJzaW9uIH0pO1xuICAgICAgICAgICAgICAgIG9wdCA9IHsgcmVzb2x2ZUtub3duVGFnczogdHJ1ZSwgc2NoZW1hOiAnY29yZScgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgbnVsbDpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kaXJlY3RpdmVzKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5kaXJlY3RpdmVzO1xuICAgICAgICAgICAgICAgIG9wdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3YgPSBKU09OLnN0cmluZ2lmeSh2ZXJzaW9uKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkICcxLjEnLCAnMS4yJyBvciBudWxsIGFzIGZpcnN0IGFyZ3VtZW50LCBidXQgZm91bmQ6ICR7c3Z9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90IHVzaW5nIGBpbnN0YW5jZW9mIFNjaGVtYWAgdG8gYWxsb3cgZm9yIGR1Y2sgdHlwaW5nXG4gICAgICAgIGlmIChvcHRpb25zLnNjaGVtYSBpbnN0YW5jZW9mIE9iamVjdClcbiAgICAgICAgICAgIHRoaXMuc2NoZW1hID0gb3B0aW9ucy5zY2hlbWE7XG4gICAgICAgIGVsc2UgaWYgKG9wdClcbiAgICAgICAgICAgIHRoaXMuc2NoZW1hID0gbmV3IFNjaGVtYS5TY2hlbWEoT2JqZWN0LmFzc2lnbihvcHQsIG9wdGlvbnMpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXaXRoIGEgbnVsbCBZQU1MIHZlcnNpb24sIHRoZSB7IHNjaGVtYTogU2NoZW1hIH0gb3B0aW9uIGlzIHJlcXVpcmVkYCk7XG4gICAgfVxuICAgIC8vIGpzb24gJiBqc29uQXJnIGFyZSBvbmx5IHVzZWQgZnJvbSB0b0pTT04oKVxuICAgIHRvSlMoeyBqc29uLCBqc29uQXJnLCBtYXBBc01hcCwgbWF4QWxpYXNDb3VudCwgb25BbmNob3IsIHJldml2ZXIgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIGFuY2hvcnM6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIGRvYzogdGhpcyxcbiAgICAgICAgICAgIGtlZXA6ICFqc29uLFxuICAgICAgICAgICAgbWFwQXNNYXA6IG1hcEFzTWFwID09PSB0cnVlLFxuICAgICAgICAgICAgbWFwS2V5V2FybmVkOiBmYWxzZSxcbiAgICAgICAgICAgIG1heEFsaWFzQ291bnQ6IHR5cGVvZiBtYXhBbGlhc0NvdW50ID09PSAnbnVtYmVyJyA/IG1heEFsaWFzQ291bnQgOiAxMDBcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzID0gdG9KUy50b0pTKHRoaXMuY29udGVudHMsIGpzb25BcmcgPz8gJycsIGN0eCk7XG4gICAgICAgIGlmICh0eXBlb2Ygb25BbmNob3IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgY291bnQsIHJlcyB9IG9mIGN0eC5hbmNob3JzLnZhbHVlcygpKVxuICAgICAgICAgICAgICAgIG9uQW5jaG9yKHJlcywgY291bnQpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHJldml2ZXIgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gYXBwbHlSZXZpdmVyLmFwcGx5UmV2aXZlcihyZXZpdmVyLCB7ICcnOiByZXMgfSwgJycsIHJlcylcbiAgICAgICAgICAgIDogcmVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIGRvY3VtZW50IGBjb250ZW50c2AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ganNvbkFyZyBVc2VkIGJ5IGBKU09OLnN0cmluZ2lmeWAgdG8gaW5kaWNhdGUgdGhlIGFycmF5IGluZGV4IG9yXG4gICAgICogICBwcm9wZXJ0eSBuYW1lLlxuICAgICAqL1xuICAgIHRvSlNPTihqc29uQXJnLCBvbkFuY2hvcikge1xuICAgICAgICByZXR1cm4gdGhpcy50b0pTKHsganNvbjogdHJ1ZSwganNvbkFyZywgbWFwQXNNYXA6IGZhbHNlLCBvbkFuY2hvciB9KTtcbiAgICB9XG4gICAgLyoqIEEgWUFNTCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZG9jdW1lbnQuICovXG4gICAgdG9TdHJpbmcob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9ycy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEb2N1bWVudCB3aXRoIGVycm9ycyBjYW5ub3QgYmUgc3RyaW5naWZpZWQnKTtcbiAgICAgICAgaWYgKCdpbmRlbnQnIGluIG9wdGlvbnMgJiZcbiAgICAgICAgICAgICghTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLmluZGVudCkgfHwgTnVtYmVyKG9wdGlvbnMuaW5kZW50KSA8PSAwKSkge1xuICAgICAgICAgICAgY29uc3QgcyA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuaW5kZW50KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCJpbmRlbnRcIiBvcHRpb24gbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIG5vdCAke3N9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeURvY3VtZW50LnN0cmluZ2lmeURvY3VtZW50KHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2VydENvbGxlY3Rpb24oY29udGVudHMpIHtcbiAgICBpZiAoaWRlbnRpdHkuaXNDb2xsZWN0aW9uKGNvbnRlbnRzKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIFlBTUwgY29sbGVjdGlvbiBhcyBkb2N1bWVudCBjb250ZW50cycpO1xufVxuXG5leHBvcnRzLkRvY3VtZW50ID0gRG9jdW1lbnQ7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxuY2xhc3MgWUFNTEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHBvcywgY29kZSwgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICB9XG59XG5jbGFzcyBZQU1MUGFyc2VFcnJvciBleHRlbmRzIFlBTUxFcnJvciB7XG4gICAgY29uc3RydWN0b3IocG9zLCBjb2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKCdZQU1MUGFyc2VFcnJvcicsIHBvcywgY29kZSwgbWVzc2FnZSk7XG4gICAgfVxufVxuY2xhc3MgWUFNTFdhcm5pbmcgZXh0ZW5kcyBZQU1MRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHBvcywgY29kZSwgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcignWUFNTFdhcm5pbmcnLCBwb3MsIGNvZGUsIG1lc3NhZ2UpO1xuICAgIH1cbn1cbmNvbnN0IHByZXR0aWZ5RXJyb3IgPSAoc3JjLCBsYykgPT4gKGVycm9yKSA9PiB7XG4gICAgaWYgKGVycm9yLnBvc1swXSA9PT0gLTEpXG4gICAgICAgIHJldHVybjtcbiAgICBlcnJvci5saW5lUG9zID0gZXJyb3IucG9zLm1hcChwb3MgPT4gbGMubGluZVBvcyhwb3MpKTtcbiAgICBjb25zdCB7IGxpbmUsIGNvbCB9ID0gZXJyb3IubGluZVBvc1swXTtcbiAgICBlcnJvci5tZXNzYWdlICs9IGAgYXQgbGluZSAke2xpbmV9LCBjb2x1bW4gJHtjb2x9YDtcbiAgICBsZXQgY2kgPSBjb2wgLSAxO1xuICAgIGxldCBsaW5lU3RyID0gc3JjXG4gICAgICAgIC5zdWJzdHJpbmcobGMubGluZVN0YXJ0c1tsaW5lIC0gMV0sIGxjLmxpbmVTdGFydHNbbGluZV0pXG4gICAgICAgIC5yZXBsYWNlKC9bXFxuXFxyXSskLywgJycpO1xuICAgIC8vIFRyaW0gdG8gbWF4IDgwIGNoYXJzLCBrZWVwaW5nIGNvbCBwb3NpdGlvbiBuZWFyIHRoZSBtaWRkbGVcbiAgICBpZiAoY2kgPj0gNjAgJiYgbGluZVN0ci5sZW5ndGggPiA4MCkge1xuICAgICAgICBjb25zdCB0cmltU3RhcnQgPSBNYXRoLm1pbihjaSAtIDM5LCBsaW5lU3RyLmxlbmd0aCAtIDc5KTtcbiAgICAgICAgbGluZVN0ciA9ICfigKYnICsgbGluZVN0ci5zdWJzdHJpbmcodHJpbVN0YXJ0KTtcbiAgICAgICAgY2kgLT0gdHJpbVN0YXJ0IC0gMTtcbiAgICB9XG4gICAgaWYgKGxpbmVTdHIubGVuZ3RoID4gODApXG4gICAgICAgIGxpbmVTdHIgPSBsaW5lU3RyLnN1YnN0cmluZygwLCA3OSkgKyAn4oCmJztcbiAgICAvLyBJbmNsdWRlIHByZXZpb3VzIGxpbmUgaW4gY29udGV4dCBpZiBwb2ludGluZyBhdCBsaW5lIHN0YXJ0XG4gICAgaWYgKGxpbmUgPiAxICYmIC9eICokLy50ZXN0KGxpbmVTdHIuc3Vic3RyaW5nKDAsIGNpKSkpIHtcbiAgICAgICAgLy8gUmVnZXhwIHdvbid0IG1hdGNoIGlmIHN0YXJ0IGlzIHRyaW1tZWRcbiAgICAgICAgbGV0IHByZXYgPSBzcmMuc3Vic3RyaW5nKGxjLmxpbmVTdGFydHNbbGluZSAtIDJdLCBsYy5saW5lU3RhcnRzW2xpbmUgLSAxXSk7XG4gICAgICAgIGlmIChwcmV2Lmxlbmd0aCA+IDgwKVxuICAgICAgICAgICAgcHJldiA9IHByZXYuc3Vic3RyaW5nKDAsIDc5KSArICfigKZcXG4nO1xuICAgICAgICBsaW5lU3RyID0gcHJldiArIGxpbmVTdHI7XG4gICAgfVxuICAgIGlmICgvW14gXS8udGVzdChsaW5lU3RyKSkge1xuICAgICAgICBsZXQgY291bnQgPSAxO1xuICAgICAgICBjb25zdCBlbmQgPSBlcnJvci5saW5lUG9zWzFdO1xuICAgICAgICBpZiAoZW5kPy5saW5lID09PSBsaW5lICYmIGVuZC5jb2wgPiBjb2wpIHtcbiAgICAgICAgICAgIGNvdW50ID0gTWF0aC5tYXgoMSwgTWF0aC5taW4oZW5kLmNvbCAtIGNvbCwgODAgLSBjaSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvaW50ZXIgPSAnICcucmVwZWF0KGNpKSArICdeJy5yZXBlYXQoY291bnQpO1xuICAgICAgICBlcnJvci5tZXNzYWdlICs9IGA6XFxuXFxuJHtsaW5lU3RyfVxcbiR7cG9pbnRlcn1cXG5gO1xuICAgIH1cbn07XG5cbmV4cG9ydHMuWUFNTEVycm9yID0gWUFNTEVycm9yO1xuZXhwb3J0cy5ZQU1MUGFyc2VFcnJvciA9IFlBTUxQYXJzZUVycm9yO1xuZXhwb3J0cy5ZQU1MV2FybmluZyA9IFlBTUxXYXJuaW5nO1xuZXhwb3J0cy5wcmV0dGlmeUVycm9yID0gcHJldHRpZnlFcnJvcjtcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiByZXNvbHZlUHJvcHModG9rZW5zLCB7IGZsb3csIGluZGljYXRvciwgbmV4dCwgb2Zmc2V0LCBvbkVycm9yLCBwYXJlbnRJbmRlbnQsIHN0YXJ0T25OZXdsaW5lIH0pIHtcbiAgICBsZXQgc3BhY2VCZWZvcmUgPSBmYWxzZTtcbiAgICBsZXQgYXROZXdsaW5lID0gc3RhcnRPbk5ld2xpbmU7XG4gICAgbGV0IGhhc1NwYWNlID0gc3RhcnRPbk5ld2xpbmU7XG4gICAgbGV0IGNvbW1lbnQgPSAnJztcbiAgICBsZXQgY29tbWVudFNlcCA9ICcnO1xuICAgIGxldCBoYXNOZXdsaW5lID0gZmFsc2U7XG4gICAgbGV0IHJlcVNwYWNlID0gZmFsc2U7XG4gICAgbGV0IHRhYiA9IG51bGw7XG4gICAgbGV0IGFuY2hvciA9IG51bGw7XG4gICAgbGV0IHRhZyA9IG51bGw7XG4gICAgbGV0IG5ld2xpbmVBZnRlclByb3AgPSBudWxsO1xuICAgIGxldCBjb21tYSA9IG51bGw7XG4gICAgbGV0IGZvdW5kID0gbnVsbDtcbiAgICBsZXQgc3RhcnQgPSBudWxsO1xuICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zKSB7XG4gICAgICAgIGlmIChyZXFTcGFjZSkge1xuICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgIT09ICdzcGFjZScgJiZcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlICE9PSAnbmV3bGluZScgJiZcbiAgICAgICAgICAgICAgICB0b2tlbi50eXBlICE9PSAnY29tbWEnKVxuICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4ub2Zmc2V0LCAnTUlTU0lOR19DSEFSJywgJ1RhZ3MgYW5kIGFuY2hvcnMgbXVzdCBiZSBzZXBhcmF0ZWQgZnJvbSB0aGUgbmV4dCB0b2tlbiBieSB3aGl0ZSBzcGFjZScpO1xuICAgICAgICAgICAgcmVxU3BhY2UgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFiKSB7XG4gICAgICAgICAgICBpZiAoYXROZXdsaW5lICYmIHRva2VuLnR5cGUgIT09ICdjb21tZW50JyAmJiB0b2tlbi50eXBlICE9PSAnbmV3bGluZScpIHtcbiAgICAgICAgICAgICAgICBvbkVycm9yKHRhYiwgJ1RBQl9BU19JTkRFTlQnLCAnVGFicyBhcmUgbm90IGFsbG93ZWQgYXMgaW5kZW50YXRpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhYiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgLy8gQXQgdGhlIGRvYyBsZXZlbCwgdGFicyBhdCBsaW5lIHN0YXJ0IG1heSBiZSBwYXJzZWRcbiAgICAgICAgICAgICAgICAvLyBhcyBsZWFkaW5nIHdoaXRlIHNwYWNlIHJhdGhlciB0aGFuIGluZGVudGF0aW9uLlxuICAgICAgICAgICAgICAgIC8vIEluIGEgZmxvdyBjb2xsZWN0aW9uLCBvbmx5IHRoZSBwYXJzZXIgaGFuZGxlcyBpbmRlbnQuXG4gICAgICAgICAgICAgICAgaWYgKCFmbG93ICYmXG4gICAgICAgICAgICAgICAgICAgIChpbmRpY2F0b3IgIT09ICdkb2Mtc3RhcnQnIHx8IG5leHQ/LnR5cGUgIT09ICdmbG93LWNvbGxlY3Rpb24nKSAmJlxuICAgICAgICAgICAgICAgICAgICB0b2tlbi5zb3VyY2UuaW5jbHVkZXMoJ1xcdCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhYiA9IHRva2VuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb21tZW50Jzoge1xuICAgICAgICAgICAgICAgIGlmICghaGFzU3BhY2UpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdNSVNTSU5HX0NIQVInLCAnQ29tbWVudHMgbXVzdCBiZSBzZXBhcmF0ZWQgZnJvbSBvdGhlciB0b2tlbnMgYnkgd2hpdGUgc3BhY2UgY2hhcmFjdGVycycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNiID0gdG9rZW4uc291cmNlLnN1YnN0cmluZygxKSB8fCAnICc7XG4gICAgICAgICAgICAgICAgaWYgKCFjb21tZW50KVxuICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gY2I7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjb21tZW50ICs9IGNvbW1lbnRTZXAgKyBjYjtcbiAgICAgICAgICAgICAgICBjb21tZW50U2VwID0gJyc7XG4gICAgICAgICAgICAgICAgYXROZXdsaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICBpZiAoYXROZXdsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudCArPSB0b2tlbi5zb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFmb3VuZCB8fCBpbmRpY2F0b3IgIT09ICdzZXEtaXRlbS1pbmQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3BhY2VCZWZvcmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnRTZXAgKz0gdG9rZW4uc291cmNlO1xuICAgICAgICAgICAgICAgIGF0TmV3bGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaGFzTmV3bGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGFuY2hvciB8fCB0YWcpXG4gICAgICAgICAgICAgICAgICAgIG5ld2xpbmVBZnRlclByb3AgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhbmNob3InOlxuICAgICAgICAgICAgICAgIGlmIChhbmNob3IpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdNVUxUSVBMRV9BTkNIT1JTJywgJ0Egbm9kZSBjYW4gaGF2ZSBhdCBtb3N0IG9uZSBhbmNob3InKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4uc291cmNlLmVuZHNXaXRoKCc6JykpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4ub2Zmc2V0ICsgdG9rZW4uc291cmNlLmxlbmd0aCAtIDEsICdCQURfQUxJQVMnLCAnQW5jaG9yIGVuZGluZyBpbiA6IGlzIGFtYmlndW91cycsIHRydWUpO1xuICAgICAgICAgICAgICAgIGFuY2hvciA9IHRva2VuO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID8/IChzdGFydCA9IHRva2VuLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgYXROZXdsaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaGFzU3BhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXFTcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0YWcnOiB7XG4gICAgICAgICAgICAgICAgaWYgKHRhZylcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ01VTFRJUExFX1RBR1MnLCAnQSBub2RlIGNhbiBoYXZlIGF0IG1vc3Qgb25lIHRhZycpO1xuICAgICAgICAgICAgICAgIHRhZyA9IHRva2VuO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID8/IChzdGFydCA9IHRva2VuLm9mZnNldCk7XG4gICAgICAgICAgICAgICAgYXROZXdsaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaGFzU3BhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXFTcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIGluZGljYXRvcjpcbiAgICAgICAgICAgICAgICAvLyBDb3VsZCBoZXJlIGhhbmRsZSBwcmVjZWRpbmcgY29tbWVudHMgZGlmZmVyZW50bHlcbiAgICAgICAgICAgICAgICBpZiAoYW5jaG9yIHx8IHRhZylcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ0JBRF9QUk9QX09SREVSJywgYEFuY2hvcnMgYW5kIHRhZ3MgbXVzdCBiZSBhZnRlciB0aGUgJHt0b2tlbi5zb3VyY2V9IGluZGljYXRvcmApO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ1VORVhQRUNURURfVE9LRU4nLCBgVW5leHBlY3RlZCAke3Rva2VuLnNvdXJjZX0gaW4gJHtmbG93ID8/ICdjb2xsZWN0aW9uJ31gKTtcbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRva2VuO1xuICAgICAgICAgICAgICAgIGF0TmV3bGluZSA9XG4gICAgICAgICAgICAgICAgICAgIGluZGljYXRvciA9PT0gJ3NlcS1pdGVtLWluZCcgfHwgaW5kaWNhdG9yID09PSAnZXhwbGljaXQta2V5LWluZCc7XG4gICAgICAgICAgICAgICAgaGFzU3BhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1hJzpcbiAgICAgICAgICAgICAgICBpZiAoZmxvdykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWEpXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnVU5FWFBFQ1RFRF9UT0tFTicsIGBVbmV4cGVjdGVkICwgaW4gJHtmbG93fWApO1xuICAgICAgICAgICAgICAgICAgICBjb21tYSA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBhdE5ld2xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaGFzU3BhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZWxzZSBmYWxsdGhyb3VnaFxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnVU5FWFBFQ1RFRF9UT0tFTicsIGBVbmV4cGVjdGVkICR7dG9rZW4udHlwZX0gdG9rZW5gKTtcbiAgICAgICAgICAgICAgICBhdE5ld2xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxhc3QgPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGVuZCA9IGxhc3QgPyBsYXN0Lm9mZnNldCArIGxhc3Quc291cmNlLmxlbmd0aCA6IG9mZnNldDtcbiAgICBpZiAocmVxU3BhY2UgJiZcbiAgICAgICAgbmV4dCAmJlxuICAgICAgICBuZXh0LnR5cGUgIT09ICdzcGFjZScgJiZcbiAgICAgICAgbmV4dC50eXBlICE9PSAnbmV3bGluZScgJiZcbiAgICAgICAgbmV4dC50eXBlICE9PSAnY29tbWEnICYmXG4gICAgICAgIChuZXh0LnR5cGUgIT09ICdzY2FsYXInIHx8IG5leHQuc291cmNlICE9PSAnJykpIHtcbiAgICAgICAgb25FcnJvcihuZXh0Lm9mZnNldCwgJ01JU1NJTkdfQ0hBUicsICdUYWdzIGFuZCBhbmNob3JzIG11c3QgYmUgc2VwYXJhdGVkIGZyb20gdGhlIG5leHQgdG9rZW4gYnkgd2hpdGUgc3BhY2UnKTtcbiAgICB9XG4gICAgaWYgKHRhYiAmJlxuICAgICAgICAoKGF0TmV3bGluZSAmJiB0YWIuaW5kZW50IDw9IHBhcmVudEluZGVudCkgfHxcbiAgICAgICAgICAgIG5leHQ/LnR5cGUgPT09ICdibG9jay1tYXAnIHx8XG4gICAgICAgICAgICBuZXh0Py50eXBlID09PSAnYmxvY2stc2VxJykpXG4gICAgICAgIG9uRXJyb3IodGFiLCAnVEFCX0FTX0lOREVOVCcsICdUYWJzIGFyZSBub3QgYWxsb3dlZCBhcyBpbmRlbnRhdGlvbicpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbW1hLFxuICAgICAgICBmb3VuZCxcbiAgICAgICAgc3BhY2VCZWZvcmUsXG4gICAgICAgIGNvbW1lbnQsXG4gICAgICAgIGhhc05ld2xpbmUsXG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgdGFnLFxuICAgICAgICBuZXdsaW5lQWZ0ZXJQcm9wLFxuICAgICAgICBlbmQsXG4gICAgICAgIHN0YXJ0OiBzdGFydCA/PyBlbmRcbiAgICB9O1xufVxuXG5leHBvcnRzLnJlc29sdmVQcm9wcyA9IHJlc29sdmVQcm9wcztcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjb250YWluc05ld2xpbmUoa2V5KSB7XG4gICAgaWYgKCFrZXkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHN3aXRjaCAoa2V5LnR5cGUpIHtcbiAgICAgICAgY2FzZSAnYWxpYXMnOlxuICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICBjYXNlICdkb3VibGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgIGlmIChrZXkuc291cmNlLmluY2x1ZGVzKCdcXG4nKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChrZXkuZW5kKVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3Qgb2Yga2V5LmVuZClcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0LnR5cGUgPT09ICduZXdsaW5lJylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjYXNlICdmbG93LWNvbGxlY3Rpb24nOlxuICAgICAgICAgICAgZm9yIChjb25zdCBpdCBvZiBrZXkuaXRlbXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN0IG9mIGl0LnN0YXJ0KVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3QudHlwZSA9PT0gJ25ld2xpbmUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGl0LnNlcClcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdCBvZiBpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3QudHlwZSA9PT0gJ25ld2xpbmUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChjb250YWluc05ld2xpbmUoaXQua2V5KSB8fCBjb250YWluc05ld2xpbmUoaXQudmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxuZXhwb3J0cy5jb250YWluc05ld2xpbmUgPSBjb250YWluc05ld2xpbmU7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxDb250YWluc05ld2xpbmUgPSByZXF1aXJlKCcuL3V0aWwtY29udGFpbnMtbmV3bGluZS5qcycpO1xuXG5mdW5jdGlvbiBmbG93SW5kZW50Q2hlY2soaW5kZW50LCBmYywgb25FcnJvcikge1xuICAgIGlmIChmYz8udHlwZSA9PT0gJ2Zsb3ctY29sbGVjdGlvbicpIHtcbiAgICAgICAgY29uc3QgZW5kID0gZmMuZW5kWzBdO1xuICAgICAgICBpZiAoZW5kLmluZGVudCA9PT0gaW5kZW50ICYmXG4gICAgICAgICAgICAoZW5kLnNvdXJjZSA9PT0gJ10nIHx8IGVuZC5zb3VyY2UgPT09ICd9JykgJiZcbiAgICAgICAgICAgIHV0aWxDb250YWluc05ld2xpbmUuY29udGFpbnNOZXdsaW5lKGZjKSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gJ0Zsb3cgZW5kIGluZGljYXRvciBzaG91bGQgYmUgbW9yZSBpbmRlbnRlZCB0aGFuIHBhcmVudCc7XG4gICAgICAgICAgICBvbkVycm9yKGVuZCwgJ0JBRF9JTkRFTlQnLCBtc2csIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnRzLmZsb3dJbmRlbnRDaGVjayA9IGZsb3dJbmRlbnRDaGVjaztcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuLi9ub2Rlcy9pZGVudGl0eS5qcycpO1xuXG5mdW5jdGlvbiBtYXBJbmNsdWRlcyhjdHgsIGl0ZW1zLCBzZWFyY2gpIHtcbiAgICBjb25zdCB7IHVuaXF1ZUtleXMgfSA9IGN0eC5vcHRpb25zO1xuICAgIGlmICh1bmlxdWVLZXlzID09PSBmYWxzZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGlzRXF1YWwgPSB0eXBlb2YgdW5pcXVlS2V5cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHVuaXF1ZUtleXNcbiAgICAgICAgOiAoYSwgYikgPT4gYSA9PT0gYiB8fCAoaWRlbnRpdHkuaXNTY2FsYXIoYSkgJiYgaWRlbnRpdHkuaXNTY2FsYXIoYikgJiYgYS52YWx1ZSA9PT0gYi52YWx1ZSk7XG4gICAgcmV0dXJuIGl0ZW1zLnNvbWUocGFpciA9PiBpc0VxdWFsKHBhaXIua2V5LCBzZWFyY2gpKTtcbn1cblxuZXhwb3J0cy5tYXBJbmNsdWRlcyA9IG1hcEluY2x1ZGVzO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBQYWlyID0gcmVxdWlyZSgnLi4vbm9kZXMvUGFpci5qcycpO1xudmFyIFlBTUxNYXAgPSByZXF1aXJlKCcuLi9ub2Rlcy9ZQU1MTWFwLmpzJyk7XG52YXIgcmVzb2x2ZVByb3BzID0gcmVxdWlyZSgnLi9yZXNvbHZlLXByb3BzLmpzJyk7XG52YXIgdXRpbENvbnRhaW5zTmV3bGluZSA9IHJlcXVpcmUoJy4vdXRpbC1jb250YWlucy1uZXdsaW5lLmpzJyk7XG52YXIgdXRpbEZsb3dJbmRlbnRDaGVjayA9IHJlcXVpcmUoJy4vdXRpbC1mbG93LWluZGVudC1jaGVjay5qcycpO1xudmFyIHV0aWxNYXBJbmNsdWRlcyA9IHJlcXVpcmUoJy4vdXRpbC1tYXAtaW5jbHVkZXMuanMnKTtcblxuY29uc3Qgc3RhcnRDb2xNc2cgPSAnQWxsIG1hcHBpbmcgaXRlbXMgbXVzdCBzdGFydCBhdCB0aGUgc2FtZSBjb2x1bW4nO1xuZnVuY3Rpb24gcmVzb2x2ZUJsb2NrTWFwKHsgY29tcG9zZU5vZGUsIGNvbXBvc2VFbXB0eU5vZGUgfSwgY3R4LCBibSwgb25FcnJvciwgdGFnKSB7XG4gICAgY29uc3QgTm9kZUNsYXNzID0gdGFnPy5ub2RlQ2xhc3MgPz8gWUFNTE1hcC5ZQU1MTWFwO1xuICAgIGNvbnN0IG1hcCA9IG5ldyBOb2RlQ2xhc3MoY3R4LnNjaGVtYSk7XG4gICAgaWYgKGN0eC5hdFJvb3QpXG4gICAgICAgIGN0eC5hdFJvb3QgPSBmYWxzZTtcbiAgICBsZXQgb2Zmc2V0ID0gYm0ub2Zmc2V0O1xuICAgIGxldCBjb21tZW50RW5kID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IGNvbGxJdGVtIG9mIGJtLml0ZW1zKSB7XG4gICAgICAgIGNvbnN0IHsgc3RhcnQsIGtleSwgc2VwLCB2YWx1ZSB9ID0gY29sbEl0ZW07XG4gICAgICAgIC8vIGtleSBwcm9wZXJ0aWVzXG4gICAgICAgIGNvbnN0IGtleVByb3BzID0gcmVzb2x2ZVByb3BzLnJlc29sdmVQcm9wcyhzdGFydCwge1xuICAgICAgICAgICAgaW5kaWNhdG9yOiAnZXhwbGljaXQta2V5LWluZCcsXG4gICAgICAgICAgICBuZXh0OiBrZXkgPz8gc2VwPy5bMF0sXG4gICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgcGFyZW50SW5kZW50OiBibS5pbmRlbnQsXG4gICAgICAgICAgICBzdGFydE9uTmV3bGluZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaW1wbGljaXRLZXkgPSAha2V5UHJvcHMuZm91bmQ7XG4gICAgICAgIGlmIChpbXBsaWNpdEtleSkge1xuICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkudHlwZSA9PT0gJ2Jsb2NrLXNlcScpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3Iob2Zmc2V0LCAnQkxPQ0tfQVNfSU1QTElDSVRfS0VZJywgJ0EgYmxvY2sgc2VxdWVuY2UgbWF5IG5vdCBiZSB1c2VkIGFzIGFuIGltcGxpY2l0IG1hcCBrZXknKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgnaW5kZW50JyBpbiBrZXkgJiYga2V5LmluZGVudCAhPT0gYm0uaW5kZW50KVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKG9mZnNldCwgJ0JBRF9JTkRFTlQnLCBzdGFydENvbE1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWtleVByb3BzLmFuY2hvciAmJiAha2V5UHJvcHMudGFnICYmICFzZXApIHtcbiAgICAgICAgICAgICAgICBjb21tZW50RW5kID0ga2V5UHJvcHMuZW5kO1xuICAgICAgICAgICAgICAgIGlmIChrZXlQcm9wcy5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXAuY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5jb21tZW50ICs9ICdcXG4nICsga2V5UHJvcHMuY29tbWVudDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLmNvbW1lbnQgPSBrZXlQcm9wcy5jb21tZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXlQcm9wcy5uZXdsaW5lQWZ0ZXJQcm9wIHx8IHV0aWxDb250YWluc05ld2xpbmUuY29udGFpbnNOZXdsaW5lKGtleSkpIHtcbiAgICAgICAgICAgICAgICBvbkVycm9yKGtleSA/PyBzdGFydFtzdGFydC5sZW5ndGggLSAxXSwgJ01VTFRJTElORV9JTVBMSUNJVF9LRVknLCAnSW1wbGljaXQga2V5cyBuZWVkIHRvIGJlIG9uIGEgc2luZ2xlIGxpbmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXlQcm9wcy5mb3VuZD8uaW5kZW50ICE9PSBibS5pbmRlbnQpIHtcbiAgICAgICAgICAgIG9uRXJyb3Iob2Zmc2V0LCAnQkFEX0lOREVOVCcsIHN0YXJ0Q29sTXNnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBrZXkgdmFsdWVcbiAgICAgICAgY3R4LmF0S2V5ID0gdHJ1ZTtcbiAgICAgICAgY29uc3Qga2V5U3RhcnQgPSBrZXlQcm9wcy5lbmQ7XG4gICAgICAgIGNvbnN0IGtleU5vZGUgPSBrZXlcbiAgICAgICAgICAgID8gY29tcG9zZU5vZGUoY3R4LCBrZXksIGtleVByb3BzLCBvbkVycm9yKVxuICAgICAgICAgICAgOiBjb21wb3NlRW1wdHlOb2RlKGN0eCwga2V5U3RhcnQsIHN0YXJ0LCBudWxsLCBrZXlQcm9wcywgb25FcnJvcik7XG4gICAgICAgIGlmIChjdHguc2NoZW1hLmNvbXBhdClcbiAgICAgICAgICAgIHV0aWxGbG93SW5kZW50Q2hlY2suZmxvd0luZGVudENoZWNrKGJtLmluZGVudCwga2V5LCBvbkVycm9yKTtcbiAgICAgICAgY3R4LmF0S2V5ID0gZmFsc2U7XG4gICAgICAgIGlmICh1dGlsTWFwSW5jbHVkZXMubWFwSW5jbHVkZXMoY3R4LCBtYXAuaXRlbXMsIGtleU5vZGUpKVxuICAgICAgICAgICAgb25FcnJvcihrZXlTdGFydCwgJ0RVUExJQ0FURV9LRVknLCAnTWFwIGtleXMgbXVzdCBiZSB1bmlxdWUnKTtcbiAgICAgICAgLy8gdmFsdWUgcHJvcGVydGllc1xuICAgICAgICBjb25zdCB2YWx1ZVByb3BzID0gcmVzb2x2ZVByb3BzLnJlc29sdmVQcm9wcyhzZXAgPz8gW10sIHtcbiAgICAgICAgICAgIGluZGljYXRvcjogJ21hcC12YWx1ZS1pbmQnLFxuICAgICAgICAgICAgbmV4dDogdmFsdWUsXG4gICAgICAgICAgICBvZmZzZXQ6IGtleU5vZGUucmFuZ2VbMl0sXG4gICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgcGFyZW50SW5kZW50OiBibS5pbmRlbnQsXG4gICAgICAgICAgICBzdGFydE9uTmV3bGluZTogIWtleSB8fCBrZXkudHlwZSA9PT0gJ2Jsb2NrLXNjYWxhcidcbiAgICAgICAgfSk7XG4gICAgICAgIG9mZnNldCA9IHZhbHVlUHJvcHMuZW5kO1xuICAgICAgICBpZiAodmFsdWVQcm9wcy5mb3VuZCkge1xuICAgICAgICAgICAgaWYgKGltcGxpY2l0S2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlPy50eXBlID09PSAnYmxvY2stbWFwJyAmJiAhdmFsdWVQcm9wcy5oYXNOZXdsaW5lKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKG9mZnNldCwgJ0JMT0NLX0FTX0lNUExJQ0lUX0tFWScsICdOZXN0ZWQgbWFwcGluZ3MgYXJlIG5vdCBhbGxvd2VkIGluIGNvbXBhY3QgbWFwcGluZ3MnKTtcbiAgICAgICAgICAgICAgICBpZiAoY3R4Lm9wdGlvbnMuc3RyaWN0ICYmXG4gICAgICAgICAgICAgICAgICAgIGtleVByb3BzLnN0YXJ0IDwgdmFsdWVQcm9wcy5mb3VuZC5vZmZzZXQgLSAxMDI0KVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGtleU5vZGUucmFuZ2UsICdLRVlfT1ZFUl8xMDI0X0NIQVJTJywgJ1RoZSA6IGluZGljYXRvciBtdXN0IGJlIGF0IG1vc3QgMTAyNCBjaGFycyBhZnRlciB0aGUgc3RhcnQgb2YgYW4gaW1wbGljaXQgYmxvY2sgbWFwcGluZyBrZXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHZhbHVlIHZhbHVlXG4gICAgICAgICAgICBjb25zdCB2YWx1ZU5vZGUgPSB2YWx1ZVxuICAgICAgICAgICAgICAgID8gY29tcG9zZU5vZGUoY3R4LCB2YWx1ZSwgdmFsdWVQcm9wcywgb25FcnJvcilcbiAgICAgICAgICAgICAgICA6IGNvbXBvc2VFbXB0eU5vZGUoY3R4LCBvZmZzZXQsIHNlcCwgbnVsbCwgdmFsdWVQcm9wcywgb25FcnJvcik7XG4gICAgICAgICAgICBpZiAoY3R4LnNjaGVtYS5jb21wYXQpXG4gICAgICAgICAgICAgICAgdXRpbEZsb3dJbmRlbnRDaGVjay5mbG93SW5kZW50Q2hlY2soYm0uaW5kZW50LCB2YWx1ZSwgb25FcnJvcik7XG4gICAgICAgICAgICBvZmZzZXQgPSB2YWx1ZU5vZGUucmFuZ2VbMl07XG4gICAgICAgICAgICBjb25zdCBwYWlyID0gbmV3IFBhaXIuUGFpcihrZXlOb2RlLCB2YWx1ZU5vZGUpO1xuICAgICAgICAgICAgaWYgKGN0eC5vcHRpb25zLmtlZXBTb3VyY2VUb2tlbnMpXG4gICAgICAgICAgICAgICAgcGFpci5zcmNUb2tlbiA9IGNvbGxJdGVtO1xuICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2gocGFpcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBrZXkgd2l0aCBubyB2YWx1ZVxuICAgICAgICAgICAgaWYgKGltcGxpY2l0S2V5KVxuICAgICAgICAgICAgICAgIG9uRXJyb3Ioa2V5Tm9kZS5yYW5nZSwgJ01JU1NJTkdfQ0hBUicsICdJbXBsaWNpdCBtYXAga2V5cyBuZWVkIHRvIGJlIGZvbGxvd2VkIGJ5IG1hcCB2YWx1ZXMnKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZVByb3BzLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5Tm9kZS5jb21tZW50KVxuICAgICAgICAgICAgICAgICAgICBrZXlOb2RlLmNvbW1lbnQgKz0gJ1xcbicgKyB2YWx1ZVByb3BzLmNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBrZXlOb2RlLmNvbW1lbnQgPSB2YWx1ZVByb3BzLmNvbW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYWlyID0gbmV3IFBhaXIuUGFpcihrZXlOb2RlKTtcbiAgICAgICAgICAgIGlmIChjdHgub3B0aW9ucy5rZWVwU291cmNlVG9rZW5zKVxuICAgICAgICAgICAgICAgIHBhaXIuc3JjVG9rZW4gPSBjb2xsSXRlbTtcbiAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHBhaXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjb21tZW50RW5kICYmIGNvbW1lbnRFbmQgPCBvZmZzZXQpXG4gICAgICAgIG9uRXJyb3IoY29tbWVudEVuZCwgJ0lNUE9TU0lCTEUnLCAnTWFwIGNvbW1lbnQgd2l0aCB0cmFpbGluZyBjb250ZW50Jyk7XG4gICAgbWFwLnJhbmdlID0gW2JtLm9mZnNldCwgb2Zmc2V0LCBjb21tZW50RW5kID8/IG9mZnNldF07XG4gICAgcmV0dXJuIG1hcDtcbn1cblxuZXhwb3J0cy5yZXNvbHZlQmxvY2tNYXAgPSByZXNvbHZlQmxvY2tNYXA7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIFlBTUxTZXEgPSByZXF1aXJlKCcuLi9ub2Rlcy9ZQU1MU2VxLmpzJyk7XG52YXIgcmVzb2x2ZVByb3BzID0gcmVxdWlyZSgnLi9yZXNvbHZlLXByb3BzLmpzJyk7XG52YXIgdXRpbEZsb3dJbmRlbnRDaGVjayA9IHJlcXVpcmUoJy4vdXRpbC1mbG93LWluZGVudC1jaGVjay5qcycpO1xuXG5mdW5jdGlvbiByZXNvbHZlQmxvY2tTZXEoeyBjb21wb3NlTm9kZSwgY29tcG9zZUVtcHR5Tm9kZSB9LCBjdHgsIGJzLCBvbkVycm9yLCB0YWcpIHtcbiAgICBjb25zdCBOb2RlQ2xhc3MgPSB0YWc/Lm5vZGVDbGFzcyA/PyBZQU1MU2VxLllBTUxTZXE7XG4gICAgY29uc3Qgc2VxID0gbmV3IE5vZGVDbGFzcyhjdHguc2NoZW1hKTtcbiAgICBpZiAoY3R4LmF0Um9vdClcbiAgICAgICAgY3R4LmF0Um9vdCA9IGZhbHNlO1xuICAgIGlmIChjdHguYXRLZXkpXG4gICAgICAgIGN0eC5hdEtleSA9IGZhbHNlO1xuICAgIGxldCBvZmZzZXQgPSBicy5vZmZzZXQ7XG4gICAgbGV0IGNvbW1lbnRFbmQgPSBudWxsO1xuICAgIGZvciAoY29uc3QgeyBzdGFydCwgdmFsdWUgfSBvZiBicy5pdGVtcykge1xuICAgICAgICBjb25zdCBwcm9wcyA9IHJlc29sdmVQcm9wcy5yZXNvbHZlUHJvcHMoc3RhcnQsIHtcbiAgICAgICAgICAgIGluZGljYXRvcjogJ3NlcS1pdGVtLWluZCcsXG4gICAgICAgICAgICBuZXh0OiB2YWx1ZSxcbiAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICAgIG9uRXJyb3IsXG4gICAgICAgICAgICBwYXJlbnRJbmRlbnQ6IGJzLmluZGVudCxcbiAgICAgICAgICAgIHN0YXJ0T25OZXdsaW5lOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXByb3BzLmZvdW5kKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMuYW5jaG9yIHx8IHByb3BzLnRhZyB8fCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZT8udHlwZSA9PT0gJ2Jsb2NrLXNlcScpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IocHJvcHMuZW5kLCAnQkFEX0lOREVOVCcsICdBbGwgc2VxdWVuY2UgaXRlbXMgbXVzdCBzdGFydCBhdCB0aGUgc2FtZSBjb2x1bW4nKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3Iob2Zmc2V0LCAnTUlTU0lOR19DSEFSJywgJ1NlcXVlbmNlIGl0ZW0gd2l0aG91dCAtIGluZGljYXRvcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tbWVudEVuZCA9IHByb3BzLmVuZDtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMuY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgc2VxLmNvbW1lbnQgPSBwcm9wcy5jb21tZW50O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGUgPSB2YWx1ZVxuICAgICAgICAgICAgPyBjb21wb3NlTm9kZShjdHgsIHZhbHVlLCBwcm9wcywgb25FcnJvcilcbiAgICAgICAgICAgIDogY29tcG9zZUVtcHR5Tm9kZShjdHgsIHByb3BzLmVuZCwgc3RhcnQsIG51bGwsIHByb3BzLCBvbkVycm9yKTtcbiAgICAgICAgaWYgKGN0eC5zY2hlbWEuY29tcGF0KVxuICAgICAgICAgICAgdXRpbEZsb3dJbmRlbnRDaGVjay5mbG93SW5kZW50Q2hlY2soYnMuaW5kZW50LCB2YWx1ZSwgb25FcnJvcik7XG4gICAgICAgIG9mZnNldCA9IG5vZGUucmFuZ2VbMl07XG4gICAgICAgIHNlcS5pdGVtcy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgICBzZXEucmFuZ2UgPSBbYnMub2Zmc2V0LCBvZmZzZXQsIGNvbW1lbnRFbmQgPz8gb2Zmc2V0XTtcbiAgICByZXR1cm4gc2VxO1xufVxuXG5leHBvcnRzLnJlc29sdmVCbG9ja1NlcSA9IHJlc29sdmVCbG9ja1NlcTtcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiByZXNvbHZlRW5kKGVuZCwgb2Zmc2V0LCByZXFTcGFjZSwgb25FcnJvcikge1xuICAgIGxldCBjb21tZW50ID0gJyc7XG4gICAgaWYgKGVuZCkge1xuICAgICAgICBsZXQgaGFzU3BhY2UgPSBmYWxzZTtcbiAgICAgICAgbGV0IHNlcCA9ICcnO1xuICAgICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIGVuZCkge1xuICAgICAgICAgICAgY29uc3QgeyBzb3VyY2UsIHR5cGUgfSA9IHRva2VuO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXFTcGFjZSAmJiAhaGFzU3BhY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnTUlTU0lOR19DSEFSJywgJ0NvbW1lbnRzIG11c3QgYmUgc2VwYXJhdGVkIGZyb20gb3RoZXIgdG9rZW5zIGJ5IHdoaXRlIHNwYWNlIGNoYXJhY3RlcnMnKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2IgPSBzb3VyY2Uuc3Vic3RyaW5nKDEpIHx8ICcgJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21tZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IGNiO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50ICs9IHNlcCArIGNiO1xuICAgICAgICAgICAgICAgICAgICBzZXAgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcCArPSBzb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgIGhhc1NwYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ1VORVhQRUNURURfVE9LRU4nLCBgVW5leHBlY3RlZCAke3R5cGV9IGF0IG5vZGUgZW5kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgKz0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBjb21tZW50LCBvZmZzZXQgfTtcbn1cblxuZXhwb3J0cy5yZXNvbHZlRW5kID0gcmVzb2x2ZUVuZDtcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuLi9ub2Rlcy9pZGVudGl0eS5qcycpO1xudmFyIFBhaXIgPSByZXF1aXJlKCcuLi9ub2Rlcy9QYWlyLmpzJyk7XG52YXIgWUFNTE1hcCA9IHJlcXVpcmUoJy4uL25vZGVzL1lBTUxNYXAuanMnKTtcbnZhciBZQU1MU2VxID0gcmVxdWlyZSgnLi4vbm9kZXMvWUFNTFNlcS5qcycpO1xudmFyIHJlc29sdmVFbmQgPSByZXF1aXJlKCcuL3Jlc29sdmUtZW5kLmpzJyk7XG52YXIgcmVzb2x2ZVByb3BzID0gcmVxdWlyZSgnLi9yZXNvbHZlLXByb3BzLmpzJyk7XG52YXIgdXRpbENvbnRhaW5zTmV3bGluZSA9IHJlcXVpcmUoJy4vdXRpbC1jb250YWlucy1uZXdsaW5lLmpzJyk7XG52YXIgdXRpbE1hcEluY2x1ZGVzID0gcmVxdWlyZSgnLi91dGlsLW1hcC1pbmNsdWRlcy5qcycpO1xuXG5jb25zdCBibG9ja01zZyA9ICdCbG9jayBjb2xsZWN0aW9ucyBhcmUgbm90IGFsbG93ZWQgd2l0aGluIGZsb3cgY29sbGVjdGlvbnMnO1xuY29uc3QgaXNCbG9jayA9ICh0b2tlbikgPT4gdG9rZW4gJiYgKHRva2VuLnR5cGUgPT09ICdibG9jay1tYXAnIHx8IHRva2VuLnR5cGUgPT09ICdibG9jay1zZXEnKTtcbmZ1bmN0aW9uIHJlc29sdmVGbG93Q29sbGVjdGlvbih7IGNvbXBvc2VOb2RlLCBjb21wb3NlRW1wdHlOb2RlIH0sIGN0eCwgZmMsIG9uRXJyb3IsIHRhZykge1xuICAgIGNvbnN0IGlzTWFwID0gZmMuc3RhcnQuc291cmNlID09PSAneyc7XG4gICAgY29uc3QgZmNOYW1lID0gaXNNYXAgPyAnZmxvdyBtYXAnIDogJ2Zsb3cgc2VxdWVuY2UnO1xuICAgIGNvbnN0IE5vZGVDbGFzcyA9ICh0YWc/Lm5vZGVDbGFzcyA/PyAoaXNNYXAgPyBZQU1MTWFwLllBTUxNYXAgOiBZQU1MU2VxLllBTUxTZXEpKTtcbiAgICBjb25zdCBjb2xsID0gbmV3IE5vZGVDbGFzcyhjdHguc2NoZW1hKTtcbiAgICBjb2xsLmZsb3cgPSB0cnVlO1xuICAgIGNvbnN0IGF0Um9vdCA9IGN0eC5hdFJvb3Q7XG4gICAgaWYgKGF0Um9vdClcbiAgICAgICAgY3R4LmF0Um9vdCA9IGZhbHNlO1xuICAgIGlmIChjdHguYXRLZXkpXG4gICAgICAgIGN0eC5hdEtleSA9IGZhbHNlO1xuICAgIGxldCBvZmZzZXQgPSBmYy5vZmZzZXQgKyBmYy5zdGFydC5zb3VyY2UubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmMuaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgY29sbEl0ZW0gPSBmYy5pdGVtc1tpXTtcbiAgICAgICAgY29uc3QgeyBzdGFydCwga2V5LCBzZXAsIHZhbHVlIH0gPSBjb2xsSXRlbTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSByZXNvbHZlUHJvcHMucmVzb2x2ZVByb3BzKHN0YXJ0LCB7XG4gICAgICAgICAgICBmbG93OiBmY05hbWUsXG4gICAgICAgICAgICBpbmRpY2F0b3I6ICdleHBsaWNpdC1rZXktaW5kJyxcbiAgICAgICAgICAgIG5leHQ6IGtleSA/PyBzZXA/LlswXSxcbiAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICAgIG9uRXJyb3IsXG4gICAgICAgICAgICBwYXJlbnRJbmRlbnQ6IGZjLmluZGVudCxcbiAgICAgICAgICAgIHN0YXJ0T25OZXdsaW5lOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFwcm9wcy5mb3VuZCkge1xuICAgICAgICAgICAgaWYgKCFwcm9wcy5hbmNob3IgJiYgIXByb3BzLnRhZyAmJiAhc2VwICYmICF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAwICYmIHByb3BzLmNvbW1hKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHByb3BzLmNvbW1hLCAnVU5FWFBFQ1RFRF9UT0tFTicsIGBVbmV4cGVjdGVkICwgaW4gJHtmY05hbWV9YCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaSA8IGZjLml0ZW1zLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IocHJvcHMuc3RhcnQsICdVTkVYUEVDVEVEX1RPS0VOJywgYFVuZXhwZWN0ZWQgZW1wdHkgaXRlbSBpbiAke2ZjTmFtZX1gKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMuY29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sbC5jb21tZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbC5jb21tZW50ICs9ICdcXG4nICsgcHJvcHMuY29tbWVudDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbC5jb21tZW50ID0gcHJvcHMuY29tbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gcHJvcHMuZW5kO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc01hcCAmJiBjdHgub3B0aW9ucy5zdHJpY3QgJiYgdXRpbENvbnRhaW5zTmV3bGluZS5jb250YWluc05ld2xpbmUoa2V5KSlcbiAgICAgICAgICAgICAgICBvbkVycm9yKGtleSwgLy8gY2hlY2tlZCBieSBjb250YWluc05ld2xpbmUoKVxuICAgICAgICAgICAgICAgICdNVUxUSUxJTkVfSU1QTElDSVRfS0VZJywgJ0ltcGxpY2l0IGtleXMgb2YgZmxvdyBzZXF1ZW5jZSBwYWlycyBuZWVkIHRvIGJlIG9uIGEgc2luZ2xlIGxpbmUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHByb3BzLmNvbW1hKVxuICAgICAgICAgICAgICAgIG9uRXJyb3IocHJvcHMuY29tbWEsICdVTkVYUEVDVEVEX1RPS0VOJywgYFVuZXhwZWN0ZWQgLCBpbiAke2ZjTmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghcHJvcHMuY29tbWEpXG4gICAgICAgICAgICAgICAgb25FcnJvcihwcm9wcy5zdGFydCwgJ01JU1NJTkdfQ0hBUicsIGBNaXNzaW5nICwgYmV0d2VlbiAke2ZjTmFtZX0gaXRlbXNgKTtcbiAgICAgICAgICAgIGlmIChwcm9wcy5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IHByZXZJdGVtQ29tbWVudCA9ICcnO1xuICAgICAgICAgICAgICAgIGxvb3A6IGZvciAoY29uc3Qgc3Qgb2Ygc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb21tYSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2SXRlbUNvbW1lbnQgPSBzdC5zb3VyY2Uuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByZXZJdGVtQ29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHJldiA9IGNvbGwuaXRlbXNbY29sbC5pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkZW50aXR5LmlzUGFpcihwcmV2KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYgPSBwcmV2LnZhbHVlID8/IHByZXYua2V5O1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldi5jb21tZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldi5jb21tZW50ICs9ICdcXG4nICsgcHJldkl0ZW1Db21tZW50O1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2LmNvbW1lbnQgPSBwcmV2SXRlbUNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmNvbW1lbnQgPSBwcm9wcy5jb21tZW50LnN1YnN0cmluZyhwcmV2SXRlbUNvbW1lbnQubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNNYXAgJiYgIXNlcCAmJiAhcHJvcHMuZm91bmQpIHtcbiAgICAgICAgICAgIC8vIGl0ZW0gaXMgYSB2YWx1ZSBpbiBhIHNlcVxuICAgICAgICAgICAgLy8g4oaSIGtleSAmIHNlcCBhcmUgZW1wdHksIHN0YXJ0IGRvZXMgbm90IGluY2x1ZGUgPyBvciA6XG4gICAgICAgICAgICBjb25zdCB2YWx1ZU5vZGUgPSB2YWx1ZVxuICAgICAgICAgICAgICAgID8gY29tcG9zZU5vZGUoY3R4LCB2YWx1ZSwgcHJvcHMsIG9uRXJyb3IpXG4gICAgICAgICAgICAgICAgOiBjb21wb3NlRW1wdHlOb2RlKGN0eCwgcHJvcHMuZW5kLCBzZXAsIG51bGwsIHByb3BzLCBvbkVycm9yKTtcbiAgICAgICAgICAgIGNvbGwuaXRlbXMucHVzaCh2YWx1ZU5vZGUpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gdmFsdWVOb2RlLnJhbmdlWzJdO1xuICAgICAgICAgICAgaWYgKGlzQmxvY2sodmFsdWUpKVxuICAgICAgICAgICAgICAgIG9uRXJyb3IodmFsdWVOb2RlLnJhbmdlLCAnQkxPQ0tfSU5fRkxPVycsIGJsb2NrTXNnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGl0ZW0gaXMgYSBrZXkrdmFsdWUgcGFpclxuICAgICAgICAgICAgLy8ga2V5IHZhbHVlXG4gICAgICAgICAgICBjdHguYXRLZXkgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3Qga2V5U3RhcnQgPSBwcm9wcy5lbmQ7XG4gICAgICAgICAgICBjb25zdCBrZXlOb2RlID0ga2V5XG4gICAgICAgICAgICAgICAgPyBjb21wb3NlTm9kZShjdHgsIGtleSwgcHJvcHMsIG9uRXJyb3IpXG4gICAgICAgICAgICAgICAgOiBjb21wb3NlRW1wdHlOb2RlKGN0eCwga2V5U3RhcnQsIHN0YXJ0LCBudWxsLCBwcm9wcywgb25FcnJvcik7XG4gICAgICAgICAgICBpZiAoaXNCbG9jayhrZXkpKVxuICAgICAgICAgICAgICAgIG9uRXJyb3Ioa2V5Tm9kZS5yYW5nZSwgJ0JMT0NLX0lOX0ZMT1cnLCBibG9ja01zZyk7XG4gICAgICAgICAgICBjdHguYXRLZXkgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIHZhbHVlIHByb3BlcnRpZXNcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlUHJvcHMgPSByZXNvbHZlUHJvcHMucmVzb2x2ZVByb3BzKHNlcCA/PyBbXSwge1xuICAgICAgICAgICAgICAgIGZsb3c6IGZjTmFtZSxcbiAgICAgICAgICAgICAgICBpbmRpY2F0b3I6ICdtYXAtdmFsdWUtaW5kJyxcbiAgICAgICAgICAgICAgICBuZXh0OiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IGtleU5vZGUucmFuZ2VbMl0sXG4gICAgICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgICAgICBwYXJlbnRJbmRlbnQ6IGZjLmluZGVudCxcbiAgICAgICAgICAgICAgICBzdGFydE9uTmV3bGluZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHZhbHVlUHJvcHMuZm91bmQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTWFwICYmICFwcm9wcy5mb3VuZCAmJiBjdHgub3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcClcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3Qgb2Ygc2VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0ID09PSB2YWx1ZVByb3BzLmZvdW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3QudHlwZSA9PT0gJ25ld2xpbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3Ioc3QsICdNVUxUSUxJTkVfSU1QTElDSVRfS0VZJywgJ0ltcGxpY2l0IGtleXMgb2YgZmxvdyBzZXF1ZW5jZSBwYWlycyBuZWVkIHRvIGJlIG9uIGEgc2luZ2xlIGxpbmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcHMuc3RhcnQgPCB2YWx1ZVByb3BzLmZvdW5kLm9mZnNldCAtIDEwMjQpXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHZhbHVlUHJvcHMuZm91bmQsICdLRVlfT1ZFUl8xMDI0X0NIQVJTJywgJ1RoZSA6IGluZGljYXRvciBtdXN0IGJlIGF0IG1vc3QgMTAyNCBjaGFycyBhZnRlciB0aGUgc3RhcnQgb2YgYW4gaW1wbGljaXQgZmxvdyBzZXF1ZW5jZSBrZXknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICgnc291cmNlJyBpbiB2YWx1ZSAmJiB2YWx1ZS5zb3VyY2U/LlswXSA9PT0gJzonKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHZhbHVlLCAnTUlTU0lOR19DSEFSJywgYE1pc3Npbmcgc3BhY2UgYWZ0ZXIgOiBpbiAke2ZjTmFtZX1gKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodmFsdWVQcm9wcy5zdGFydCwgJ01JU1NJTkdfQ0hBUicsIGBNaXNzaW5nICwgb3IgOiBiZXR3ZWVuICR7ZmNOYW1lfSBpdGVtc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdmFsdWUgdmFsdWVcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlTm9kZSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgPyBjb21wb3NlTm9kZShjdHgsIHZhbHVlLCB2YWx1ZVByb3BzLCBvbkVycm9yKVxuICAgICAgICAgICAgICAgIDogdmFsdWVQcm9wcy5mb3VuZFxuICAgICAgICAgICAgICAgICAgICA/IGNvbXBvc2VFbXB0eU5vZGUoY3R4LCB2YWx1ZVByb3BzLmVuZCwgc2VwLCBudWxsLCB2YWx1ZVByb3BzLCBvbkVycm9yKVxuICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICBpZiAodmFsdWVOb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQmxvY2sodmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHZhbHVlTm9kZS5yYW5nZSwgJ0JMT0NLX0lOX0ZMT1cnLCBibG9ja01zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZVByb3BzLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5Tm9kZS5jb21tZW50KVxuICAgICAgICAgICAgICAgICAgICBrZXlOb2RlLmNvbW1lbnQgKz0gJ1xcbicgKyB2YWx1ZVByb3BzLmNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBrZXlOb2RlLmNvbW1lbnQgPSB2YWx1ZVByb3BzLmNvbW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYWlyID0gbmV3IFBhaXIuUGFpcihrZXlOb2RlLCB2YWx1ZU5vZGUpO1xuICAgICAgICAgICAgaWYgKGN0eC5vcHRpb25zLmtlZXBTb3VyY2VUb2tlbnMpXG4gICAgICAgICAgICAgICAgcGFpci5zcmNUb2tlbiA9IGNvbGxJdGVtO1xuICAgICAgICAgICAgaWYgKGlzTWFwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFwID0gY29sbDtcbiAgICAgICAgICAgICAgICBpZiAodXRpbE1hcEluY2x1ZGVzLm1hcEluY2x1ZGVzKGN0eCwgbWFwLml0ZW1zLCBrZXlOb2RlKSlcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihrZXlTdGFydCwgJ0RVUExJQ0FURV9LRVknLCAnTWFwIGtleXMgbXVzdCBiZSB1bmlxdWUnKTtcbiAgICAgICAgICAgICAgICBtYXAuaXRlbXMucHVzaChwYWlyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcCA9IG5ldyBZQU1MTWFwLllBTUxNYXAoY3R4LnNjaGVtYSk7XG4gICAgICAgICAgICAgICAgbWFwLmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHBhaXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZFJhbmdlID0gKHZhbHVlTm9kZSA/PyBrZXlOb2RlKS5yYW5nZTtcbiAgICAgICAgICAgICAgICBtYXAucmFuZ2UgPSBba2V5Tm9kZS5yYW5nZVswXSwgZW5kUmFuZ2VbMV0sIGVuZFJhbmdlWzJdXTtcbiAgICAgICAgICAgICAgICBjb2xsLml0ZW1zLnB1c2gobWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCA9IHZhbHVlTm9kZSA/IHZhbHVlTm9kZS5yYW5nZVsyXSA6IHZhbHVlUHJvcHMuZW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGV4cGVjdGVkRW5kID0gaXNNYXAgPyAnfScgOiAnXSc7XG4gICAgY29uc3QgW2NlLCAuLi5lZV0gPSBmYy5lbmQ7XG4gICAgbGV0IGNlUG9zID0gb2Zmc2V0O1xuICAgIGlmIChjZT8uc291cmNlID09PSBleHBlY3RlZEVuZClcbiAgICAgICAgY2VQb3MgPSBjZS5vZmZzZXQgKyBjZS5zb3VyY2UubGVuZ3RoO1xuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBuYW1lID0gZmNOYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBmY05hbWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICBjb25zdCBtc2cgPSBhdFJvb3RcbiAgICAgICAgICAgID8gYCR7bmFtZX0gbXVzdCBlbmQgd2l0aCBhICR7ZXhwZWN0ZWRFbmR9YFxuICAgICAgICAgICAgOiBgJHtuYW1lfSBpbiBibG9jayBjb2xsZWN0aW9uIG11c3QgYmUgc3VmZmljaWVudGx5IGluZGVudGVkIGFuZCBlbmQgd2l0aCBhICR7ZXhwZWN0ZWRFbmR9YDtcbiAgICAgICAgb25FcnJvcihvZmZzZXQsIGF0Um9vdCA/ICdNSVNTSU5HX0NIQVInIDogJ0JBRF9JTkRFTlQnLCBtc2cpO1xuICAgICAgICBpZiAoY2UgJiYgY2Uuc291cmNlLmxlbmd0aCAhPT0gMSlcbiAgICAgICAgICAgIGVlLnVuc2hpZnQoY2UpO1xuICAgIH1cbiAgICBpZiAoZWUubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBlbmQgPSByZXNvbHZlRW5kLnJlc29sdmVFbmQoZWUsIGNlUG9zLCBjdHgub3B0aW9ucy5zdHJpY3QsIG9uRXJyb3IpO1xuICAgICAgICBpZiAoZW5kLmNvbW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChjb2xsLmNvbW1lbnQpXG4gICAgICAgICAgICAgICAgY29sbC5jb21tZW50ICs9ICdcXG4nICsgZW5kLmNvbW1lbnQ7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY29sbC5jb21tZW50ID0gZW5kLmNvbW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29sbC5yYW5nZSA9IFtmYy5vZmZzZXQsIGNlUG9zLCBlbmQub2Zmc2V0XTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbGwucmFuZ2UgPSBbZmMub2Zmc2V0LCBjZVBvcywgY2VQb3NdO1xuICAgIH1cbiAgICByZXR1cm4gY29sbDtcbn1cblxuZXhwb3J0cy5yZXNvbHZlRmxvd0NvbGxlY3Rpb24gPSByZXNvbHZlRmxvd0NvbGxlY3Rpb247XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi4vbm9kZXMvaWRlbnRpdHkuanMnKTtcbnZhciBTY2FsYXIgPSByZXF1aXJlKCcuLi9ub2Rlcy9TY2FsYXIuanMnKTtcbnZhciBZQU1MTWFwID0gcmVxdWlyZSgnLi4vbm9kZXMvWUFNTE1hcC5qcycpO1xudmFyIFlBTUxTZXEgPSByZXF1aXJlKCcuLi9ub2Rlcy9ZQU1MU2VxLmpzJyk7XG52YXIgcmVzb2x2ZUJsb2NrTWFwID0gcmVxdWlyZSgnLi9yZXNvbHZlLWJsb2NrLW1hcC5qcycpO1xudmFyIHJlc29sdmVCbG9ja1NlcSA9IHJlcXVpcmUoJy4vcmVzb2x2ZS1ibG9jay1zZXEuanMnKTtcbnZhciByZXNvbHZlRmxvd0NvbGxlY3Rpb24gPSByZXF1aXJlKCcuL3Jlc29sdmUtZmxvdy1jb2xsZWN0aW9uLmpzJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVDb2xsZWN0aW9uKENOLCBjdHgsIHRva2VuLCBvbkVycm9yLCB0YWdOYW1lLCB0YWcpIHtcbiAgICBjb25zdCBjb2xsID0gdG9rZW4udHlwZSA9PT0gJ2Jsb2NrLW1hcCdcbiAgICAgICAgPyByZXNvbHZlQmxvY2tNYXAucmVzb2x2ZUJsb2NrTWFwKENOLCBjdHgsIHRva2VuLCBvbkVycm9yLCB0YWcpXG4gICAgICAgIDogdG9rZW4udHlwZSA9PT0gJ2Jsb2NrLXNlcSdcbiAgICAgICAgICAgID8gcmVzb2x2ZUJsb2NrU2VxLnJlc29sdmVCbG9ja1NlcShDTiwgY3R4LCB0b2tlbiwgb25FcnJvciwgdGFnKVxuICAgICAgICAgICAgOiByZXNvbHZlRmxvd0NvbGxlY3Rpb24ucmVzb2x2ZUZsb3dDb2xsZWN0aW9uKENOLCBjdHgsIHRva2VuLCBvbkVycm9yLCB0YWcpO1xuICAgIGNvbnN0IENvbGwgPSBjb2xsLmNvbnN0cnVjdG9yO1xuICAgIC8vIElmIHdlIGdvdCBhIHRhZ05hbWUgbWF0Y2hpbmcgdGhlIGNsYXNzLCBvciB0aGUgdGFnIG5hbWUgaXMgJyEnLFxuICAgIC8vIHRoZW4gdXNlIHRoZSB0YWdOYW1lIGZyb20gdGhlIG5vZGUgY2xhc3MgdXNlZCB0byBjcmVhdGUgaXQuXG4gICAgaWYgKHRhZ05hbWUgPT09ICchJyB8fCB0YWdOYW1lID09PSBDb2xsLnRhZ05hbWUpIHtcbiAgICAgICAgY29sbC50YWcgPSBDb2xsLnRhZ05hbWU7XG4gICAgICAgIHJldHVybiBjb2xsO1xuICAgIH1cbiAgICBpZiAodGFnTmFtZSlcbiAgICAgICAgY29sbC50YWcgPSB0YWdOYW1lO1xuICAgIHJldHVybiBjb2xsO1xufVxuZnVuY3Rpb24gY29tcG9zZUNvbGxlY3Rpb24oQ04sIGN0eCwgdG9rZW4sIHByb3BzLCBvbkVycm9yKSB7XG4gICAgY29uc3QgdGFnVG9rZW4gPSBwcm9wcy50YWc7XG4gICAgY29uc3QgdGFnTmFtZSA9ICF0YWdUb2tlblxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiBjdHguZGlyZWN0aXZlcy50YWdOYW1lKHRhZ1Rva2VuLnNvdXJjZSwgbXNnID0+IG9uRXJyb3IodGFnVG9rZW4sICdUQUdfUkVTT0xWRV9GQUlMRUQnLCBtc2cpKTtcbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2Jsb2NrLXNlcScpIHtcbiAgICAgICAgY29uc3QgeyBhbmNob3IsIG5ld2xpbmVBZnRlclByb3A6IG5sIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgbGFzdFByb3AgPSBhbmNob3IgJiYgdGFnVG9rZW5cbiAgICAgICAgICAgID8gYW5jaG9yLm9mZnNldCA+IHRhZ1Rva2VuLm9mZnNldFxuICAgICAgICAgICAgICAgID8gYW5jaG9yXG4gICAgICAgICAgICAgICAgOiB0YWdUb2tlblxuICAgICAgICAgICAgOiAoYW5jaG9yID8/IHRhZ1Rva2VuKTtcbiAgICAgICAgaWYgKGxhc3RQcm9wICYmICghbmwgfHwgbmwub2Zmc2V0IDwgbGFzdFByb3Aub2Zmc2V0KSkge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdNaXNzaW5nIG5ld2xpbmUgYWZ0ZXIgYmxvY2sgc2VxdWVuY2UgcHJvcHMnO1xuICAgICAgICAgICAgb25FcnJvcihsYXN0UHJvcCwgJ01JU1NJTkdfQ0hBUicsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGV4cFR5cGUgPSB0b2tlbi50eXBlID09PSAnYmxvY2stbWFwJ1xuICAgICAgICA/ICdtYXAnXG4gICAgICAgIDogdG9rZW4udHlwZSA9PT0gJ2Jsb2NrLXNlcSdcbiAgICAgICAgICAgID8gJ3NlcSdcbiAgICAgICAgICAgIDogdG9rZW4uc3RhcnQuc291cmNlID09PSAneydcbiAgICAgICAgICAgICAgICA/ICdtYXAnXG4gICAgICAgICAgICAgICAgOiAnc2VxJztcbiAgICAvLyBzaG9ydGN1dDogY2hlY2sgaWYgaXQncyBhIGdlbmVyaWMgWUFNTE1hcCBvciBZQU1MU2VxXG4gICAgLy8gYmVmb3JlIGp1bXBpbmcgaW50byB0aGUgY3VzdG9tIHRhZyBsb2dpYy5cbiAgICBpZiAoIXRhZ1Rva2VuIHx8XG4gICAgICAgICF0YWdOYW1lIHx8XG4gICAgICAgIHRhZ05hbWUgPT09ICchJyB8fFxuICAgICAgICAodGFnTmFtZSA9PT0gWUFNTE1hcC5ZQU1MTWFwLnRhZ05hbWUgJiYgZXhwVHlwZSA9PT0gJ21hcCcpIHx8XG4gICAgICAgICh0YWdOYW1lID09PSBZQU1MU2VxLllBTUxTZXEudGFnTmFtZSAmJiBleHBUeXBlID09PSAnc2VxJykpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVDb2xsZWN0aW9uKENOLCBjdHgsIHRva2VuLCBvbkVycm9yLCB0YWdOYW1lKTtcbiAgICB9XG4gICAgbGV0IHRhZyA9IGN0eC5zY2hlbWEudGFncy5maW5kKHQgPT4gdC50YWcgPT09IHRhZ05hbWUgJiYgdC5jb2xsZWN0aW9uID09PSBleHBUeXBlKTtcbiAgICBpZiAoIXRhZykge1xuICAgICAgICBjb25zdCBrdCA9IGN0eC5zY2hlbWEua25vd25UYWdzW3RhZ05hbWVdO1xuICAgICAgICBpZiAoa3Q/LmNvbGxlY3Rpb24gPT09IGV4cFR5cGUpIHtcbiAgICAgICAgICAgIGN0eC5zY2hlbWEudGFncy5wdXNoKE9iamVjdC5hc3NpZ24oe30sIGt0LCB7IGRlZmF1bHQ6IGZhbHNlIH0pKTtcbiAgICAgICAgICAgIHRhZyA9IGt0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGt0KSB7XG4gICAgICAgICAgICAgICAgb25FcnJvcih0YWdUb2tlbiwgJ0JBRF9DT0xMRUNUSU9OX1RZUEUnLCBgJHtrdC50YWd9IHVzZWQgZm9yICR7ZXhwVHlwZX0gY29sbGVjdGlvbiwgYnV0IGV4cGVjdHMgJHtrdC5jb2xsZWN0aW9uID8/ICdzY2FsYXInfWAsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb25FcnJvcih0YWdUb2tlbiwgJ1RBR19SRVNPTFZFX0ZBSUxFRCcsIGBVbnJlc29sdmVkIHRhZzogJHt0YWdOYW1lfWAsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVDb2xsZWN0aW9uKENOLCBjdHgsIHRva2VuLCBvbkVycm9yLCB0YWdOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjb2xsID0gcmVzb2x2ZUNvbGxlY3Rpb24oQ04sIGN0eCwgdG9rZW4sIG9uRXJyb3IsIHRhZ05hbWUsIHRhZyk7XG4gICAgY29uc3QgcmVzID0gdGFnLnJlc29sdmU/Lihjb2xsLCBtc2cgPT4gb25FcnJvcih0YWdUb2tlbiwgJ1RBR19SRVNPTFZFX0ZBSUxFRCcsIG1zZyksIGN0eC5vcHRpb25zKSA/PyBjb2xsO1xuICAgIGNvbnN0IG5vZGUgPSBpZGVudGl0eS5pc05vZGUocmVzKVxuICAgICAgICA/IHJlc1xuICAgICAgICA6IG5ldyBTY2FsYXIuU2NhbGFyKHJlcyk7XG4gICAgbm9kZS5yYW5nZSA9IGNvbGwucmFuZ2U7XG4gICAgbm9kZS50YWcgPSB0YWdOYW1lO1xuICAgIGlmICh0YWc/LmZvcm1hdClcbiAgICAgICAgbm9kZS5mb3JtYXQgPSB0YWcuZm9ybWF0O1xuICAgIHJldHVybiBub2RlO1xufVxuXG5leHBvcnRzLmNvbXBvc2VDb2xsZWN0aW9uID0gY29tcG9zZUNvbGxlY3Rpb247XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIFNjYWxhciA9IHJlcXVpcmUoJy4uL25vZGVzL1NjYWxhci5qcycpO1xuXG5mdW5jdGlvbiByZXNvbHZlQmxvY2tTY2FsYXIoY3R4LCBzY2FsYXIsIG9uRXJyb3IpIHtcbiAgICBjb25zdCBzdGFydCA9IHNjYWxhci5vZmZzZXQ7XG4gICAgY29uc3QgaGVhZGVyID0gcGFyc2VCbG9ja1NjYWxhckhlYWRlcihzY2FsYXIsIGN0eC5vcHRpb25zLnN0cmljdCwgb25FcnJvcik7XG4gICAgaWYgKCFoZWFkZXIpXG4gICAgICAgIHJldHVybiB7IHZhbHVlOiAnJywgdHlwZTogbnVsbCwgY29tbWVudDogJycsIHJhbmdlOiBbc3RhcnQsIHN0YXJ0LCBzdGFydF0gfTtcbiAgICBjb25zdCB0eXBlID0gaGVhZGVyLm1vZGUgPT09ICc+JyA/IFNjYWxhci5TY2FsYXIuQkxPQ0tfRk9MREVEIDogU2NhbGFyLlNjYWxhci5CTE9DS19MSVRFUkFMO1xuICAgIGNvbnN0IGxpbmVzID0gc2NhbGFyLnNvdXJjZSA/IHNwbGl0TGluZXMoc2NhbGFyLnNvdXJjZSkgOiBbXTtcbiAgICAvLyBkZXRlcm1pbmUgdGhlIGVuZCBvZiBjb250ZW50ICYgc3RhcnQgb2YgY2hvbXBpbmdcbiAgICBsZXQgY2hvbXBTdGFydCA9IGxpbmVzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gbGluZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGxpbmVzW2ldWzFdO1xuICAgICAgICBpZiAoY29udGVudCA9PT0gJycgfHwgY29udGVudCA9PT0gJ1xccicpXG4gICAgICAgICAgICBjaG9tcFN0YXJ0ID0gaTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIHNob3J0Y3V0IGZvciBlbXB0eSBjb250ZW50c1xuICAgIGlmIChjaG9tcFN0YXJ0ID09PSAwKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaGVhZGVyLmNob21wID09PSAnKycgJiYgbGluZXMubGVuZ3RoID4gMFxuICAgICAgICAgICAgPyAnXFxuJy5yZXBlYXQoTWF0aC5tYXgoMSwgbGluZXMubGVuZ3RoIC0gMSkpXG4gICAgICAgICAgICA6ICcnO1xuICAgICAgICBsZXQgZW5kID0gc3RhcnQgKyBoZWFkZXIubGVuZ3RoO1xuICAgICAgICBpZiAoc2NhbGFyLnNvdXJjZSlcbiAgICAgICAgICAgIGVuZCArPSBzY2FsYXIuc291cmNlLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWUsIHR5cGUsIGNvbW1lbnQ6IGhlYWRlci5jb21tZW50LCByYW5nZTogW3N0YXJ0LCBlbmQsIGVuZF0gfTtcbiAgICB9XG4gICAgLy8gZmluZCB0aGUgaW5kZW50YXRpb24gbGV2ZWwgdG8gdHJpbSBmcm9tIHN0YXJ0XG4gICAgbGV0IHRyaW1JbmRlbnQgPSBzY2FsYXIuaW5kZW50ICsgaGVhZGVyLmluZGVudDtcbiAgICBsZXQgb2Zmc2V0ID0gc2NhbGFyLm9mZnNldCArIGhlYWRlci5sZW5ndGg7XG4gICAgbGV0IGNvbnRlbnRTdGFydCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaG9tcFN0YXJ0OyArK2kpIHtcbiAgICAgICAgY29uc3QgW2luZGVudCwgY29udGVudF0gPSBsaW5lc1tpXTtcbiAgICAgICAgaWYgKGNvbnRlbnQgPT09ICcnIHx8IGNvbnRlbnQgPT09ICdcXHInKSB7XG4gICAgICAgICAgICBpZiAoaGVhZGVyLmluZGVudCA9PT0gMCAmJiBpbmRlbnQubGVuZ3RoID4gdHJpbUluZGVudClcbiAgICAgICAgICAgICAgICB0cmltSW5kZW50ID0gaW5kZW50Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpbmRlbnQubGVuZ3RoIDwgdHJpbUluZGVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnQmxvY2sgc2NhbGFycyB3aXRoIG1vcmUtaW5kZW50ZWQgbGVhZGluZyBlbXB0eSBsaW5lcyBtdXN0IHVzZSBhbiBleHBsaWNpdCBpbmRlbnRhdGlvbiBpbmRpY2F0b3InO1xuICAgICAgICAgICAgICAgIG9uRXJyb3Iob2Zmc2V0ICsgaW5kZW50Lmxlbmd0aCwgJ01JU1NJTkdfQ0hBUicsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhlYWRlci5pbmRlbnQgPT09IDApXG4gICAgICAgICAgICAgICAgdHJpbUluZGVudCA9IGluZGVudC5sZW5ndGg7XG4gICAgICAgICAgICBjb250ZW50U3RhcnQgPSBpO1xuICAgICAgICAgICAgaWYgKHRyaW1JbmRlbnQgPT09IDAgJiYgIWN0eC5hdFJvb3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0Jsb2NrIHNjYWxhciB2YWx1ZXMgaW4gY29sbGVjdGlvbnMgbXVzdCBiZSBpbmRlbnRlZCc7XG4gICAgICAgICAgICAgICAgb25FcnJvcihvZmZzZXQsICdCQURfSU5ERU5UJywgbWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgKz0gaW5kZW50Lmxlbmd0aCArIGNvbnRlbnQubGVuZ3RoICsgMTtcbiAgICB9XG4gICAgLy8gaW5jbHVkZSB0cmFpbGluZyBtb3JlLWluZGVudGVkIGVtcHR5IGxpbmVzIGluIGNvbnRlbnRcbiAgICBmb3IgKGxldCBpID0gbGluZXMubGVuZ3RoIC0gMTsgaSA+PSBjaG9tcFN0YXJ0OyAtLWkpIHtcbiAgICAgICAgaWYgKGxpbmVzW2ldWzBdLmxlbmd0aCA+IHRyaW1JbmRlbnQpXG4gICAgICAgICAgICBjaG9tcFN0YXJ0ID0gaSArIDE7XG4gICAgfVxuICAgIGxldCB2YWx1ZSA9ICcnO1xuICAgIGxldCBzZXAgPSAnJztcbiAgICBsZXQgcHJldk1vcmVJbmRlbnRlZCA9IGZhbHNlO1xuICAgIC8vIGxlYWRpbmcgd2hpdGVzcGFjZSBpcyBrZXB0IGludGFjdFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGVudFN0YXJ0OyArK2kpXG4gICAgICAgIHZhbHVlICs9IGxpbmVzW2ldWzBdLnNsaWNlKHRyaW1JbmRlbnQpICsgJ1xcbic7XG4gICAgZm9yIChsZXQgaSA9IGNvbnRlbnRTdGFydDsgaSA8IGNob21wU3RhcnQ7ICsraSkge1xuICAgICAgICBsZXQgW2luZGVudCwgY29udGVudF0gPSBsaW5lc1tpXTtcbiAgICAgICAgb2Zmc2V0ICs9IGluZGVudC5sZW5ndGggKyBjb250ZW50Lmxlbmd0aCArIDE7XG4gICAgICAgIGNvbnN0IGNybGYgPSBjb250ZW50W2NvbnRlbnQubGVuZ3RoIC0gMV0gPT09ICdcXHInO1xuICAgICAgICBpZiAoY3JsZilcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDAsIC0xKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmIGFscmVhZHkgY2F1Z2h0IGluIGxleGVyICovXG4gICAgICAgIGlmIChjb250ZW50ICYmIGluZGVudC5sZW5ndGggPCB0cmltSW5kZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzcmMgPSBoZWFkZXIuaW5kZW50XG4gICAgICAgICAgICAgICAgPyAnZXhwbGljaXQgaW5kZW50YXRpb24gaW5kaWNhdG9yJ1xuICAgICAgICAgICAgICAgIDogJ2ZpcnN0IGxpbmUnO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBCbG9jayBzY2FsYXIgbGluZXMgbXVzdCBub3QgYmUgbGVzcyBpbmRlbnRlZCB0aGFuIHRoZWlyICR7c3JjfWA7XG4gICAgICAgICAgICBvbkVycm9yKG9mZnNldCAtIGNvbnRlbnQubGVuZ3RoIC0gKGNybGYgPyAyIDogMSksICdCQURfSU5ERU5UJywgbWVzc2FnZSk7XG4gICAgICAgICAgICBpbmRlbnQgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gU2NhbGFyLlNjYWxhci5CTE9DS19MSVRFUkFMKSB7XG4gICAgICAgICAgICB2YWx1ZSArPSBzZXAgKyBpbmRlbnQuc2xpY2UodHJpbUluZGVudCkgKyBjb250ZW50O1xuICAgICAgICAgICAgc2VwID0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5kZW50Lmxlbmd0aCA+IHRyaW1JbmRlbnQgfHwgY29udGVudFswXSA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICAgIC8vIG1vcmUtaW5kZW50ZWQgY29udGVudCB3aXRoaW4gYSBmb2xkZWQgYmxvY2tcbiAgICAgICAgICAgIGlmIChzZXAgPT09ICcgJylcbiAgICAgICAgICAgICAgICBzZXAgPSAnXFxuJztcbiAgICAgICAgICAgIGVsc2UgaWYgKCFwcmV2TW9yZUluZGVudGVkICYmIHNlcCA9PT0gJ1xcbicpXG4gICAgICAgICAgICAgICAgc2VwID0gJ1xcblxcbic7XG4gICAgICAgICAgICB2YWx1ZSArPSBzZXAgKyBpbmRlbnQuc2xpY2UodHJpbUluZGVudCkgKyBjb250ZW50O1xuICAgICAgICAgICAgc2VwID0gJ1xcbic7XG4gICAgICAgICAgICBwcmV2TW9yZUluZGVudGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250ZW50ID09PSAnJykge1xuICAgICAgICAgICAgLy8gZW1wdHkgbGluZVxuICAgICAgICAgICAgaWYgKHNlcCA9PT0gJ1xcbicpXG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gJ1xcbic7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc2VwID0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSArPSBzZXAgKyBjb250ZW50O1xuICAgICAgICAgICAgc2VwID0gJyAnO1xuICAgICAgICAgICAgcHJldk1vcmVJbmRlbnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAoaGVhZGVyLmNob21wKSB7XG4gICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGNob21wU3RhcnQ7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSAnXFxuJyArIGxpbmVzW2ldWzBdLnNsaWNlKHRyaW1JbmRlbnQpO1xuICAgICAgICAgICAgaWYgKHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdICE9PSAnXFxuJylcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSAnXFxuJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFsdWUgKz0gJ1xcbic7XG4gICAgfVxuICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgaGVhZGVyLmxlbmd0aCArIHNjYWxhci5zb3VyY2UubGVuZ3RoO1xuICAgIHJldHVybiB7IHZhbHVlLCB0eXBlLCBjb21tZW50OiBoZWFkZXIuY29tbWVudCwgcmFuZ2U6IFtzdGFydCwgZW5kLCBlbmRdIH07XG59XG5mdW5jdGlvbiBwYXJzZUJsb2NrU2NhbGFySGVhZGVyKHsgb2Zmc2V0LCBwcm9wcyB9LCBzdHJpY3QsIG9uRXJyb3IpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICBpZiAocHJvcHNbMF0udHlwZSAhPT0gJ2Jsb2NrLXNjYWxhci1oZWFkZXInKSB7XG4gICAgICAgIG9uRXJyb3IocHJvcHNbMF0sICdJTVBPU1NJQkxFJywgJ0Jsb2NrIHNjYWxhciBoZWFkZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7IHNvdXJjZSB9ID0gcHJvcHNbMF07XG4gICAgY29uc3QgbW9kZSA9IHNvdXJjZVswXTtcbiAgICBsZXQgaW5kZW50ID0gMDtcbiAgICBsZXQgY2hvbXAgPSAnJztcbiAgICBsZXQgZXJyb3IgPSAtMTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNvdXJjZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBjaCA9IHNvdXJjZVtpXTtcbiAgICAgICAgaWYgKCFjaG9tcCAmJiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJysnKSlcbiAgICAgICAgICAgIGNob21wID0gY2g7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbiA9IE51bWJlcihjaCk7XG4gICAgICAgICAgICBpZiAoIWluZGVudCAmJiBuKVxuICAgICAgICAgICAgICAgIGluZGVudCA9IG47XG4gICAgICAgICAgICBlbHNlIGlmIChlcnJvciA9PT0gLTEpXG4gICAgICAgICAgICAgICAgZXJyb3IgPSBvZmZzZXQgKyBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlcnJvciAhPT0gLTEpXG4gICAgICAgIG9uRXJyb3IoZXJyb3IsICdVTkVYUEVDVEVEX1RPS0VOJywgYEJsb2NrIHNjYWxhciBoZWFkZXIgaW5jbHVkZXMgZXh0cmEgY2hhcmFjdGVyczogJHtzb3VyY2V9YCk7XG4gICAgbGV0IGhhc1NwYWNlID0gZmFsc2U7XG4gICAgbGV0IGNvbW1lbnQgPSAnJztcbiAgICBsZXQgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHByb3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gcHJvcHNbaV07XG4gICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgICAgIGhhc1NwYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICBsZW5ndGggKz0gdG9rZW4uc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIWhhc1NwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnQ29tbWVudHMgbXVzdCBiZSBzZXBhcmF0ZWQgZnJvbSBvdGhlciB0b2tlbnMgYnkgd2hpdGUgc3BhY2UgY2hhcmFjdGVycyc7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdNSVNTSU5HX0NIQVInLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGVuZ3RoICs9IHRva2VuLnNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29tbWVudCA9IHRva2VuLnNvdXJjZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ1VORVhQRUNURURfVE9LRU4nLCB0b2tlbi5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBsZW5ndGggKz0gdG9rZW4uc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IHNob3VsZCBub3QgaGFwcGVuICovXG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBVbmV4cGVjdGVkIHRva2VuIGluIGJsb2NrIHNjYWxhciBoZWFkZXI6ICR7dG9rZW4udHlwZX1gO1xuICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdVTkVYUEVDVEVEX1RPS0VOJywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHMgPSB0b2tlbi5zb3VyY2U7XG4gICAgICAgICAgICAgICAgaWYgKHRzICYmIHR5cGVvZiB0cyA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCArPSB0cy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbW9kZSwgaW5kZW50LCBjaG9tcCwgY29tbWVudCwgbGVuZ3RoIH07XG59XG4vKiogQHJldHVybnMgQXJyYXkgb2YgbGluZXMgc3BsaXQgdXAgYXMgYFtpbmRlbnQsIGNvbnRlbnRdYCAqL1xuZnVuY3Rpb24gc3BsaXRMaW5lcyhzb3VyY2UpIHtcbiAgICBjb25zdCBzcGxpdCA9IHNvdXJjZS5zcGxpdCgvXFxuKCAqKS8pO1xuICAgIGNvbnN0IGZpcnN0ID0gc3BsaXRbMF07XG4gICAgY29uc3QgbSA9IGZpcnN0Lm1hdGNoKC9eKCAqKS8pO1xuICAgIGNvbnN0IGxpbmUwID0gbT8uWzFdXG4gICAgICAgID8gW21bMV0sIGZpcnN0LnNsaWNlKG1bMV0ubGVuZ3RoKV1cbiAgICAgICAgOiBbJycsIGZpcnN0XTtcbiAgICBjb25zdCBsaW5lcyA9IFtsaW5lMF07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzcGxpdC5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgbGluZXMucHVzaChbc3BsaXRbaV0sIHNwbGl0W2kgKyAxXV0pO1xuICAgIHJldHVybiBsaW5lcztcbn1cblxuZXhwb3J0cy5yZXNvbHZlQmxvY2tTY2FsYXIgPSByZXNvbHZlQmxvY2tTY2FsYXI7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIFNjYWxhciA9IHJlcXVpcmUoJy4uL25vZGVzL1NjYWxhci5qcycpO1xudmFyIHJlc29sdmVFbmQgPSByZXF1aXJlKCcuL3Jlc29sdmUtZW5kLmpzJyk7XG5cbmZ1bmN0aW9uIHJlc29sdmVGbG93U2NhbGFyKHNjYWxhciwgc3RyaWN0LCBvbkVycm9yKSB7XG4gICAgY29uc3QgeyBvZmZzZXQsIHR5cGUsIHNvdXJjZSwgZW5kIH0gPSBzY2FsYXI7XG4gICAgbGV0IF90eXBlO1xuICAgIGxldCB2YWx1ZTtcbiAgICBjb25zdCBfb25FcnJvciA9IChyZWwsIGNvZGUsIG1zZykgPT4gb25FcnJvcihvZmZzZXQgKyByZWwsIGNvZGUsIG1zZyk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgICAgICAgICBfdHlwZSA9IFNjYWxhci5TY2FsYXIuUExBSU47XG4gICAgICAgICAgICB2YWx1ZSA9IHBsYWluVmFsdWUoc291cmNlLCBfb25FcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2luZ2xlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgX3R5cGUgPSBTY2FsYXIuU2NhbGFyLlFVT1RFX1NJTkdMRTtcbiAgICAgICAgICAgIHZhbHVlID0gc2luZ2xlUXVvdGVkVmFsdWUoc291cmNlLCBfb25FcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZG91YmxlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgX3R5cGUgPSBTY2FsYXIuU2NhbGFyLlFVT1RFX0RPVUJMRTtcbiAgICAgICAgICAgIHZhbHVlID0gZG91YmxlUXVvdGVkVmFsdWUoc291cmNlLCBfb25FcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIG9uRXJyb3Ioc2NhbGFyLCAnVU5FWFBFQ1RFRF9UT0tFTicsIGBFeHBlY3RlZCBhIGZsb3cgc2NhbGFyIHZhbHVlLCBidXQgZm91bmQ6ICR7dHlwZX1gKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6ICcnLFxuICAgICAgICAgICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgICAgICAgICAgY29tbWVudDogJycsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFtvZmZzZXQsIG9mZnNldCArIHNvdXJjZS5sZW5ndGgsIG9mZnNldCArIHNvdXJjZS5sZW5ndGhdXG4gICAgICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZUVuZCA9IG9mZnNldCArIHNvdXJjZS5sZW5ndGg7XG4gICAgY29uc3QgcmUgPSByZXNvbHZlRW5kLnJlc29sdmVFbmQoZW5kLCB2YWx1ZUVuZCwgc3RyaWN0LCBvbkVycm9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgdHlwZTogX3R5cGUsXG4gICAgICAgIGNvbW1lbnQ6IHJlLmNvbW1lbnQsXG4gICAgICAgIHJhbmdlOiBbb2Zmc2V0LCB2YWx1ZUVuZCwgcmUub2Zmc2V0XVxuICAgIH07XG59XG5mdW5jdGlvbiBwbGFpblZhbHVlKHNvdXJjZSwgb25FcnJvcikge1xuICAgIGxldCBiYWRDaGFyID0gJyc7XG4gICAgc3dpdGNoIChzb3VyY2VbMF0pIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICAgY2FzZSAnXFx0JzpcbiAgICAgICAgICAgIGJhZENoYXIgPSAnYSB0YWIgY2hhcmFjdGVyJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcsJzpcbiAgICAgICAgICAgIGJhZENoYXIgPSAnZmxvdyBpbmRpY2F0b3IgY2hhcmFjdGVyICwnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgYmFkQ2hhciA9ICdkaXJlY3RpdmUgaW5kaWNhdG9yIGNoYXJhY3RlciAlJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd8JzpcbiAgICAgICAgY2FzZSAnPic6IHtcbiAgICAgICAgICAgIGJhZENoYXIgPSBgYmxvY2sgc2NhbGFyIGluZGljYXRvciAke3NvdXJjZVswXX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnQCc6XG4gICAgICAgIGNhc2UgJ2AnOiB7XG4gICAgICAgICAgICBiYWRDaGFyID0gYHJlc2VydmVkIGNoYXJhY3RlciAke3NvdXJjZVswXX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJhZENoYXIpXG4gICAgICAgIG9uRXJyb3IoMCwgJ0JBRF9TQ0FMQVJfU1RBUlQnLCBgUGxhaW4gdmFsdWUgY2Fubm90IHN0YXJ0IHdpdGggJHtiYWRDaGFyfWApO1xuICAgIHJldHVybiBmb2xkTGluZXMoc291cmNlKTtcbn1cbmZ1bmN0aW9uIHNpbmdsZVF1b3RlZFZhbHVlKHNvdXJjZSwgb25FcnJvcikge1xuICAgIGlmIChzb3VyY2Vbc291cmNlLmxlbmd0aCAtIDFdICE9PSBcIidcIiB8fCBzb3VyY2UubGVuZ3RoID09PSAxKVxuICAgICAgICBvbkVycm9yKHNvdXJjZS5sZW5ndGgsICdNSVNTSU5HX0NIQVInLCBcIk1pc3NpbmcgY2xvc2luZyAncXVvdGVcIik7XG4gICAgcmV0dXJuIGZvbGRMaW5lcyhzb3VyY2Uuc2xpY2UoMSwgLTEpKS5yZXBsYWNlKC8nJy9nLCBcIidcIik7XG59XG5mdW5jdGlvbiBmb2xkTGluZXMoc291cmNlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIG5lZ2F0aXZlIGxvb2tiZWhpbmQgaGVyZSBhbmQgaW4gdGhlIGByZWAgUmVnRXhwIGlzIHRvXG4gICAgICogcHJldmVudCBjYXVzaW5nIGEgcG9seW5vbWlhbCBzZWFyY2ggdGltZSBpbiBjZXJ0YWluIGNhc2VzLlxuICAgICAqXG4gICAgICogVGhlIHRyeS1jYXRjaCBpcyBmb3IgU2FmYXJpLCB3aGljaCBkb2Vzbid0IHN1cHBvcnQgdGhpcyB5ZXQ6XG4gICAgICogaHR0cHM6Ly9jYW5pdXNlLmNvbS9qcy1yZWdleHAtbG9va2JlaGluZFxuICAgICAqL1xuICAgIGxldCBmaXJzdCwgbGluZTtcbiAgICB0cnkge1xuICAgICAgICBmaXJzdCA9IG5ldyBSZWdFeHAoJyguKj8pKD88IVsgXFx0XSlbIFxcdF0qXFxyP1xcbicsICdzeScpO1xuICAgICAgICBsaW5lID0gbmV3IFJlZ0V4cCgnWyBcXHRdKiguKj8pKD86KD88IVsgXFx0XSlbIFxcdF0qKT9cXHI/XFxuJywgJ3N5Jyk7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgZmlyc3QgPSAvKC4qPylbIFxcdF0qXFxyP1xcbi9zeTtcbiAgICAgICAgbGluZSA9IC9bIFxcdF0qKC4qPylbIFxcdF0qXFxyP1xcbi9zeTtcbiAgICB9XG4gICAgbGV0IG1hdGNoID0gZmlyc3QuZXhlYyhzb3VyY2UpO1xuICAgIGlmICghbWF0Y2gpXG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgbGV0IHJlcyA9IG1hdGNoWzFdO1xuICAgIGxldCBzZXAgPSAnICc7XG4gICAgbGV0IHBvcyA9IGZpcnN0Lmxhc3RJbmRleDtcbiAgICBsaW5lLmxhc3RJbmRleCA9IHBvcztcbiAgICB3aGlsZSAoKG1hdGNoID0gbGluZS5leGVjKHNvdXJjZSkpKSB7XG4gICAgICAgIGlmIChtYXRjaFsxXSA9PT0gJycpIHtcbiAgICAgICAgICAgIGlmIChzZXAgPT09ICdcXG4nKVxuICAgICAgICAgICAgICAgIHJlcyArPSBzZXA7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc2VwID0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXMgKz0gc2VwICsgbWF0Y2hbMV07XG4gICAgICAgICAgICBzZXAgPSAnICc7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gbGluZS5sYXN0SW5kZXg7XG4gICAgfVxuICAgIGNvbnN0IGxhc3QgPSAvWyBcXHRdKiguKikvc3k7XG4gICAgbGFzdC5sYXN0SW5kZXggPSBwb3M7XG4gICAgbWF0Y2ggPSBsYXN0LmV4ZWMoc291cmNlKTtcbiAgICByZXR1cm4gcmVzICsgc2VwICsgKG1hdGNoPy5bMV0gPz8gJycpO1xufVxuZnVuY3Rpb24gZG91YmxlUXVvdGVkVmFsdWUoc291cmNlLCBvbkVycm9yKSB7XG4gICAgbGV0IHJlcyA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc291cmNlLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICBjb25zdCBjaCA9IHNvdXJjZVtpXTtcbiAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiBzb3VyY2VbaSArIDFdID09PSAnXFxuJylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoY2ggPT09ICdcXG4nKSB7XG4gICAgICAgICAgICBjb25zdCB7IGZvbGQsIG9mZnNldCB9ID0gZm9sZE5ld2xpbmUoc291cmNlLCBpKTtcbiAgICAgICAgICAgIHJlcyArPSBmb2xkO1xuICAgICAgICAgICAgaSA9IG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHNvdXJjZVsrK2ldO1xuICAgICAgICAgICAgY29uc3QgY2MgPSBlc2NhcGVDb2Rlc1tuZXh0XTtcbiAgICAgICAgICAgIGlmIChjYylcbiAgICAgICAgICAgICAgICByZXMgKz0gY2M7XG4gICAgICAgICAgICBlbHNlIGlmIChuZXh0ID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgIC8vIHNraXAgZXNjYXBlZCBuZXdsaW5lcywgYnV0IHN0aWxsIHRyaW0gdGhlIGZvbGxvd2luZyBsaW5lXG4gICAgICAgICAgICAgICAgbmV4dCA9IHNvdXJjZVtpICsgMV07XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHQgPT09ICcgJyB8fCBuZXh0ID09PSAnXFx0JylcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHNvdXJjZVsrK2kgKyAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPT09ICdcXHInICYmIHNvdXJjZVtpICsgMV0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgLy8gc2tpcCBlc2NhcGVkIENSTEYgbmV3bGluZXMsIGJ1dCBzdGlsbCB0cmltIHRoZSBmb2xsb3dpbmcgbGluZVxuICAgICAgICAgICAgICAgIG5leHQgPSBzb3VyY2VbKytpICsgMV07XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHQgPT09ICcgJyB8fCBuZXh0ID09PSAnXFx0JylcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHNvdXJjZVsrK2kgKyAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPT09ICd4JyB8fCBuZXh0ID09PSAndScgfHwgbmV4dCA9PT0gJ1UnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0geyB4OiAyLCB1OiA0LCBVOiA4IH1bbmV4dF07XG4gICAgICAgICAgICAgICAgcmVzICs9IHBhcnNlQ2hhckNvZGUoc291cmNlLCBpICsgMSwgbGVuZ3RoLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICBpICs9IGxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhdyA9IHNvdXJjZS5zdWJzdHIoaSAtIDEsIDIpO1xuICAgICAgICAgICAgICAgIG9uRXJyb3IoaSAtIDEsICdCQURfRFFfRVNDQVBFJywgYEludmFsaWQgZXNjYXBlIHNlcXVlbmNlICR7cmF3fWApO1xuICAgICAgICAgICAgICAgIHJlcyArPSByYXc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICAgIC8vIHRyaW0gdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgICAgICAgY29uc3Qgd3NTdGFydCA9IGk7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHNvdXJjZVtpICsgMV07XG4gICAgICAgICAgICB3aGlsZSAobmV4dCA9PT0gJyAnIHx8IG5leHQgPT09ICdcXHQnKVxuICAgICAgICAgICAgICAgIG5leHQgPSBzb3VyY2VbKytpICsgMV07XG4gICAgICAgICAgICBpZiAobmV4dCAhPT0gJ1xcbicgJiYgIShuZXh0ID09PSAnXFxyJyAmJiBzb3VyY2VbaSArIDJdID09PSAnXFxuJykpXG4gICAgICAgICAgICAgICAgcmVzICs9IGkgPiB3c1N0YXJ0ID8gc291cmNlLnNsaWNlKHdzU3RhcnQsIGkgKyAxKSA6IGNoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzICs9IGNoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzb3VyY2Vbc291cmNlLmxlbmd0aCAtIDFdICE9PSAnXCInIHx8IHNvdXJjZS5sZW5ndGggPT09IDEpXG4gICAgICAgIG9uRXJyb3Ioc291cmNlLmxlbmd0aCwgJ01JU1NJTkdfQ0hBUicsICdNaXNzaW5nIGNsb3NpbmcgXCJxdW90ZScpO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIEZvbGQgYSBzaW5nbGUgbmV3bGluZSBpbnRvIGEgc3BhY2UsIG11bHRpcGxlIG5ld2xpbmVzIHRvIE4gLSAxIG5ld2xpbmVzLlxuICogUHJlc3VtZXMgYHNvdXJjZVtvZmZzZXRdID09PSAnXFxuJ2BcbiAqL1xuZnVuY3Rpb24gZm9sZE5ld2xpbmUoc291cmNlLCBvZmZzZXQpIHtcbiAgICBsZXQgZm9sZCA9ICcnO1xuICAgIGxldCBjaCA9IHNvdXJjZVtvZmZzZXQgKyAxXTtcbiAgICB3aGlsZSAoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcgfHwgY2ggPT09ICdcXG4nIHx8IGNoID09PSAnXFxyJykge1xuICAgICAgICBpZiAoY2ggPT09ICdcXHInICYmIHNvdXJjZVtvZmZzZXQgKyAyXSAhPT0gJ1xcbicpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKGNoID09PSAnXFxuJylcbiAgICAgICAgICAgIGZvbGQgKz0gJ1xcbic7XG4gICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICBjaCA9IHNvdXJjZVtvZmZzZXQgKyAxXTtcbiAgICB9XG4gICAgaWYgKCFmb2xkKVxuICAgICAgICBmb2xkID0gJyAnO1xuICAgIHJldHVybiB7IGZvbGQsIG9mZnNldCB9O1xufVxuY29uc3QgZXNjYXBlQ29kZXMgPSB7XG4gICAgJzAnOiAnXFwwJywgLy8gbnVsbCBjaGFyYWN0ZXJcbiAgICBhOiAnXFx4MDcnLCAvLyBiZWxsIGNoYXJhY3RlclxuICAgIGI6ICdcXGInLCAvLyBiYWNrc3BhY2VcbiAgICBlOiAnXFx4MWInLCAvLyBlc2NhcGUgY2hhcmFjdGVyXG4gICAgZjogJ1xcZicsIC8vIGZvcm0gZmVlZFxuICAgIG46ICdcXG4nLCAvLyBsaW5lIGZlZWRcbiAgICByOiAnXFxyJywgLy8gY2FycmlhZ2UgcmV0dXJuXG4gICAgdDogJ1xcdCcsIC8vIGhvcml6b250YWwgdGFiXG4gICAgdjogJ1xcdicsIC8vIHZlcnRpY2FsIHRhYlxuICAgIE46ICdcXHUwMDg1JywgLy8gVW5pY29kZSBuZXh0IGxpbmVcbiAgICBfOiAnXFx1MDBhMCcsIC8vIFVuaWNvZGUgbm9uLWJyZWFraW5nIHNwYWNlXG4gICAgTDogJ1xcdTIwMjgnLCAvLyBVbmljb2RlIGxpbmUgc2VwYXJhdG9yXG4gICAgUDogJ1xcdTIwMjknLCAvLyBVbmljb2RlIHBhcmFncmFwaCBzZXBhcmF0b3JcbiAgICAnICc6ICcgJyxcbiAgICAnXCInOiAnXCInLFxuICAgICcvJzogJy8nLFxuICAgICdcXFxcJzogJ1xcXFwnLFxuICAgICdcXHQnOiAnXFx0J1xufTtcbmZ1bmN0aW9uIHBhcnNlQ2hhckNvZGUoc291cmNlLCBvZmZzZXQsIGxlbmd0aCwgb25FcnJvcikge1xuICAgIGNvbnN0IGNjID0gc291cmNlLnN1YnN0cihvZmZzZXQsIGxlbmd0aCk7XG4gICAgY29uc3Qgb2sgPSBjYy5sZW5ndGggPT09IGxlbmd0aCAmJiAvXlswLTlhLWZBLUZdKyQvLnRlc3QoY2MpO1xuICAgIGNvbnN0IGNvZGUgPSBvayA/IHBhcnNlSW50KGNjLCAxNikgOiBOYU47XG4gICAgaWYgKGlzTmFOKGNvZGUpKSB7XG4gICAgICAgIGNvbnN0IHJhdyA9IHNvdXJjZS5zdWJzdHIob2Zmc2V0IC0gMiwgbGVuZ3RoICsgMik7XG4gICAgICAgIG9uRXJyb3Iob2Zmc2V0IC0gMiwgJ0JBRF9EUV9FU0NBUEUnLCBgSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UgJHtyYXd9YCk7XG4gICAgICAgIHJldHVybiByYXc7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlKTtcbn1cblxuZXhwb3J0cy5yZXNvbHZlRmxvd1NjYWxhciA9IHJlc29sdmVGbG93U2NhbGFyO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4uL25vZGVzL2lkZW50aXR5LmpzJyk7XG52YXIgU2NhbGFyID0gcmVxdWlyZSgnLi4vbm9kZXMvU2NhbGFyLmpzJyk7XG52YXIgcmVzb2x2ZUJsb2NrU2NhbGFyID0gcmVxdWlyZSgnLi9yZXNvbHZlLWJsb2NrLXNjYWxhci5qcycpO1xudmFyIHJlc29sdmVGbG93U2NhbGFyID0gcmVxdWlyZSgnLi9yZXNvbHZlLWZsb3ctc2NhbGFyLmpzJyk7XG5cbmZ1bmN0aW9uIGNvbXBvc2VTY2FsYXIoY3R4LCB0b2tlbiwgdGFnVG9rZW4sIG9uRXJyb3IpIHtcbiAgICBjb25zdCB7IHZhbHVlLCB0eXBlLCBjb21tZW50LCByYW5nZSB9ID0gdG9rZW4udHlwZSA9PT0gJ2Jsb2NrLXNjYWxhcidcbiAgICAgICAgPyByZXNvbHZlQmxvY2tTY2FsYXIucmVzb2x2ZUJsb2NrU2NhbGFyKGN0eCwgdG9rZW4sIG9uRXJyb3IpXG4gICAgICAgIDogcmVzb2x2ZUZsb3dTY2FsYXIucmVzb2x2ZUZsb3dTY2FsYXIodG9rZW4sIGN0eC5vcHRpb25zLnN0cmljdCwgb25FcnJvcik7XG4gICAgY29uc3QgdGFnTmFtZSA9IHRhZ1Rva2VuXG4gICAgICAgID8gY3R4LmRpcmVjdGl2ZXMudGFnTmFtZSh0YWdUb2tlbi5zb3VyY2UsIG1zZyA9PiBvbkVycm9yKHRhZ1Rva2VuLCAnVEFHX1JFU09MVkVfRkFJTEVEJywgbXNnKSlcbiAgICAgICAgOiBudWxsO1xuICAgIGxldCB0YWc7XG4gICAgaWYgKGN0eC5vcHRpb25zLnN0cmluZ0tleXMgJiYgY3R4LmF0S2V5KSB7XG4gICAgICAgIHRhZyA9IGN0eC5zY2hlbWFbaWRlbnRpdHkuU0NBTEFSXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGFnTmFtZSlcbiAgICAgICAgdGFnID0gZmluZFNjYWxhclRhZ0J5TmFtZShjdHguc2NoZW1hLCB2YWx1ZSwgdGFnTmFtZSwgdGFnVG9rZW4sIG9uRXJyb3IpO1xuICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09ICdzY2FsYXInKVxuICAgICAgICB0YWcgPSBmaW5kU2NhbGFyVGFnQnlUZXN0KGN0eCwgdmFsdWUsIHRva2VuLCBvbkVycm9yKTtcbiAgICBlbHNlXG4gICAgICAgIHRhZyA9IGN0eC5zY2hlbWFbaWRlbnRpdHkuU0NBTEFSXTtcbiAgICBsZXQgc2NhbGFyO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHRhZy5yZXNvbHZlKHZhbHVlLCBtc2cgPT4gb25FcnJvcih0YWdUb2tlbiA/PyB0b2tlbiwgJ1RBR19SRVNPTFZFX0ZBSUxFRCcsIG1zZyksIGN0eC5vcHRpb25zKTtcbiAgICAgICAgc2NhbGFyID0gaWRlbnRpdHkuaXNTY2FsYXIocmVzKSA/IHJlcyA6IG5ldyBTY2FsYXIuU2NhbGFyKHJlcyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBtc2cgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICAgIG9uRXJyb3IodGFnVG9rZW4gPz8gdG9rZW4sICdUQUdfUkVTT0xWRV9GQUlMRUQnLCBtc2cpO1xuICAgICAgICBzY2FsYXIgPSBuZXcgU2NhbGFyLlNjYWxhcih2YWx1ZSk7XG4gICAgfVxuICAgIHNjYWxhci5yYW5nZSA9IHJhbmdlO1xuICAgIHNjYWxhci5zb3VyY2UgPSB2YWx1ZTtcbiAgICBpZiAodHlwZSlcbiAgICAgICAgc2NhbGFyLnR5cGUgPSB0eXBlO1xuICAgIGlmICh0YWdOYW1lKVxuICAgICAgICBzY2FsYXIudGFnID0gdGFnTmFtZTtcbiAgICBpZiAodGFnLmZvcm1hdClcbiAgICAgICAgc2NhbGFyLmZvcm1hdCA9IHRhZy5mb3JtYXQ7XG4gICAgaWYgKGNvbW1lbnQpXG4gICAgICAgIHNjYWxhci5jb21tZW50ID0gY29tbWVudDtcbiAgICByZXR1cm4gc2NhbGFyO1xufVxuZnVuY3Rpb24gZmluZFNjYWxhclRhZ0J5TmFtZShzY2hlbWEsIHZhbHVlLCB0YWdOYW1lLCB0YWdUb2tlbiwgb25FcnJvcikge1xuICAgIGlmICh0YWdOYW1lID09PSAnIScpXG4gICAgICAgIHJldHVybiBzY2hlbWFbaWRlbnRpdHkuU0NBTEFSXTsgLy8gbm9uLXNwZWNpZmljIHRhZ1xuICAgIGNvbnN0IG1hdGNoV2l0aFRlc3QgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHRhZyBvZiBzY2hlbWEudGFncykge1xuICAgICAgICBpZiAoIXRhZy5jb2xsZWN0aW9uICYmIHRhZy50YWcgPT09IHRhZ05hbWUpIHtcbiAgICAgICAgICAgIGlmICh0YWcuZGVmYXVsdCAmJiB0YWcudGVzdClcbiAgICAgICAgICAgICAgICBtYXRjaFdpdGhUZXN0LnB1c2godGFnKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgdGFnIG9mIG1hdGNoV2l0aFRlc3QpXG4gICAgICAgIGlmICh0YWcudGVzdD8udGVzdCh2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gdGFnO1xuICAgIGNvbnN0IGt0ID0gc2NoZW1hLmtub3duVGFnc1t0YWdOYW1lXTtcbiAgICBpZiAoa3QgJiYgIWt0LmNvbGxlY3Rpb24pIHtcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGtub3duIHRhZyBpcyBhdmFpbGFibGUgZm9yIHN0cmluZ2lmeWluZyxcbiAgICAgICAgLy8gYnV0IGRvZXMgbm90IGdldCB1c2VkIGJ5IGRlZmF1bHQuXG4gICAgICAgIHNjaGVtYS50YWdzLnB1c2goT2JqZWN0LmFzc2lnbih7fSwga3QsIHsgZGVmYXVsdDogZmFsc2UsIHRlc3Q6IHVuZGVmaW5lZCB9KSk7XG4gICAgICAgIHJldHVybiBrdDtcbiAgICB9XG4gICAgb25FcnJvcih0YWdUb2tlbiwgJ1RBR19SRVNPTFZFX0ZBSUxFRCcsIGBVbnJlc29sdmVkIHRhZzogJHt0YWdOYW1lfWAsIHRhZ05hbWUgIT09ICd0YWc6eWFtbC5vcmcsMjAwMjpzdHInKTtcbiAgICByZXR1cm4gc2NoZW1hW2lkZW50aXR5LlNDQUxBUl07XG59XG5mdW5jdGlvbiBmaW5kU2NhbGFyVGFnQnlUZXN0KHsgYXRLZXksIGRpcmVjdGl2ZXMsIHNjaGVtYSB9LCB2YWx1ZSwgdG9rZW4sIG9uRXJyb3IpIHtcbiAgICBjb25zdCB0YWcgPSBzY2hlbWEudGFncy5maW5kKHRhZyA9PiAodGFnLmRlZmF1bHQgPT09IHRydWUgfHwgKGF0S2V5ICYmIHRhZy5kZWZhdWx0ID09PSAna2V5JykpICYmXG4gICAgICAgIHRhZy50ZXN0Py50ZXN0KHZhbHVlKSkgfHwgc2NoZW1hW2lkZW50aXR5LlNDQUxBUl07XG4gICAgaWYgKHNjaGVtYS5jb21wYXQpIHtcbiAgICAgICAgY29uc3QgY29tcGF0ID0gc2NoZW1hLmNvbXBhdC5maW5kKHRhZyA9PiB0YWcuZGVmYXVsdCAmJiB0YWcudGVzdD8udGVzdCh2YWx1ZSkpID8/XG4gICAgICAgICAgICBzY2hlbWFbaWRlbnRpdHkuU0NBTEFSXTtcbiAgICAgICAgaWYgKHRhZy50YWcgIT09IGNvbXBhdC50YWcpIHtcbiAgICAgICAgICAgIGNvbnN0IHRzID0gZGlyZWN0aXZlcy50YWdTdHJpbmcodGFnLnRhZyk7XG4gICAgICAgICAgICBjb25zdCBjcyA9IGRpcmVjdGl2ZXMudGFnU3RyaW5nKGNvbXBhdC50YWcpO1xuICAgICAgICAgICAgY29uc3QgbXNnID0gYFZhbHVlIG1heSBiZSBwYXJzZWQgYXMgZWl0aGVyICR7dHN9IG9yICR7Y3N9YDtcbiAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdUQUdfUkVTT0xWRV9GQUlMRUQnLCBtc2csIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YWc7XG59XG5cbmV4cG9ydHMuY29tcG9zZVNjYWxhciA9IGNvbXBvc2VTY2FsYXI7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZW1wdHlTY2FsYXJQb3NpdGlvbihvZmZzZXQsIGJlZm9yZSwgcG9zKSB7XG4gICAgaWYgKGJlZm9yZSkge1xuICAgICAgICBwb3MgPz8gKHBvcyA9IGJlZm9yZS5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIGxldCBzdCA9IGJlZm9yZVtpXTtcbiAgICAgICAgICAgIHN3aXRjaCAoc3QudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0IC09IHN0LnNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGVjaG5pY2FsbHksIGFuIGVtcHR5IHNjYWxhciBpcyBpbW1lZGlhdGVseSBhZnRlciB0aGUgbGFzdCBub24tZW1wdHlcbiAgICAgICAgICAgIC8vIG5vZGUsIGJ1dCBpdCdzIG1vcmUgdXNlZnVsIHRvIHBsYWNlIGl0IGFmdGVyIGFueSB3aGl0ZXNwYWNlLlxuICAgICAgICAgICAgc3QgPSBiZWZvcmVbKytpXTtcbiAgICAgICAgICAgIHdoaWxlIChzdD8udHlwZSA9PT0gJ3NwYWNlJykge1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBzdC5zb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHN0ID0gYmVmb3JlWysraV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0O1xufVxuXG5leHBvcnRzLmVtcHR5U2NhbGFyUG9zaXRpb24gPSBlbXB0eVNjYWxhclBvc2l0aW9uO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBBbGlhcyA9IHJlcXVpcmUoJy4uL25vZGVzL0FsaWFzLmpzJyk7XG52YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuLi9ub2Rlcy9pZGVudGl0eS5qcycpO1xudmFyIGNvbXBvc2VDb2xsZWN0aW9uID0gcmVxdWlyZSgnLi9jb21wb3NlLWNvbGxlY3Rpb24uanMnKTtcbnZhciBjb21wb3NlU2NhbGFyID0gcmVxdWlyZSgnLi9jb21wb3NlLXNjYWxhci5qcycpO1xudmFyIHJlc29sdmVFbmQgPSByZXF1aXJlKCcuL3Jlc29sdmUtZW5kLmpzJyk7XG52YXIgdXRpbEVtcHR5U2NhbGFyUG9zaXRpb24gPSByZXF1aXJlKCcuL3V0aWwtZW1wdHktc2NhbGFyLXBvc2l0aW9uLmpzJyk7XG5cbmNvbnN0IENOID0geyBjb21wb3NlTm9kZSwgY29tcG9zZUVtcHR5Tm9kZSB9O1xuZnVuY3Rpb24gY29tcG9zZU5vZGUoY3R4LCB0b2tlbiwgcHJvcHMsIG9uRXJyb3IpIHtcbiAgICBjb25zdCBhdEtleSA9IGN0eC5hdEtleTtcbiAgICBjb25zdCB7IHNwYWNlQmVmb3JlLCBjb21tZW50LCBhbmNob3IsIHRhZyB9ID0gcHJvcHM7XG4gICAgbGV0IG5vZGU7XG4gICAgbGV0IGlzU3JjVG9rZW4gPSB0cnVlO1xuICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICBjYXNlICdhbGlhcyc6XG4gICAgICAgICAgICBub2RlID0gY29tcG9zZUFsaWFzKGN0eCwgdG9rZW4sIG9uRXJyb3IpO1xuICAgICAgICAgICAgaWYgKGFuY2hvciB8fCB0YWcpXG4gICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ0FMSUFTX1BST1BTJywgJ0FuIGFsaWFzIG5vZGUgbXVzdCBub3Qgc3BlY2lmeSBhbnkgcHJvcGVydGllcycpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgY2FzZSAnZG91YmxlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICBjYXNlICdibG9jay1zY2FsYXInOlxuICAgICAgICAgICAgbm9kZSA9IGNvbXBvc2VTY2FsYXIuY29tcG9zZVNjYWxhcihjdHgsIHRva2VuLCB0YWcsIG9uRXJyb3IpO1xuICAgICAgICAgICAgaWYgKGFuY2hvcilcbiAgICAgICAgICAgICAgICBub2RlLmFuY2hvciA9IGFuY2hvci5zb3VyY2Uuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Jsb2NrLW1hcCc6XG4gICAgICAgIGNhc2UgJ2Jsb2NrLXNlcSc6XG4gICAgICAgIGNhc2UgJ2Zsb3ctY29sbGVjdGlvbic6XG4gICAgICAgICAgICBub2RlID0gY29tcG9zZUNvbGxlY3Rpb24uY29tcG9zZUNvbGxlY3Rpb24oQ04sIGN0eCwgdG9rZW4sIHByb3BzLCBvbkVycm9yKTtcbiAgICAgICAgICAgIGlmIChhbmNob3IpXG4gICAgICAgICAgICAgICAgbm9kZS5hbmNob3IgPSBhbmNob3Iuc291cmNlLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gdG9rZW4udHlwZSA9PT0gJ2Vycm9yJ1xuICAgICAgICAgICAgICAgID8gdG9rZW4ubWVzc2FnZVxuICAgICAgICAgICAgICAgIDogYFVuc3VwcG9ydGVkIHRva2VuICh0eXBlOiAke3Rva2VuLnR5cGV9KWA7XG4gICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnVU5FWFBFQ1RFRF9UT0tFTicsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgbm9kZSA9IGNvbXBvc2VFbXB0eU5vZGUoY3R4LCB0b2tlbi5vZmZzZXQsIHVuZGVmaW5lZCwgbnVsbCwgcHJvcHMsIG9uRXJyb3IpO1xuICAgICAgICAgICAgaXNTcmNUb2tlbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhbmNob3IgJiYgbm9kZS5hbmNob3IgPT09ICcnKVxuICAgICAgICBvbkVycm9yKGFuY2hvciwgJ0JBRF9BTElBUycsICdBbmNob3IgY2Fubm90IGJlIGFuIGVtcHR5IHN0cmluZycpO1xuICAgIGlmIChhdEtleSAmJlxuICAgICAgICBjdHgub3B0aW9ucy5zdHJpbmdLZXlzICYmXG4gICAgICAgICghaWRlbnRpdHkuaXNTY2FsYXIobm9kZSkgfHxcbiAgICAgICAgICAgIHR5cGVvZiBub2RlLnZhbHVlICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgKG5vZGUudGFnICYmIG5vZGUudGFnICE9PSAndGFnOnlhbWwub3JnLDIwMDI6c3RyJykpKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9ICdXaXRoIHN0cmluZ0tleXMsIGFsbCBrZXlzIG11c3QgYmUgc3RyaW5ncyc7XG4gICAgICAgIG9uRXJyb3IodGFnID8/IHRva2VuLCAnTk9OX1NUUklOR19LRVknLCBtc2cpO1xuICAgIH1cbiAgICBpZiAoc3BhY2VCZWZvcmUpXG4gICAgICAgIG5vZGUuc3BhY2VCZWZvcmUgPSB0cnVlO1xuICAgIGlmIChjb21tZW50KSB7XG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnc2NhbGFyJyAmJiB0b2tlbi5zb3VyY2UgPT09ICcnKVxuICAgICAgICAgICAgbm9kZS5jb21tZW50ID0gY29tbWVudDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbm9kZS5jb21tZW50QmVmb3JlID0gY29tbWVudDtcbiAgICB9XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUeXBlIGNoZWNraW5nIG1pc3NlcyBtZWFuaW5nIG9mIGlzU3JjVG9rZW5cbiAgICBpZiAoY3R4Lm9wdGlvbnMua2VlcFNvdXJjZVRva2VucyAmJiBpc1NyY1Rva2VuKVxuICAgICAgICBub2RlLnNyY1Rva2VuID0gdG9rZW47XG4gICAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBjb21wb3NlRW1wdHlOb2RlKGN0eCwgb2Zmc2V0LCBiZWZvcmUsIHBvcywgeyBzcGFjZUJlZm9yZSwgY29tbWVudCwgYW5jaG9yLCB0YWcsIGVuZCB9LCBvbkVycm9yKSB7XG4gICAgY29uc3QgdG9rZW4gPSB7XG4gICAgICAgIHR5cGU6ICdzY2FsYXInLFxuICAgICAgICBvZmZzZXQ6IHV0aWxFbXB0eVNjYWxhclBvc2l0aW9uLmVtcHR5U2NhbGFyUG9zaXRpb24ob2Zmc2V0LCBiZWZvcmUsIHBvcyksXG4gICAgICAgIGluZGVudDogLTEsXG4gICAgICAgIHNvdXJjZTogJydcbiAgICB9O1xuICAgIGNvbnN0IG5vZGUgPSBjb21wb3NlU2NhbGFyLmNvbXBvc2VTY2FsYXIoY3R4LCB0b2tlbiwgdGFnLCBvbkVycm9yKTtcbiAgICBpZiAoYW5jaG9yKSB7XG4gICAgICAgIG5vZGUuYW5jaG9yID0gYW5jaG9yLnNvdXJjZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIGlmIChub2RlLmFuY2hvciA9PT0gJycpXG4gICAgICAgICAgICBvbkVycm9yKGFuY2hvciwgJ0JBRF9BTElBUycsICdBbmNob3IgY2Fubm90IGJlIGFuIGVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAoc3BhY2VCZWZvcmUpXG4gICAgICAgIG5vZGUuc3BhY2VCZWZvcmUgPSB0cnVlO1xuICAgIGlmIChjb21tZW50KSB7XG4gICAgICAgIG5vZGUuY29tbWVudCA9IGNvbW1lbnQ7XG4gICAgICAgIG5vZGUucmFuZ2VbMl0gPSBlbmQ7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gY29tcG9zZUFsaWFzKHsgb3B0aW9ucyB9LCB7IG9mZnNldCwgc291cmNlLCBlbmQgfSwgb25FcnJvcikge1xuICAgIGNvbnN0IGFsaWFzID0gbmV3IEFsaWFzLkFsaWFzKHNvdXJjZS5zdWJzdHJpbmcoMSkpO1xuICAgIGlmIChhbGlhcy5zb3VyY2UgPT09ICcnKVxuICAgICAgICBvbkVycm9yKG9mZnNldCwgJ0JBRF9BTElBUycsICdBbGlhcyBjYW5ub3QgYmUgYW4gZW1wdHkgc3RyaW5nJyk7XG4gICAgaWYgKGFsaWFzLnNvdXJjZS5lbmRzV2l0aCgnOicpKVxuICAgICAgICBvbkVycm9yKG9mZnNldCArIHNvdXJjZS5sZW5ndGggLSAxLCAnQkFEX0FMSUFTJywgJ0FsaWFzIGVuZGluZyBpbiA6IGlzIGFtYmlndW91cycsIHRydWUpO1xuICAgIGNvbnN0IHZhbHVlRW5kID0gb2Zmc2V0ICsgc291cmNlLmxlbmd0aDtcbiAgICBjb25zdCByZSA9IHJlc29sdmVFbmQucmVzb2x2ZUVuZChlbmQsIHZhbHVlRW5kLCBvcHRpb25zLnN0cmljdCwgb25FcnJvcik7XG4gICAgYWxpYXMucmFuZ2UgPSBbb2Zmc2V0LCB2YWx1ZUVuZCwgcmUub2Zmc2V0XTtcbiAgICBpZiAocmUuY29tbWVudClcbiAgICAgICAgYWxpYXMuY29tbWVudCA9IHJlLmNvbW1lbnQ7XG4gICAgcmV0dXJuIGFsaWFzO1xufVxuXG5leHBvcnRzLmNvbXBvc2VFbXB0eU5vZGUgPSBjb21wb3NlRW1wdHlOb2RlO1xuZXhwb3J0cy5jb21wb3NlTm9kZSA9IGNvbXBvc2VOb2RlO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBEb2N1bWVudCA9IHJlcXVpcmUoJy4uL2RvYy9Eb2N1bWVudC5qcycpO1xudmFyIGNvbXBvc2VOb2RlID0gcmVxdWlyZSgnLi9jb21wb3NlLW5vZGUuanMnKTtcbnZhciByZXNvbHZlRW5kID0gcmVxdWlyZSgnLi9yZXNvbHZlLWVuZC5qcycpO1xudmFyIHJlc29sdmVQcm9wcyA9IHJlcXVpcmUoJy4vcmVzb2x2ZS1wcm9wcy5qcycpO1xuXG5mdW5jdGlvbiBjb21wb3NlRG9jKG9wdGlvbnMsIGRpcmVjdGl2ZXMsIHsgb2Zmc2V0LCBzdGFydCwgdmFsdWUsIGVuZCB9LCBvbkVycm9yKSB7XG4gICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyBfZGlyZWN0aXZlczogZGlyZWN0aXZlcyB9LCBvcHRpb25zKTtcbiAgICBjb25zdCBkb2MgPSBuZXcgRG9jdW1lbnQuRG9jdW1lbnQodW5kZWZpbmVkLCBvcHRzKTtcbiAgICBjb25zdCBjdHggPSB7XG4gICAgICAgIGF0S2V5OiBmYWxzZSxcbiAgICAgICAgYXRSb290OiB0cnVlLFxuICAgICAgICBkaXJlY3RpdmVzOiBkb2MuZGlyZWN0aXZlcyxcbiAgICAgICAgb3B0aW9uczogZG9jLm9wdGlvbnMsXG4gICAgICAgIHNjaGVtYTogZG9jLnNjaGVtYVxuICAgIH07XG4gICAgY29uc3QgcHJvcHMgPSByZXNvbHZlUHJvcHMucmVzb2x2ZVByb3BzKHN0YXJ0LCB7XG4gICAgICAgIGluZGljYXRvcjogJ2RvYy1zdGFydCcsXG4gICAgICAgIG5leHQ6IHZhbHVlID8/IGVuZD8uWzBdLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIG9uRXJyb3IsXG4gICAgICAgIHBhcmVudEluZGVudDogMCxcbiAgICAgICAgc3RhcnRPbk5ld2xpbmU6IHRydWVcbiAgICB9KTtcbiAgICBpZiAocHJvcHMuZm91bmQpIHtcbiAgICAgICAgZG9jLmRpcmVjdGl2ZXMuZG9jU3RhcnQgPSB0cnVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgICh2YWx1ZS50eXBlID09PSAnYmxvY2stbWFwJyB8fCB2YWx1ZS50eXBlID09PSAnYmxvY2stc2VxJykgJiZcbiAgICAgICAgICAgICFwcm9wcy5oYXNOZXdsaW5lKVxuICAgICAgICAgICAgb25FcnJvcihwcm9wcy5lbmQsICdNSVNTSU5HX0NIQVInLCAnQmxvY2sgY29sbGVjdGlvbiBjYW5ub3Qgc3RhcnQgb24gc2FtZSBsaW5lIHdpdGggZGlyZWN0aXZlcy1lbmQgbWFya2VyJyk7XG4gICAgfVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgSWYgQ29udGVudHMgaXMgc2V0LCBsZXQncyB0cnVzdCB0aGUgdXNlclxuICAgIGRvYy5jb250ZW50cyA9IHZhbHVlXG4gICAgICAgID8gY29tcG9zZU5vZGUuY29tcG9zZU5vZGUoY3R4LCB2YWx1ZSwgcHJvcHMsIG9uRXJyb3IpXG4gICAgICAgIDogY29tcG9zZU5vZGUuY29tcG9zZUVtcHR5Tm9kZShjdHgsIHByb3BzLmVuZCwgc3RhcnQsIG51bGwsIHByb3BzLCBvbkVycm9yKTtcbiAgICBjb25zdCBjb250ZW50RW5kID0gZG9jLmNvbnRlbnRzLnJhbmdlWzJdO1xuICAgIGNvbnN0IHJlID0gcmVzb2x2ZUVuZC5yZXNvbHZlRW5kKGVuZCwgY29udGVudEVuZCwgZmFsc2UsIG9uRXJyb3IpO1xuICAgIGlmIChyZS5jb21tZW50KVxuICAgICAgICBkb2MuY29tbWVudCA9IHJlLmNvbW1lbnQ7XG4gICAgZG9jLnJhbmdlID0gW29mZnNldCwgY29udGVudEVuZCwgcmUub2Zmc2V0XTtcbiAgICByZXR1cm4gZG9jO1xufVxuXG5leHBvcnRzLmNvbXBvc2VEb2MgPSBjb21wb3NlRG9jO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBub2RlX3Byb2Nlc3MgPSByZXF1aXJlKCdwcm9jZXNzJyk7XG52YXIgZGlyZWN0aXZlcyA9IHJlcXVpcmUoJy4uL2RvYy9kaXJlY3RpdmVzLmpzJyk7XG52YXIgRG9jdW1lbnQgPSByZXF1aXJlKCcuLi9kb2MvRG9jdW1lbnQuanMnKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMuanMnKTtcbnZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4uL25vZGVzL2lkZW50aXR5LmpzJyk7XG52YXIgY29tcG9zZURvYyA9IHJlcXVpcmUoJy4vY29tcG9zZS1kb2MuanMnKTtcbnZhciByZXNvbHZlRW5kID0gcmVxdWlyZSgnLi9yZXNvbHZlLWVuZC5qcycpO1xuXG5mdW5jdGlvbiBnZXRFcnJvclBvcyhzcmMpIHtcbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ251bWJlcicpXG4gICAgICAgIHJldHVybiBbc3JjLCBzcmMgKyAxXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzcmMpKVxuICAgICAgICByZXR1cm4gc3JjLmxlbmd0aCA9PT0gMiA/IHNyYyA6IFtzcmNbMF0sIHNyY1sxXV07XG4gICAgY29uc3QgeyBvZmZzZXQsIHNvdXJjZSB9ID0gc3JjO1xuICAgIHJldHVybiBbb2Zmc2V0LCBvZmZzZXQgKyAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgPyBzb3VyY2UubGVuZ3RoIDogMSldO1xufVxuZnVuY3Rpb24gcGFyc2VQcmVsdWRlKHByZWx1ZGUpIHtcbiAgICBsZXQgY29tbWVudCA9ICcnO1xuICAgIGxldCBhdENvbW1lbnQgPSBmYWxzZTtcbiAgICBsZXQgYWZ0ZXJFbXB0eUxpbmUgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZWx1ZGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3Qgc291cmNlID0gcHJlbHVkZVtpXTtcbiAgICAgICAgc3dpdGNoIChzb3VyY2VbMF0pIHtcbiAgICAgICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgICAgICAgIGNvbW1lbnQgKz1cbiAgICAgICAgICAgICAgICAgICAgKGNvbW1lbnQgPT09ICcnID8gJycgOiBhZnRlckVtcHR5TGluZSA/ICdcXG5cXG4nIDogJ1xcbicpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzb3VyY2Uuc3Vic3RyaW5nKDEpIHx8ICcgJyk7XG4gICAgICAgICAgICAgICAgYXRDb21tZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhZnRlckVtcHR5TGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICAgICAgaWYgKHByZWx1ZGVbaSArIDFdPy5bMF0gIT09ICcjJylcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgIGF0Q29tbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG1heSBiZSB3cm9uZyBhZnRlciBkb2MtZW5kLCBidXQgaW4gdGhhdCBjYXNlIGl0IGRvZXNuJ3QgbWF0dGVyXG4gICAgICAgICAgICAgICAgaWYgKCFhdENvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyRW1wdHlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhdENvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBjb21tZW50LCBhZnRlckVtcHR5TGluZSB9O1xufVxuLyoqXG4gKiBDb21wb3NlIGEgc3RyZWFtIG9mIENTVCBub2RlcyBpbnRvIGEgc3RyZWFtIG9mIFlBTUwgRG9jdW1lbnRzLlxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBDb21wb3NlciwgUGFyc2VyIH0gZnJvbSAneWFtbCdcbiAqXG4gKiBjb25zdCBzcmM6IHN0cmluZyA9IC4uLlxuICogY29uc3QgdG9rZW5zID0gbmV3IFBhcnNlcigpLnBhcnNlKHNyYylcbiAqIGNvbnN0IGRvY3MgPSBuZXcgQ29tcG9zZXIoKS5jb21wb3NlKHRva2VucylcbiAqIGBgYFxuICovXG5jbGFzcyBDb21wb3NlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuZG9jID0gbnVsbDtcbiAgICAgICAgdGhpcy5hdERpcmVjdGl2ZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcmVsdWRlID0gW107XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICAgIHRoaXMud2FybmluZ3MgPSBbXTtcbiAgICAgICAgdGhpcy5vbkVycm9yID0gKHNvdXJjZSwgY29kZSwgbWVzc2FnZSwgd2FybmluZykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcG9zID0gZ2V0RXJyb3JQb3Moc291cmNlKTtcbiAgICAgICAgICAgIGlmICh3YXJuaW5nKVxuICAgICAgICAgICAgICAgIHRoaXMud2FybmluZ3MucHVzaChuZXcgZXJyb3JzLllBTUxXYXJuaW5nKHBvcywgY29kZSwgbWVzc2FnZSkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IGVycm9ycy5ZQU1MUGFyc2VFcnJvcihwb3MsIGNvZGUsIG1lc3NhZ2UpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItbnVsbGlzaC1jb2FsZXNjaW5nXG4gICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IG5ldyBkaXJlY3RpdmVzLkRpcmVjdGl2ZXMoeyB2ZXJzaW9uOiBvcHRpb25zLnZlcnNpb24gfHwgJzEuMicgfSk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIGRlY29yYXRlKGRvYywgYWZ0ZXJEb2MpIHtcbiAgICAgICAgY29uc3QgeyBjb21tZW50LCBhZnRlckVtcHR5TGluZSB9ID0gcGFyc2VQcmVsdWRlKHRoaXMucHJlbHVkZSk7XG4gICAgICAgIC8vY29uc29sZS5sb2coeyBkYzogZG9jLmNvbW1lbnQsIHByZWx1ZGUsIGNvbW1lbnQgfSlcbiAgICAgICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRjID0gZG9jLmNvbnRlbnRzO1xuICAgICAgICAgICAgaWYgKGFmdGVyRG9jKSB7XG4gICAgICAgICAgICAgICAgZG9jLmNvbW1lbnQgPSBkb2MuY29tbWVudCA/IGAke2RvYy5jb21tZW50fVxcbiR7Y29tbWVudH1gIDogY29tbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFmdGVyRW1wdHlMaW5lIHx8IGRvYy5kaXJlY3RpdmVzLmRvY1N0YXJ0IHx8ICFkYykge1xuICAgICAgICAgICAgICAgIGRvYy5jb21tZW50QmVmb3JlID0gY29tbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlkZW50aXR5LmlzQ29sbGVjdGlvbihkYykgJiYgIWRjLmZsb3cgJiYgZGMuaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBpdCA9IGRjLml0ZW1zWzBdO1xuICAgICAgICAgICAgICAgIGlmIChpZGVudGl0eS5pc1BhaXIoaXQpKVxuICAgICAgICAgICAgICAgICAgICBpdCA9IGl0LmtleTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYiA9IGl0LmNvbW1lbnRCZWZvcmU7XG4gICAgICAgICAgICAgICAgaXQuY29tbWVudEJlZm9yZSA9IGNiID8gYCR7Y29tbWVudH1cXG4ke2NifWAgOiBjb21tZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2IgPSBkYy5jb21tZW50QmVmb3JlO1xuICAgICAgICAgICAgICAgIGRjLmNvbW1lbnRCZWZvcmUgPSBjYiA/IGAke2NvbW1lbnR9XFxuJHtjYn1gIDogY29tbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWZ0ZXJEb2MpIHtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGRvYy5lcnJvcnMsIHRoaXMuZXJyb3JzKTtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGRvYy53YXJuaW5ncywgdGhpcy53YXJuaW5ncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkb2MuZXJyb3JzID0gdGhpcy5lcnJvcnM7XG4gICAgICAgICAgICBkb2Mud2FybmluZ3MgPSB0aGlzLndhcm5pbmdzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlbHVkZSA9IFtdO1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLndhcm5pbmdzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgc3RyZWFtIHN0YXR1cyBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIE1vc3RseSB1c2VmdWwgYXQgdGhlIGVuZCBvZiBpbnB1dCBmb3IgYW4gZW1wdHkgc3RyZWFtLlxuICAgICAqL1xuICAgIHN0cmVhbUluZm8oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb21tZW50OiBwYXJzZVByZWx1ZGUodGhpcy5wcmVsdWRlKS5jb21tZW50LFxuICAgICAgICAgICAgZGlyZWN0aXZlczogdGhpcy5kaXJlY3RpdmVzLFxuICAgICAgICAgICAgZXJyb3JzOiB0aGlzLmVycm9ycyxcbiAgICAgICAgICAgIHdhcm5pbmdzOiB0aGlzLndhcm5pbmdzXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXBvc2UgdG9rZW5zIGludG8gZG9jdW1lbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZvcmNlRG9jIC0gSWYgdGhlIHN0cmVhbSBjb250YWlucyBubyBkb2N1bWVudCwgc3RpbGwgZW1pdCBhIGZpbmFsIGRvY3VtZW50IGluY2x1ZGluZyBhbnkgY29tbWVudHMgYW5kIGRpcmVjdGl2ZXMgdGhhdCB3b3VsZCBiZSBhcHBsaWVkIHRvIGEgc3Vic2VxdWVudCBkb2N1bWVudC5cbiAgICAgKiBAcGFyYW0gZW5kT2Zmc2V0IC0gU2hvdWxkIGJlIHNldCBpZiBgZm9yY2VEb2NgIGlzIGFsc28gc2V0LCB0byBzZXQgdGhlIGRvY3VtZW50IHJhbmdlIGVuZCBhbmQgdG8gaW5kaWNhdGUgZXJyb3JzIGNvcnJlY3RseS5cbiAgICAgKi9cbiAgICAqY29tcG9zZSh0b2tlbnMsIGZvcmNlRG9jID0gZmFsc2UsIGVuZE9mZnNldCA9IC0xKSB7XG4gICAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zKVxuICAgICAgICAgICAgeWllbGQqIHRoaXMubmV4dCh0b2tlbik7XG4gICAgICAgIHlpZWxkKiB0aGlzLmVuZChmb3JjZURvYywgZW5kT2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqIEFkdmFuY2UgdGhlIGNvbXBvc2VyIGJ5IG9uZSBDU1QgdG9rZW4uICovXG4gICAgKm5leHQodG9rZW4pIHtcbiAgICAgICAgaWYgKG5vZGVfcHJvY2Vzcy5lbnYuTE9HX1NUUkVBTSlcbiAgICAgICAgICAgIGNvbnNvbGUuZGlyKHRva2VuLCB7IGRlcHRoOiBudWxsIH0pO1xuICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RpcmVjdGl2ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzLmFkZCh0b2tlbi5zb3VyY2UsIChvZmZzZXQsIG1lc3NhZ2UsIHdhcm5pbmcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zID0gZ2V0RXJyb3JQb3ModG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBwb3NbMF0gKz0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IocG9zLCAnQkFEX0RJUkVDVElWRScsIG1lc3NhZ2UsIHdhcm5pbmcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucHJlbHVkZS5wdXNoKHRva2VuLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hdERpcmVjdGl2ZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZG9jdW1lbnQnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZG9jID0gY29tcG9zZURvYy5jb21wb3NlRG9jKHRoaXMub3B0aW9ucywgdGhpcy5kaXJlY3RpdmVzLCB0b2tlbiwgdGhpcy5vbkVycm9yKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdERpcmVjdGl2ZXMgJiYgIWRvYy5kaXJlY3RpdmVzLmRvY1N0YXJ0KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IodG9rZW4sICdNSVNTSU5HX0NIQVInLCAnTWlzc2luZyBkaXJlY3RpdmVzLWVuZC9kb2Mtc3RhcnQgaW5kaWNhdG9yIGxpbmUnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29yYXRlKGRvYywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRvYylcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5kb2M7XG4gICAgICAgICAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgICAgICAgICAgICAgdGhpcy5hdERpcmVjdGl2ZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2J5dGUtb3JkZXItbWFyayc6XG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIHRoaXMucHJlbHVkZS5wdXNoKHRva2VuLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdlcnJvcic6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSB0b2tlbi5zb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgPyBgJHt0b2tlbi5tZXNzYWdlfTogJHtKU09OLnN0cmluZ2lmeSh0b2tlbi5zb3VyY2UpfWBcbiAgICAgICAgICAgICAgICAgICAgOiB0b2tlbi5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IGVycm9ycy5ZQU1MUGFyc2VFcnJvcihnZXRFcnJvclBvcyh0b2tlbiksICdVTkVYUEVDVEVEX1RPS0VOJywgbXNnKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdERpcmVjdGl2ZXMgfHwgIXRoaXMuZG9jKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jLmVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2RvYy1lbmQnOiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRvYykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSAnVW5leHBlY3RlZCBkb2MtZW5kIHdpdGhvdXQgcHJlY2VkaW5nIGRvY3VtZW50JztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgZXJyb3JzLllBTUxQYXJzZUVycm9yKGdldEVycm9yUG9zKHRva2VuKSwgJ1VORVhQRUNURURfVE9LRU4nLCBtc2cpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZG9jLmRpcmVjdGl2ZXMuZG9jRW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSByZXNvbHZlRW5kLnJlc29sdmVFbmQodG9rZW4uZW5kLCB0b2tlbi5vZmZzZXQgKyB0b2tlbi5zb3VyY2UubGVuZ3RoLCB0aGlzLmRvYy5vcHRpb25zLnN0cmljdCwgdGhpcy5vbkVycm9yKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29yYXRlKHRoaXMuZG9jLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGMgPSB0aGlzLmRvYy5jb21tZW50O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvYy5jb21tZW50ID0gZGMgPyBgJHtkY31cXG4ke2VuZC5jb21tZW50fWAgOiBlbmQuY29tbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5kb2MucmFuZ2VbMl0gPSBlbmQub2Zmc2V0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBlcnJvcnMuWUFNTFBhcnNlRXJyb3IoZ2V0RXJyb3JQb3ModG9rZW4pLCAnVU5FWFBFQ1RFRF9UT0tFTicsIGBVbnN1cHBvcnRlZCB0b2tlbiAke3Rva2VuLnR5cGV9YCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgYXQgZW5kIG9mIGlucHV0IHRvIHlpZWxkIGFueSByZW1haW5pbmcgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm9yY2VEb2MgLSBJZiB0aGUgc3RyZWFtIGNvbnRhaW5zIG5vIGRvY3VtZW50LCBzdGlsbCBlbWl0IGEgZmluYWwgZG9jdW1lbnQgaW5jbHVkaW5nIGFueSBjb21tZW50cyBhbmQgZGlyZWN0aXZlcyB0aGF0IHdvdWxkIGJlIGFwcGxpZWQgdG8gYSBzdWJzZXF1ZW50IGRvY3VtZW50LlxuICAgICAqIEBwYXJhbSBlbmRPZmZzZXQgLSBTaG91bGQgYmUgc2V0IGlmIGBmb3JjZURvY2AgaXMgYWxzbyBzZXQsIHRvIHNldCB0aGUgZG9jdW1lbnQgcmFuZ2UgZW5kIGFuZCB0byBpbmRpY2F0ZSBlcnJvcnMgY29ycmVjdGx5LlxuICAgICAqL1xuICAgICplbmQoZm9yY2VEb2MgPSBmYWxzZSwgZW5kT2Zmc2V0ID0gLTEpIHtcbiAgICAgICAgaWYgKHRoaXMuZG9jKSB7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRlKHRoaXMuZG9jLCB0cnVlKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZG9jO1xuICAgICAgICAgICAgdGhpcy5kb2MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZvcmNlRG9jKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7IF9kaXJlY3RpdmVzOiB0aGlzLmRpcmVjdGl2ZXMgfSwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGRvYyA9IG5ldyBEb2N1bWVudC5Eb2N1bWVudCh1bmRlZmluZWQsIG9wdHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXREaXJlY3RpdmVzKVxuICAgICAgICAgICAgICAgIHRoaXMub25FcnJvcihlbmRPZmZzZXQsICdNSVNTSU5HX0NIQVInLCAnTWlzc2luZyBkaXJlY3RpdmVzLWVuZCBpbmRpY2F0b3IgbGluZScpO1xuICAgICAgICAgICAgZG9jLnJhbmdlID0gWzAsIGVuZE9mZnNldCwgZW5kT2Zmc2V0XTtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGUoZG9jLCBmYWxzZSk7XG4gICAgICAgICAgICB5aWVsZCBkb2M7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydHMuQ29tcG9zZXIgPSBDb21wb3NlcjtcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVzb2x2ZUJsb2NrU2NhbGFyID0gcmVxdWlyZSgnLi4vY29tcG9zZS9yZXNvbHZlLWJsb2NrLXNjYWxhci5qcycpO1xudmFyIHJlc29sdmVGbG93U2NhbGFyID0gcmVxdWlyZSgnLi4vY29tcG9zZS9yZXNvbHZlLWZsb3ctc2NhbGFyLmpzJyk7XG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzLmpzJyk7XG52YXIgc3RyaW5naWZ5U3RyaW5nID0gcmVxdWlyZSgnLi4vc3RyaW5naWZ5L3N0cmluZ2lmeVN0cmluZy5qcycpO1xuXG5mdW5jdGlvbiByZXNvbHZlQXNTY2FsYXIodG9rZW4sIHN0cmljdCA9IHRydWUsIG9uRXJyb3IpIHtcbiAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgY29uc3QgX29uRXJyb3IgPSAocG9zLCBjb2RlLCBtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0eXBlb2YgcG9zID09PSAnbnVtYmVyJyA/IHBvcyA6IEFycmF5LmlzQXJyYXkocG9zKSA/IHBvc1swXSA6IHBvcy5vZmZzZXQ7XG4gICAgICAgICAgICBpZiAob25FcnJvcilcbiAgICAgICAgICAgICAgICBvbkVycm9yKG9mZnNldCwgY29kZSwgbWVzc2FnZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5ZQU1MUGFyc2VFcnJvcihbb2Zmc2V0LCBvZmZzZXQgKyAxXSwgY29kZSwgbWVzc2FnZSk7XG4gICAgICAgIH07XG4gICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgIGNhc2UgJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZUZsb3dTY2FsYXIucmVzb2x2ZUZsb3dTY2FsYXIodG9rZW4sIHN0cmljdCwgX29uRXJyb3IpO1xuICAgICAgICAgICAgY2FzZSAnYmxvY2stc2NhbGFyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZUJsb2NrU2NhbGFyLnJlc29sdmVCbG9ja1NjYWxhcih7IG9wdGlvbnM6IHsgc3RyaWN0IH0gfSwgdG9rZW4sIF9vbkVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHNjYWxhciB0b2tlbiB3aXRoIGB2YWx1ZWBcbiAqXG4gKiBWYWx1ZXMgdGhhdCByZXByZXNlbnQgYW4gYWN0dWFsIHN0cmluZyBidXQgbWF5IGJlIHBhcnNlZCBhcyBhIGRpZmZlcmVudCB0eXBlIHNob3VsZCB1c2UgYSBgdHlwZWAgb3RoZXIgdGhhbiBgJ1BMQUlOJ2AsXG4gKiBhcyB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IHN1cHBvcnQgYW55IHNjaGVtYSBvcGVyYXRpb25zIGFuZCB3b24ndCBjaGVjayBmb3Igc3VjaCBjb25mbGljdHMuXG4gKlxuICogQHBhcmFtIHZhbHVlIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZhbHVlLCB3aGljaCB3aWxsIGhhdmUgaXRzIGNvbnRlbnQgcHJvcGVybHkgaW5kZW50ZWQuXG4gKiBAcGFyYW0gY29udGV4dC5lbmQgQ29tbWVudHMgYW5kIHdoaXRlc3BhY2UgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgdmFsdWUsIG9yIGFmdGVyIHRoZSBibG9jayBzY2FsYXIgaGVhZGVyLiBJZiB1bmRlZmluZWQsIGEgbmV3bGluZSB3aWxsIGJlIGFkZGVkLlxuICogQHBhcmFtIGNvbnRleHQuaW1wbGljaXRLZXkgQmVpbmcgd2l0aGluIGFuIGltcGxpY2l0IGtleSBtYXkgYWZmZWN0IHRoZSByZXNvbHZlZCB0eXBlIG9mIHRoZSB0b2tlbidzIHZhbHVlLlxuICogQHBhcmFtIGNvbnRleHQuaW5kZW50IFRoZSBpbmRlbnQgbGV2ZWwgb2YgdGhlIHRva2VuLlxuICogQHBhcmFtIGNvbnRleHQuaW5GbG93IElzIHRoaXMgc2NhbGFyIHdpdGhpbiBhIGZsb3cgY29sbGVjdGlvbj8gVGhpcyBtYXkgYWZmZWN0IHRoZSByZXNvbHZlZCB0eXBlIG9mIHRoZSB0b2tlbidzIHZhbHVlLlxuICogQHBhcmFtIGNvbnRleHQub2Zmc2V0IFRoZSBvZmZzZXQgcG9zaXRpb24gb2YgdGhlIHRva2VuLlxuICogQHBhcmFtIGNvbnRleHQudHlwZSBUaGUgcHJlZmVycmVkIHR5cGUgb2YgdGhlIHNjYWxhciB0b2tlbi4gSWYgdW5kZWZpbmVkLCB0aGUgcHJldmlvdXMgdHlwZSBvZiB0aGUgYHRva2VuYCB3aWxsIGJlIHVzZWQsIGRlZmF1bHRpbmcgdG8gYCdQTEFJTidgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVTY2FsYXJUb2tlbih2YWx1ZSwgY29udGV4dCkge1xuICAgIGNvbnN0IHsgaW1wbGljaXRLZXkgPSBmYWxzZSwgaW5kZW50LCBpbkZsb3cgPSBmYWxzZSwgb2Zmc2V0ID0gLTEsIHR5cGUgPSAnUExBSU4nIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmluZ2lmeVN0cmluZy5zdHJpbmdpZnlTdHJpbmcoeyB0eXBlLCB2YWx1ZSB9LCB7XG4gICAgICAgIGltcGxpY2l0S2V5LFxuICAgICAgICBpbmRlbnQ6IGluZGVudCA+IDAgPyAnICcucmVwZWF0KGluZGVudCkgOiAnJyxcbiAgICAgICAgaW5GbG93LFxuICAgICAgICBvcHRpb25zOiB7IGJsb2NrUXVvdGU6IHRydWUsIGxpbmVXaWR0aDogLTEgfVxuICAgIH0pO1xuICAgIGNvbnN0IGVuZCA9IGNvbnRleHQuZW5kID8/IFtcbiAgICAgICAgeyB0eXBlOiAnbmV3bGluZScsIG9mZnNldDogLTEsIGluZGVudCwgc291cmNlOiAnXFxuJyB9XG4gICAgXTtcbiAgICBzd2l0Y2ggKHNvdXJjZVswXSkge1xuICAgICAgICBjYXNlICd8JzpcbiAgICAgICAgY2FzZSAnPic6IHtcbiAgICAgICAgICAgIGNvbnN0IGhlID0gc291cmNlLmluZGV4T2YoJ1xcbicpO1xuICAgICAgICAgICAgY29uc3QgaGVhZCA9IHNvdXJjZS5zdWJzdHJpbmcoMCwgaGUpO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHNvdXJjZS5zdWJzdHJpbmcoaGUgKyAxKSArICdcXG4nO1xuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBbXG4gICAgICAgICAgICAgICAgeyB0eXBlOiAnYmxvY2stc2NhbGFyLWhlYWRlcicsIG9mZnNldCwgaW5kZW50LCBzb3VyY2U6IGhlYWQgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGlmICghYWRkRW5kdG9CbG9ja1Byb3BzKHByb3BzLCBlbmQpKVxuICAgICAgICAgICAgICAgIHByb3BzLnB1c2goeyB0eXBlOiAnbmV3bGluZScsIG9mZnNldDogLTEsIGluZGVudCwgc291cmNlOiAnXFxuJyB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICdibG9jay1zY2FsYXInLCBvZmZzZXQsIGluZGVudCwgcHJvcHMsIHNvdXJjZTogYm9keSB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICdkb3VibGUtcXVvdGVkLXNjYWxhcicsIG9mZnNldCwgaW5kZW50LCBzb3VyY2UsIGVuZCB9O1xuICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJywgb2Zmc2V0LCBpbmRlbnQsIHNvdXJjZSwgZW5kIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnc2NhbGFyJywgb2Zmc2V0LCBpbmRlbnQsIHNvdXJjZSwgZW5kIH07XG4gICAgfVxufVxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGB0b2tlbmAgdG8gdGhlIGdpdmVuIHN0cmluZyBgdmFsdWVgLCBvdmVyd3JpdGluZyBhbnkgcHJldmlvdXMgY29udGVudHMgYW5kIHR5cGUgdGhhdCBpdCBtYXkgaGF2ZS5cbiAqXG4gKiBCZXN0IGVmZm9ydHMgYXJlIG1hZGUgdG8gcmV0YWluIGFueSBjb21tZW50cyBwcmV2aW91c2x5IGFzc29jaWF0ZWQgd2l0aCB0aGUgYHRva2VuYCxcbiAqIHRob3VnaCBhbGwgY29udGVudHMgd2l0aGluIGEgY29sbGVjdGlvbidzIGBpdGVtc2Agd2lsbCBiZSBvdmVyd3JpdHRlbi5cbiAqXG4gKiBWYWx1ZXMgdGhhdCByZXByZXNlbnQgYW4gYWN0dWFsIHN0cmluZyBidXQgbWF5IGJlIHBhcnNlZCBhcyBhIGRpZmZlcmVudCB0eXBlIHNob3VsZCB1c2UgYSBgdHlwZWAgb3RoZXIgdGhhbiBgJ1BMQUlOJ2AsXG4gKiBhcyB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IHN1cHBvcnQgYW55IHNjaGVtYSBvcGVyYXRpb25zIGFuZCB3b24ndCBjaGVjayBmb3Igc3VjaCBjb25mbGljdHMuXG4gKlxuICogQHBhcmFtIHRva2VuIEFueSB0b2tlbi4gSWYgaXQgZG9lcyBub3QgaW5jbHVkZSBhbiBgaW5kZW50YCB2YWx1ZSwgdGhlIHZhbHVlIHdpbGwgYmUgc3RyaW5naWZpZWQgYXMgaWYgaXQgd2VyZSBhbiBpbXBsaWNpdCBrZXkuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmFsdWUsIHdoaWNoIHdpbGwgaGF2ZSBpdHMgY29udGVudCBwcm9wZXJseSBpbmRlbnRlZC5cbiAqIEBwYXJhbSBjb250ZXh0LmFmdGVyS2V5IEluIG1vc3QgY2FzZXMsIHZhbHVlcyBhZnRlciBhIGtleSBzaG91bGQgaGF2ZSBhbiBhZGRpdGlvbmFsIGxldmVsIG9mIGluZGVudGF0aW9uLlxuICogQHBhcmFtIGNvbnRleHQuaW1wbGljaXRLZXkgQmVpbmcgd2l0aGluIGFuIGltcGxpY2l0IGtleSBtYXkgYWZmZWN0IHRoZSByZXNvbHZlZCB0eXBlIG9mIHRoZSB0b2tlbidzIHZhbHVlLlxuICogQHBhcmFtIGNvbnRleHQuaW5GbG93IEJlaW5nIHdpdGhpbiBhIGZsb3cgY29sbGVjdGlvbiBtYXkgYWZmZWN0IHRoZSByZXNvbHZlZCB0eXBlIG9mIHRoZSB0b2tlbidzIHZhbHVlLlxuICogQHBhcmFtIGNvbnRleHQudHlwZSBUaGUgcHJlZmVycmVkIHR5cGUgb2YgdGhlIHNjYWxhciB0b2tlbi4gSWYgdW5kZWZpbmVkLCB0aGUgcHJldmlvdXMgdHlwZSBvZiB0aGUgYHRva2VuYCB3aWxsIGJlIHVzZWQsIGRlZmF1bHRpbmcgdG8gYCdQTEFJTidgLlxuICovXG5mdW5jdGlvbiBzZXRTY2FsYXJWYWx1ZSh0b2tlbiwgdmFsdWUsIGNvbnRleHQgPSB7fSkge1xuICAgIGxldCB7IGFmdGVyS2V5ID0gZmFsc2UsIGltcGxpY2l0S2V5ID0gZmFsc2UsIGluRmxvdyA9IGZhbHNlLCB0eXBlIH0gPSBjb250ZXh0O1xuICAgIGxldCBpbmRlbnQgPSAnaW5kZW50JyBpbiB0b2tlbiA/IHRva2VuLmluZGVudCA6IG51bGw7XG4gICAgaWYgKGFmdGVyS2V5ICYmIHR5cGVvZiBpbmRlbnQgPT09ICdudW1iZXInKVxuICAgICAgICBpbmRlbnQgKz0gMjtcbiAgICBpZiAoIXR5cGUpXG4gICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc2luZ2xlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgICAgIHR5cGUgPSAnUVVPVEVfU0lOR0xFJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgICAgICB0eXBlID0gJ1FVT1RFX0RPVUJMRSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdibG9jay1zY2FsYXInOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVyID0gdG9rZW4ucHJvcHNbMF07XG4gICAgICAgICAgICAgICAgaWYgKGhlYWRlci50eXBlICE9PSAnYmxvY2stc2NhbGFyLWhlYWRlcicpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBibG9jayBzY2FsYXIgaGVhZGVyJyk7XG4gICAgICAgICAgICAgICAgdHlwZSA9IGhlYWRlci5zb3VyY2VbMF0gPT09ICc+JyA/ICdCTE9DS19GT0xERUQnIDogJ0JMT0NLX0xJVEVSQUwnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0eXBlID0gJ1BMQUlOJztcbiAgICAgICAgfVxuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmluZ2lmeVN0cmluZy5zdHJpbmdpZnlTdHJpbmcoeyB0eXBlLCB2YWx1ZSB9LCB7XG4gICAgICAgIGltcGxpY2l0S2V5OiBpbXBsaWNpdEtleSB8fCBpbmRlbnQgPT09IG51bGwsXG4gICAgICAgIGluZGVudDogaW5kZW50ICE9PSBudWxsICYmIGluZGVudCA+IDAgPyAnICcucmVwZWF0KGluZGVudCkgOiAnJyxcbiAgICAgICAgaW5GbG93LFxuICAgICAgICBvcHRpb25zOiB7IGJsb2NrUXVvdGU6IHRydWUsIGxpbmVXaWR0aDogLTEgfVxuICAgIH0pO1xuICAgIHN3aXRjaCAoc291cmNlWzBdKSB7XG4gICAgICAgIGNhc2UgJ3wnOlxuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgIHNldEJsb2NrU2NhbGFyVmFsdWUodG9rZW4sIHNvdXJjZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgICAgc2V0Rmxvd1NjYWxhclZhbHVlKHRva2VuLCBzb3VyY2UsICdkb3VibGUtcXVvdGVkLXNjYWxhcicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCInXCI6XG4gICAgICAgICAgICBzZXRGbG93U2NhbGFyVmFsdWUodG9rZW4sIHNvdXJjZSwgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHNldEZsb3dTY2FsYXJWYWx1ZSh0b2tlbiwgc291cmNlLCAnc2NhbGFyJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0QmxvY2tTY2FsYXJWYWx1ZSh0b2tlbiwgc291cmNlKSB7XG4gICAgY29uc3QgaGUgPSBzb3VyY2UuaW5kZXhPZignXFxuJyk7XG4gICAgY29uc3QgaGVhZCA9IHNvdXJjZS5zdWJzdHJpbmcoMCwgaGUpO1xuICAgIGNvbnN0IGJvZHkgPSBzb3VyY2Uuc3Vic3RyaW5nKGhlICsgMSkgKyAnXFxuJztcbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2Jsb2NrLXNjYWxhcicpIHtcbiAgICAgICAgY29uc3QgaGVhZGVyID0gdG9rZW4ucHJvcHNbMF07XG4gICAgICAgIGlmIChoZWFkZXIudHlwZSAhPT0gJ2Jsb2NrLXNjYWxhci1oZWFkZXInKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJsb2NrIHNjYWxhciBoZWFkZXInKTtcbiAgICAgICAgaGVhZGVyLnNvdXJjZSA9IGhlYWQ7XG4gICAgICAgIHRva2VuLnNvdXJjZSA9IGJvZHk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB7IG9mZnNldCB9ID0gdG9rZW47XG4gICAgICAgIGNvbnN0IGluZGVudCA9ICdpbmRlbnQnIGluIHRva2VuID8gdG9rZW4uaW5kZW50IDogLTE7XG4gICAgICAgIGNvbnN0IHByb3BzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiAnYmxvY2stc2NhbGFyLWhlYWRlcicsIG9mZnNldCwgaW5kZW50LCBzb3VyY2U6IGhlYWQgfVxuICAgICAgICBdO1xuICAgICAgICBpZiAoIWFkZEVuZHRvQmxvY2tQcm9wcyhwcm9wcywgJ2VuZCcgaW4gdG9rZW4gPyB0b2tlbi5lbmQgOiB1bmRlZmluZWQpKVxuICAgICAgICAgICAgcHJvcHMucHVzaCh7IHR5cGU6ICduZXdsaW5lJywgb2Zmc2V0OiAtMSwgaW5kZW50LCBzb3VyY2U6ICdcXG4nIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0b2tlbikpXG4gICAgICAgICAgICBpZiAoa2V5ICE9PSAndHlwZScgJiYga2V5ICE9PSAnb2Zmc2V0JylcbiAgICAgICAgICAgICAgICBkZWxldGUgdG9rZW5ba2V5XTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0b2tlbiwgeyB0eXBlOiAnYmxvY2stc2NhbGFyJywgaW5kZW50LCBwcm9wcywgc291cmNlOiBib2R5IH0pO1xuICAgIH1cbn1cbi8qKiBAcmV0dXJucyBgdHJ1ZWAgaWYgbGFzdCB0b2tlbiBpcyBhIG5ld2xpbmUgKi9cbmZ1bmN0aW9uIGFkZEVuZHRvQmxvY2tQcm9wcyhwcm9wcywgZW5kKSB7XG4gICAgaWYgKGVuZClcbiAgICAgICAgZm9yIChjb25zdCBzdCBvZiBlbmQpXG4gICAgICAgICAgICBzd2l0Y2ggKHN0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnB1c2goc3QpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMucHVzaChzdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNldEZsb3dTY2FsYXJWYWx1ZSh0b2tlbiwgc291cmNlLCB0eXBlKSB7XG4gICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgICAgIGNhc2UgJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgY2FzZSAnc2luZ2xlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgdG9rZW4udHlwZSA9IHR5cGU7XG4gICAgICAgICAgICB0b2tlbi5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYmxvY2stc2NhbGFyJzoge1xuICAgICAgICAgICAgY29uc3QgZW5kID0gdG9rZW4ucHJvcHMuc2xpY2UoMSk7XG4gICAgICAgICAgICBsZXQgb2EgPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRva2VuLnByb3BzWzBdLnR5cGUgPT09ICdibG9jay1zY2FsYXItaGVhZGVyJylcbiAgICAgICAgICAgICAgICBvYSAtPSB0b2tlbi5wcm9wc1swXS5zb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0b2sgb2YgZW5kKVxuICAgICAgICAgICAgICAgIHRvay5vZmZzZXQgKz0gb2E7XG4gICAgICAgICAgICBkZWxldGUgdG9rZW4ucHJvcHM7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRva2VuLCB7IHR5cGUsIHNvdXJjZSwgZW5kIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnYmxvY2stbWFwJzpcbiAgICAgICAgY2FzZSAnYmxvY2stc2VxJzoge1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdG9rZW4ub2Zmc2V0ICsgc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IG5sID0geyB0eXBlOiAnbmV3bGluZScsIG9mZnNldCwgaW5kZW50OiB0b2tlbi5pbmRlbnQsIHNvdXJjZTogJ1xcbicgfTtcbiAgICAgICAgICAgIGRlbGV0ZSB0b2tlbi5pdGVtcztcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odG9rZW4sIHsgdHlwZSwgc291cmNlLCBlbmQ6IFtubF0gfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBjb25zdCBpbmRlbnQgPSAnaW5kZW50JyBpbiB0b2tlbiA/IHRva2VuLmluZGVudCA6IC0xO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gJ2VuZCcgaW4gdG9rZW4gJiYgQXJyYXkuaXNBcnJheSh0b2tlbi5lbmQpXG4gICAgICAgICAgICAgICAgPyB0b2tlbi5lbmQuZmlsdGVyKHN0ID0+IHN0LnR5cGUgPT09ICdzcGFjZScgfHxcbiAgICAgICAgICAgICAgICAgICAgc3QudHlwZSA9PT0gJ2NvbW1lbnQnIHx8XG4gICAgICAgICAgICAgICAgICAgIHN0LnR5cGUgPT09ICduZXdsaW5lJylcbiAgICAgICAgICAgICAgICA6IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModG9rZW4pKVxuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICd0eXBlJyAmJiBrZXkgIT09ICdvZmZzZXQnKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdG9rZW5ba2V5XTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odG9rZW4sIHsgdHlwZSwgaW5kZW50LCBzb3VyY2UsIGVuZCB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0cy5jcmVhdGVTY2FsYXJUb2tlbiA9IGNyZWF0ZVNjYWxhclRva2VuO1xuZXhwb3J0cy5yZXNvbHZlQXNTY2FsYXIgPSByZXNvbHZlQXNTY2FsYXI7XG5leHBvcnRzLnNldFNjYWxhclZhbHVlID0gc2V0U2NhbGFyVmFsdWU7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTdHJpbmdpZnkgYSBDU1QgZG9jdW1lbnQsIHRva2VuLCBvciBjb2xsZWN0aW9uIGl0ZW1cbiAqXG4gKiBGYWlyIHdhcm5pbmc6IFRoaXMgYXBwbGllcyBubyB2YWxpZGF0aW9uIHdoYXRzb2V2ZXIsIGFuZFxuICogc2ltcGx5IGNvbmNhdGVuYXRlcyB0aGUgc291cmNlcyBpbiB0aGVpciBsb2dpY2FsIG9yZGVyLlxuICovXG5jb25zdCBzdHJpbmdpZnkgPSAoY3N0KSA9PiAndHlwZScgaW4gY3N0ID8gc3RyaW5naWZ5VG9rZW4oY3N0KSA6IHN0cmluZ2lmeUl0ZW0oY3N0KTtcbmZ1bmN0aW9uIHN0cmluZ2lmeVRva2VuKHRva2VuKSB7XG4gICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2Jsb2NrLXNjYWxhcic6IHtcbiAgICAgICAgICAgIGxldCByZXMgPSAnJztcbiAgICAgICAgICAgIGZvciAoY29uc3QgdG9rIG9mIHRva2VuLnByb3BzKVxuICAgICAgICAgICAgICAgIHJlcyArPSBzdHJpbmdpZnlUb2tlbih0b2spO1xuICAgICAgICAgICAgcmV0dXJuIHJlcyArIHRva2VuLnNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdibG9jay1tYXAnOlxuICAgICAgICBjYXNlICdibG9jay1zZXEnOiB7XG4gICAgICAgICAgICBsZXQgcmVzID0gJyc7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdG9rZW4uaXRlbXMpXG4gICAgICAgICAgICAgICAgcmVzICs9IHN0cmluZ2lmeUl0ZW0oaXRlbSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2Zsb3ctY29sbGVjdGlvbic6IHtcbiAgICAgICAgICAgIGxldCByZXMgPSB0b2tlbi5zdGFydC5zb3VyY2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdG9rZW4uaXRlbXMpXG4gICAgICAgICAgICAgICAgcmVzICs9IHN0cmluZ2lmeUl0ZW0oaXRlbSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHN0IG9mIHRva2VuLmVuZClcbiAgICAgICAgICAgICAgICByZXMgKz0gc3Quc291cmNlO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdkb2N1bWVudCc6IHtcbiAgICAgICAgICAgIGxldCByZXMgPSBzdHJpbmdpZnlJdGVtKHRva2VuKTtcbiAgICAgICAgICAgIGlmICh0b2tlbi5lbmQpXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdCBvZiB0b2tlbi5lbmQpXG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSBzdC5zb3VyY2U7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGxldCByZXMgPSB0b2tlbi5zb3VyY2U7XG4gICAgICAgICAgICBpZiAoJ2VuZCcgaW4gdG9rZW4gJiYgdG9rZW4uZW5kKVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3Qgb2YgdG9rZW4uZW5kKVxuICAgICAgICAgICAgICAgICAgICByZXMgKz0gc3Quc291cmNlO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeUl0ZW0oeyBzdGFydCwga2V5LCBzZXAsIHZhbHVlIH0pIHtcbiAgICBsZXQgcmVzID0gJyc7XG4gICAgZm9yIChjb25zdCBzdCBvZiBzdGFydClcbiAgICAgICAgcmVzICs9IHN0LnNvdXJjZTtcbiAgICBpZiAoa2V5KVxuICAgICAgICByZXMgKz0gc3RyaW5naWZ5VG9rZW4oa2V5KTtcbiAgICBpZiAoc2VwKVxuICAgICAgICBmb3IgKGNvbnN0IHN0IG9mIHNlcClcbiAgICAgICAgICAgIHJlcyArPSBzdC5zb3VyY2U7XG4gICAgaWYgKHZhbHVlKVxuICAgICAgICByZXMgKz0gc3RyaW5naWZ5VG9rZW4odmFsdWUpO1xuICAgIHJldHVybiByZXM7XG59XG5cbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJSRUFLID0gU3ltYm9sKCdicmVhayB2aXNpdCcpO1xuY29uc3QgU0tJUCA9IFN5bWJvbCgnc2tpcCBjaGlsZHJlbicpO1xuY29uc3QgUkVNT1ZFID0gU3ltYm9sKCdyZW1vdmUgaXRlbScpO1xuLyoqXG4gKiBBcHBseSBhIHZpc2l0b3IgdG8gYSBDU1QgZG9jdW1lbnQgb3IgaXRlbS5cbiAqXG4gKiBXYWxrcyB0aHJvdWdoIHRoZSB0cmVlIChkZXB0aC1maXJzdCkgc3RhcnRpbmcgZnJvbSB0aGUgcm9vdCwgY2FsbGluZyBhXG4gKiBgdmlzaXRvcmAgZnVuY3Rpb24gd2l0aCB0d28gYXJndW1lbnRzIHdoZW4gZW50ZXJpbmcgZWFjaCBpdGVtOlxuICogICAtIGBpdGVtYDogVGhlIGN1cnJlbnQgaXRlbSwgd2hpY2ggaW5jbHVkZWQgdGhlIGZvbGxvd2luZyBtZW1iZXJzOlxuICogICAgIC0gYHN0YXJ0OiBTb3VyY2VUb2tlbltdYCDigJMgU291cmNlIHRva2VucyBiZWZvcmUgdGhlIGtleSBvciB2YWx1ZSxcbiAqICAgICAgIHBvc3NpYmx5IGluY2x1ZGluZyBpdHMgYW5jaG9yIG9yIHRhZy5cbiAqICAgICAtIGBrZXk/OiBUb2tlbiB8IG51bGxgIOKAkyBTZXQgZm9yIHBhaXIgdmFsdWVzLiBNYXkgdGhlbiBiZSBgbnVsbGAsIGlmXG4gKiAgICAgICB0aGUga2V5IGJlZm9yZSB0aGUgYDpgIHNlcGFyYXRvciBpcyBlbXB0eS5cbiAqICAgICAtIGBzZXA/OiBTb3VyY2VUb2tlbltdYCDigJMgU291cmNlIHRva2VucyBiZXR3ZWVuIHRoZSBrZXkgYW5kIHRoZSB2YWx1ZSxcbiAqICAgICAgIHdoaWNoIHNob3VsZCBpbmNsdWRlIHRoZSBgOmAgbWFwIHZhbHVlIGluZGljYXRvciBpZiBgdmFsdWVgIGlzIHNldC5cbiAqICAgICAtIGB2YWx1ZT86IFRva2VuYCDigJMgVGhlIHZhbHVlIG9mIGEgc2VxdWVuY2UgaXRlbSwgb3Igb2YgYSBtYXAgcGFpci5cbiAqICAgLSBgcGF0aGA6IFRoZSBzdGVwcyBmcm9tIHRoZSByb290IHRvIHRoZSBjdXJyZW50IG5vZGUsIGFzIGFuIGFycmF5IG9mXG4gKiAgICAgYFsna2V5JyB8ICd2YWx1ZScsIG51bWJlcl1gIHR1cGxlcy5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSB2aXNpdG9yIG1heSBiZSB1c2VkIHRvIGNvbnRyb2wgdGhlIHRyYXZlcnNhbDpcbiAqICAgLSBgdW5kZWZpbmVkYCAoZGVmYXVsdCk6IERvIG5vdGhpbmcgYW5kIGNvbnRpbnVlXG4gKiAgIC0gYHZpc2l0LlNLSVBgOiBEbyBub3QgdmlzaXQgdGhlIGNoaWxkcmVuIG9mIHRoaXMgdG9rZW4sIGNvbnRpbnVlIHdpdGhcbiAqICAgICAgbmV4dCBzaWJsaW5nXG4gKiAgIC0gYHZpc2l0LkJSRUFLYDogVGVybWluYXRlIHRyYXZlcnNhbCBjb21wbGV0ZWx5XG4gKiAgIC0gYHZpc2l0LlJFTU9WRWA6IFJlbW92ZSB0aGUgY3VycmVudCBpdGVtLCB0aGVuIGNvbnRpbnVlIHdpdGggdGhlIG5leHQgb25lXG4gKiAgIC0gYG51bWJlcmA6IFNldCB0aGUgaW5kZXggb2YgdGhlIG5leHQgc3RlcC4gVGhpcyBpcyB1c2VmdWwgZXNwZWNpYWxseSBpZlxuICogICAgIHRoZSBpbmRleCBvZiB0aGUgY3VycmVudCB0b2tlbiBoYXMgY2hhbmdlZC5cbiAqICAgLSBgZnVuY3Rpb25gOiBEZWZpbmUgdGhlIG5leHQgdmlzaXRvciBmb3IgdGhpcyBpdGVtLiBBZnRlciB0aGUgb3JpZ2luYWxcbiAqICAgICB2aXNpdG9yIGlzIGNhbGxlZCBvbiBpdGVtIGVudHJ5LCBuZXh0IHZpc2l0b3JzIGFyZSBjYWxsZWQgYWZ0ZXIgaGFuZGxpbmdcbiAqICAgICBhIG5vbi1lbXB0eSBga2V5YCBhbmQgd2hlbiBleGl0aW5nIHRoZSBpdGVtLlxuICovXG5mdW5jdGlvbiB2aXNpdChjc3QsIHZpc2l0b3IpIHtcbiAgICBpZiAoJ3R5cGUnIGluIGNzdCAmJiBjc3QudHlwZSA9PT0gJ2RvY3VtZW50JylcbiAgICAgICAgY3N0ID0geyBzdGFydDogY3N0LnN0YXJ0LCB2YWx1ZTogY3N0LnZhbHVlIH07XG4gICAgX3Zpc2l0KE9iamVjdC5mcmVlemUoW10pLCBjc3QsIHZpc2l0b3IpO1xufVxuLy8gV2l0aG91dCB0aGUgYGFzIHN5bWJvbGAgY2FzdHMsIFRTIGRlY2xhcmVzIHRoZXNlIGluIHRoZSBgdmlzaXRgXG4vLyBuYW1lc3BhY2UgdXNpbmcgYHZhcmAsIGJ1dCB0aGVuIGNvbXBsYWlucyBhYm91dCB0aGF0IGJlY2F1c2Vcbi8vIGB1bmlxdWUgc3ltYm9sYCBtdXN0IGJlIGBjb25zdGAuXG4vKiogVGVybWluYXRlIHZpc2l0IHRyYXZlcnNhbCBjb21wbGV0ZWx5ICovXG52aXNpdC5CUkVBSyA9IEJSRUFLO1xuLyoqIERvIG5vdCB2aXNpdCB0aGUgY2hpbGRyZW4gb2YgdGhlIGN1cnJlbnQgaXRlbSAqL1xudmlzaXQuU0tJUCA9IFNLSVA7XG4vKiogUmVtb3ZlIHRoZSBjdXJyZW50IGl0ZW0gKi9cbnZpc2l0LlJFTU9WRSA9IFJFTU9WRTtcbi8qKiBGaW5kIHRoZSBpdGVtIGF0IGBwYXRoYCBmcm9tIGBjc3RgIGFzIHRoZSByb290ICovXG52aXNpdC5pdGVtQXRQYXRoID0gKGNzdCwgcGF0aCkgPT4ge1xuICAgIGxldCBpdGVtID0gY3N0O1xuICAgIGZvciAoY29uc3QgW2ZpZWxkLCBpbmRleF0gb2YgcGF0aCkge1xuICAgICAgICBjb25zdCB0b2sgPSBpdGVtPy5bZmllbGRdO1xuICAgICAgICBpZiAodG9rICYmICdpdGVtcycgaW4gdG9rKSB7XG4gICAgICAgICAgICBpdGVtID0gdG9rLml0ZW1zW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbn07XG4vKipcbiAqIEdldCB0aGUgaW1tZWRpYXRlIHBhcmVudCBjb2xsZWN0aW9uIG9mIHRoZSBpdGVtIGF0IGBwYXRoYCBmcm9tIGBjc3RgIGFzIHRoZSByb290LlxuICpcbiAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgY29sbGVjdGlvbiBpcyBub3QgZm91bmQsIHdoaWNoIHNob3VsZCBuZXZlciBoYXBwZW4gaWYgdGhlIGl0ZW0gaXRzZWxmIGV4aXN0cy5cbiAqL1xudmlzaXQucGFyZW50Q29sbGVjdGlvbiA9IChjc3QsIHBhdGgpID0+IHtcbiAgICBjb25zdCBwYXJlbnQgPSB2aXNpdC5pdGVtQXRQYXRoKGNzdCwgcGF0aC5zbGljZSgwLCAtMSkpO1xuICAgIGNvbnN0IGZpZWxkID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdWzBdO1xuICAgIGNvbnN0IGNvbGwgPSBwYXJlbnQ/LltmaWVsZF07XG4gICAgaWYgKGNvbGwgJiYgJ2l0ZW1zJyBpbiBjb2xsKVxuICAgICAgICByZXR1cm4gY29sbDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmVudCBjb2xsZWN0aW9uIG5vdCBmb3VuZCcpO1xufTtcbmZ1bmN0aW9uIF92aXNpdChwYXRoLCBpdGVtLCB2aXNpdG9yKSB7XG4gICAgbGV0IGN0cmwgPSB2aXNpdG9yKGl0ZW0sIHBhdGgpO1xuICAgIGlmICh0eXBlb2YgY3RybCA9PT0gJ3N5bWJvbCcpXG4gICAgICAgIHJldHVybiBjdHJsO1xuICAgIGZvciAoY29uc3QgZmllbGQgb2YgWydrZXknLCAndmFsdWUnXSkge1xuICAgICAgICBjb25zdCB0b2tlbiA9IGl0ZW1bZmllbGRdO1xuICAgICAgICBpZiAodG9rZW4gJiYgJ2l0ZW1zJyBpbiB0b2tlbikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbi5pdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNpID0gX3Zpc2l0KE9iamVjdC5mcmVlemUocGF0aC5jb25jYXQoW1tmaWVsZCwgaV1dKSksIHRva2VuLml0ZW1zW2ldLCB2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNpID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICAgICAgaSA9IGNpIC0gMTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaSA9PT0gQlJFQUspXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCUkVBSztcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaSA9PT0gUkVNT1ZFKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuLml0ZW1zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3RybCA9PT0gJ2Z1bmN0aW9uJyAmJiBmaWVsZCA9PT0gJ2tleScpXG4gICAgICAgICAgICAgICAgY3RybCA9IGN0cmwoaXRlbSwgcGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiBjdHJsID09PSAnZnVuY3Rpb24nID8gY3RybChpdGVtLCBwYXRoKSA6IGN0cmw7XG59XG5cbmV4cG9ydHMudmlzaXQgPSB2aXNpdDtcbiIsCiAgICAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3N0U2NhbGFyID0gcmVxdWlyZSgnLi9jc3Qtc2NhbGFyLmpzJyk7XG52YXIgY3N0U3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9jc3Qtc3RyaW5naWZ5LmpzJyk7XG52YXIgY3N0VmlzaXQgPSByZXF1aXJlKCcuL2NzdC12aXNpdC5qcycpO1xuXG4vKiogVGhlIGJ5dGUgb3JkZXIgbWFyayAqL1xuY29uc3QgQk9NID0gJ1xcdXtGRUZGfSc7XG4vKiogU3RhcnQgb2YgZG9jLW1vZGUgKi9cbmNvbnN0IERPQ1VNRU5UID0gJ1xceDAyJzsgLy8gQzA6IFN0YXJ0IG9mIFRleHRcbi8qKiBVbmV4cGVjdGVkIGVuZCBvZiBmbG93LW1vZGUgKi9cbmNvbnN0IEZMT1dfRU5EID0gJ1xceDE4JzsgLy8gQzA6IENhbmNlbFxuLyoqIE5leHQgdG9rZW4gaXMgYSBzY2FsYXIgdmFsdWUgKi9cbmNvbnN0IFNDQUxBUiA9ICdcXHgxZic7IC8vIEMwOiBVbml0IFNlcGFyYXRvclxuLyoqIEByZXR1cm5zIGB0cnVlYCBpZiBgdG9rZW5gIGlzIGEgZmxvdyBvciBibG9jayBjb2xsZWN0aW9uICovXG5jb25zdCBpc0NvbGxlY3Rpb24gPSAodG9rZW4pID0+ICEhdG9rZW4gJiYgJ2l0ZW1zJyBpbiB0b2tlbjtcbi8qKiBAcmV0dXJucyBgdHJ1ZWAgaWYgYHRva2VuYCBpcyBhIGZsb3cgb3IgYmxvY2sgc2NhbGFyOyBub3QgYW4gYWxpYXMgKi9cbmNvbnN0IGlzU2NhbGFyID0gKHRva2VuKSA9PiAhIXRva2VuICYmXG4gICAgKHRva2VuLnR5cGUgPT09ICdzY2FsYXInIHx8XG4gICAgICAgIHRva2VuLnR5cGUgPT09ICdzaW5nbGUtcXVvdGVkLXNjYWxhcicgfHxcbiAgICAgICAgdG9rZW4udHlwZSA9PT0gJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJyB8fFxuICAgICAgICB0b2tlbi50eXBlID09PSAnYmxvY2stc2NhbGFyJyk7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuLyoqIEdldCBhIHByaW50YWJsZSByZXByZXNlbnRhdGlvbiBvZiBhIGxleGVyIHRva2VuICovXG5mdW5jdGlvbiBwcmV0dHlUb2tlbih0b2tlbikge1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgY2FzZSBCT006XG4gICAgICAgICAgICByZXR1cm4gJzxCT00+JztcbiAgICAgICAgY2FzZSBET0NVTUVOVDpcbiAgICAgICAgICAgIHJldHVybiAnPERPQz4nO1xuICAgICAgICBjYXNlIEZMT1dfRU5EOlxuICAgICAgICAgICAgcmV0dXJuICc8RkxPV19FTkQ+JztcbiAgICAgICAgY2FzZSBTQ0FMQVI6XG4gICAgICAgICAgICByZXR1cm4gJzxTQ0FMQVI+JztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0b2tlbik7XG4gICAgfVxufVxuLyoqIElkZW50aWZ5IHRoZSB0eXBlIG9mIGEgbGV4ZXIgdG9rZW4uIE1heSByZXR1cm4gYG51bGxgIGZvciB1bmtub3duIHRva2Vucy4gKi9cbmZ1bmN0aW9uIHRva2VuVHlwZShzb3VyY2UpIHtcbiAgICBzd2l0Y2ggKHNvdXJjZSkge1xuICAgICAgICBjYXNlIEJPTTpcbiAgICAgICAgICAgIHJldHVybiAnYnl0ZS1vcmRlci1tYXJrJztcbiAgICAgICAgY2FzZSBET0NVTUVOVDpcbiAgICAgICAgICAgIHJldHVybiAnZG9jLW1vZGUnO1xuICAgICAgICBjYXNlIEZMT1dfRU5EOlxuICAgICAgICAgICAgcmV0dXJuICdmbG93LWVycm9yLWVuZCc7XG4gICAgICAgIGNhc2UgU0NBTEFSOlxuICAgICAgICAgICAgcmV0dXJuICdzY2FsYXInO1xuICAgICAgICBjYXNlICctLS0nOlxuICAgICAgICAgICAgcmV0dXJuICdkb2Mtc3RhcnQnO1xuICAgICAgICBjYXNlICcuLi4nOlxuICAgICAgICAgICAgcmV0dXJuICdkb2MtZW5kJztcbiAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgY2FzZSAnXFxuJzpcbiAgICAgICAgY2FzZSAnXFxyXFxuJzpcbiAgICAgICAgICAgIHJldHVybiAnbmV3bGluZSc7XG4gICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgcmV0dXJuICdzZXEtaXRlbS1pbmQnO1xuICAgICAgICBjYXNlICc/JzpcbiAgICAgICAgICAgIHJldHVybiAnZXhwbGljaXQta2V5LWluZCc7XG4gICAgICAgIGNhc2UgJzonOlxuICAgICAgICAgICAgcmV0dXJuICdtYXAtdmFsdWUtaW5kJztcbiAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICByZXR1cm4gJ2Zsb3ctbWFwLXN0YXJ0JztcbiAgICAgICAgY2FzZSAnfSc6XG4gICAgICAgICAgICByZXR1cm4gJ2Zsb3ctbWFwLWVuZCc7XG4gICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgcmV0dXJuICdmbG93LXNlcS1zdGFydCc7XG4gICAgICAgIGNhc2UgJ10nOlxuICAgICAgICAgICAgcmV0dXJuICdmbG93LXNlcS1lbmQnO1xuICAgICAgICBjYXNlICcsJzpcbiAgICAgICAgICAgIHJldHVybiAnY29tbWEnO1xuICAgIH1cbiAgICBzd2l0Y2ggKHNvdXJjZVswXSkge1xuICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgY2FzZSAnXFx0JzpcbiAgICAgICAgICAgIHJldHVybiAnc3BhY2UnO1xuICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgIHJldHVybiAnY29tbWVudCc7XG4gICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgcmV0dXJuICdkaXJlY3RpdmUtbGluZSc7XG4gICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgcmV0dXJuICdhbGlhcyc7XG4gICAgICAgIGNhc2UgJyYnOlxuICAgICAgICAgICAgcmV0dXJuICdhbmNob3InO1xuICAgICAgICBjYXNlICchJzpcbiAgICAgICAgICAgIHJldHVybiAndGFnJztcbiAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICAgIHJldHVybiAnc2luZ2xlLXF1b3RlZC1zY2FsYXInO1xuICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICByZXR1cm4gJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJztcbiAgICAgICAgY2FzZSAnfCc6XG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgcmV0dXJuICdibG9jay1zY2FsYXItaGVhZGVyJztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydHMuY3JlYXRlU2NhbGFyVG9rZW4gPSBjc3RTY2FsYXIuY3JlYXRlU2NhbGFyVG9rZW47XG5leHBvcnRzLnJlc29sdmVBc1NjYWxhciA9IGNzdFNjYWxhci5yZXNvbHZlQXNTY2FsYXI7XG5leHBvcnRzLnNldFNjYWxhclZhbHVlID0gY3N0U2NhbGFyLnNldFNjYWxhclZhbHVlO1xuZXhwb3J0cy5zdHJpbmdpZnkgPSBjc3RTdHJpbmdpZnkuc3RyaW5naWZ5O1xuZXhwb3J0cy52aXNpdCA9IGNzdFZpc2l0LnZpc2l0O1xuZXhwb3J0cy5CT00gPSBCT007XG5leHBvcnRzLkRPQ1VNRU5UID0gRE9DVU1FTlQ7XG5leHBvcnRzLkZMT1dfRU5EID0gRkxPV19FTkQ7XG5leHBvcnRzLlNDQUxBUiA9IFNDQUxBUjtcbmV4cG9ydHMuaXNDb2xsZWN0aW9uID0gaXNDb2xsZWN0aW9uO1xuZXhwb3J0cy5pc1NjYWxhciA9IGlzU2NhbGFyO1xuZXhwb3J0cy5wcmV0dHlUb2tlbiA9IHByZXR0eVRva2VuO1xuZXhwb3J0cy50b2tlblR5cGUgPSB0b2tlblR5cGU7XG4iLAogICAgIid1c2Ugc3RyaWN0JztcblxudmFyIGNzdCA9IHJlcXVpcmUoJy4vY3N0LmpzJyk7XG5cbi8qXG5TVEFSVCAtPiBzdHJlYW1cblxuc3RyZWFtXG4gIGRpcmVjdGl2ZSAtPiBsaW5lLWVuZCAtPiBzdHJlYW1cbiAgaW5kZW50ICsgbGluZS1lbmQgLT4gc3RyZWFtXG4gIFtlbHNlXSAtPiBsaW5lLXN0YXJ0XG5cbmxpbmUtZW5kXG4gIGNvbW1lbnQgLT4gbGluZS1lbmRcbiAgbmV3bGluZSAtPiAuXG4gIGlucHV0LWVuZCAtPiBFTkRcblxubGluZS1zdGFydFxuICBkb2Mtc3RhcnQgLT4gZG9jXG4gIGRvYy1lbmQgLT4gc3RyZWFtXG4gIFtlbHNlXSAtPiBpbmRlbnQgLT4gYmxvY2stc3RhcnRcblxuYmxvY2stc3RhcnRcbiAgc2VxLWl0ZW0tc3RhcnQgLT4gYmxvY2stc3RhcnRcbiAgZXhwbGljaXQta2V5LXN0YXJ0IC0+IGJsb2NrLXN0YXJ0XG4gIG1hcC12YWx1ZS1zdGFydCAtPiBibG9jay1zdGFydFxuICBbZWxzZV0gLT4gZG9jXG5cbmRvY1xuICBsaW5lLWVuZCAtPiBsaW5lLXN0YXJ0XG4gIHNwYWNlcyAtPiBkb2NcbiAgYW5jaG9yIC0+IGRvY1xuICB0YWcgLT4gZG9jXG4gIGZsb3ctc3RhcnQgLT4gZmxvdyAtPiBkb2NcbiAgZmxvdy1lbmQgLT4gZXJyb3IgLT4gZG9jXG4gIHNlcS1pdGVtLXN0YXJ0IC0+IGVycm9yIC0+IGRvY1xuICBleHBsaWNpdC1rZXktc3RhcnQgLT4gZXJyb3IgLT4gZG9jXG4gIG1hcC12YWx1ZS1zdGFydCAtPiBkb2NcbiAgYWxpYXMgLT4gZG9jXG4gIHF1b3RlLXN0YXJ0IC0+IHF1b3RlZC1zY2FsYXIgLT4gZG9jXG4gIGJsb2NrLXNjYWxhci1oZWFkZXIgLT4gbGluZS1lbmQgLT4gYmxvY2stc2NhbGFyKG1pbikgLT4gbGluZS1zdGFydFxuICBbZWxzZV0gLT4gcGxhaW4tc2NhbGFyKGZhbHNlLCBtaW4pIC0+IGRvY1xuXG5mbG93XG4gIGxpbmUtZW5kIC0+IGZsb3dcbiAgc3BhY2VzIC0+IGZsb3dcbiAgYW5jaG9yIC0+IGZsb3dcbiAgdGFnIC0+IGZsb3dcbiAgZmxvdy1zdGFydCAtPiBmbG93IC0+IGZsb3dcbiAgZmxvdy1lbmQgLT4gLlxuICBzZXEtaXRlbS1zdGFydCAtPiBlcnJvciAtPiBmbG93XG4gIGV4cGxpY2l0LWtleS1zdGFydCAtPiBmbG93XG4gIG1hcC12YWx1ZS1zdGFydCAtPiBmbG93XG4gIGFsaWFzIC0+IGZsb3dcbiAgcXVvdGUtc3RhcnQgLT4gcXVvdGVkLXNjYWxhciAtPiBmbG93XG4gIGNvbW1hIC0+IGZsb3dcbiAgW2Vsc2VdIC0+IHBsYWluLXNjYWxhcih0cnVlLCAwKSAtPiBmbG93XG5cbnF1b3RlZC1zY2FsYXJcbiAgcXVvdGUtZW5kIC0+IC5cbiAgW2Vsc2VdIC0+IHF1b3RlZC1zY2FsYXJcblxuYmxvY2stc2NhbGFyKG1pbilcbiAgbmV3bGluZSArIHBlZWsoaW5kZW50IDwgbWluKSAtPiAuXG4gIFtlbHNlXSAtPiBibG9jay1zY2FsYXIobWluKVxuXG5wbGFpbi1zY2FsYXIoaXMtZmxvdywgbWluKVxuICBzY2FsYXItZW5kKGlzLWZsb3cpIC0+IC5cbiAgcGVlayhuZXdsaW5lICsgKGluZGVudCA8IG1pbikpIC0+IC5cbiAgW2Vsc2VdIC0+IHBsYWluLXNjYWxhcihtaW4pXG4qL1xuZnVuY3Rpb24gaXNFbXB0eShjaCkge1xuICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIGNhc2UgJyAnOlxuICAgICAgICBjYXNlICdcXG4nOlxuICAgICAgICBjYXNlICdcXHInOlxuICAgICAgICBjYXNlICdcXHQnOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuY29uc3QgaGV4RGlnaXRzID0gbmV3IFNldCgnMDEyMzQ1Njc4OUFCQ0RFRmFiY2RlZicpO1xuY29uc3QgdGFnQ2hhcnMgPSBuZXcgU2V0KFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXotIzsvPzpAJj0rJF8uIX4qJygpXCIpO1xuY29uc3QgZmxvd0luZGljYXRvckNoYXJzID0gbmV3IFNldCgnLFtde30nKTtcbmNvbnN0IGludmFsaWRBbmNob3JDaGFycyA9IG5ldyBTZXQoJyAsW117fVxcblxcclxcdCcpO1xuY29uc3QgaXNOb3RBbmNob3JDaGFyID0gKGNoKSA9PiAhY2ggfHwgaW52YWxpZEFuY2hvckNoYXJzLmhhcyhjaCk7XG4vKipcbiAqIFNwbGl0cyBhbiBpbnB1dCBzdHJpbmcgaW50byBsZXhpY2FsIHRva2VucywgaS5lLiBzbWFsbGVyIHN0cmluZ3MgdGhhdCBhcmVcbiAqIGVhc2lseSBpZGVudGlmaWFibGUgYnkgYHRva2Vucy50b2tlblR5cGUoKWAuXG4gKlxuICogTGV4aW5nIHN0YXJ0cyBhbHdheXMgaW4gYSBcInN0cmVhbVwiIGNvbnRleHQuIEluY29tcGxldGUgaW5wdXQgbWF5IGJlIGJ1ZmZlcmVkXG4gKiB1bnRpbCBhIGNvbXBsZXRlIHRva2VuIGNhbiBiZSBlbWl0dGVkLlxuICpcbiAqIEluIGFkZGl0aW9uIHRvIHNsaWNlcyBvZiB0aGUgb3JpZ2luYWwgaW5wdXQsIHRoZSBmb2xsb3dpbmcgY29udHJvbCBjaGFyYWN0ZXJzXG4gKiBtYXkgYWxzbyBiZSBlbWl0dGVkOlxuICpcbiAqIC0gYFxceDAyYCAoU3RhcnQgb2YgVGV4dCk6IEEgZG9jdW1lbnQgc3RhcnRzIHdpdGggdGhlIG5leHQgdG9rZW5cbiAqIC0gYFxceDE4YCAoQ2FuY2VsKTogVW5leHBlY3RlZCBlbmQgb2YgZmxvdy1tb2RlIChpbmRpY2F0ZXMgYW4gZXJyb3IpXG4gKiAtIGBcXHgxZmAgKFVuaXQgU2VwYXJhdG9yKTogTmV4dCB0b2tlbiBpcyBhIHNjYWxhciB2YWx1ZVxuICogLSBgXFx1e0ZFRkZ9YCAoQnl0ZSBvcmRlciBtYXJrKTogRW1pdHRlZCBzZXBhcmF0ZWx5IG91dHNpZGUgZG9jdW1lbnRzXG4gKi9cbmNsYXNzIExleGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgYnVmZmVyIG1hcmtzIHRoZSBlbmQgb2ZcbiAgICAgICAgICogYWxsIGlucHV0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmF0RW5kID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHBsaWNpdCBpbmRlbnQgc2V0IGluIGJsb2NrIHNjYWxhciBoZWFkZXIsIGFzIGFuIG9mZnNldCBmcm9tIHRoZSBjdXJyZW50XG4gICAgICAgICAqIG1pbmltdW0gaW5kZW50LCBzbyBlLmcuIHNldCB0byAxIGZyb20gYSBoZWFkZXIgYHwyK2AuIFNldCB0byAtMSBpZiBub3RcbiAgICAgICAgICogZXhwbGljaXRseSBzZXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJsb2NrU2NhbGFySW5kZW50ID0gLTE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCbG9jayBzY2FsYXJzIHRoYXQgaW5jbHVkZSBhICsgKGtlZXApIGNob21waW5nIGluZGljYXRvciBpbiB0aGVpciBoZWFkZXJcbiAgICAgICAgICogaW5jbHVkZSB0cmFpbGluZyBlbXB0eSBsaW5lcywgd2hpY2ggYXJlIG90aGVyd2lzZSBleGNsdWRlZCBmcm9tIHRoZVxuICAgICAgICAgKiBzY2FsYXIncyBjb250ZW50cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmxvY2tTY2FsYXJLZWVwID0gZmFsc2U7XG4gICAgICAgIC8qKiBDdXJyZW50IGlucHV0ICovXG4gICAgICAgIHRoaXMuYnVmZmVyID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGbGFnIG5vdGluZyB3aGV0aGVyIHRoZSBtYXAgdmFsdWUgaW5kaWNhdG9yIDogY2FuIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGlzXG4gICAgICAgICAqIG5vZGUgd2l0aGluIGEgZmxvdyBjb250ZXh0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mbG93S2V5ID0gZmFsc2U7XG4gICAgICAgIC8qKiBDb3VudCBvZiBzdXJyb3VuZGluZyBmbG93IGNvbGxlY3Rpb24gbGV2ZWxzLiAqL1xuICAgICAgICB0aGlzLmZsb3dMZXZlbCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNaW5pbXVtIGxldmVsIG9mIGluZGVudGF0aW9uIHJlcXVpcmVkIGZvciBuZXh0IGxpbmVzIHRvIGJlIHBhcnNlZCBhcyBhXG4gICAgICAgICAqIHBhcnQgb2YgdGhlIGN1cnJlbnQgc2NhbGFyIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmRlbnROZXh0ID0gMDtcbiAgICAgICAgLyoqIEluZGVudGF0aW9uIGxldmVsIG9mIHRoZSBjdXJyZW50IGxpbmUuICovXG4gICAgICAgIHRoaXMuaW5kZW50VmFsdWUgPSAwO1xuICAgICAgICAvKiogUG9zaXRpb24gb2YgdGhlIG5leHQgXFxuIGNoYXJhY3Rlci4gKi9cbiAgICAgICAgdGhpcy5saW5lRW5kUG9zID0gbnVsbDtcbiAgICAgICAgLyoqIFN0b3JlcyB0aGUgc3RhdGUgb2YgdGhlIGxleGVyIGlmIHJlYWNoaW5nIHRoZSBlbmQgb2YgaW5jcG9tcGxldGUgaW5wdXQgKi9cbiAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICAgICAgLyoqIEEgcG9pbnRlciB0byBgYnVmZmVyYDsgdGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIGxleGVyLiAqL1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIFlBTUwgdG9rZW5zIGZyb20gdGhlIGBzb3VyY2VgIHN0cmluZy4gSWYgYGluY29tcGxldGVgLFxuICAgICAqIGEgcGFydCBvZiB0aGUgbGFzdCBsaW5lIG1heSBiZSBsZWZ0IGFzIGEgYnVmZmVyIGZvciB0aGUgbmV4dCBjYWxsLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBnZW5lcmF0b3Igb2YgbGV4aWNhbCB0b2tlbnNcbiAgICAgKi9cbiAgICAqbGV4KHNvdXJjZSwgaW5jb21wbGV0ZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ3NvdXJjZSBpcyBub3QgYSBzdHJpbmcnKTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIgPyB0aGlzLmJ1ZmZlciArIHNvdXJjZSA6IHNvdXJjZTtcbiAgICAgICAgICAgIHRoaXMubGluZUVuZFBvcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hdEVuZCA9ICFpbmNvbXBsZXRlO1xuICAgICAgICBsZXQgbmV4dCA9IHRoaXMubmV4dCA/PyAnc3RyZWFtJztcbiAgICAgICAgd2hpbGUgKG5leHQgJiYgKGluY29tcGxldGUgfHwgdGhpcy5oYXNDaGFycygxKSkpXG4gICAgICAgICAgICBuZXh0ID0geWllbGQqIHRoaXMucGFyc2VOZXh0KG5leHQpO1xuICAgIH1cbiAgICBhdExpbmVFbmQoKSB7XG4gICAgICAgIGxldCBpID0gdGhpcy5wb3M7XG4gICAgICAgIGxldCBjaCA9IHRoaXMuYnVmZmVyW2ldO1xuICAgICAgICB3aGlsZSAoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcpXG4gICAgICAgICAgICBjaCA9IHRoaXMuYnVmZmVyWysraV07XG4gICAgICAgIGlmICghY2ggfHwgY2ggPT09ICcjJyB8fCBjaCA9PT0gJ1xcbicpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGNoID09PSAnXFxyJylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcltpICsgMV0gPT09ICdcXG4nO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNoYXJBdChuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLnBvcyArIG5dO1xuICAgIH1cbiAgICBjb250aW51ZVNjYWxhcihvZmZzZXQpIHtcbiAgICAgICAgbGV0IGNoID0gdGhpcy5idWZmZXJbb2Zmc2V0XTtcbiAgICAgICAgaWYgKHRoaXMuaW5kZW50TmV4dCA+IDApIHtcbiAgICAgICAgICAgIGxldCBpbmRlbnQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGNoID09PSAnICcpXG4gICAgICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclsrK2luZGVudCArIG9mZnNldF07XG4gICAgICAgICAgICBpZiAoY2ggPT09ICdcXHInKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuYnVmZmVyW2luZGVudCArIG9mZnNldCArIDFdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0ID09PSAnXFxuJyB8fCAoIW5leHQgJiYgIXRoaXMuYXRFbmQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0ICsgaW5kZW50ICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaCA9PT0gJ1xcbicgfHwgaW5kZW50ID49IHRoaXMuaW5kZW50TmV4dCB8fCAoIWNoICYmICF0aGlzLmF0RW5kKVxuICAgICAgICAgICAgICAgID8gb2Zmc2V0ICsgaW5kZW50XG4gICAgICAgICAgICAgICAgOiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJy4nKSB7XG4gICAgICAgICAgICBjb25zdCBkdCA9IHRoaXMuYnVmZmVyLnN1YnN0cihvZmZzZXQsIDMpO1xuICAgICAgICAgICAgaWYgKChkdCA9PT0gJy0tLScgfHwgZHQgPT09ICcuLi4nKSAmJiBpc0VtcHR5KHRoaXMuYnVmZmVyW29mZnNldCArIDNdKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gICAgZ2V0TGluZSgpIHtcbiAgICAgICAgbGV0IGVuZCA9IHRoaXMubGluZUVuZFBvcztcbiAgICAgICAgaWYgKHR5cGVvZiBlbmQgIT09ICdudW1iZXInIHx8IChlbmQgIT09IC0xICYmIGVuZCA8IHRoaXMucG9zKSkge1xuICAgICAgICAgICAgZW5kID0gdGhpcy5idWZmZXIuaW5kZXhPZignXFxuJywgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5saW5lRW5kUG9zID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPT09IC0xKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXRFbmQgPyB0aGlzLmJ1ZmZlci5zdWJzdHJpbmcodGhpcy5wb3MpIDogbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyW2VuZCAtIDFdID09PSAnXFxyJylcbiAgICAgICAgICAgIGVuZCAtPSAxO1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIuc3Vic3RyaW5nKHRoaXMucG9zLCBlbmQpO1xuICAgIH1cbiAgICBoYXNDaGFycyhuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyArIG4gPD0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgIH1cbiAgICBzZXROZXh0KHN0YXRlKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIuc3Vic3RyaW5nKHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmxpbmVFbmRQb3MgPSBudWxsO1xuICAgICAgICB0aGlzLm5leHQgPSBzdGF0ZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHBlZWsobikge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIuc3Vic3RyKHRoaXMucG9zLCBuKTtcbiAgICB9XG4gICAgKnBhcnNlTmV4dChuZXh0KSB7XG4gICAgICAgIHN3aXRjaCAobmV4dCkge1xuICAgICAgICAgICAgY2FzZSAnc3RyZWFtJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VTdHJlYW0oKTtcbiAgICAgICAgICAgIGNhc2UgJ2xpbmUtc3RhcnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUxpbmVTdGFydCgpO1xuICAgICAgICAgICAgY2FzZSAnYmxvY2stc3RhcnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUJsb2NrU3RhcnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ2RvYyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlRG9jdW1lbnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ2Zsb3cnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUZsb3dDb2xsZWN0aW9uKCk7XG4gICAgICAgICAgICBjYXNlICdxdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VRdW90ZWRTY2FsYXIoKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlQmxvY2tTY2FsYXIoKTtcbiAgICAgICAgICAgIGNhc2UgJ3BsYWluLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlUGxhaW5TY2FsYXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqcGFyc2VTdHJlYW0oKSB7XG4gICAgICAgIGxldCBsaW5lID0gdGhpcy5nZXRMaW5lKCk7XG4gICAgICAgIGlmIChsaW5lID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgnc3RyZWFtJyk7XG4gICAgICAgIGlmIChsaW5lWzBdID09PSBjc3QuQk9NKSB7XG4gICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQoMSk7XG4gICAgICAgICAgICBsaW5lID0gbGluZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmVbMF0gPT09ICclJykge1xuICAgICAgICAgICAgbGV0IGRpckVuZCA9IGxpbmUubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGNzID0gbGluZS5pbmRleE9mKCcjJyk7XG4gICAgICAgICAgICB3aGlsZSAoY3MgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2ggPSBsaW5lW2NzIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnICcgfHwgY2ggPT09ICdcXHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpckVuZCA9IGNzIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjcyA9IGxpbmUuaW5kZXhPZignIycsIGNzICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaCA9IGxpbmVbZGlyRW5kIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnICcgfHwgY2ggPT09ICdcXHQnKVxuICAgICAgICAgICAgICAgICAgICBkaXJFbmQgLT0gMTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbiA9ICh5aWVsZCogdGhpcy5wdXNoQ291bnQoZGlyRW5kKSkgKyAoeWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKSk7XG4gICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQobGluZS5sZW5ndGggLSBuKTsgLy8gcG9zc2libGUgY29tbWVudFxuICAgICAgICAgICAgdGhpcy5wdXNoTmV3bGluZSgpO1xuICAgICAgICAgICAgcmV0dXJuICdzdHJlYW0nO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF0TGluZUVuZCgpKSB7XG4gICAgICAgICAgICBjb25zdCBzcCA9IHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSk7XG4gICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQobGluZS5sZW5ndGggLSBzcCk7XG4gICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoTmV3bGluZSgpO1xuICAgICAgICAgICAgcmV0dXJuICdzdHJlYW0nO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIGNzdC5ET0NVTUVOVDtcbiAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlTGluZVN0YXJ0KCk7XG4gICAgfVxuICAgICpwYXJzZUxpbmVTdGFydCgpIHtcbiAgICAgICAgY29uc3QgY2ggPSB0aGlzLmNoYXJBdCgwKTtcbiAgICAgICAgaWYgKCFjaCAmJiAhdGhpcy5hdEVuZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE5leHQoJ2xpbmUtc3RhcnQnKTtcbiAgICAgICAgaWYgKGNoID09PSAnLScgfHwgY2ggPT09ICcuJykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmF0RW5kICYmICF0aGlzLmhhc0NoYXJzKDQpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE5leHQoJ2xpbmUtc3RhcnQnKTtcbiAgICAgICAgICAgIGNvbnN0IHMgPSB0aGlzLnBlZWsoMyk7XG4gICAgICAgICAgICBpZiAoKHMgPT09ICctLS0nIHx8IHMgPT09ICcuLi4nKSAmJiBpc0VtcHR5KHRoaXMuY2hhckF0KDMpKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudFZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudE5leHQgPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiBzID09PSAnLS0tJyA/ICdkb2MnIDogJ3N0cmVhbSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmRlbnRWYWx1ZSA9IHlpZWxkKiB0aGlzLnB1c2hTcGFjZXMoZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5pbmRlbnROZXh0ID4gdGhpcy5pbmRlbnRWYWx1ZSAmJiAhaXNFbXB0eSh0aGlzLmNoYXJBdCgxKSkpXG4gICAgICAgICAgICB0aGlzLmluZGVudE5leHQgPSB0aGlzLmluZGVudFZhbHVlO1xuICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VCbG9ja1N0YXJ0KCk7XG4gICAgfVxuICAgICpwYXJzZUJsb2NrU3RhcnQoKSB7XG4gICAgICAgIGNvbnN0IFtjaDAsIGNoMV0gPSB0aGlzLnBlZWsoMik7XG4gICAgICAgIGlmICghY2gxICYmICF0aGlzLmF0RW5kKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgnYmxvY2stc3RhcnQnKTtcbiAgICAgICAgaWYgKChjaDAgPT09ICctJyB8fCBjaDAgPT09ICc/JyB8fCBjaDAgPT09ICc6JykgJiYgaXNFbXB0eShjaDEpKSB7XG4gICAgICAgICAgICBjb25zdCBuID0gKHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKSkgKyAoeWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKSk7XG4gICAgICAgICAgICB0aGlzLmluZGVudE5leHQgPSB0aGlzLmluZGVudFZhbHVlICsgMTtcbiAgICAgICAgICAgIHRoaXMuaW5kZW50VmFsdWUgKz0gbjtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUJsb2NrU3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ2RvYyc7XG4gICAgfVxuICAgICpwYXJzZURvY3VtZW50KCkge1xuICAgICAgICB5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpO1xuICAgICAgICBjb25zdCBsaW5lID0gdGhpcy5nZXRMaW5lKCk7XG4gICAgICAgIGlmIChsaW5lID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgnZG9jJyk7XG4gICAgICAgIGxldCBuID0geWllbGQqIHRoaXMucHVzaEluZGljYXRvcnMoKTtcbiAgICAgICAgc3dpdGNoIChsaW5lW25dKSB7XG4gICAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQobGluZS5sZW5ndGggLSBuKTtcbiAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoTmV3bGluZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUxpbmVTdGFydCgpO1xuICAgICAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQoMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5mbG93S2V5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5mbG93TGV2ZWwgPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiAnZmxvdyc7XG4gICAgICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICAgIGNhc2UgJ10nOlxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQoMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdkb2MnO1xuICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaFVudGlsKGlzTm90QW5jaG9yQ2hhcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdkb2MnO1xuICAgICAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VRdW90ZWRTY2FsYXIoKTtcbiAgICAgICAgICAgIGNhc2UgJ3wnOlxuICAgICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICAgICAgbiArPSB5aWVsZCogdGhpcy5wYXJzZUJsb2NrU2NhbGFySGVhZGVyKCk7XG4gICAgICAgICAgICAgICAgbiArPSB5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpO1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudChsaW5lLmxlbmd0aCAtIG4pO1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hOZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlQmxvY2tTY2FsYXIoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlUGxhaW5TY2FsYXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqcGFyc2VGbG93Q29sbGVjdGlvbigpIHtcbiAgICAgICAgbGV0IG5sLCBzcDtcbiAgICAgICAgbGV0IGluZGVudCA9IC0xO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBubCA9IHlpZWxkKiB0aGlzLnB1c2hOZXdsaW5lKCk7XG4gICAgICAgICAgICBpZiAobmwgPiAwKSB7XG4gICAgICAgICAgICAgICAgc3AgPSB5aWVsZCogdGhpcy5wdXNoU3BhY2VzKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudFZhbHVlID0gaW5kZW50ID0gc3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzcCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzcCArPSB5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpO1xuICAgICAgICB9IHdoaWxlIChubCArIHNwID4gMCk7XG4gICAgICAgIGNvbnN0IGxpbmUgPSB0aGlzLmdldExpbmUoKTtcbiAgICAgICAgaWYgKGxpbmUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdmbG93Jyk7XG4gICAgICAgIGlmICgoaW5kZW50ICE9PSAtMSAmJiBpbmRlbnQgPCB0aGlzLmluZGVudE5leHQgJiYgbGluZVswXSAhPT0gJyMnKSB8fFxuICAgICAgICAgICAgKGluZGVudCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIChsaW5lLnN0YXJ0c1dpdGgoJy0tLScpIHx8IGxpbmUuc3RhcnRzV2l0aCgnLi4uJykpICYmXG4gICAgICAgICAgICAgICAgaXNFbXB0eShsaW5lWzNdKSkpIHtcbiAgICAgICAgICAgIC8vIEFsbG93aW5nIGZvciB0aGUgdGVybWluYWwgXSBvciB9IGF0IHRoZSBzYW1lIChyYXRoZXIgdGhhbiBncmVhdGVyKVxuICAgICAgICAgICAgLy8gaW5kZW50IGxldmVsIGFzIHRoZSBpbml0aWFsIFsgb3IgeyBpcyB0ZWNobmljYWxseSBpbnZhbGlkLCBidXRcbiAgICAgICAgICAgIC8vIGZhaWxpbmcgaGVyZSB3b3VsZCBiZSBzdXJwcmlzaW5nIHRvIHVzZXJzLlxuICAgICAgICAgICAgY29uc3QgYXRGbG93RW5kTWFya2VyID0gaW5kZW50ID09PSB0aGlzLmluZGVudE5leHQgLSAxICYmXG4gICAgICAgICAgICAgICAgdGhpcy5mbG93TGV2ZWwgPT09IDEgJiZcbiAgICAgICAgICAgICAgICAobGluZVswXSA9PT0gJ10nIHx8IGxpbmVbMF0gPT09ICd9Jyk7XG4gICAgICAgICAgICBpZiAoIWF0Rmxvd0VuZE1hcmtlcikge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dMZXZlbCA9IDA7XG4gICAgICAgICAgICAgICAgeWllbGQgY3N0LkZMT1dfRU5EO1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUxpbmVTdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBuID0gMDtcbiAgICAgICAgd2hpbGUgKGxpbmVbbl0gPT09ICcsJykge1xuICAgICAgICAgICAgbiArPSB5aWVsZCogdGhpcy5wdXNoQ291bnQoMSk7XG4gICAgICAgICAgICBuICs9IHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmZsb3dLZXkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBuICs9IHlpZWxkKiB0aGlzLnB1c2hJbmRpY2F0b3JzKCk7XG4gICAgICAgIHN3aXRjaCAobGluZVtuXSkge1xuICAgICAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdmbG93JztcbiAgICAgICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudChsaW5lLmxlbmd0aCAtIG4pO1xuICAgICAgICAgICAgICAgIHJldHVybiAnZmxvdyc7XG4gICAgICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dLZXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dMZXZlbCArPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiAnZmxvdyc7XG4gICAgICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICAgIGNhc2UgJ10nOlxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dLZXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0xldmVsIC09IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmxvd0xldmVsID8gJ2Zsb3cnIDogJ2RvYyc7XG4gICAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoVW50aWwoaXNOb3RBbmNob3JDaGFyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2Zsb3cnO1xuICAgICAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dLZXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZVF1b3RlZFNjYWxhcigpO1xuICAgICAgICAgICAgY2FzZSAnOic6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5jaGFyQXQoMSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmxvd0tleSB8fCBpc0VtcHR5KG5leHQpIHx8IG5leHQgPT09ICcsJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZsb3dLZXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KDEpO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2Zsb3cnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0tleSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZVBsYWluU2NhbGFyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKnBhcnNlUXVvdGVkU2NhbGFyKCkge1xuICAgICAgICBjb25zdCBxdW90ZSA9IHRoaXMuY2hhckF0KDApO1xuICAgICAgICBsZXQgZW5kID0gdGhpcy5idWZmZXIuaW5kZXhPZihxdW90ZSwgdGhpcy5wb3MgKyAxKTtcbiAgICAgICAgaWYgKHF1b3RlID09PSBcIidcIikge1xuICAgICAgICAgICAgd2hpbGUgKGVuZCAhPT0gLTEgJiYgdGhpcy5idWZmZXJbZW5kICsgMV0gPT09IFwiJ1wiKVxuICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMuYnVmZmVyLmluZGV4T2YoXCInXCIsIGVuZCArIDIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZG91YmxlLXF1b3RlXG4gICAgICAgICAgICB3aGlsZSAoZW5kICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGxldCBuID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5idWZmZXJbZW5kIC0gMSAtIG5dID09PSAnXFxcXCcpXG4gICAgICAgICAgICAgICAgICAgIG4gKz0gMTtcbiAgICAgICAgICAgICAgICBpZiAobiAlIDIgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMuYnVmZmVyLmluZGV4T2YoJ1wiJywgZW5kICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSBsb29raW5nIGZvciBuZXdsaW5lcyB3aXRoaW4gdGhlIHF1b3Rlc1xuICAgICAgICBjb25zdCBxYiA9IHRoaXMuYnVmZmVyLnN1YnN0cmluZygwLCBlbmQpO1xuICAgICAgICBsZXQgbmwgPSBxYi5pbmRleE9mKCdcXG4nLCB0aGlzLnBvcyk7XG4gICAgICAgIGlmIChubCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHdoaWxlIChubCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjcyA9IHRoaXMuY29udGludWVTY2FsYXIobmwgKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAoY3MgPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBubCA9IHFiLmluZGV4T2YoJ1xcbicsIGNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChubCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGFuIGVycm9yIGNhdXNlZCBieSBhbiB1bmV4cGVjdGVkIHVuaW5kZW50XG4gICAgICAgICAgICAgICAgZW5kID0gbmwgLSAocWJbbmwgLSAxXSA9PT0gJ1xccicgPyAyIDogMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hdEVuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdxdW90ZWQtc2NhbGFyJyk7XG4gICAgICAgICAgICBlbmQgPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQqIHRoaXMucHVzaFRvSW5kZXgoZW5kICsgMSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5mbG93TGV2ZWwgPyAnZmxvdycgOiAnZG9jJztcbiAgICB9XG4gICAgKnBhcnNlQmxvY2tTY2FsYXJIZWFkZXIoKSB7XG4gICAgICAgIHRoaXMuYmxvY2tTY2FsYXJJbmRlbnQgPSAtMTtcbiAgICAgICAgdGhpcy5ibG9ja1NjYWxhcktlZXAgPSBmYWxzZTtcbiAgICAgICAgbGV0IGkgPSB0aGlzLnBvcztcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoID0gdGhpcy5idWZmZXJbKytpXTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJysnKVxuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tTY2FsYXJLZWVwID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoID4gJzAnICYmIGNoIDw9ICc5JylcbiAgICAgICAgICAgICAgICB0aGlzLmJsb2NrU2NhbGFySW5kZW50ID0gTnVtYmVyKGNoKSAtIDE7XG4gICAgICAgICAgICBlbHNlIGlmIChjaCAhPT0gJy0nKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wdXNoVW50aWwoY2ggPT4gaXNFbXB0eShjaCkgfHwgY2ggPT09ICcjJyk7XG4gICAgfVxuICAgICpwYXJzZUJsb2NrU2NhbGFyKCkge1xuICAgICAgICBsZXQgbmwgPSB0aGlzLnBvcyAtIDE7IC8vIG1heSBiZSAtMSBpZiB0aGlzLnBvcyA9PT0gMFxuICAgICAgICBsZXQgaW5kZW50ID0gMDtcbiAgICAgICAgbGV0IGNoO1xuICAgICAgICBsb29wOiBmb3IgKGxldCBpID0gdGhpcy5wb3M7IChjaCA9IHRoaXMuYnVmZmVyW2ldKTsgKytpKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnICc6XG4gICAgICAgICAgICAgICAgICAgIGluZGVudCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdcXG4nOlxuICAgICAgICAgICAgICAgICAgICBubCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGluZGVudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1xccic6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuYnVmZmVyW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXh0ICYmICF0aGlzLmF0RW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgnYmxvY2stc2NhbGFyJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID09PSAnXFxuJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghY2ggJiYgIXRoaXMuYXRFbmQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdibG9jay1zY2FsYXInKTtcbiAgICAgICAgaWYgKGluZGVudCA+PSB0aGlzLmluZGVudE5leHQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJsb2NrU2NhbGFySW5kZW50ID09PSAtMSlcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudE5leHQgPSBpbmRlbnQ7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudE5leHQgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJsb2NrU2NhbGFySW5kZW50ICsgKHRoaXMuaW5kZW50TmV4dCA9PT0gMCA/IDEgOiB0aGlzLmluZGVudE5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNzID0gdGhpcy5jb250aW51ZVNjYWxhcihubCArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChjcyA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIG5sID0gdGhpcy5idWZmZXIuaW5kZXhPZignXFxuJywgY3MpO1xuICAgICAgICAgICAgfSB3aGlsZSAobmwgIT09IC0xKTtcbiAgICAgICAgICAgIGlmIChubCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYXRFbmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE5leHQoJ2Jsb2NrLXNjYWxhcicpO1xuICAgICAgICAgICAgICAgIG5sID0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRyYWlsaW5nIGluc3VmZmljaWVudGx5IGluZGVudGVkIHRhYnMgYXJlIGludmFsaWQuXG4gICAgICAgIC8vIFRvIGNhdGNoIHRoYXQgZHVyaW5nIHBhcnNpbmcsIHdlIGluY2x1ZGUgdGhlbSBpbiB0aGUgYmxvY2sgc2NhbGFyIHZhbHVlLlxuICAgICAgICBsZXQgaSA9IG5sICsgMTtcbiAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlcltpXTtcbiAgICAgICAgd2hpbGUgKGNoID09PSAnICcpXG4gICAgICAgICAgICBjaCA9IHRoaXMuYnVmZmVyWysraV07XG4gICAgICAgIGlmIChjaCA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICAgIHdoaWxlIChjaCA9PT0gJ1xcdCcgfHwgY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xccicgfHwgY2ggPT09ICdcXG4nKVxuICAgICAgICAgICAgICAgIGNoID0gdGhpcy5idWZmZXJbKytpXTtcbiAgICAgICAgICAgIG5sID0gaSAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuYmxvY2tTY2FsYXJLZWVwKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSBubCAtIDE7XG4gICAgICAgICAgICAgICAgbGV0IGNoID0gdGhpcy5idWZmZXJbaV07XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJylcbiAgICAgICAgICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclstLWldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RDaGFyID0gaTsgLy8gRHJvcCB0aGUgbGluZSBpZiBsYXN0IGNoYXIgbm90IG1vcmUgaW5kZW50ZWRcbiAgICAgICAgICAgICAgICB3aGlsZSAoY2ggPT09ICcgJylcbiAgICAgICAgICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclstLWldO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcbicgJiYgaSA+PSB0aGlzLnBvcyAmJiBpICsgMSArIGluZGVudCA+IGxhc3RDaGFyKVxuICAgICAgICAgICAgICAgICAgICBubCA9IGk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gd2hpbGUgKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIGNzdC5TQ0FMQVI7XG4gICAgICAgIHlpZWxkKiB0aGlzLnB1c2hUb0luZGV4KG5sICsgMSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUxpbmVTdGFydCgpO1xuICAgIH1cbiAgICAqcGFyc2VQbGFpblNjYWxhcigpIHtcbiAgICAgICAgY29uc3QgaW5GbG93ID0gdGhpcy5mbG93TGV2ZWwgPiAwO1xuICAgICAgICBsZXQgZW5kID0gdGhpcy5wb3MgLSAxO1xuICAgICAgICBsZXQgaSA9IHRoaXMucG9zIC0gMTtcbiAgICAgICAgbGV0IGNoO1xuICAgICAgICB3aGlsZSAoKGNoID0gdGhpcy5idWZmZXJbKytpXSkpIHtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJzonKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuYnVmZmVyW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShuZXh0KSB8fCAoaW5GbG93ICYmIGZsb3dJbmRpY2F0b3JDaGFycy5oYXMobmV4dCkpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNFbXB0eShjaCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMuYnVmZmVyW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXHInKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSB0aGlzLmJ1ZmZlcltpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgPT09ICcjJyB8fCAoaW5GbG93ICYmIGZsb3dJbmRpY2F0b3JDaGFycy5oYXMobmV4dCkpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNzID0gdGhpcy5jb250aW51ZVNjYWxhcihpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjcyA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgaSA9IE1hdGgubWF4KGksIGNzIC0gMik7IC8vIHRvIGFkdmFuY2UsIGJ1dCBzdGlsbCBhY2NvdW50IGZvciAnICMnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGluRmxvdyAmJiBmbG93SW5kaWNhdG9yQ2hhcnMuaGFzKGNoKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNoICYmICF0aGlzLmF0RW5kKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgncGxhaW4tc2NhbGFyJyk7XG4gICAgICAgIHlpZWxkIGNzdC5TQ0FMQVI7XG4gICAgICAgIHlpZWxkKiB0aGlzLnB1c2hUb0luZGV4KGVuZCArIDEsIHRydWUpO1xuICAgICAgICByZXR1cm4gaW5GbG93ID8gJ2Zsb3cnIDogJ2RvYyc7XG4gICAgfVxuICAgICpwdXNoQ291bnQobikge1xuICAgICAgICBpZiAobiA+IDApIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuYnVmZmVyLnN1YnN0cih0aGlzLnBvcywgbik7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSBuO1xuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgICpwdXNoVG9JbmRleChpLCBhbGxvd0VtcHR5KSB7XG4gICAgICAgIGNvbnN0IHMgPSB0aGlzLmJ1ZmZlci5zbGljZSh0aGlzLnBvcywgaSk7XG4gICAgICAgIGlmIChzKSB7XG4gICAgICAgICAgICB5aWVsZCBzO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gcy5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWxsb3dFbXB0eSlcbiAgICAgICAgICAgIHlpZWxkICcnO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgKnB1c2hJbmRpY2F0b3JzKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuY2hhckF0KDApKSB7XG4gICAgICAgICAgICBjYXNlICchJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKCh5aWVsZCogdGhpcy5wdXNoVGFnKCkpICtcbiAgICAgICAgICAgICAgICAgICAgKHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSkpICtcbiAgICAgICAgICAgICAgICAgICAgKHlpZWxkKiB0aGlzLnB1c2hJbmRpY2F0b3JzKCkpKTtcbiAgICAgICAgICAgIGNhc2UgJyYnOlxuICAgICAgICAgICAgICAgIHJldHVybiAoKHlpZWxkKiB0aGlzLnB1c2hVbnRpbChpc05vdEFuY2hvckNoYXIpKSArXG4gICAgICAgICAgICAgICAgICAgICh5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpKSArXG4gICAgICAgICAgICAgICAgICAgICh5aWVsZCogdGhpcy5wdXNoSW5kaWNhdG9ycygpKSk7XG4gICAgICAgICAgICBjYXNlICctJzogLy8gdGhpcyBpcyBhbiBlcnJvclxuICAgICAgICAgICAgY2FzZSAnPyc6IC8vIHRoaXMgaXMgYW4gZXJyb3Igb3V0c2lkZSBmbG93IGNvbGxlY3Rpb25zXG4gICAgICAgICAgICBjYXNlICc6Jzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluRmxvdyA9IHRoaXMuZmxvd0xldmVsID4gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBjaDEgPSB0aGlzLmNoYXJBdCgxKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShjaDEpIHx8IChpbkZsb3cgJiYgZmxvd0luZGljYXRvckNoYXJzLmhhcyhjaDEpKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWluRmxvdylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50TmV4dCA9IHRoaXMuaW5kZW50VmFsdWUgKyAxO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmZsb3dLZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZsb3dLZXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgoeWllbGQqIHRoaXMucHVzaENvdW50KDEpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoeWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHlpZWxkKiB0aGlzLnB1c2hJbmRpY2F0b3JzKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgICpwdXNoVGFnKCkge1xuICAgICAgICBpZiAodGhpcy5jaGFyQXQoMSkgPT09ICc8Jykge1xuICAgICAgICAgICAgbGV0IGkgPSB0aGlzLnBvcyArIDI7XG4gICAgICAgICAgICBsZXQgY2ggPSB0aGlzLmJ1ZmZlcltpXTtcbiAgICAgICAgICAgIHdoaWxlICghaXNFbXB0eShjaCkgJiYgY2ggIT09ICc+JylcbiAgICAgICAgICAgICAgICBjaCA9IHRoaXMuYnVmZmVyWysraV07XG4gICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucHVzaFRvSW5kZXgoY2ggPT09ICc+JyA/IGkgKyAxIDogaSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGkgPSB0aGlzLnBvcyArIDE7XG4gICAgICAgICAgICBsZXQgY2ggPSB0aGlzLmJ1ZmZlcltpXTtcbiAgICAgICAgICAgIHdoaWxlIChjaCkge1xuICAgICAgICAgICAgICAgIGlmICh0YWdDaGFycy5oYXMoY2gpKVxuICAgICAgICAgICAgICAgICAgICBjaCA9IHRoaXMuYnVmZmVyWysraV07XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09ICclJyAmJlxuICAgICAgICAgICAgICAgICAgICBoZXhEaWdpdHMuaGFzKHRoaXMuYnVmZmVyW2kgKyAxXSkgJiZcbiAgICAgICAgICAgICAgICAgICAgaGV4RGlnaXRzLmhhcyh0aGlzLmJ1ZmZlcltpICsgMl0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoID0gdGhpcy5idWZmZXJbKGkgKz0gMyldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnB1c2hUb0luZGV4KGksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqcHVzaE5ld2xpbmUoKSB7XG4gICAgICAgIGNvbnN0IGNoID0gdGhpcy5idWZmZXJbdGhpcy5wb3NdO1xuICAgICAgICBpZiAoY2ggPT09ICdcXG4nKVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKTtcbiAgICAgICAgZWxzZSBpZiAoY2ggPT09ICdcXHInICYmIHRoaXMuY2hhckF0KDEpID09PSAnXFxuJylcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wdXNoQ291bnQoMik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAqcHVzaFNwYWNlcyhhbGxvd1RhYnMpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzLnBvcyAtIDE7XG4gICAgICAgIGxldCBjaDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclsrK2ldO1xuICAgICAgICB9IHdoaWxlIChjaCA9PT0gJyAnIHx8IChhbGxvd1RhYnMgJiYgY2ggPT09ICdcXHQnKSk7XG4gICAgICAgIGNvbnN0IG4gPSBpIC0gdGhpcy5wb3M7XG4gICAgICAgIGlmIChuID4gMCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5idWZmZXIuc3Vic3RyKHRoaXMucG9zLCBuKTtcbiAgICAgICAgICAgIHRoaXMucG9zID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG4gICAgKnB1c2hVbnRpbCh0ZXN0KSB7XG4gICAgICAgIGxldCBpID0gdGhpcy5wb3M7XG4gICAgICAgIGxldCBjaCA9IHRoaXMuYnVmZmVyW2ldO1xuICAgICAgICB3aGlsZSAoIXRlc3QoY2gpKVxuICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclsrK2ldO1xuICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucHVzaFRvSW5kZXgoaSwgZmFsc2UpO1xuICAgIH1cbn1cblxuZXhwb3J0cy5MZXhlciA9IExleGVyO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVHJhY2tzIG5ld2xpbmVzIGR1cmluZyBwYXJzaW5nIGluIG9yZGVyIHRvIHByb3ZpZGUgYW4gZWZmaWNpZW50IEFQSSBmb3JcbiAqIGRldGVybWluaW5nIHRoZSBvbmUtaW5kZXhlZCBgeyBsaW5lLCBjb2wgfWAgcG9zaXRpb24gZm9yIGFueSBvZmZzZXRcbiAqIHdpdGhpbiB0aGUgaW5wdXQuXG4gKi9cbmNsYXNzIExpbmVDb3VudGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5saW5lU3RhcnRzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG91bGQgYmUgY2FsbGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLCBjYWxsXG4gICAgICAgICAqIGBsaW5lQ291bnRlci5saW5lU3RhcnRzLnNvcnQoKWAgYmVmb3JlIGNhbGxpbmcgYGxpbmVQb3MoKWAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFkZE5ld0xpbmUgPSAob2Zmc2V0KSA9PiB0aGlzLmxpbmVTdGFydHMucHVzaChvZmZzZXQpO1xuICAgICAgICAvKipcbiAgICAgICAgICogUGVyZm9ybXMgYSBiaW5hcnkgc2VhcmNoIGFuZCByZXR1cm5zIHRoZSAxLWluZGV4ZWQgeyBsaW5lLCBjb2wgfVxuICAgICAgICAgKiBwb3NpdGlvbiBvZiBgb2Zmc2V0YC4gSWYgYGxpbmUgPT09IDBgLCBgYWRkTmV3TGluZWAgaGFzIG5ldmVyIGJlZW5cbiAgICAgICAgICogY2FsbGVkIG9yIGBvZmZzZXRgIGlzIGJlZm9yZSB0aGUgZmlyc3Qga25vd24gbmV3bGluZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGluZVBvcyA9IChvZmZzZXQpID0+IHtcbiAgICAgICAgICAgIGxldCBsb3cgPSAwO1xuICAgICAgICAgICAgbGV0IGhpZ2ggPSB0aGlzLmxpbmVTdGFydHMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtaWQgPSAobG93ICsgaGlnaCkgPj4gMTsgLy8gTWF0aC5mbG9vcigobG93ICsgaGlnaCkgLyAyKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxpbmVTdGFydHNbbWlkXSA8IG9mZnNldClcbiAgICAgICAgICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5saW5lU3RhcnRzW2xvd10gPT09IG9mZnNldClcbiAgICAgICAgICAgICAgICByZXR1cm4geyBsaW5lOiBsb3cgKyAxLCBjb2w6IDEgfTtcbiAgICAgICAgICAgIGlmIChsb3cgPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbGluZTogMCwgY29sOiBvZmZzZXQgfTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5saW5lU3RhcnRzW2xvdyAtIDFdO1xuICAgICAgICAgICAgcmV0dXJuIHsgbGluZTogbG93LCBjb2w6IG9mZnNldCAtIHN0YXJ0ICsgMSB9O1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuZXhwb3J0cy5MaW5lQ291bnRlciA9IExpbmVDb3VudGVyO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBub2RlX3Byb2Nlc3MgPSByZXF1aXJlKCdwcm9jZXNzJyk7XG52YXIgY3N0ID0gcmVxdWlyZSgnLi9jc3QuanMnKTtcbnZhciBsZXhlciA9IHJlcXVpcmUoJy4vbGV4ZXIuanMnKTtcblxuZnVuY3Rpb24gaW5jbHVkZXNUb2tlbihsaXN0LCB0eXBlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAobGlzdFtpXS50eXBlID09PSB0eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZmluZE5vbkVtcHR5SW5kZXgobGlzdCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgICBzd2l0Y2ggKGxpc3RbaV0udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gaXNGbG93VG9rZW4odG9rZW4pIHtcbiAgICBzd2l0Y2ggKHRva2VuPy50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2FsaWFzJzpcbiAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgY2FzZSAnc2luZ2xlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICBjYXNlICdkb3VibGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgIGNhc2UgJ2Zsb3ctY29sbGVjdGlvbic6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRQcmV2UHJvcHMocGFyZW50KSB7XG4gICAgc3dpdGNoIChwYXJlbnQudHlwZSkge1xuICAgICAgICBjYXNlICdkb2N1bWVudCc6XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50LnN0YXJ0O1xuICAgICAgICBjYXNlICdibG9jay1tYXAnOiB7XG4gICAgICAgICAgICBjb25zdCBpdCA9IHBhcmVudC5pdGVtc1twYXJlbnQuaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICByZXR1cm4gaXQuc2VwID8/IGl0LnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2Jsb2NrLXNlcSc6XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50Lml0ZW1zW3BhcmVudC5pdGVtcy5sZW5ndGggLSAxXS5zdGFydDtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG4vKiogTm90ZTogTWF5IG1vZGlmeSBpbnB1dCBhcnJheSAqL1xuZnVuY3Rpb24gZ2V0Rmlyc3RLZXlTdGFydFByb3BzKHByZXYpIHtcbiAgICBpZiAocHJldi5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBsZXQgaSA9IHByZXYubGVuZ3RoO1xuICAgIGxvb3A6IHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICBzd2l0Y2ggKHByZXZbaV0udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnZG9jLXN0YXJ0JzpcbiAgICAgICAgICAgIGNhc2UgJ2V4cGxpY2l0LWtleS1pbmQnOlxuICAgICAgICAgICAgY2FzZSAnbWFwLXZhbHVlLWluZCc6XG4gICAgICAgICAgICBjYXNlICdzZXEtaXRlbS1pbmQnOlxuICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAocHJldlsrK2ldPy50eXBlID09PSAnc3BhY2UnKSB7XG4gICAgICAgIC8qIGxvb3AgKi9cbiAgICB9XG4gICAgcmV0dXJuIHByZXYuc3BsaWNlKGksIHByZXYubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGZpeEZsb3dTZXFJdGVtcyhmYykge1xuICAgIGlmIChmYy5zdGFydC50eXBlID09PSAnZmxvdy1zZXEtc3RhcnQnKSB7XG4gICAgICAgIGZvciAoY29uc3QgaXQgb2YgZmMuaXRlbXMpIHtcbiAgICAgICAgICAgIGlmIChpdC5zZXAgJiZcbiAgICAgICAgICAgICAgICAhaXQudmFsdWUgJiZcbiAgICAgICAgICAgICAgICAhaW5jbHVkZXNUb2tlbihpdC5zdGFydCwgJ2V4cGxpY2l0LWtleS1pbmQnKSAmJlxuICAgICAgICAgICAgICAgICFpbmNsdWRlc1Rva2VuKGl0LnNlcCwgJ21hcC12YWx1ZS1pbmQnKSkge1xuICAgICAgICAgICAgICAgIGlmIChpdC5rZXkpXG4gICAgICAgICAgICAgICAgICAgIGl0LnZhbHVlID0gaXQua2V5O1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpdC5rZXk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRmxvd1Rva2VuKGl0LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXQudmFsdWUuZW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoaXQudmFsdWUuZW5kLCBpdC5zZXApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpdC52YWx1ZS5lbmQgPSBpdC5zZXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoaXQuc3RhcnQsIGl0LnNlcCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGl0LnNlcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQSBZQU1MIGNvbmNyZXRlIHN5bnRheCB0cmVlIChDU1QpIHBhcnNlclxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBzcmM6IHN0cmluZyA9IC4uLlxuICogZm9yIChjb25zdCB0b2tlbiBvZiBuZXcgUGFyc2VyKCkucGFyc2Uoc3JjKSkge1xuICogICAvLyB0b2tlbjogVG9rZW5cbiAqIH1cbiAqIGBgYFxuICpcbiAqIFRvIHVzZSB0aGUgcGFyc2VyIHdpdGggYSB1c2VyLXByb3ZpZGVkIGxleGVyOlxuICpcbiAqIGBgYHRzXG4gKiBmdW5jdGlvbiogcGFyc2Uoc291cmNlOiBzdHJpbmcsIGxleGVyOiBMZXhlcikge1xuICogICBjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2VyKClcbiAqICAgZm9yIChjb25zdCBsZXhlbWUgb2YgbGV4ZXIubGV4KHNvdXJjZSkpXG4gKiAgICAgeWllbGQqIHBhcnNlci5uZXh0KGxleGVtZSlcbiAqICAgeWllbGQqIHBhcnNlci5lbmQoKVxuICogfVxuICpcbiAqIGNvbnN0IHNyYzogc3RyaW5nID0gLi4uXG4gKiBjb25zdCBsZXhlciA9IG5ldyBMZXhlcigpXG4gKiBmb3IgKGNvbnN0IHRva2VuIG9mIHBhcnNlKHNyYywgbGV4ZXIpKSB7XG4gKiAgIC8vIHRva2VuOiBUb2tlblxuICogfVxuICogYGBgXG4gKi9cbmNsYXNzIFBhcnNlciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9uTmV3TGluZSAtIElmIGRlZmluZWQsIGNhbGxlZCBzZXBhcmF0ZWx5IHdpdGggdGhlIHN0YXJ0IHBvc2l0aW9uIG9mXG4gICAgICogICBlYWNoIG5ldyBsaW5lIChpbiBgcGFyc2UoKWAsIGluY2x1ZGluZyB0aGUgc3RhcnQgb2YgaW5wdXQpLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9uTmV3TGluZSkge1xuICAgICAgICAvKiogSWYgdHJ1ZSwgc3BhY2UgYW5kIHNlcXVlbmNlIGluZGljYXRvcnMgY291bnQgYXMgaW5kZW50YXRpb24gKi9cbiAgICAgICAgdGhpcy5hdE5ld0xpbmUgPSB0cnVlO1xuICAgICAgICAvKiogSWYgdHJ1ZSwgbmV4dCB0b2tlbiBpcyBhIHNjYWxhciB2YWx1ZSAqL1xuICAgICAgICB0aGlzLmF0U2NhbGFyID0gZmFsc2U7XG4gICAgICAgIC8qKiBDdXJyZW50IGluZGVudGF0aW9uIGxldmVsICovXG4gICAgICAgIHRoaXMuaW5kZW50ID0gMDtcbiAgICAgICAgLyoqIEN1cnJlbnQgb2Zmc2V0IHNpbmNlIHRoZSBzdGFydCBvZiBwYXJzaW5nICovXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgICAgLyoqIE9uIHRoZSBzYW1lIGxpbmUgd2l0aCBhIGJsb2NrIG1hcCBrZXkgKi9cbiAgICAgICAgdGhpcy5vbktleUxpbmUgPSBmYWxzZTtcbiAgICAgICAgLyoqIFRvcCBpbmRpY2F0ZXMgdGhlIG5vZGUgdGhhdCdzIGN1cnJlbnRseSBiZWluZyBidWlsdCAqL1xuICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICAgIC8qKiBUaGUgc291cmNlIG9mIHRoZSBjdXJyZW50IHRva2VuLCBzZXQgaW4gcGFyc2UoKSAqL1xuICAgICAgICB0aGlzLnNvdXJjZSA9ICcnO1xuICAgICAgICAvKiogVGhlIHR5cGUgb2YgdGhlIGN1cnJlbnQgdG9rZW4sIHNldCBpbiBwYXJzZSgpICovXG4gICAgICAgIHRoaXMudHlwZSA9ICcnO1xuICAgICAgICAvLyBNdXN0IGJlIGRlZmluZWQgYWZ0ZXIgYG5leHQoKWBcbiAgICAgICAgdGhpcy5sZXhlciA9IG5ldyBsZXhlci5MZXhlcigpO1xuICAgICAgICB0aGlzLm9uTmV3TGluZSA9IG9uTmV3TGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgYHNvdXJjZWAgYXMgYSBZQU1MIHN0cmVhbS5cbiAgICAgKiBJZiBgaW5jb21wbGV0ZWAsIGEgcGFydCBvZiB0aGUgbGFzdCBsaW5lIG1heSBiZSBsZWZ0IGFzIGEgYnVmZmVyIGZvciB0aGUgbmV4dCBjYWxsLlxuICAgICAqXG4gICAgICogRXJyb3JzIGFyZSBub3QgdGhyb3duLCBidXQgeWllbGRlZCBhcyBgeyB0eXBlOiAnZXJyb3InLCBtZXNzYWdlIH1gIHRva2Vucy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgZ2VuZXJhdG9yIG9mIHRva2VucyByZXByZXNlbnRpbmcgZWFjaCBkaXJlY3RpdmUsIGRvY3VtZW50LCBhbmQgb3RoZXIgc3RydWN0dXJlLlxuICAgICAqL1xuICAgICpwYXJzZShzb3VyY2UsIGluY29tcGxldGUgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5vbk5ld0xpbmUgJiYgdGhpcy5vZmZzZXQgPT09IDApXG4gICAgICAgICAgICB0aGlzLm9uTmV3TGluZSgwKTtcbiAgICAgICAgZm9yIChjb25zdCBsZXhlbWUgb2YgdGhpcy5sZXhlci5sZXgoc291cmNlLCBpbmNvbXBsZXRlKSlcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLm5leHQobGV4ZW1lKTtcbiAgICAgICAgaWYgKCFpbmNvbXBsZXRlKVxuICAgICAgICAgICAgeWllbGQqIHRoaXMuZW5kKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkdmFuY2UgdGhlIHBhcnNlciBieSB0aGUgYHNvdXJjZWAgb2Ygb25lIGxleGljYWwgdG9rZW4uXG4gICAgICovXG4gICAgKm5leHQoc291cmNlKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICBpZiAobm9kZV9wcm9jZXNzLmVudi5MT0dfVE9LRU5TKVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ3wnLCBjc3QucHJldHR5VG9rZW4oc291cmNlKSk7XG4gICAgICAgIGlmICh0aGlzLmF0U2NhbGFyKSB7XG4gICAgICAgICAgICB0aGlzLmF0U2NhbGFyID0gZmFsc2U7XG4gICAgICAgICAgICB5aWVsZCogdGhpcy5zdGVwKCk7XG4gICAgICAgICAgICB0aGlzLm9mZnNldCArPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGUgPSBjc3QudG9rZW5UeXBlKHNvdXJjZSk7XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBOb3QgYSBZQU1MIHRva2VuOiAke3NvdXJjZX1gO1xuICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKHsgdHlwZTogJ2Vycm9yJywgb2Zmc2V0OiB0aGlzLm9mZnNldCwgbWVzc2FnZSwgc291cmNlIH0pO1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnc2NhbGFyJykge1xuICAgICAgICAgICAgdGhpcy5hdE5ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuYXRTY2FsYXIgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy50eXBlID0gJ3NjYWxhcic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgeWllbGQqIHRoaXMuc3RlcCgpO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXROZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRlbnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vbk5ld0xpbmUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTmV3TGluZSh0aGlzLm9mZnNldCArIHNvdXJjZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0TmV3TGluZSAmJiBzb3VyY2VbMF0gPT09ICcgJylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50ICs9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2V4cGxpY2l0LWtleS1pbmQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ21hcC12YWx1ZS1pbmQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3NlcS1pdGVtLWluZCc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0TmV3TGluZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50ICs9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RvYy1tb2RlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdmbG93LWVycm9yLWVuZCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0TmV3TGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQ2FsbCBhdCBlbmQgb2YgaW5wdXQgdG8gcHVzaCBvdXQgYW55IHJlbWFpbmluZyBjb25zdHJ1Y3Rpb25zICovXG4gICAgKmVuZCgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuc3RhY2subGVuZ3RoID4gMClcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgIH1cbiAgICBnZXQgc291cmNlVG9rZW4oKSB7XG4gICAgICAgIGNvbnN0IHN0ID0ge1xuICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzdDtcbiAgICB9XG4gICAgKnN0ZXAoKSB7XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygxKTtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2RvYy1lbmQnICYmIHRvcD8udHlwZSAhPT0gJ2RvYy1lbmQnKSB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5zdGFjay5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZG9jLWVuZCcsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRvcClcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5zdHJlYW0oKTtcbiAgICAgICAgc3dpdGNoICh0b3AudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnZG9jdW1lbnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5kb2N1bWVudCh0b3ApO1xuICAgICAgICAgICAgY2FzZSAnYWxpYXMnOlxuICAgICAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgIGNhc2UgJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMuc2NhbGFyKHRvcCk7XG4gICAgICAgICAgICBjYXNlICdibG9jay1zY2FsYXInOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5ibG9ja1NjYWxhcih0b3ApO1xuICAgICAgICAgICAgY2FzZSAnYmxvY2stbWFwJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMuYmxvY2tNYXAodG9wKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLXNlcSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLmJsb2NrU2VxdWVuY2UodG9wKTtcbiAgICAgICAgICAgIGNhc2UgJ2Zsb3ctY29sbGVjdGlvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLmZsb3dDb2xsZWN0aW9uKHRvcCk7XG4gICAgICAgICAgICBjYXNlICdkb2MtZW5kJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMuZG9jdW1lbnRFbmQodG9wKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICB9XG4gICAgcGVlayhuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gbl07XG4gICAgfVxuICAgICpwb3AoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBlcnJvciA/PyB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdUcmllZCB0byBwb3AgYW4gZW1wdHkgc3RhY2snO1xuICAgICAgICAgICAgeWllbGQgeyB0eXBlOiAnZXJyb3InLCBvZmZzZXQ6IHRoaXMub2Zmc2V0LCBzb3VyY2U6ICcnLCBtZXNzYWdlIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHlpZWxkIHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrKDEpO1xuICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdibG9jay1zY2FsYXInKSB7XG4gICAgICAgICAgICAgICAgLy8gQmxvY2sgc2NhbGFycyB1c2UgdGhlaXIgcGFyZW50IHJhdGhlciB0aGFuIGhlYWRlciBpbmRlbnRcbiAgICAgICAgICAgICAgICB0b2tlbi5pbmRlbnQgPSAnaW5kZW50JyBpbiB0b3AgPyB0b3AuaW5kZW50IDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09ICdmbG93LWNvbGxlY3Rpb24nICYmIHRvcC50eXBlID09PSAnZG9jdW1lbnQnKSB7XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIGFsbCBpbmRlbnQgZm9yIHRvcC1sZXZlbCBmbG93IGNvbGxlY3Rpb25zXG4gICAgICAgICAgICAgICAgdG9rZW4uaW5kZW50ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnZmxvdy1jb2xsZWN0aW9uJylcbiAgICAgICAgICAgICAgICBmaXhGbG93U2VxSXRlbXModG9rZW4pO1xuICAgICAgICAgICAgc3dpdGNoICh0b3AudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RvY3VtZW50JzpcbiAgICAgICAgICAgICAgICAgICAgdG9wLnZhbHVlID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgICAgIHRvcC5wcm9wcy5wdXNoKHRva2VuKTsgLy8gZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYmxvY2stbWFwJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdCA9IHRvcC5pdGVtc1t0b3AuaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wLml0ZW1zLnB1c2goeyBzdGFydDogW10sIGtleTogdG9rZW4sIHNlcDogW10gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXQuc2VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdC52YWx1ZSA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpdCwgeyBrZXk6IHRva2VuLCBzZXA6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSAhaXQuZXhwbGljaXRLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLXNlcSc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXQgPSB0b3AuaXRlbXNbdG9wLml0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AuaXRlbXMucHVzaCh7IHN0YXJ0OiBbXSwgdmFsdWU6IHRva2VuIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpdC52YWx1ZSA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnZmxvdy1jb2xsZWN0aW9uJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdCA9IHRvcC5pdGVtc1t0b3AuaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXQgfHwgaXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AuaXRlbXMucHVzaCh7IHN0YXJ0OiBbXSwga2V5OiB0b2tlbiwgc2VwOiBbXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXQuc2VwKVxuICAgICAgICAgICAgICAgICAgICAgICAgaXQudmFsdWUgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpdCwgeyBrZXk6IHRva2VuLCBzZXA6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IHNob3VsZCBub3QgaGFwcGVuICovXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRvcC50eXBlID09PSAnZG9jdW1lbnQnIHx8XG4gICAgICAgICAgICAgICAgdG9wLnR5cGUgPT09ICdibG9jay1tYXAnIHx8XG4gICAgICAgICAgICAgICAgdG9wLnR5cGUgPT09ICdibG9jay1zZXEnKSAmJlxuICAgICAgICAgICAgICAgICh0b2tlbi50eXBlID09PSAnYmxvY2stbWFwJyB8fCB0b2tlbi50eXBlID09PSAnYmxvY2stc2VxJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0ID0gdG9rZW4uaXRlbXNbdG9rZW4uaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QgJiZcbiAgICAgICAgICAgICAgICAgICAgIWxhc3Quc2VwICYmXG4gICAgICAgICAgICAgICAgICAgICFsYXN0LnZhbHVlICYmXG4gICAgICAgICAgICAgICAgICAgIGxhc3Quc3RhcnQubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmaW5kTm9uRW1wdHlJbmRleChsYXN0LnN0YXJ0KSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgKHRva2VuLmluZGVudCA9PT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdC5zdGFydC5ldmVyeShzdCA9PiBzdC50eXBlICE9PSAnY29tbWVudCcgfHwgc3QuaW5kZW50IDwgdG9rZW4uaW5kZW50KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvcC50eXBlID09PSAnZG9jdW1lbnQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wLmVuZCA9IGxhc3Quc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcC5pdGVtcy5wdXNoKHsgc3RhcnQ6IGxhc3Quc3RhcnQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuLml0ZW1zLnNwbGljZSgtMSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgICpzdHJlYW0oKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdkaXJlY3RpdmUtbGluZSc6XG4gICAgICAgICAgICAgICAgeWllbGQgeyB0eXBlOiAnZGlyZWN0aXZlJywgb2Zmc2V0OiB0aGlzLm9mZnNldCwgc291cmNlOiB0aGlzLnNvdXJjZSB9O1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ2J5dGUtb3JkZXItbWFyayc6XG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuc291cmNlVG9rZW47XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAnZG9jLW1vZGUnOlxuICAgICAgICAgICAgY2FzZSAnZG9jLXN0YXJ0Jzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvYyA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RvY3VtZW50JyxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnZG9jLXN0YXJ0JylcbiAgICAgICAgICAgICAgICAgICAgZG9jLnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGRvYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHlpZWxkIHtcbiAgICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgbWVzc2FnZTogYFVuZXhwZWN0ZWQgJHt0aGlzLnR5cGV9IHRva2VuIGluIFlBTUwgc3RyZWFtYCxcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2VcbiAgICAgICAgfTtcbiAgICB9XG4gICAgKmRvY3VtZW50KGRvYykge1xuICAgICAgICBpZiAoZG9jLnZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLmxpbmVFbmQoZG9jKTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RvYy1zdGFydCc6IHtcbiAgICAgICAgICAgICAgICBpZiAoZmluZE5vbkVtcHR5SW5kZXgoZG9jLnN0YXJ0KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnN0ZXAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBkb2Muc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdhbmNob3InOlxuICAgICAgICAgICAgY2FzZSAndGFnJzpcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgZG9jLnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ2ID0gdGhpcy5zdGFydEJsb2NrVmFsdWUoZG9jKTtcbiAgICAgICAgaWYgKGJ2KVxuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGJ2KTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBVbmV4cGVjdGVkICR7dGhpcy50eXBlfSB0b2tlbiBpbiBZQU1MIGRvY3VtZW50YCxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgICpzY2FsYXIoc2NhbGFyKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdtYXAtdmFsdWUtaW5kJykge1xuICAgICAgICAgICAgY29uc3QgcHJldiA9IGdldFByZXZQcm9wcyh0aGlzLnBlZWsoMikpO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBnZXRGaXJzdEtleVN0YXJ0UHJvcHMocHJldik7XG4gICAgICAgICAgICBsZXQgc2VwO1xuICAgICAgICAgICAgaWYgKHNjYWxhci5lbmQpIHtcbiAgICAgICAgICAgICAgICBzZXAgPSBzY2FsYXIuZW5kO1xuICAgICAgICAgICAgICAgIHNlcC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2FsYXIuZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNlcCA9IFt0aGlzLnNvdXJjZVRva2VuXTtcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2stbWFwJyxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHNjYWxhci5vZmZzZXQsXG4gICAgICAgICAgICAgICAgaW5kZW50OiBzY2FsYXIuaW5kZW50LFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbeyBzdGFydCwga2V5OiBzY2FsYXIsIHNlcCB9XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXSA9IG1hcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB5aWVsZCogdGhpcy5saW5lRW5kKHNjYWxhcik7XG4gICAgfVxuICAgICpibG9ja1NjYWxhcihzY2FsYXIpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgc2NhbGFyLnByb3BzLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgICAgICAgICBzY2FsYXIuc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgICAgICAgICAgICAgLy8gYmxvY2stc2NhbGFyIHNvdXJjZSBpbmNsdWRlcyB0cmFpbGluZyBuZXdsaW5lXG4gICAgICAgICAgICAgICAgdGhpcy5hdE5ld0xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbk5ld0xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5sID0gdGhpcy5zb3VyY2UuaW5kZXhPZignXFxuJykgKyAxO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobmwgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25OZXdMaW5lKHRoaXMub2Zmc2V0ICsgbmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmwgPSB0aGlzLnNvdXJjZS5pbmRleE9mKCdcXG4nLCBubCkgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMuc3RlcCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgICpibG9ja01hcChtYXApIHtcbiAgICAgICAgY29uc3QgaXQgPSBtYXAuaXRlbXNbbWFwLml0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICAvLyBpdC5zZXAgaXMgdHJ1ZS1pc2ggaWYgcGFpciBhbHJlYWR5IGhhcyBrZXkgb3IgOiBzZXBhcmF0b3JcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKGl0LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9ICdlbmQnIGluIGl0LnZhbHVlID8gaXQudmFsdWUuZW5kIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0ID0gQXJyYXkuaXNBcnJheShlbmQpID8gZW5kW2VuZC5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3Q/LnR5cGUgPT09ICdjb21tZW50JylcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZD8ucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2goeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApIHtcbiAgICAgICAgICAgICAgICAgICAgaXQuc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICBpZiAoaXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2goeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApIHtcbiAgICAgICAgICAgICAgICAgICAgaXQuc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdEluZGVudGVkQ29tbWVudChpdC5zdGFydCwgbWFwLmluZGVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBtYXAuaXRlbXNbbWFwLml0ZW1zLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kID0gcHJldj8udmFsdWU/LmVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShlbmQsIGl0LnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXAuaXRlbXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGl0LnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmRlbnQgPj0gbWFwLmluZGVudCkge1xuICAgICAgICAgICAgY29uc3QgYXRNYXBJbmRlbnQgPSAhdGhpcy5vbktleUxpbmUgJiYgdGhpcy5pbmRlbnQgPT09IG1hcC5pbmRlbnQ7XG4gICAgICAgICAgICBjb25zdCBhdE5leHRJdGVtID0gYXRNYXBJbmRlbnQgJiZcbiAgICAgICAgICAgICAgICAoaXQuc2VwIHx8IGl0LmV4cGxpY2l0S2V5KSAmJlxuICAgICAgICAgICAgICAgIHRoaXMudHlwZSAhPT0gJ3NlcS1pdGVtLWluZCc7XG4gICAgICAgICAgICAvLyBGb3IgZW1wdHkgbm9kZXMsIGFzc2lnbiBuZXdsaW5lLXNlcGFyYXRlZCBub3QgaW5kZW50ZWQgZW1wdHkgdG9rZW5zIHRvIGZvbGxvd2luZyBub2RlXG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBbXTtcbiAgICAgICAgICAgIGlmIChhdE5leHRJdGVtICYmIGl0LnNlcCAmJiAhaXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBubCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXQuc2VwLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0ID0gaXQuc2VwW2ldO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5sLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3QuaW5kZW50ID4gbWFwLmluZGVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmwubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmwubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmwubGVuZ3RoID49IDIpXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gaXQuc2VwLnNwbGljZShubFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FuY2hvcic6XG4gICAgICAgICAgICAgICAgY2FzZSAndGFnJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0TmV4dEl0ZW0gfHwgaXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAuaXRlbXMucHVzaCh7IHN0YXJ0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0LnNlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXQuc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlICdleHBsaWNpdC1rZXktaW5kJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdC5zZXAgJiYgIWl0LmV4cGxpY2l0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXQuZXhwbGljaXRLZXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGF0TmV4dEl0ZW0gfHwgaXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAuaXRlbXMucHVzaCh7IHN0YXJ0LCBleHBsaWNpdEtleTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jsb2NrLW1hcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dLCBleHBsaWNpdEtleTogdHJ1ZSB9XVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSAnbWFwLXZhbHVlLWluZCc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdC5leHBsaWNpdEtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpdC5zZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZXNUb2tlbihpdC5zdGFydCwgJ25ld2xpbmUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGl0LCB7IGtleTogbnVsbCwgc2VwOiBbdGhpcy5zb3VyY2VUb2tlbl0gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IGdldEZpcnN0S2V5U3RhcnRQcm9wcyhpdC5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2stbWFwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFt7IHN0YXJ0LCBrZXk6IG51bGwsIHNlcDogW3RoaXMuc291cmNlVG9rZW5dIH1dXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2goeyBzdGFydDogW10sIGtleTogbnVsbCwgc2VwOiBbdGhpcy5zb3VyY2VUb2tlbl0gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpbmNsdWRlc1Rva2VuKGl0LnNlcCwgJ21hcC12YWx1ZS1pbmQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1tYXAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogW3sgc3RhcnQsIGtleTogbnVsbCwgc2VwOiBbdGhpcy5zb3VyY2VUb2tlbl0gfV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzRmxvd1Rva2VuKGl0LmtleSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaW5jbHVkZXNUb2tlbihpdC5zZXAsICduZXdsaW5lJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IGdldEZpcnN0S2V5U3RhcnRQcm9wcyhpdC5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gaXQua2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcCA9IGl0LnNlcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXAucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHR5cGUgZ3VhcmQgaXMgd3JvbmcgaGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBpdC5rZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciB0eXBlIGd1YXJkIGlzIHdyb25nIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgaXQuc2VwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1tYXAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogW3sgc3RhcnQsIGtleSwgc2VwIH1dXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGFydC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90IGFjdHVhbGx5IGF0IG5leHQgaXRlbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0LnNlcCA9IGl0LnNlcC5jb25jYXQoc3RhcnQsIHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXQuc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWl0LnNlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaXQsIHsga2V5OiBudWxsLCBzZXA6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0LnZhbHVlIHx8IGF0TmV4dEl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXAuaXRlbXMucHVzaCh7IHN0YXJ0LCBrZXk6IG51bGwsIHNlcDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5jbHVkZXNUb2tlbihpdC5zZXAsICdtYXAtdmFsdWUtaW5kJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2stbWFwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZW50OiB0aGlzLmluZGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFt7IHN0YXJ0OiBbXSwga2V5OiBudWxsLCBzZXA6IFt0aGlzLnNvdXJjZVRva2VuXSB9XVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXQuc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSAnYWxpYXMnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnc2luZ2xlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmcyA9IHRoaXMuZmxvd1NjYWxhcih0aGlzLnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXROZXh0SXRlbSB8fCBpdC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2goeyBzdGFydCwga2V5OiBmcywgc2VwOiBbXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChmcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGl0LCB7IGtleTogZnMsIHNlcDogW10gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ2ID0gdGhpcy5zdGFydEJsb2NrVmFsdWUobWFwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnYudHlwZSA9PT0gJ2Jsb2NrLXNlcScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWl0LmV4cGxpY2l0S2V5ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0LnNlcCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaW5jbHVkZXNUb2tlbihpdC5zZXAsICduZXdsaW5lJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdlcnJvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ1VuZXhwZWN0ZWQgYmxvY2stc2VxLWluZCBvbiBzYW1lIGxpbmUgd2l0aCBrZXknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGF0TWFwSW5kZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2goeyBzdGFydCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChidik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgICAgIHlpZWxkKiB0aGlzLnN0ZXAoKTtcbiAgICB9XG4gICAgKmJsb2NrU2VxdWVuY2Uoc2VxKSB7XG4gICAgICAgIGNvbnN0IGl0ID0gc2VxLml0ZW1zW3NlcS5pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIGlmIChpdC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSAnZW5kJyBpbiBpdC52YWx1ZSA/IGl0LnZhbHVlLmVuZCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IEFycmF5LmlzQXJyYXkoZW5kKSA/IGVuZFtlbmQubGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0Py50eXBlID09PSAnY29tbWVudCcpXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ/LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcS5pdGVtcy5wdXNoKHsgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgICAgIGlmIChpdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgc2VxLml0ZW1zLnB1c2goeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdEluZGVudGVkQ29tbWVudChpdC5zdGFydCwgc2VxLmluZGVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBzZXEuaXRlbXNbc2VxLml0ZW1zLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kID0gcHJldj8udmFsdWU/LmVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShlbmQsIGl0LnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXEuaXRlbXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGl0LnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ2FuY2hvcic6XG4gICAgICAgICAgICBjYXNlICd0YWcnOlxuICAgICAgICAgICAgICAgIGlmIChpdC52YWx1ZSB8fCB0aGlzLmluZGVudCA8PSBzZXEuaW5kZW50KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ3NlcS1pdGVtLWluZCc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5kZW50ICE9PSBzZXEuaW5kZW50KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoaXQudmFsdWUgfHwgaW5jbHVkZXNUb2tlbihpdC5zdGFydCwgJ3NlcS1pdGVtLWluZCcpKVxuICAgICAgICAgICAgICAgICAgICBzZXEuaXRlbXMucHVzaCh7IHN0YXJ0OiBbdGhpcy5zb3VyY2VUb2tlbl0gfSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmRlbnQgPiBzZXEuaW5kZW50KSB7XG4gICAgICAgICAgICBjb25zdCBidiA9IHRoaXMuc3RhcnRCbG9ja1ZhbHVlKHNlcSk7XG4gICAgICAgICAgICBpZiAoYnYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goYnYpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgeWllbGQqIHRoaXMuc3RlcCgpO1xuICAgIH1cbiAgICAqZmxvd0NvbGxlY3Rpb24oZmMpIHtcbiAgICAgICAgY29uc3QgaXQgPSBmYy5pdGVtc1tmYy5pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2Zsb3ctZXJyb3ItZW5kJykge1xuICAgICAgICAgICAgbGV0IHRvcDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB0b3AgPSB0aGlzLnBlZWsoMSk7XG4gICAgICAgICAgICB9IHdoaWxlICh0b3A/LnR5cGUgPT09ICdmbG93LWNvbGxlY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmYy5lbmQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NvbW1hJzpcbiAgICAgICAgICAgICAgICBjYXNlICdleHBsaWNpdC1rZXktaW5kJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdCB8fCBpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgICAgICBmYy5pdGVtcy5wdXNoKHsgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgaXQuc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgJ21hcC12YWx1ZS1pbmQnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0IHx8IGl0LnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZmMuaXRlbXMucHVzaCh7IHN0YXJ0OiBbXSwga2V5OiBudWxsLCBzZXA6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXQuc2VwKVxuICAgICAgICAgICAgICAgICAgICAgICAgaXQuc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaXQsIHsga2V5OiBudWxsLCBzZXA6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICBjYXNlICdhbmNob3InOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3RhZyc6XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXQgfHwgaXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBmYy5pdGVtcy5wdXNoKHsgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXQuc2VwKVxuICAgICAgICAgICAgICAgICAgICAgICAgaXQuc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0LnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlICdhbGlhcyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdzaW5nbGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnZG91YmxlLXF1b3RlZC1zY2FsYXInOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZzID0gdGhpcy5mbG93U2NhbGFyKHRoaXMudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXQgfHwgaXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBmYy5pdGVtcy5wdXNoKHsgc3RhcnQ6IFtdLCBrZXk6IGZzLCBzZXA6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goZnMpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGl0LCB7IGtleTogZnMsIHNlcDogW10gfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnZmxvdy1tYXAtZW5kJzpcbiAgICAgICAgICAgICAgICBjYXNlICdmbG93LXNlcS1lbmQnOlxuICAgICAgICAgICAgICAgICAgICBmYy5lbmQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYnYgPSB0aGlzLnN0YXJ0QmxvY2tWYWx1ZShmYyk7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgICAgICAgICAgaWYgKGJ2KVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChidik7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5zdGVwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnBlZWsoMik7XG4gICAgICAgICAgICBpZiAocGFyZW50LnR5cGUgPT09ICdibG9jay1tYXAnICYmXG4gICAgICAgICAgICAgICAgKCh0aGlzLnR5cGUgPT09ICdtYXAtdmFsdWUtaW5kJyAmJiBwYXJlbnQuaW5kZW50ID09PSBmYy5pbmRlbnQpIHx8XG4gICAgICAgICAgICAgICAgICAgICh0aGlzLnR5cGUgPT09ICduZXdsaW5lJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXBhcmVudC5pdGVtc1twYXJlbnQuaXRlbXMubGVuZ3RoIC0gMV0uc2VwKSkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5zdGVwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdtYXAtdmFsdWUtaW5kJyAmJlxuICAgICAgICAgICAgICAgIHBhcmVudC50eXBlICE9PSAnZmxvdy1jb2xsZWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBnZXRQcmV2UHJvcHMocGFyZW50KTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IGdldEZpcnN0S2V5U3RhcnRQcm9wcyhwcmV2KTtcbiAgICAgICAgICAgICAgICBmaXhGbG93U2VxSXRlbXMoZmMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlcCA9IGZjLmVuZC5zcGxpY2UoMSwgZmMuZW5kLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFwID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2stbWFwJyxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBmYy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGluZGVudDogZmMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICBpdGVtczogW3sgc3RhcnQsIGtleTogZmMsIHNlcCB9XVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXSA9IG1hcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLmxpbmVFbmQoZmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZsb3dTY2FsYXIodHlwZSkge1xuICAgICAgICBpZiAodGhpcy5vbk5ld0xpbmUpIHtcbiAgICAgICAgICAgIGxldCBubCA9IHRoaXMuc291cmNlLmluZGV4T2YoJ1xcbicpICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChubCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25OZXdMaW5lKHRoaXMub2Zmc2V0ICsgbmwpO1xuICAgICAgICAgICAgICAgIG5sID0gdGhpcy5zb3VyY2UuaW5kZXhPZignXFxuJywgbmwpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGFydEJsb2NrVmFsdWUocGFyZW50KSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdhbGlhcyc6XG4gICAgICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICAgICAgY2FzZSAnc2luZ2xlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgY2FzZSAnZG91YmxlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZsb3dTY2FsYXIodGhpcy50eXBlKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLXNjYWxhci1oZWFkZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1zY2FsYXInLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICBwcm9wczogW3RoaXMuc291cmNlVG9rZW5dLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6ICcnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ2Zsb3ctbWFwLXN0YXJ0JzpcbiAgICAgICAgICAgIGNhc2UgJ2Zsb3ctc2VxLXN0YXJ0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZmxvdy1jb2xsZWN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50OiB0aGlzLmluZGVudCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHRoaXMuc291cmNlVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBbXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICdzZXEtaXRlbS1pbmQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1zZXEnLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICBpdGVtczogW3sgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9XVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICdleHBsaWNpdC1rZXktaW5kJzoge1xuICAgICAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gZ2V0UHJldlByb3BzKHBhcmVudCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBnZXRGaXJzdEtleVN0YXJ0UHJvcHMocHJldik7XG4gICAgICAgICAgICAgICAgc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2stbWFwJyxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50OiB0aGlzLmluZGVudCxcbiAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFt7IHN0YXJ0LCBleHBsaWNpdEtleTogdHJ1ZSB9XVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdtYXAtdmFsdWUtaW5kJzoge1xuICAgICAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gZ2V0UHJldlByb3BzKHBhcmVudCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBnZXRGaXJzdEtleVN0YXJ0UHJvcHMocHJldik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jsb2NrLW1hcCcsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbeyBzdGFydCwga2V5OiBudWxsLCBzZXA6IFt0aGlzLnNvdXJjZVRva2VuXSB9XVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGF0SW5kZW50ZWRDb21tZW50KHN0YXJ0LCBpbmRlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gJ2NvbW1lbnQnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5pbmRlbnQgPD0gaW5kZW50KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gc3RhcnQuZXZlcnkoc3QgPT4gc3QudHlwZSA9PT0gJ25ld2xpbmUnIHx8IHN0LnR5cGUgPT09ICdzcGFjZScpO1xuICAgIH1cbiAgICAqZG9jdW1lbnRFbmQoZG9jRW5kKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09ICdkb2MtbW9kZScpIHtcbiAgICAgICAgICAgIGlmIChkb2NFbmQuZW5kKVxuICAgICAgICAgICAgICAgIGRvY0VuZC5lbmQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBkb2NFbmQuZW5kID0gW3RoaXMuc291cmNlVG9rZW5dO1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ25ld2xpbmUnKVxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgICpsaW5lRW5kKHRva2VuKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdjb21tYSc6XG4gICAgICAgICAgICBjYXNlICdkb2Mtc3RhcnQnOlxuICAgICAgICAgICAgY2FzZSAnZG9jLWVuZCc6XG4gICAgICAgICAgICBjYXNlICdmbG93LXNlcS1lbmQnOlxuICAgICAgICAgICAgY2FzZSAnZmxvdy1tYXAtZW5kJzpcbiAgICAgICAgICAgIGNhc2UgJ21hcC12YWx1ZS1pbmQnOlxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnN0ZXAoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBmYWxsdGhyb3VnaFxuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIGFsbCBvdGhlciB2YWx1ZXMgYXJlIGVycm9yc1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbi5lbmQpXG4gICAgICAgICAgICAgICAgICAgIHRva2VuLmVuZC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4uZW5kID0gW3RoaXMuc291cmNlVG9rZW5dO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICduZXdsaW5lJylcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydHMuUGFyc2VyID0gUGFyc2VyO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBjb21wb3NlciA9IHJlcXVpcmUoJy4vY29tcG9zZS9jb21wb3Nlci5qcycpO1xudmFyIERvY3VtZW50ID0gcmVxdWlyZSgnLi9kb2MvRG9jdW1lbnQuanMnKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycy5qcycpO1xudmFyIGxvZyA9IHJlcXVpcmUoJy4vbG9nLmpzJyk7XG52YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuL25vZGVzL2lkZW50aXR5LmpzJyk7XG52YXIgbGluZUNvdW50ZXIgPSByZXF1aXJlKCcuL3BhcnNlL2xpbmUtY291bnRlci5qcycpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2UvcGFyc2VyLmpzJyk7XG5cbmZ1bmN0aW9uIHBhcnNlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgY29uc3QgcHJldHR5RXJyb3JzID0gb3B0aW9ucy5wcmV0dHlFcnJvcnMgIT09IGZhbHNlO1xuICAgIGNvbnN0IGxpbmVDb3VudGVyJDEgPSBvcHRpb25zLmxpbmVDb3VudGVyIHx8IChwcmV0dHlFcnJvcnMgJiYgbmV3IGxpbmVDb3VudGVyLkxpbmVDb3VudGVyKCkpIHx8IG51bGw7XG4gICAgcmV0dXJuIHsgbGluZUNvdW50ZXI6IGxpbmVDb3VudGVyJDEsIHByZXR0eUVycm9ycyB9O1xufVxuLyoqXG4gKiBQYXJzZSB0aGUgaW5wdXQgYXMgYSBzdHJlYW0gb2YgWUFNTCBkb2N1bWVudHMuXG4gKlxuICogRG9jdW1lbnRzIHNob3VsZCBiZSBzZXBhcmF0ZWQgZnJvbSBlYWNoIG90aGVyIGJ5IGAuLi5gIG9yIGAtLS1gIG1hcmtlciBsaW5lcy5cbiAqXG4gKiBAcmV0dXJucyBJZiBhbiBlbXB0eSBgZG9jc2AgYXJyYXkgaXMgcmV0dXJuZWQsIGl0IHdpbGwgYmUgb2YgdHlwZVxuICogICBFbXB0eVN0cmVhbSBhbmQgY29udGFpbiBhZGRpdGlvbmFsIHN0cmVhbSBpbmZvcm1hdGlvbi4gSW5cbiAqICAgVHlwZVNjcmlwdCwgeW91IHNob3VsZCB1c2UgYCdlbXB0eScgaW4gZG9jc2AgYXMgYSB0eXBlIGd1YXJkIGZvciBpdC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VBbGxEb2N1bWVudHMoc291cmNlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGxpbmVDb3VudGVyLCBwcmV0dHlFcnJvcnMgfSA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCBwYXJzZXIkMSA9IG5ldyBwYXJzZXIuUGFyc2VyKGxpbmVDb3VudGVyPy5hZGROZXdMaW5lKTtcbiAgICBjb25zdCBjb21wb3NlciQxID0gbmV3IGNvbXBvc2VyLkNvbXBvc2VyKG9wdGlvbnMpO1xuICAgIGNvbnN0IGRvY3MgPSBBcnJheS5mcm9tKGNvbXBvc2VyJDEuY29tcG9zZShwYXJzZXIkMS5wYXJzZShzb3VyY2UpKSk7XG4gICAgaWYgKHByZXR0eUVycm9ycyAmJiBsaW5lQ291bnRlcilcbiAgICAgICAgZm9yIChjb25zdCBkb2Mgb2YgZG9jcykge1xuICAgICAgICAgICAgZG9jLmVycm9ycy5mb3JFYWNoKGVycm9ycy5wcmV0dGlmeUVycm9yKHNvdXJjZSwgbGluZUNvdW50ZXIpKTtcbiAgICAgICAgICAgIGRvYy53YXJuaW5ncy5mb3JFYWNoKGVycm9ycy5wcmV0dGlmeUVycm9yKHNvdXJjZSwgbGluZUNvdW50ZXIpKTtcbiAgICAgICAgfVxuICAgIGlmIChkb2NzLmxlbmd0aCA+IDApXG4gICAgICAgIHJldHVybiBkb2NzO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKFtdLCB7IGVtcHR5OiB0cnVlIH0sIGNvbXBvc2VyJDEuc3RyZWFtSW5mbygpKTtcbn1cbi8qKiBQYXJzZSBhbiBpbnB1dCBzdHJpbmcgaW50byBhIHNpbmdsZSBZQU1MLkRvY3VtZW50ICovXG5mdW5jdGlvbiBwYXJzZURvY3VtZW50KHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBsaW5lQ291bnRlciwgcHJldHR5RXJyb3JzIH0gPSBwYXJzZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgY29uc3QgcGFyc2VyJDEgPSBuZXcgcGFyc2VyLlBhcnNlcihsaW5lQ291bnRlcj8uYWRkTmV3TGluZSk7XG4gICAgY29uc3QgY29tcG9zZXIkMSA9IG5ldyBjb21wb3Nlci5Db21wb3NlcihvcHRpb25zKTtcbiAgICAvLyBgZG9jYCBpcyBhbHdheXMgc2V0IGJ5IGNvbXBvc2UuZW5kKHRydWUpIGF0IHRoZSB2ZXJ5IGxhdGVzdFxuICAgIGxldCBkb2MgPSBudWxsO1xuICAgIGZvciAoY29uc3QgX2RvYyBvZiBjb21wb3NlciQxLmNvbXBvc2UocGFyc2VyJDEucGFyc2Uoc291cmNlKSwgdHJ1ZSwgc291cmNlLmxlbmd0aCkpIHtcbiAgICAgICAgaWYgKCFkb2MpXG4gICAgICAgICAgICBkb2MgPSBfZG9jO1xuICAgICAgICBlbHNlIGlmIChkb2Mub3B0aW9ucy5sb2dMZXZlbCAhPT0gJ3NpbGVudCcpIHtcbiAgICAgICAgICAgIGRvYy5lcnJvcnMucHVzaChuZXcgZXJyb3JzLllBTUxQYXJzZUVycm9yKF9kb2MucmFuZ2Uuc2xpY2UoMCwgMiksICdNVUxUSVBMRV9ET0NTJywgJ1NvdXJjZSBjb250YWlucyBtdWx0aXBsZSBkb2N1bWVudHM7IHBsZWFzZSB1c2UgWUFNTC5wYXJzZUFsbERvY3VtZW50cygpJykpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByZXR0eUVycm9ycyAmJiBsaW5lQ291bnRlcikge1xuICAgICAgICBkb2MuZXJyb3JzLmZvckVhY2goZXJyb3JzLnByZXR0aWZ5RXJyb3Ioc291cmNlLCBsaW5lQ291bnRlcikpO1xuICAgICAgICBkb2Mud2FybmluZ3MuZm9yRWFjaChlcnJvcnMucHJldHRpZnlFcnJvcihzb3VyY2UsIGxpbmVDb3VudGVyKSk7XG4gICAgfVxuICAgIHJldHVybiBkb2M7XG59XG5mdW5jdGlvbiBwYXJzZShzcmMsIHJldml2ZXIsIG9wdGlvbnMpIHtcbiAgICBsZXQgX3Jldml2ZXIgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHR5cGVvZiByZXZpdmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIF9yZXZpdmVyID0gcmV2aXZlcjtcbiAgICB9XG4gICAgZWxzZSBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkICYmIHJldml2ZXIgJiYgdHlwZW9mIHJldml2ZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG9wdGlvbnMgPSByZXZpdmVyO1xuICAgIH1cbiAgICBjb25zdCBkb2MgPSBwYXJzZURvY3VtZW50KHNyYywgb3B0aW9ucyk7XG4gICAgaWYgKCFkb2MpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGRvYy53YXJuaW5ncy5mb3JFYWNoKHdhcm5pbmcgPT4gbG9nLndhcm4oZG9jLm9wdGlvbnMubG9nTGV2ZWwsIHdhcm5pbmcpKTtcbiAgICBpZiAoZG9jLmVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChkb2Mub3B0aW9ucy5sb2dMZXZlbCAhPT0gJ3NpbGVudCcpXG4gICAgICAgICAgICB0aHJvdyBkb2MuZXJyb3JzWzBdO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBkb2MuZXJyb3JzID0gW107XG4gICAgfVxuICAgIHJldHVybiBkb2MudG9KUyhPYmplY3QuYXNzaWduKHsgcmV2aXZlcjogX3Jldml2ZXIgfSwgb3B0aW9ucykpO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5KHZhbHVlLCByZXBsYWNlciwgb3B0aW9ucykge1xuICAgIGxldCBfcmVwbGFjZXIgPSBudWxsO1xuICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicgfHwgQXJyYXkuaXNBcnJheShyZXBsYWNlcikpIHtcbiAgICAgICAgX3JlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCAmJiByZXBsYWNlcikge1xuICAgICAgICBvcHRpb25zID0gcmVwbGFjZXI7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zLmxlbmd0aDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbnN0IGluZGVudCA9IE1hdGgucm91bmQob3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMgPSBpbmRlbnQgPCAxID8gdW5kZWZpbmVkIDogaW5kZW50ID4gOCA/IHsgaW5kZW50OiA4IH0gOiB7IGluZGVudCB9O1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB7IGtlZXBVbmRlZmluZWQgfSA9IG9wdGlvbnMgPz8gcmVwbGFjZXIgPz8ge307XG4gICAgICAgIGlmICgha2VlcFVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmIChpZGVudGl0eS5pc0RvY3VtZW50KHZhbHVlKSAmJiAhX3JlcGxhY2VyKVxuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcob3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBEb2N1bWVudC5Eb2N1bWVudCh2YWx1ZSwgX3JlcGxhY2VyLCBvcHRpb25zKS50b1N0cmluZyhvcHRpb25zKTtcbn1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZXhwb3J0cy5wYXJzZUFsbERvY3VtZW50cyA9IHBhcnNlQWxsRG9jdW1lbnRzO1xuZXhwb3J0cy5wYXJzZURvY3VtZW50ID0gcGFyc2VEb2N1bWVudDtcbmV4cG9ydHMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5O1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbnZhciBjb21wb3NlciA9IHJlcXVpcmUoJy4vY29tcG9zZS9jb21wb3Nlci5qcycpO1xudmFyIERvY3VtZW50ID0gcmVxdWlyZSgnLi9kb2MvRG9jdW1lbnQuanMnKTtcbnZhciBTY2hlbWEgPSByZXF1aXJlKCcuL3NjaGVtYS9TY2hlbWEuanMnKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycy5qcycpO1xudmFyIEFsaWFzID0gcmVxdWlyZSgnLi9ub2Rlcy9BbGlhcy5qcycpO1xudmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9ub2Rlcy9pZGVudGl0eS5qcycpO1xudmFyIFBhaXIgPSByZXF1aXJlKCcuL25vZGVzL1BhaXIuanMnKTtcbnZhciBTY2FsYXIgPSByZXF1aXJlKCcuL25vZGVzL1NjYWxhci5qcycpO1xudmFyIFlBTUxNYXAgPSByZXF1aXJlKCcuL25vZGVzL1lBTUxNYXAuanMnKTtcbnZhciBZQU1MU2VxID0gcmVxdWlyZSgnLi9ub2Rlcy9ZQU1MU2VxLmpzJyk7XG52YXIgY3N0ID0gcmVxdWlyZSgnLi9wYXJzZS9jc3QuanMnKTtcbnZhciBsZXhlciA9IHJlcXVpcmUoJy4vcGFyc2UvbGV4ZXIuanMnKTtcbnZhciBsaW5lQ291bnRlciA9IHJlcXVpcmUoJy4vcGFyc2UvbGluZS1jb3VudGVyLmpzJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnLi9wYXJzZS9wYXJzZXIuanMnKTtcbnZhciBwdWJsaWNBcGkgPSByZXF1aXJlKCcuL3B1YmxpYy1hcGkuanMnKTtcbnZhciB2aXNpdCA9IHJlcXVpcmUoJy4vdmlzaXQuanMnKTtcblxuXG5cbmV4cG9ydHMuQ29tcG9zZXIgPSBjb21wb3Nlci5Db21wb3NlcjtcbmV4cG9ydHMuRG9jdW1lbnQgPSBEb2N1bWVudC5Eb2N1bWVudDtcbmV4cG9ydHMuU2NoZW1hID0gU2NoZW1hLlNjaGVtYTtcbmV4cG9ydHMuWUFNTEVycm9yID0gZXJyb3JzLllBTUxFcnJvcjtcbmV4cG9ydHMuWUFNTFBhcnNlRXJyb3IgPSBlcnJvcnMuWUFNTFBhcnNlRXJyb3I7XG5leHBvcnRzLllBTUxXYXJuaW5nID0gZXJyb3JzLllBTUxXYXJuaW5nO1xuZXhwb3J0cy5BbGlhcyA9IEFsaWFzLkFsaWFzO1xuZXhwb3J0cy5pc0FsaWFzID0gaWRlbnRpdHkuaXNBbGlhcztcbmV4cG9ydHMuaXNDb2xsZWN0aW9uID0gaWRlbnRpdHkuaXNDb2xsZWN0aW9uO1xuZXhwb3J0cy5pc0RvY3VtZW50ID0gaWRlbnRpdHkuaXNEb2N1bWVudDtcbmV4cG9ydHMuaXNNYXAgPSBpZGVudGl0eS5pc01hcDtcbmV4cG9ydHMuaXNOb2RlID0gaWRlbnRpdHkuaXNOb2RlO1xuZXhwb3J0cy5pc1BhaXIgPSBpZGVudGl0eS5pc1BhaXI7XG5leHBvcnRzLmlzU2NhbGFyID0gaWRlbnRpdHkuaXNTY2FsYXI7XG5leHBvcnRzLmlzU2VxID0gaWRlbnRpdHkuaXNTZXE7XG5leHBvcnRzLlBhaXIgPSBQYWlyLlBhaXI7XG5leHBvcnRzLlNjYWxhciA9IFNjYWxhci5TY2FsYXI7XG5leHBvcnRzLllBTUxNYXAgPSBZQU1MTWFwLllBTUxNYXA7XG5leHBvcnRzLllBTUxTZXEgPSBZQU1MU2VxLllBTUxTZXE7XG5leHBvcnRzLkNTVCA9IGNzdDtcbmV4cG9ydHMuTGV4ZXIgPSBsZXhlci5MZXhlcjtcbmV4cG9ydHMuTGluZUNvdW50ZXIgPSBsaW5lQ291bnRlci5MaW5lQ291bnRlcjtcbmV4cG9ydHMuUGFyc2VyID0gcGFyc2VyLlBhcnNlcjtcbmV4cG9ydHMucGFyc2UgPSBwdWJsaWNBcGkucGFyc2U7XG5leHBvcnRzLnBhcnNlQWxsRG9jdW1lbnRzID0gcHVibGljQXBpLnBhcnNlQWxsRG9jdW1lbnRzO1xuZXhwb3J0cy5wYXJzZURvY3VtZW50ID0gcHVibGljQXBpLnBhcnNlRG9jdW1lbnQ7XG5leHBvcnRzLnN0cmluZ2lmeSA9IHB1YmxpY0FwaS5zdHJpbmdpZnk7XG5leHBvcnRzLnZpc2l0ID0gdmlzaXQudmlzaXQ7XG5leHBvcnRzLnZpc2l0QXN5bmMgPSB2aXNpdC52aXNpdEFzeW5jO1xuIiwKICAgICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEVTQyA9ICdcXHgxQic7XG5jb25zdCBDU0kgPSBgJHtFU0N9W2A7XG5jb25zdCBiZWVwID0gJ1xcdTAwMDcnO1xuXG5jb25zdCBjdXJzb3IgPSB7XG4gIHRvKHgsIHkpIHtcbiAgICBpZiAoIXkpIHJldHVybiBgJHtDU0l9JHt4ICsgMX1HYDtcbiAgICByZXR1cm4gYCR7Q1NJfSR7eSArIDF9OyR7eCArIDF9SGA7XG4gIH0sXG4gIG1vdmUoeCwgeSkge1xuICAgIGxldCByZXQgPSAnJztcblxuICAgIGlmICh4IDwgMCkgcmV0ICs9IGAke0NTSX0key14fURgO1xuICAgIGVsc2UgaWYgKHggPiAwKSByZXQgKz0gYCR7Q1NJfSR7eH1DYDtcblxuICAgIGlmICh5IDwgMCkgcmV0ICs9IGAke0NTSX0key15fUFgO1xuICAgIGVsc2UgaWYgKHkgPiAwKSByZXQgKz0gYCR7Q1NJfSR7eX1CYDtcblxuICAgIHJldHVybiByZXQ7XG4gIH0sXG4gIHVwOiAoY291bnQgPSAxKSA9PiBgJHtDU0l9JHtjb3VudH1BYCxcbiAgZG93bjogKGNvdW50ID0gMSkgPT4gYCR7Q1NJfSR7Y291bnR9QmAsXG4gIGZvcndhcmQ6IChjb3VudCA9IDEpID0+IGAke0NTSX0ke2NvdW50fUNgLFxuICBiYWNrd2FyZDogKGNvdW50ID0gMSkgPT4gYCR7Q1NJfSR7Y291bnR9RGAsXG4gIG5leHRMaW5lOiAoY291bnQgPSAxKSA9PiBgJHtDU0l9RWAucmVwZWF0KGNvdW50KSxcbiAgcHJldkxpbmU6IChjb3VudCA9IDEpID0+IGAke0NTSX1GYC5yZXBlYXQoY291bnQpLFxuICBsZWZ0OiBgJHtDU0l9R2AsXG4gIGhpZGU6IGAke0NTSX0/MjVsYCxcbiAgc2hvdzogYCR7Q1NJfT8yNWhgLFxuICBzYXZlOiBgJHtFU0N9N2AsXG4gIHJlc3RvcmU6IGAke0VTQ304YFxufVxuXG5jb25zdCBzY3JvbGwgPSB7XG4gIHVwOiAoY291bnQgPSAxKSA9PiBgJHtDU0l9U2AucmVwZWF0KGNvdW50KSxcbiAgZG93bjogKGNvdW50ID0gMSkgPT4gYCR7Q1NJfVRgLnJlcGVhdChjb3VudClcbn1cblxuY29uc3QgZXJhc2UgPSB7XG4gIHNjcmVlbjogYCR7Q1NJfTJKYCxcbiAgdXA6IChjb3VudCA9IDEpID0+IGAke0NTSX0xSmAucmVwZWF0KGNvdW50KSxcbiAgZG93bjogKGNvdW50ID0gMSkgPT4gYCR7Q1NJfUpgLnJlcGVhdChjb3VudCksXG4gIGxpbmU6IGAke0NTSX0yS2AsXG4gIGxpbmVFbmQ6IGAke0NTSX1LYCxcbiAgbGluZVN0YXJ0OiBgJHtDU0l9MUtgLFxuICBsaW5lcyhjb3VudCkge1xuICAgIGxldCBjbGVhciA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKylcbiAgICAgIGNsZWFyICs9IHRoaXMubGluZSArIChpIDwgY291bnQgLSAxID8gY3Vyc29yLnVwKCkgOiAnJyk7XG4gICAgaWYgKGNvdW50KVxuICAgICAgY2xlYXIgKz0gY3Vyc29yLmxlZnQ7XG4gICAgcmV0dXJuIGNsZWFyO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBjdXJzb3IsIHNjcm9sbCwgZXJhc2UsIGJlZXAgfTtcbiIsCiAgICAibGV0IHAgPSBwcm9jZXNzIHx8IHt9LCBhcmd2ID0gcC5hcmd2IHx8IFtdLCBlbnYgPSBwLmVudiB8fCB7fVxubGV0IGlzQ29sb3JTdXBwb3J0ZWQgPVxuXHQhKCEhZW52Lk5PX0NPTE9SIHx8IGFyZ3YuaW5jbHVkZXMoXCItLW5vLWNvbG9yXCIpKSAmJlxuXHQoISFlbnYuRk9SQ0VfQ09MT1IgfHwgYXJndi5pbmNsdWRlcyhcIi0tY29sb3JcIikgfHwgcC5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiIHx8ICgocC5zdGRvdXQgfHwge30pLmlzVFRZICYmIGVudi5URVJNICE9PSBcImR1bWJcIikgfHwgISFlbnYuQ0kpXG5cbmxldCBmb3JtYXR0ZXIgPSAob3BlbiwgY2xvc2UsIHJlcGxhY2UgPSBvcGVuKSA9PlxuXHRpbnB1dCA9PiB7XG5cdFx0bGV0IHN0cmluZyA9IFwiXCIgKyBpbnB1dCwgaW5kZXggPSBzdHJpbmcuaW5kZXhPZihjbG9zZSwgb3Blbi5sZW5ndGgpXG5cdFx0cmV0dXJuIH5pbmRleCA/IG9wZW4gKyByZXBsYWNlQ2xvc2Uoc3RyaW5nLCBjbG9zZSwgcmVwbGFjZSwgaW5kZXgpICsgY2xvc2UgOiBvcGVuICsgc3RyaW5nICsgY2xvc2Vcblx0fVxuXG5sZXQgcmVwbGFjZUNsb3NlID0gKHN0cmluZywgY2xvc2UsIHJlcGxhY2UsIGluZGV4KSA9PiB7XG5cdGxldCByZXN1bHQgPSBcIlwiLCBjdXJzb3IgPSAwXG5cdGRvIHtcblx0XHRyZXN1bHQgKz0gc3RyaW5nLnN1YnN0cmluZyhjdXJzb3IsIGluZGV4KSArIHJlcGxhY2Vcblx0XHRjdXJzb3IgPSBpbmRleCArIGNsb3NlLmxlbmd0aFxuXHRcdGluZGV4ID0gc3RyaW5nLmluZGV4T2YoY2xvc2UsIGN1cnNvcilcblx0fSB3aGlsZSAofmluZGV4KVxuXHRyZXR1cm4gcmVzdWx0ICsgc3RyaW5nLnN1YnN0cmluZyhjdXJzb3IpXG59XG5cbmxldCBjcmVhdGVDb2xvcnMgPSAoZW5hYmxlZCA9IGlzQ29sb3JTdXBwb3J0ZWQpID0+IHtcblx0bGV0IGYgPSBlbmFibGVkID8gZm9ybWF0dGVyIDogKCkgPT4gU3RyaW5nXG5cdHJldHVybiB7XG5cdFx0aXNDb2xvclN1cHBvcnRlZDogZW5hYmxlZCxcblx0XHRyZXNldDogZihcIlxceDFiWzBtXCIsIFwiXFx4MWJbMG1cIiksXG5cdFx0Ym9sZDogZihcIlxceDFiWzFtXCIsIFwiXFx4MWJbMjJtXCIsIFwiXFx4MWJbMjJtXFx4MWJbMW1cIiksXG5cdFx0ZGltOiBmKFwiXFx4MWJbMm1cIiwgXCJcXHgxYlsyMm1cIiwgXCJcXHgxYlsyMm1cXHgxYlsybVwiKSxcblx0XHRpdGFsaWM6IGYoXCJcXHgxYlszbVwiLCBcIlxceDFiWzIzbVwiKSxcblx0XHR1bmRlcmxpbmU6IGYoXCJcXHgxYls0bVwiLCBcIlxceDFiWzI0bVwiKSxcblx0XHRpbnZlcnNlOiBmKFwiXFx4MWJbN21cIiwgXCJcXHgxYlsyN21cIiksXG5cdFx0aGlkZGVuOiBmKFwiXFx4MWJbOG1cIiwgXCJcXHgxYlsyOG1cIiksXG5cdFx0c3RyaWtldGhyb3VnaDogZihcIlxceDFiWzltXCIsIFwiXFx4MWJbMjltXCIpLFxuXG5cdFx0YmxhY2s6IGYoXCJcXHgxYlszMG1cIiwgXCJcXHgxYlszOW1cIiksXG5cdFx0cmVkOiBmKFwiXFx4MWJbMzFtXCIsIFwiXFx4MWJbMzltXCIpLFxuXHRcdGdyZWVuOiBmKFwiXFx4MWJbMzJtXCIsIFwiXFx4MWJbMzltXCIpLFxuXHRcdHllbGxvdzogZihcIlxceDFiWzMzbVwiLCBcIlxceDFiWzM5bVwiKSxcblx0XHRibHVlOiBmKFwiXFx4MWJbMzRtXCIsIFwiXFx4MWJbMzltXCIpLFxuXHRcdG1hZ2VudGE6IGYoXCJcXHgxYlszNW1cIiwgXCJcXHgxYlszOW1cIiksXG5cdFx0Y3lhbjogZihcIlxceDFiWzM2bVwiLCBcIlxceDFiWzM5bVwiKSxcblx0XHR3aGl0ZTogZihcIlxceDFiWzM3bVwiLCBcIlxceDFiWzM5bVwiKSxcblx0XHRncmF5OiBmKFwiXFx4MWJbOTBtXCIsIFwiXFx4MWJbMzltXCIpLFxuXG5cdFx0YmdCbGFjazogZihcIlxceDFiWzQwbVwiLCBcIlxceDFiWzQ5bVwiKSxcblx0XHRiZ1JlZDogZihcIlxceDFiWzQxbVwiLCBcIlxceDFiWzQ5bVwiKSxcblx0XHRiZ0dyZWVuOiBmKFwiXFx4MWJbNDJtXCIsIFwiXFx4MWJbNDltXCIpLFxuXHRcdGJnWWVsbG93OiBmKFwiXFx4MWJbNDNtXCIsIFwiXFx4MWJbNDltXCIpLFxuXHRcdGJnQmx1ZTogZihcIlxceDFiWzQ0bVwiLCBcIlxceDFiWzQ5bVwiKSxcblx0XHRiZ01hZ2VudGE6IGYoXCJcXHgxYls0NW1cIiwgXCJcXHgxYls0OW1cIiksXG5cdFx0YmdDeWFuOiBmKFwiXFx4MWJbNDZtXCIsIFwiXFx4MWJbNDltXCIpLFxuXHRcdGJnV2hpdGU6IGYoXCJcXHgxYls0N21cIiwgXCJcXHgxYls0OW1cIiksXG5cblx0XHRibGFja0JyaWdodDogZihcIlxceDFiWzkwbVwiLCBcIlxceDFiWzM5bVwiKSxcblx0XHRyZWRCcmlnaHQ6IGYoXCJcXHgxYls5MW1cIiwgXCJcXHgxYlszOW1cIiksXG5cdFx0Z3JlZW5CcmlnaHQ6IGYoXCJcXHgxYls5Mm1cIiwgXCJcXHgxYlszOW1cIiksXG5cdFx0eWVsbG93QnJpZ2h0OiBmKFwiXFx4MWJbOTNtXCIsIFwiXFx4MWJbMzltXCIpLFxuXHRcdGJsdWVCcmlnaHQ6IGYoXCJcXHgxYls5NG1cIiwgXCJcXHgxYlszOW1cIiksXG5cdFx0bWFnZW50YUJyaWdodDogZihcIlxceDFiWzk1bVwiLCBcIlxceDFiWzM5bVwiKSxcblx0XHRjeWFuQnJpZ2h0OiBmKFwiXFx4MWJbOTZtXCIsIFwiXFx4MWJbMzltXCIpLFxuXHRcdHdoaXRlQnJpZ2h0OiBmKFwiXFx4MWJbOTdtXCIsIFwiXFx4MWJbMzltXCIpLFxuXG5cdFx0YmdCbGFja0JyaWdodDogZihcIlxceDFiWzEwMG1cIiwgXCJcXHgxYls0OW1cIiksXG5cdFx0YmdSZWRCcmlnaHQ6IGYoXCJcXHgxYlsxMDFtXCIsIFwiXFx4MWJbNDltXCIpLFxuXHRcdGJnR3JlZW5CcmlnaHQ6IGYoXCJcXHgxYlsxMDJtXCIsIFwiXFx4MWJbNDltXCIpLFxuXHRcdGJnWWVsbG93QnJpZ2h0OiBmKFwiXFx4MWJbMTAzbVwiLCBcIlxceDFiWzQ5bVwiKSxcblx0XHRiZ0JsdWVCcmlnaHQ6IGYoXCJcXHgxYlsxMDRtXCIsIFwiXFx4MWJbNDltXCIpLFxuXHRcdGJnTWFnZW50YUJyaWdodDogZihcIlxceDFiWzEwNW1cIiwgXCJcXHgxYls0OW1cIiksXG5cdFx0YmdDeWFuQnJpZ2h0OiBmKFwiXFx4MWJbMTA2bVwiLCBcIlxceDFiWzQ5bVwiKSxcblx0XHRiZ1doaXRlQnJpZ2h0OiBmKFwiXFx4MWJbMTA3bVwiLCBcIlxceDFiWzQ5bVwiKSxcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUNvbG9ycygpXG5tb2R1bGUuZXhwb3J0cy5jcmVhdGVDb2xvcnMgPSBjcmVhdGVDb2xvcnNcbiIsCiAgICAiLyoqXG4gKiBDTEkgVUkgdXRpbGl0aWVzIGZvciBhaS1lbmcgcmFscGhcbiAqXG4gKiBDb25zb2xlIHN0eWxpbmcgYW5kIG91dHB1dCBoZWxwZXJzXG4gKi9cbmltcG9ydCB7IEVPTCB9IGZyb20gXCJub2RlOm9zXCI7XG5cbmV4cG9ydCBuYW1lc3BhY2UgVUkge1xuICAgIGV4cG9ydCBjb25zdCBTdHlsZSA9IHtcbiAgICAgICAgLy8gQ29sb3JzXG4gICAgICAgIFRFWFRfSElHSExJR0hUOiBcIlxceDFiWzk2bVwiLFxuICAgICAgICBURVhUX0hJR0hMSUdIVF9CT0xEOiBcIlxceDFiWzk2bVxceDFiWzFtXCIsXG4gICAgICAgIFRFWFRfRElNOiBcIlxceDFiWzkwbVwiLFxuICAgICAgICBURVhUX0RJTV9CT0xEOiBcIlxceDFiWzkwbVxceDFiWzFtXCIsXG4gICAgICAgIFRFWFRfTk9STUFMOiBcIlxceDFiWzBtXCIsXG4gICAgICAgIFRFWFRfTk9STUFMX0JPTEQ6IFwiXFx4MWJbMW1cIixcbiAgICAgICAgVEVYVF9XQVJOSU5HOiBcIlxceDFiWzkzbVwiLFxuICAgICAgICBURVhUX1dBUk5JTkdfQk9MRDogXCJcXHgxYls5M21cXHgxYlsxbVwiLFxuICAgICAgICBURVhUX0RBTkdFUjogXCJcXHgxYls5MW1cIixcbiAgICAgICAgVEVYVF9EQU5HRVJfQk9MRDogXCJcXHgxYls5MW1cXHgxYlsxbVwiLFxuICAgICAgICBURVhUX1NVQ0NFU1M6IFwiXFx4MWJbOTJtXCIsXG4gICAgICAgIFRFWFRfU1VDQ0VTU19CT0xEOiBcIlxceDFiWzkybVxceDFiWzFtXCIsXG4gICAgICAgIFRFWFRfSU5GTzogXCJcXHgxYls5NG1cIixcbiAgICAgICAgVEVYVF9JTkZPX0JPTEQ6IFwiXFx4MWJbOTRtXFx4MWJbMW1cIixcbiAgICB9O1xuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHByaW50bG4oLi4ubWVzc2FnZTogc3RyaW5nW10pOiB2b2lkIHtcbiAgICAgICAgcHJvY2Vzcy5zdGRlcnIud3JpdGUobWVzc2FnZS5qb2luKFwiIFwiKSArIEVPTCk7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHByaW50KC4uLm1lc3NhZ2U6IHN0cmluZ1tdKTogdm9pZCB7XG4gICAgICAgIHByb2Nlc3Muc3RkZXJyLndyaXRlKG1lc3NhZ2Uuam9pbihcIiBcIikpO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBlcnJvcihtZXNzYWdlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgcHJpbnRsbihcbiAgICAgICAgICAgIGAke1N0eWxlLlRFWFRfREFOR0VSX0JPTER9RXJyb3I6ICR7U3R5bGUuVEVYVF9OT1JNQUx9JHttZXNzYWdlfWAsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZXhwb3J0IGZ1bmN0aW9uIHN1Y2Nlc3MobWVzc2FnZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHByaW50bG4oYCR7U3R5bGUuVEVYVF9TVUNDRVNTX0JPTER94pyTICR7U3R5bGUuVEVYVF9OT1JNQUx9JHttZXNzYWdlfWApO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBpbmZvKG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBwcmludGxuKGAke1N0eWxlLlRFWFRfSU5GT19CT0xEfeKEuSAke1N0eWxlLlRFWFRfTk9STUFMfSR7bWVzc2FnZX1gKTtcbiAgICB9XG5cbiAgICBleHBvcnQgZnVuY3Rpb24gd2FybihtZXNzYWdlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgcHJpbnRsbihgJHtTdHlsZS5URVhUX1dBUk5JTkdfQk9MRH0hICR7U3R5bGUuVEVYVF9OT1JNQUx9JHttZXNzYWdlfWApO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBoZWFkZXIodGl0bGU6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBwcmludGxuKCk7XG4gICAgICAgIHByaW50bG4oU3R5bGUuVEVYVF9ISUdITElHSFRfQk9MRCArIHRpdGxlICsgU3R5bGUuVEVYVF9OT1JNQUwpO1xuICAgICAgICBwcmludGxuKFN0eWxlLlRFWFRfRElNICsgXCLilIBcIi5yZXBlYXQoNTApICsgU3R5bGUuVEVYVF9OT1JNQUwpO1xuICAgIH1cbn1cbiIsCiAgICAiLyoqXG4gKiBJbml0aWFsaXplIGFpLWVuZyBjb25maWd1cmF0aW9uIGZpbGVcbiAqL1xuXG5pbXBvcnQgeyBleGlzdHNTeW5jLCB3cml0ZUZpbGUgfSBmcm9tIFwibm9kZTpmcy9wcm9taXNlc1wiO1xuaW1wb3J0IHsgam9pbiB9IGZyb20gXCJub2RlOnBhdGhcIjtcbmltcG9ydCBZQU1MIGZyb20gXCJ5YW1sXCI7XG5pbXBvcnQgdHlwZSB7IEluaXRGbGFncyB9IGZyb20gXCIuLi9jbGkvZmxhZ3NcIjtcbmltcG9ydCB7IFVJIH0gZnJvbSBcIi4uL2NsaS91aVwiO1xuaW1wb3J0IHsgREVGQVVMVF9DT05GSUcgfSBmcm9tIFwiLi4vY29uZmlnL3NjaGVtYVwiO1xuXG4vKipcbiAqIERlZmF1bHQgY29uZmlndXJhdGlvbiB0ZW1wbGF0ZVxuICovXG5jb25zdCBDT05GSUdfVEVNUExBVEUgPSB7XG4gICAgdmVyc2lvbjogMSxcbiAgICBydW5uZXI6IHtcbiAgICAgICAgYmFja2VuZDogXCJvcGVuY29kZVwiLFxuICAgICAgICByZXZpZXc6IFwib3BlbmNvZGVcIixcbiAgICAgICAgYXJ0aWZhY3RzRGlyOiBcIi5haS1lbmcvcnVuc1wiLFxuICAgICAgICBtYXhJdGVyczogMyxcbiAgICAgICAgcHJpbnRMb2dzOiBmYWxzZSxcbiAgICAgICAgbG9nTGV2ZWw6IFwiSU5GT1wiLFxuICAgIH0sXG4gICAgbG9vcDoge1xuICAgICAgICBtYXhDeWNsZXM6IDUwLFxuICAgICAgICBjeWNsZVJldHJpZXM6IDIsXG4gICAgICAgIGNoZWNrcG9pbnRGcmVxdWVuY3k6IDEsXG4gICAgICAgIHN0dWNrVGhyZXNob2xkOiA1LFxuICAgIH0sXG4gICAgZGVidWc6IHtcbiAgICAgICAgd29yazogZmFsc2UsXG4gICAgfSxcbiAgICBvcGVuY29kZToge1xuICAgICAgICBtb2RlbDogXCJjbGF1ZGUtMy01LXNvbm5ldC1sYXRlc3RcIixcbiAgICAgICAgdGVtcGVyYXR1cmU6IDAuMixcbiAgICAgICAgcHJvbXB0VGltZW91dE1zOiAxMjAwMDAsXG4gICAgfSxcbiAgICBhbnRocm9waWM6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIG1vZGVsOiBcImNsYXVkZS0zLTUtc29ubmV0LWxhdGVzdFwiLFxuICAgIH0sXG4gICAgZ2F0ZXM6IHtcbiAgICAgICAgbGludDogeyBjb21tYW5kOiBcImJ1biBydW4gbGludFwiIH0sXG4gICAgICAgIHR5cGVjaGVjazogeyBjb21tYW5kOiBcImJ1biBydW4gdHlwZWNoZWNrXCIgfSxcbiAgICAgICAgdGVzdDogeyBjb21tYW5kOiBcImJ1biB0ZXN0XCIgfSxcbiAgICAgICAgYnVpbGQ6IHsgY29tbWFuZDogXCJidW4gcnVuIGJ1aWxkXCIgfSxcbiAgICAgICAgYWNjZXB0YW5jZTogeyBjb21tYW5kOiBcImdpdCBkaWZmIC0tbmFtZS1vbmx5XCIgfSxcbiAgICB9LFxuICAgIG1vZGVsczoge1xuICAgICAgICByZXNlYXJjaDogXCJnaXRodWItY29waWxvdC9ncHQtNS4yXCIsXG4gICAgICAgIHBsYW5uaW5nOiBcImdpdGh1Yi1jb3BpbG90L2dwdC01LjJcIixcbiAgICAgICAgZXhwbG9yYXRpb246IFwiZ2l0aHViLWNvcGlsb3QvZ3B0LTUuMlwiLFxuICAgICAgICBjb2Rpbmc6IFwiZ2l0aHViLWNvcGlsb3QvZ3B0LTUuMlwiLFxuICAgICAgICBkZWZhdWx0OiBcImdpdGh1Yi1jb3BpbG90L2dwdC01LjJcIixcbiAgICB9LFxuICAgIG5vdGlmaWNhdGlvbnM6IHtcbiAgICAgICAgZGlzY29yZDoge1xuICAgICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICB1c2VybmFtZTogXCJSYWxwaFwiLFxuICAgICAgICAgICAgd2ViaG9vazoge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogXCJlbnZcIixcbiAgICAgICAgICAgICAgICBlbnZWYXI6IFwiRElTQ09SRF9XRUJIT09LX1VSTFwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHVpOiB7XG4gICAgICAgIHNpbGVudDogZmFsc2UsXG4gICAgfSxcbn07XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBjb25maWd1cmF0aW9uIGZpbGVcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluaXRDb25maWcoZmxhZ3M6IEluaXRGbGFncyk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGNvbmZpZ0RpciA9IGpvaW4ocHJvY2Vzcy5jd2QoKSwgXCIuYWktZW5nXCIpO1xuICAgIGNvbnN0IGNvbmZpZ1BhdGggPSBqb2luKGNvbmZpZ0RpciwgXCJjb25maWcueWFtbFwiKTtcblxuICAgIC8vIENoZWNrIGlmIGNvbmZpZyBhbHJlYWR5IGV4aXN0c1xuICAgIGlmIChleGlzdHNTeW5jKGNvbmZpZ1BhdGgpICYmICFmbGFncy5vdmVyd3JpdGUpIHtcbiAgICAgICAgVUkuZXJyb3IoXCJDb25maWd1cmF0aW9uIGZpbGUgYWxyZWFkeSBleGlzdHM6XCIpO1xuICAgICAgICBjb25zb2xlLmVycm9yKGAgICR7Y29uZmlnUGF0aH1gKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiVXNlIC0tb3ZlcndyaXRlIHRvIHJlcGxhY2UgaXQsIG9yIGVkaXQgdGhlIGV4aXN0aW5nIGZpbGUuXCIsXG4gICAgICAgICk7XG4gICAgICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgICB9XG5cbiAgICBpZiAoZmxhZ3MuaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCLimqDvuI8gIEludGVyYWN0aXZlIG1vZGUgcmVxdWlyZXMgYWRkaXRpb25hbCBkZXBlbmRlbmNpZXMuXCIpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIiAgbnBtIGluc3RhbGwgQGNsYWNrL3Byb21wdHNcIik7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRm9yIG5vdywgY3JlYXRpbmcgY29uZmlnIHdpdGggZGVmYXVsdHMuLi5cXG5cIik7XG4gICAgfVxuXG4gICAgLy8gV3JpdGUgZGVmYXVsdCBjb25maWd1cmF0aW9uXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeWFtbENvbnRlbnQgPSBZQU1MLnN0cmluZ2lmeShDT05GSUdfVEVNUExBVEUsIHtcbiAgICAgICAgICAgIGluZGVudDogMixcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXdhaXQgd3JpdGVGaWxlKGNvbmZpZ1BhdGgsIHlhbWxDb250ZW50LCBcInV0Zi04XCIpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIuKchSBJbml0aWFsaXplZCAuYWktZW5nL2NvbmZpZy55YW1sIHdpdGggZGVmYXVsdHNcIik7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiXFxu8J+TiyBOZXh0IHN0ZXBzOlwiKTtcbiAgICAgICAgY29uc29sZS5sb2coXCIgIDEuIEVkaXQgLmFpLWVuZy9jb25maWcueWFtbCB0byBjdXN0b21pemUgc2V0dGluZ3NcIik7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiICAyLiBTZXQgdXAgQUkgbW9kZWxzIGFuZCBiYWNrZW5kc1wiKTtcbiAgICAgICAgY29uc29sZS5sb2coXCIgIDMuIENvbmZpZ3VyZSBxdWFsaXR5IGdhdGVzIGZvciB5b3VyIHByb2plY3RcIik7XG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgXCIgIDQuIFJ1biAnYWktZW5nIHJhbHBoIFxcXCJ5b3VyIHRhc2tcXFwiJyB0byBzdGFydCBkZXZlbG9wbWVudFwiLFxuICAgICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gd3JpdGUgY29uZmlndXJhdGlvbiBmaWxlXCIpO1xuICAgICAgICBwcm9jZXNzLmV4aXQoMSk7XG4gICAgfVxufVxuIiwKICAgICIvKipcbiAqIGFpLWVuZyBpbnN0YWxsIGNvbW1hbmRcbiAqXG4gKiBJbnN0YWxscyBPcGVuQ29kZS9DbGF1ZGUgYXNzZXRzIHRvIHByb2plY3Qgb3IgZ2xvYmFsIGxvY2F0aW9uLlxuICogUmVwbGFjZXMgdGhlIGF1dG9tYXRpYyBwb3N0aW5zdGFsbCBiZWhhdmlvci5cbiAqL1xuXG5pbXBvcnQgZnMgZnJvbSBcIm5vZGU6ZnNcIjtcbmltcG9ydCBwYXRoIGZyb20gXCJub2RlOnBhdGhcIjtcbmltcG9ydCB7IGZpbGVVUkxUb1BhdGggfSBmcm9tIFwibm9kZTp1cmxcIjtcblxuY29uc3QgX19maWxlbmFtZSA9IGZpbGVVUkxUb1BhdGgoaW1wb3J0Lm1ldGEudXJsKTtcbmNvbnN0IF9fZGlybmFtZSA9IHBhdGguZGlybmFtZShfX2ZpbGVuYW1lKTtcbmNvbnN0IFJPT1QgPSBwYXRoLmRpcm5hbWUoX19kaXJuYW1lKTtcbmNvbnN0IE5BTUVTUEFDRV9QUkVGSVggPSBcImFpLWVuZ1wiO1xuXG5pbnRlcmZhY2UgSW5zdGFsbEZsYWdzIHtcbiAgICBzY29wZT86IFwicHJvamVjdFwiIHwgXCJnbG9iYWxcIiB8IFwiYXV0b1wiO1xuICAgIGRyeVJ1bj86IGJvb2xlYW47XG4gICAgeWVzPzogYm9vbGVhbjtcbiAgICB2ZXJib3NlPzogYm9vbGVhbjtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY2xlYW5OYW1lc3BhY2VkRGlyZWN0b3J5KFxuICAgIGJhc2VEaXI6IHN0cmluZyxcbiAgICBzdWJkaXI6IHN0cmluZyxcbiAgICBuYW1lc3BhY2U6IHN0cmluZyxcbiAgICBzaWxlbnQgPSBmYWxzZSxcbik6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGRpciA9IHBhdGguam9pbihiYXNlRGlyLCBzdWJkaXIsIG5hbWVzcGFjZSk7XG4gICAgaWYgKGZzLmV4aXN0c1N5bmMoZGlyKSkge1xuICAgICAgICBmcy5ybVN5bmMoZGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSwgZm9yY2U6IHRydWUgfSk7XG4gICAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgICDinIUgQ2xlYW5lZCBleGlzdGluZyAke3N1YmRpcn0vJHtuYW1lc3BhY2V9L2ApO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBjbGVhbkFpRW5nU2tpbGxzKFxuICAgIHRhcmdldE9wZW5Db2RlRGlyOiBzdHJpbmcsXG4gICAgZGlzdE9wZW5Db2RlRGlyOiBzdHJpbmcsXG4gICAgc2lsZW50ID0gZmFsc2UsXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCB0YXJnZXRTa2lsbERpciA9IHBhdGguam9pbih0YXJnZXRPcGVuQ29kZURpciwgXCJza2lsbFwiKTtcbiAgICBjb25zdCBkaXN0U2tpbGxEaXIgPSBwYXRoLmpvaW4oZGlzdE9wZW5Db2RlRGlyLCBcInNraWxsXCIpO1xuICAgIGlmICghZnMuZXhpc3RzU3luYyhkaXN0U2tpbGxEaXIpKSByZXR1cm47XG5cbiAgICBjb25zdCBhaUVuZ1NraWxsTmFtZXMgPSBmc1xuICAgICAgICAucmVhZGRpclN5bmMoZGlzdFNraWxsRGlyLCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSlcbiAgICAgICAgLmZpbHRlcigoZW50cnkpID0+IGVudHJ5LmlzRGlyZWN0b3J5KCkpXG4gICAgICAgIC5tYXAoKGVudHJ5KSA9PiBlbnRyeS5uYW1lKTtcblxuICAgIGlmIChhaUVuZ1NraWxsTmFtZXMubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICBsZXQgY2xlYW5lZENvdW50ID0gMDtcbiAgICBmb3IgKGNvbnN0IHNraWxsTmFtZSBvZiBhaUVuZ1NraWxsTmFtZXMpIHtcbiAgICAgICAgY29uc3Qgc2tpbGxQYXRoID0gcGF0aC5qb2luKHRhcmdldFNraWxsRGlyLCBza2lsbE5hbWUpO1xuICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyhza2lsbFBhdGgpKSB7XG4gICAgICAgICAgICBmcy5ybVN5bmMoc2tpbGxQYXRoLCB7IHJlY3Vyc2l2ZTogdHJ1ZSwgZm9yY2U6IHRydWUgfSk7XG4gICAgICAgICAgICBjbGVhbmVkQ291bnQrKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghc2lsZW50ICYmIGNsZWFuZWRDb3VudCA+IDApIHtcbiAgICAgICAgY29uc29sZS5sb2coYCAg4pyFIENsZWFuZWQgJHtjbGVhbmVkQ291bnR9IGV4aXN0aW5nIGFpLWVuZyBza2lsbHNgKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzUGx1Z2luUmVmZXJlbmNlZChjb25maWdQYXRoOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBjb25maWdDb250ZW50ID0gZnMucmVhZEZpbGVTeW5jKGNvbmZpZ1BhdGgsIFwidXRmLThcIik7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IEpTT04ucGFyc2UoY29uZmlnQ29udGVudCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZy5wbHVnaW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uZmlnLnBsdWdpbi5pbmNsdWRlcyhcImFpLWVuZy1zeXN0ZW1cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmaW5kT3BlbkNvZGVDb25maWcoXG4gICAgcHJvamVjdERpcjogc3RyaW5nLFxuKTogeyBwYXRoOiBzdHJpbmc7IGlzR2xvYmFsOiBib29sZWFuIH0gfCBudWxsIHtcbiAgICBjb25zdCBob21lRGlyID0gcHJvY2Vzcy5lbnYuSE9NRSB8fCBwcm9jZXNzLmVudi5VU0VSUFJPRklMRSB8fCBcIlwiO1xuXG4gICAgLy8gQ2hlY2sgcHJvamVjdCAub3BlbmNvZGUvXG4gICAgY29uc3QgcHJvamVjdENvbmZpZyA9IHBhdGguam9pbihwcm9qZWN0RGlyLCBcIi5vcGVuY29kZVwiLCBcIm9wZW5jb2RlLmpzb25jXCIpO1xuICAgIGlmIChmcy5leGlzdHNTeW5jKHByb2plY3RDb25maWcpKSB7XG4gICAgICAgIHJldHVybiB7IHBhdGg6IHByb2plY3RDb25maWcsIGlzR2xvYmFsOiBmYWxzZSB9O1xuICAgIH1cblxuICAgIC8vIENoZWNrIGdsb2JhbCB+Ly5jb25maWcvb3BlbmNvZGUvXG4gICAgY29uc3QgZ2xvYmFsQ29uZmlnID0gcGF0aC5qb2luKFxuICAgICAgICBob21lRGlyLFxuICAgICAgICBcIi5jb25maWdcIixcbiAgICAgICAgXCJvcGVuY29kZVwiLFxuICAgICAgICBcIm9wZW5jb2RlLmpzb25jXCIsXG4gICAgKTtcbiAgICBpZiAoZnMuZXhpc3RzU3luYyhnbG9iYWxDb25maWcpKSB7XG4gICAgICAgIHJldHVybiB7IHBhdGg6IGdsb2JhbENvbmZpZywgaXNHbG9iYWw6IHRydWUgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZGV0ZWN0SW5zdGFsbGF0aW9uU2NvcGUoXG4gICAgcHJvamVjdERpcjogc3RyaW5nLFxuKTogXCJwcm9qZWN0XCIgfCBcImdsb2JhbFwiIHwgbnVsbCB7XG4gICAgY29uc3QgY29uZmlnID0gZmluZE9wZW5Db2RlQ29uZmlnKHByb2plY3REaXIpO1xuICAgIGlmIChjb25maWcpIHJldHVybiBjb25maWcuaXNHbG9iYWwgPyBcImdsb2JhbFwiIDogXCJwcm9qZWN0XCI7XG5cbiAgICAvLyBJZiBubyBjb25maWcgZXhpc3RzLCBjaGVjayBpZiB3ZSdyZSBpbiBhIHByb2plY3Qgd2l0aCBwYWNrYWdlLmpzb25cbiAgICBpZiAoZnMuZXhpc3RzU3luYyhwYXRoLmpvaW4ocHJvamVjdERpciwgXCJwYWNrYWdlLmpzb25cIikpKSB7XG4gICAgICAgIHJldHVybiBcInByb2plY3RcIjtcbiAgICB9XG5cbiAgICByZXR1cm4gXCJnbG9iYWxcIjtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcnVuSW5zdGFsbGVyKGZsYWdzOiBJbnN0YWxsRmxhZ3MpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBwcm9qZWN0RGlyID0gcHJvY2Vzcy5jd2QoKTtcbiAgICBjb25zdCBob21lRGlyID0gcHJvY2Vzcy5lbnYuSE9NRSB8fCBwcm9jZXNzLmVudi5VU0VSUFJPRklMRSB8fCBcIlwiO1xuICAgIGNvbnN0IGRpc3RPcGVuQ29kZURpciA9IHBhdGguam9pbihST09ULCBcImRpc3RcIiwgXCIub3BlbmNvZGVcIik7XG5cbiAgICAvLyBEZXRlcm1pbmUgaW5zdGFsbGF0aW9uIHNjb3BlXG4gICAgbGV0IHNjb3BlID0gZmxhZ3Muc2NvcGU7XG4gICAgaWYgKCFzY29wZSB8fCBzY29wZSA9PT0gXCJhdXRvXCIpIHtcbiAgICAgICAgY29uc3QgZGV0ZWN0ZWQgPSBkZXRlY3RJbnN0YWxsYXRpb25TY29wZShwcm9qZWN0RGlyKTtcbiAgICAgICAgaWYgKCFkZXRlY3RlZCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICAgICAgXCLinYwgQ291bGQgbm90IGRldGVjdCBpbnN0YWxsYXRpb24gc2NvcGUuIFVzZSAtLXNjb3BlIHByb2plY3R8Z2xvYmFsXCIsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcHJvY2Vzcy5leGl0KDEpO1xuICAgICAgICB9XG4gICAgICAgIHNjb3BlID0gZGV0ZWN0ZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0T3BlbkNvZGVEaXIgPVxuICAgICAgICBzY29wZSA9PT0gXCJnbG9iYWxcIlxuICAgICAgICAgICAgPyBwYXRoLmpvaW4oaG9tZURpciwgXCIuY29uZmlnXCIsIFwib3BlbmNvZGVcIilcbiAgICAgICAgICAgIDogcGF0aC5qb2luKHByb2plY3REaXIsIFwiLm9wZW5jb2RlXCIpO1xuXG4gICAgaWYgKGZsYWdzLnZlcmJvc2UpIHtcbiAgICAgICAgY29uc29sZS5sb2coYEluc3RhbGxpbmcgdG86ICR7dGFyZ2V0T3BlbkNvZGVEaXJ9YCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBTY29wZTogJHtzY29wZX1gKTtcbiAgICB9XG5cbiAgICAvLyBWYWxpZGF0ZSB0YXJnZXQgZGlyZWN0b3J5XG4gICAgaWYgKHNjb3BlID09PSBcInByb2plY3RcIikge1xuICAgICAgICBjb25zdCBvcGVuY29kZURpciA9IHBhdGguam9pbihwcm9qZWN0RGlyLCBcIi5vcGVuY29kZVwiKTtcbiAgICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKG9wZW5jb2RlRGlyKSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCLinYwgTm8gLm9wZW5jb2RlLyBkaXJlY3RvcnkgZm91bmQgaW4gcHJvamVjdFwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiICAgUnVuICdvcGVuY29kZSBpbml0JyBmaXJzdCBvciB1c2UgLS1zY29wZSBnbG9iYWxcIik7XG4gICAgICAgICAgICBwcm9jZXNzLmV4aXQoMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgYWktZW5nLXN5c3RlbSBwbHVnaW4gcmVmZXJlbmNlXG4gICAgY29uc3QgY29uZmlnID0gZmluZE9wZW5Db2RlQ29uZmlnKHByb2plY3REaXIpO1xuICAgIGlmIChjb25maWcgJiYgIWlzUGx1Z2luUmVmZXJlbmNlZChjb25maWcucGF0aCkpIHtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBcIuKaoO+4jyAgb3BlbmNvZGUuanNvbmMgZG9lcyBub3QgcmVmZXJlbmNlIGFpLWVuZy1zeXN0ZW0gcGx1Z2luXCIsXG4gICAgICAgICk7XG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgXCIgICBBZGQgJ2FpLWVuZy1zeXN0ZW0nIHRvIHRoZSBwbHVnaW4gYXJyYXkgaW4gb3BlbmNvZGUuanNvbmNcIixcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoZmxhZ3MuZHJ5UnVuKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwi8J+UjSBkcnktcnVuOiBXb3VsZCBpbnN0YWxsIHRoZSBmb2xsb3dpbmcgZmlsZXM6XCIpO1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgIGAgICBDb21tYW5kcyAtPiAke3RhcmdldE9wZW5Db2RlRGlyfS9jb21tYW5kLyR7TkFNRVNQQUNFX1BSRUZJWH0vYCxcbiAgICAgICAgKTtcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBgICAgQWdlbnRzICAgLT4gJHt0YXJnZXRPcGVuQ29kZURpcn0vYWdlbnQvJHtOQU1FU1BBQ0VfUFJFRklYfS9gLFxuICAgICAgICApO1xuICAgICAgICBjb25zb2xlLmxvZyhgICAgU2tpbGxzICAgLT4gJHt0YXJnZXRPcGVuQ29kZURpcn0vc2tpbGwvYCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJbnN0YWxsIGNvbW1hbmRzXG4gICAgY29uc3QgY29tbWFuZHNEaXIgPSBwYXRoLmpvaW4oXG4gICAgICAgIHRhcmdldE9wZW5Db2RlRGlyLFxuICAgICAgICBcImNvbW1hbmRcIixcbiAgICAgICAgTkFNRVNQQUNFX1BSRUZJWCxcbiAgICApO1xuICAgIGNvbnN0IGRpc3RDb21tYW5kc0RpciA9IHBhdGguam9pbihcbiAgICAgICAgZGlzdE9wZW5Db2RlRGlyLFxuICAgICAgICBcImNvbW1hbmRcIixcbiAgICAgICAgTkFNRVNQQUNFX1BSRUZJWCxcbiAgICApO1xuXG4gICAgaWYgKGZzLmV4aXN0c1N5bmMoZGlzdENvbW1hbmRzRGlyKSkge1xuICAgICAgICBhd2FpdCBjbGVhbk5hbWVzcGFjZWREaXJlY3RvcnkoXG4gICAgICAgICAgICB0YXJnZXRPcGVuQ29kZURpcixcbiAgICAgICAgICAgIFwiY29tbWFuZFwiLFxuICAgICAgICAgICAgTkFNRVNQQUNFX1BSRUZJWCxcbiAgICAgICAgKTtcbiAgICAgICAgZnMuY3BTeW5jKGRpc3RDb21tYW5kc0RpciwgY29tbWFuZHNEaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgICAgICBjb25zb2xlLmxvZyhgICDinIUgSW5zdGFsbGVkIGNvbW1hbmRzIHRvICR7Y29tbWFuZHNEaXJ9YCk7XG4gICAgfVxuXG4gICAgLy8gSW5zdGFsbCBhZ2VudHNcbiAgICBjb25zdCBhZ2VudHNEaXIgPSBwYXRoLmpvaW4odGFyZ2V0T3BlbkNvZGVEaXIsIFwiYWdlbnRcIiwgTkFNRVNQQUNFX1BSRUZJWCk7XG4gICAgY29uc3QgZGlzdEFnZW50c0RpciA9IHBhdGguam9pbihkaXN0T3BlbkNvZGVEaXIsIFwiYWdlbnRcIiwgTkFNRVNQQUNFX1BSRUZJWCk7XG5cbiAgICBpZiAoZnMuZXhpc3RzU3luYyhkaXN0QWdlbnRzRGlyKSkge1xuICAgICAgICBhd2FpdCBjbGVhbk5hbWVzcGFjZWREaXJlY3RvcnkoXG4gICAgICAgICAgICB0YXJnZXRPcGVuQ29kZURpcixcbiAgICAgICAgICAgIFwiYWdlbnRcIixcbiAgICAgICAgICAgIE5BTUVTUEFDRV9QUkVGSVgsXG4gICAgICAgICk7XG4gICAgICAgIGZzLmNwU3luYyhkaXN0QWdlbnRzRGlyLCBhZ2VudHNEaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgICAgICBjb25zb2xlLmxvZyhgICDinIUgSW5zdGFsbGVkIGFnZW50cyB0byAke2FnZW50c0Rpcn1gKTtcbiAgICB9XG5cbiAgICAvLyBJbnN0YWxsIHNraWxsc1xuICAgIGNvbnN0IHNraWxsc0RpciA9IHBhdGguam9pbih0YXJnZXRPcGVuQ29kZURpciwgXCJza2lsbFwiKTtcbiAgICBjb25zdCBkaXN0U2tpbGxzRGlyID0gcGF0aC5qb2luKGRpc3RPcGVuQ29kZURpciwgXCJza2lsbFwiKTtcblxuICAgIGlmIChmcy5leGlzdHNTeW5jKGRpc3RTa2lsbHNEaXIpKSB7XG4gICAgICAgIGF3YWl0IGNsZWFuQWlFbmdTa2lsbHModGFyZ2V0T3BlbkNvZGVEaXIsIGRpc3RPcGVuQ29kZURpcik7XG4gICAgICAgIGZzLmNwU3luYyhkaXN0U2tpbGxzRGlyLCBza2lsbHNEaXIsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgICAgICBjb25zb2xlLmxvZyhgICDinIUgSW5zdGFsbGVkIHNraWxscyB0byAke3NraWxsc0Rpcn1gKTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhcIlxcbuKchSBJbnN0YWxsYXRpb24gY29tcGxldGUhXCIpO1xuICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBcIiAgIFJlc3RhcnQgT3BlbkNvZGUgb3IgQ2xhdWRlIENvZGUgdG8gdXNlIG5ldyBjb21tYW5kcyBhbmQgYWdlbnRzLlwiLFxuICAgICk7XG59XG5cbmV4cG9ydCB7IHJ1bkluc3RhbGxlciB9O1xuIiwKICAgICIjIS91c3IvYmluL2VudiBub2RlXG4vKipcbiAqIENMSSBlbnRyeSBwb2ludCBmb3IgYWktZW5nLXN5c3RlbVxuICpcbiAqIERpc3BhdGNoZXIgdGhhdCByb3V0ZXMgdG8gc3ViY29tbWFuZHM6XG4gKiAgIC0gYWktZW5nIHJhbHBoIC4uLiAgICAgOiBJdGVyYXRpb24gbG9vcCBydW5uZXIgKGRlZmF1bHQgYmVoYXZpb3IpXG4gKiAgIC0gYWktZW5nIGluc3RhbGwgICAgICA6IEluc3RhbGwgT3BlbkNvZGUvQ2xhdWRlIGFzc2V0c1xuICogICAtIGFpLWVuZyBcInByb21wdFwiICAgICA6IERlZmF1bHRzIHRvIHJhbHBoIChzaG9ydGN1dClcbiAqL1xuXG5pbXBvcnQgeyBwYXJzZUFyZ3MgfSBmcm9tIFwibm9kZTp1dGlsXCI7XG5pbXBvcnQgeyBsb2FkQ29uZmlnIH0gZnJvbSBcIi4uL2NvbmZpZy9sb2FkQ29uZmlnXCI7XG5pbXBvcnQgeyBMb2cgfSBmcm9tIFwiLi4vdXRpbC9sb2dcIjtcbmltcG9ydCB0eXBlIHsgTG9nTGV2ZWwsIFJhbHBoRmxhZ3MgfSBmcm9tIFwiLi9mbGFnc1wiO1xuaW1wb3J0IHsgcnVuQ2xpIH0gZnJvbSBcIi4vcnVuLWNsaVwiO1xuaW1wb3J0IHsgVUkgfSBmcm9tIFwiLi91aVwiO1xuXG4vLyBUVUkgaXMgbG9hZGVkIGR5bmFtaWNhbGx5IHRvIGF2b2lkIGJ1bmRsaW5nIGlzc3Vlc1xuLy8gaW1wb3J0IHsgbGF1bmNoVHVpIH0gZnJvbSBcIi4vdHVpL0FwcFwiO1xuXG5jb25zdCBUT1BfSEVMUF9URVhUID0gYFxuYWktZW5nIC0gQUkgRW5naW5lZXJpbmcgU3lzdGVtIENMSVxuXG5VU0FHRTpcbiAgYWktZW5nIDxjb21tYW5kPiBbb3B0aW9uc11cbiAgYWktZW5nIFwicHJvbXB0XCIgW29wdGlvbnNdICAgICAgICAgICMgU2hvcnRjdXQ6IGRlZmF1bHRzIHRvICdyYWxwaCdcblxuQ09NTUFORFM6XG4gIGluaXQgW29wdGlvbnNdICAgICAgICAgICAgICAgICAgICAgIyBJbml0aWFsaXplIC5haS1lbmcvY29uZmlnLnlhbWwgd2l0aCBkZWZhdWx0c1xuICByYWxwaCA8cHJvbXB0fHdvcmtmbG93PiBbb3B0aW9uc10gICMgSXRlcmF0aW9uIGxvb3AgcnVubmVyXG4gIGluc3RhbGwgW29wdGlvbnNdICAgICAgICAgICAgICAgICAgIyBJbnN0YWxsIE9wZW5Db2RlL0NsYXVkZSBhc3NldHNcblxuR0xPQkFMIE9QVElPTlM6XG4gIC1oLCAtLWhlbHAgICAgICAgICAgICAgICAgICAgICAgICAgU2hvdyB0aGlzIGhlbHAgbWVzc2FnZVxuICAtdiwgLS12ZXJib3NlICAgICAgICAgICAgICAgICAgICAgIFZlcmJvc2Ugb3V0cHV0IChERUJVRyBsZXZlbCBsb2dzKVxuXG5FWEFNUExFUzpcbiAgYWktZW5nIGluaXQgICAgICAgICAgICAgICAgICAgICMgSW5pdGlhbGl6ZSBjb25maWcgd2l0aCBkZWZhdWx0c1xuICBhaS1lbmcgaW5pdCAtLWludGVyYWN0aXZlICAgICAgICMgSW50ZXJhY3RpdmUgY29uZmlnIHNldHVwXG4gIGFpLWVuZyBcImltcGxlbWVudCB1c2VyIGF1dGhlbnRpY2F0aW9uXCJcbiAgYWktZW5nIHJhbHBoIFwiZml4IGJ1Z1wiIC0tcHJpbnQtbG9ncyAtLWxvZy1sZXZlbCBERUJVR1xuICBhaS1lbmcgaW5zdGFsbCAtLXNjb3BlIHByb2plY3RcbiAgYWktZW5nIHJhbHBoIGZlYXR1cmUtc3BlYy55bWwgLS1tYXgtaXRlcnMgNVxuICBhaS1lbmcgcmFscGggLS10dWkgLS1yZXN1bWVcbiAgYWktZW5nIHJhbHBoIFwibWFrZSBmbGVldHRvb2xzIHVzYWJsZVwiIC0tc2hpcCAtLW1heC1jeWNsZXMgMzBcbiAgYWktZW5nIHJhbHBoIFwibWFrZSBmbGVldHRvb2xzIHVzYWJsZVwiIC0tZHJhZnQgLS1tYXgtY3ljbGVzIDEwIC0tY2lcbmA7XG5cbmNvbnN0IElOSVRfSEVMUF9URVhUID0gYFxuYWktZW5nIGluaXQgLSBJbml0aWFsaXplIC5haS1lbmcvY29uZmlnLnlhbWwgd2l0aCBkZWZhdWx0c1xuXG5VU0FHRTpcbiAgYWktZW5nIGluaXQgW29wdGlvbnNdXG5cbk9QVElPTlM6XG4gIC1pLCAtLWludGVyYWN0aXZlICAgIEludGVyYWN0aXZlIGNvbmZpZ3VyYXRpb24gc2V0dXBcbiAgLS1vdmVyd3JpdGUgICAgICAgICAgIE92ZXJ3cml0ZSBleGlzdGluZyBjb25maWcgZmlsZVxuICAtaCwgLS1oZWxwICAgICAgICAgIFNob3cgdGhpcyBoZWxwIG1lc3NhZ2VcbiAgLXYsIC0tdmVyYm9zZSAgICAgICAgIFZlcmJvc2Ugb3V0cHV0XG5cbkVYQU1QTEVTOlxuICBhaS1lbmcgaW5pdCAgICAgICAgICAgICAgICAgICAgIyBDcmVhdGUgY29uZmlnIHdpdGggZGVmYXVsdHNcbiAgYWktZW5nIGluaXQgLS1pbnRlcmFjdGl2ZSAgICAgICAjIEludGVyYWN0aXZlIHNldHVwIHdpdGggcHJvbXB0c1xuICBhaS1lbmcgaW5pdCAtLW92ZXJ3cml0ZSAgICAgICAgICAjIFJlcGxhY2UgZXhpc3RpbmcgY29uZmlnXG5gO1xuXG5jb25zdCBJTlNUQUxMX0hFTFBfVEVYVCA9IGBcbmFpLWVuZyBpbnN0YWxsIC0gSW5zdGFsbCBPcGVuQ29kZS9DbGF1ZGUgYXNzZXRzXG5cblVTQUdFOlxuICBhaS1lbmcgaW5zdGFsbCBbb3B0aW9uc11cblxuT1BUSU9OUzpcbiAgLS1zY29wZSBwcm9qZWN0fGdsb2JhbHxhdXRvICAgICAgICBXaGVyZSB0byBpbnN0YWxsIChkZWZhdWx0OiBhdXRvLWRldGVjdClcbiAgLS1kcnktcnVuICAgICAgICAgICAgICAgICAgICAgICAgICBTaG93IHdoYXQgd291bGQgYmUgZG9uZSB3aXRob3V0IHdyaXRpbmdcbiAgLS15ZXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTa2lwIGNvbmZpcm1hdGlvbiBwcm9tcHRzXG4gIC12LCAtLXZlcmJvc2UgICAgICAgICAgICAgICAgICAgICAgVmVyYm9zZSBvdXRwdXRcblxuRVhBTVBMRVM6XG4gIGFpLWVuZyBpbnN0YWxsICAgICAgICAgICAgICAgICAgICAgICAgICAjIEF1dG8tZGV0ZWN0IHByb2plY3QgdnMgZ2xvYmFsXG4gIGFpLWVuZyBpbnN0YWxsIC0tc2NvcGUgcHJvamVjdCAgICAgICAgICAjIEluc3RhbGwgdG8gcHJvamVjdCAub3BlbmNvZGUvXG4gIGFpLWVuZyBpbnN0YWxsIC0tc2NvcGUgZ2xvYmFsICAgICAgICAgICAjIEluc3RhbGwgdG8gfi8uY29uZmlnL29wZW5jb2RlL1xuICBhaS1lbmcgaW5zdGFsbCAtLWRyeS1ydW4gICAgICAgICAgICAgICAgIyBQcmV2aWV3IG9wZXJhdGlvbnNcbmA7XG5cbmNvbnN0IFJBTFBIX0hFTFBfVEVYVCA9IGBcbmFpLWVuZyByYWxwaCAtIEl0ZXJhdGlvbiBsb29wIHJ1bm5lciBmb3IgYWktZW5nLXN5c3RlbVxuXG5VU0FHRTpcbiAgYWktZW5nIHJhbHBoIDxwcm9tcHR8d29ya2Zsb3c+IFtvcHRpb25zXVxuXG5QT1NJVElPTkFMOlxuICBwcm9tcHQvd29ya2Zsb3cgICAgVGFzayBwcm9tcHQgb3IgcGF0aCB0byB3b3JrZmxvdyBzcGVjaWZpY2F0aW9uXG5cbk9QVElPTlM6XG4gIC0tbWF4LWl0ZXJzIDxuPiAgICAgTWF4aW11bSBpdGVyYXRpb25zIChkZWZhdWx0OiBmcm9tIGNvbmZpZylcbiAgLS1nYXRlcyA8ZzEsZzI+ICAgICBDb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBxdWFsaXR5IGdhdGVzXG4gIC0tcmV2aWV3IDxtb2RlPiAgICAgUmV2aWV3IG1vZGU6IG5vbmV8b3BlbmNvZGV8YW50aHJvcGljfGJvdGhcbiAgLS1yZXN1bWUgICAgICAgICAgICBSZXN1bWUgcHJldmlvdXMgcnVuXG4gIC0tcnVuLWlkIDxpZD4gICAgICAgU3BlY2lmaWMgcnVuIElEIHRvIHJlc3VtZVxuICAtLWRyeS1ydW4gICAgICAgICAgIFNob3cgd2hhdCB3b3VsZCBiZSBkb25lIHdpdGhvdXQgZXhlY3V0aW5nXG4gIC0tY2kgICAgICAgICAgICAgICAgUnVuIGluIENJIG1vZGUgKG5vIGludGVyYWN0aXZlIHByb21wdHMpXG5cbiAgLS1wcmludC1sb2dzICAgICAgICBQcmludCBkZXRhaWxlZCBsb2dzIHRvIHN0ZGVyclxuICAtLWxvZy1sZXZlbCA8bHZsPiAgIExvZyBsZXZlbDogREVCVUd8SU5GT3xXQVJOfEVSUk9SIChkZWZhdWx0OiBJTkZPKVxuICAtdiwgLS12ZXJib3NlICAgICAgIFZlcmJvc2Ugb3V0cHV0IChzYW1lIGFzIC0tbG9nLWxldmVsIERFQlVHKVxuICAtLXR1aSAgICAgICAgICAgICAgIFVzZSBUVUkgbW9kZSBpbnN0ZWFkIG9mIENMSVxuICAtLW5vLXN0cmVhbSAgICAgICAgIERpc2FibGUgc3RyZWFtaW5nIG91dHB1dCAoYnVmZmVyZWQgbW9kZSlcblxuICAtLW5vLWxvb3AgICAgICAgICAgIFJ1biBzaW5nbGUgaXRlcmF0aW9uIG9ubHkgKGRpc2FibGUgbG9vcCBtb2RlKVxuICAtLWNvbXBsZXRpb24gPHRvaz4gIExvb3AgZXhpdCB0b2tlbiAocmVxdWlyZWQsIGUuZy4sIC0tY29tcGxldGlvbiBcIjxwcm9taXNlPkRPTkU8L3Byb21pc2U+XCIpXG4gIC0tc2hpcCAgICAgICAgICAgICAgQXV0by1leGl0IHdoZW4gYWdlbnQgb3V0cHV0cyBcIjxwcm9taXNlPlNISVA8L3Byb21pc2U+XCJcbiAgLS1kcmFmdCAgICAgICAgICAgICBSdW4gZm9yIG1heC1jeWNsZXMgdGhlbiBzdG9wIGZvciB5b3VyIHJldmlldyAoZGVmYXVsdCBiZWhhdmlvcilcbiAgLS1tYXgtY3ljbGVzIDxuPiAgICBNYXhpbXVtIGxvb3AgY3ljbGVzIChkZWZhdWx0OiA1MClcbiAgLS1zdHVjay10aHJlc2hvbGQgPG4+IEFib3J0IGFmdGVyIE4gY3ljbGVzIHdpdGggbm8gcHJvZ3Jlc3MgKGRlZmF1bHQ6IDUpXG4gIC0tY2hlY2twb2ludCA8bj4gICAgU2F2ZSBjaGVja3BvaW50IGV2ZXJ5IE4gY3ljbGVzIChkZWZhdWx0OiAxKVxuICAtLWRlYnVnLXdvcmsgICAgICAgIFByaW50IGV2ZXJ5IHRvb2wgaW52b2NhdGlvbiBpbnB1dC9vdXRwdXQgdG8gY29uc29sZSBhbmQgbG9nc1xuXG4gIC0taGVscCAgICAgICAgICAgICAgU2hvdyB0aGlzIGhlbHAgbWVzc2FnZVxuXG5FWEFNUExFUzpcbiAgYWktZW5nIHJhbHBoIFwiaW1wbGVtZW50IHVzZXIgYXV0aGVudGljYXRpb25cIlxuICBhaS1lbmcgcmFscGggZmVhdHVyZS1zcGVjLnltbCAtLW1heC1pdGVycyA1XG4gIGFpLWVuZyByYWxwaCBcImZpeCB0aGUgYnVnXCIgLS1wcmludC1sb2dzIC0tbG9nLWxldmVsIERFQlVHXG4gIGFpLWVuZyByYWxwaCAtLXR1aSAtLXJlc3VtZVxuICBhaS1lbmcgcmFscGggXCJtYWtlIGZsZWV0dG9vbHMgdXNhYmxlXCIgLS1zaGlwIC0tbWF4LWN5Y2xlcyAzMFxuICBhaS1lbmcgcmFscGggXCJtYWtlIGZsZWV0dG9vbHMgdXNhYmxlXCIgLS1kcmFmdCAtLW1heC1jeWNsZXMgMTAgLS1jaVxuICBhaS1lbmcgcmFscGggLS1uby1sb29wIFwic2luZ2xlLXNob3QgdGFza1wiXG5gO1xuXG5pbnRlcmZhY2UgSW5zdGFsbEZsYWdzIHtcbiAgICBzY29wZT86IFwicHJvamVjdFwiIHwgXCJnbG9iYWxcIiB8IFwiYXV0b1wiO1xuICAgIGRyeVJ1bj86IGJvb2xlYW47XG4gICAgeWVzPzogYm9vbGVhbjtcbiAgICB2ZXJib3NlPzogYm9vbGVhbjtcbiAgICBoZWxwPzogYm9vbGVhbjtcbn1cblxuaW50ZXJmYWNlIEluaXRGbGFncyB7XG4gICAgaW50ZXJhY3RpdmU/OiBib29sZWFuO1xuICAgIG92ZXJ3cml0ZT86IGJvb2xlYW47XG4gICAgaGVscD86IGJvb2xlYW47XG4gICAgdmVyYm9zZT86IGJvb2xlYW47XG59XG5cbi8qKlxuICogSGFuZGxlIHRoZSAnaW5pdCcgc3ViY29tbWFuZFxuICovXG5hc3luYyBmdW5jdGlvbiBydW5Jbml0KGFyZ3M6IHN0cmluZ1tdKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgeyB2YWx1ZXMsIHBvc2l0aW9uYWxzIH0gPSBwYXJzZUFyZ3Moe1xuICAgICAgICBhcmdzLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBpbnRlcmFjdGl2ZTogeyB0eXBlOiBcImJvb2xlYW5cIiwgc2hvcnQ6IFwiaVwiIH0sXG4gICAgICAgICAgICBvdmVyd3JpdGU6IHsgdHlwZTogXCJib29sZWFuXCIgfSxcbiAgICAgICAgICAgIGhlbHA6IHsgdHlwZTogXCJib29sZWFuXCIgfSxcbiAgICAgICAgICAgIHZlcmJvc2U6IHsgdHlwZTogXCJib29sZWFuXCIsIHNob3J0OiBcInZcIiB9LFxuICAgICAgICB9LFxuICAgICAgICBhbGxvd1Bvc2l0aW9uYWxzOiB0cnVlLFxuICAgIH0pO1xuXG4gICAgY29uc3QgZmxhZ3M6IEluaXRGbGFncyA9IHtcbiAgICAgICAgaW50ZXJhY3RpdmU6IHZhbHVlcy5pbnRlcmFjdGl2ZSxcbiAgICAgICAgb3ZlcndyaXRlOiB2YWx1ZXMub3ZlcndyaXRlLFxuICAgICAgICBoZWxwOiB2YWx1ZXMuaGVscCxcbiAgICAgICAgdmVyYm9zZTogdmFsdWVzLnZlcmJvc2UsXG4gICAgfTtcblxuICAgIGlmIChmbGFncy5oZWxwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKElOSVRfSEVMUF9URVhUKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGF3YWl0IExvZy5pbml0KHtcbiAgICAgICAgcHJpbnQ6IGZhbHNlLFxuICAgICAgICBsZXZlbDogZmxhZ3MudmVyYm9zZSA/IFwiREVCVUdcIiA6IFwiSU5GT1wiLFxuICAgICAgICBsb2dEaXI6IFwiLmFpLWVuZy9sb2dzXCIsXG4gICAgfSk7XG5cbiAgICBjb25zdCB7IGluaXRDb25maWcgfSA9IGF3YWl0IGltcG9ydChcIi4uL2luc3RhbGwvaW5pdFwiKTtcbiAgICBhd2FpdCBpbml0Q29uZmlnKGZsYWdzKTtcbn1cblxuLyoqXG4gKiBIYW5kbGUgdGhlICdpbnN0YWxsJyBzdWJjb21tYW5kXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJ1bkluc3RhbGwoYXJnczogc3RyaW5nW10pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCB7IHZhbHVlcywgcG9zaXRpb25hbHMgfSA9IHBhcnNlQXJncyh7XG4gICAgICAgIGFyZ3MsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHNjb3BlOiB7IHR5cGU6IFwic3RyaW5nXCIgfSxcbiAgICAgICAgICAgIFwiZHJ5LXJ1blwiOiB7IHR5cGU6IFwiYm9vbGVhblwiIH0sXG4gICAgICAgICAgICB5ZXM6IHsgdHlwZTogXCJib29sZWFuXCIgfSxcbiAgICAgICAgICAgIHZlcmJvc2U6IHsgdHlwZTogXCJib29sZWFuXCIsIHNob3J0OiBcInZcIiB9LFxuICAgICAgICAgICAgaGVscDogeyB0eXBlOiBcImJvb2xlYW5cIiB9LFxuICAgICAgICB9LFxuICAgICAgICBhbGxvd1Bvc2l0aW9uYWxzOiB0cnVlLFxuICAgIH0pO1xuXG4gICAgY29uc3QgZmxhZ3M6IEluc3RhbGxGbGFncyA9IHtcbiAgICAgICAgc2NvcGU6IHZhbHVlcy5zY29wZSBhcyBJbnN0YWxsRmxhZ3NbXCJzY29wZVwiXSxcbiAgICAgICAgZHJ5UnVuOiB2YWx1ZXNbXCJkcnktcnVuXCJdLFxuICAgICAgICB5ZXM6IHZhbHVlcy55ZXMsXG4gICAgICAgIHZlcmJvc2U6IHZhbHVlcy52ZXJib3NlLFxuICAgICAgICBoZWxwOiB2YWx1ZXMuaGVscCxcbiAgICB9O1xuXG4gICAgaWYgKGZsYWdzLmhlbHApIHtcbiAgICAgICAgY29uc29sZS5sb2coSU5TVEFMTF9IRUxQX1RFWFQpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRHluYW1pYyBpbXBvcnQgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzIGFuZCB0byBhbGxvdyBpbnN0YWxsIGxvZ2ljIHRvIGJlIG9wdGlvbmFsXG4gICAgY29uc3QgeyBydW5JbnN0YWxsZXIgfSA9IGF3YWl0IGltcG9ydChcIi4uL2luc3RhbGwvaW5zdGFsbFwiKTtcbiAgICBhd2FpdCBydW5JbnN0YWxsZXIoZmxhZ3MpO1xufVxuXG4vKipcbiAqIFBhcnNlIFJhbHBoIGZsYWdzIGZyb20gcmF3IGFyZ3ZcbiAqL1xuZnVuY3Rpb24gcGFyc2VSYWxwaEZsYWdzKGFyZ3M6IHN0cmluZ1tdKToge1xuICAgIGZsYWdzOiBSYWxwaEZsYWdzO1xuICAgIHJlbWFpbmluZzogc3RyaW5nW107XG59IHtcbiAgICBjb25zdCB7IHZhbHVlcywgcG9zaXRpb25hbHMgfSA9IHBhcnNlQXJncyh7XG4gICAgICAgIGFyZ3MsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIFwibWF4LWl0ZXJzXCI6IHsgdHlwZTogXCJzdHJpbmdcIiB9LFxuICAgICAgICAgICAgZ2F0ZXM6IHsgdHlwZTogXCJzdHJpbmdcIiB9LFxuICAgICAgICAgICAgcmV2aWV3OiB7IHR5cGU6IFwic3RyaW5nXCIgfSxcbiAgICAgICAgICAgIHJlc3VtZTogeyB0eXBlOiBcImJvb2xlYW5cIiB9LFxuICAgICAgICAgICAgXCJydW4taWRcIjogeyB0eXBlOiBcInN0cmluZ1wiIH0sXG4gICAgICAgICAgICBcImRyeS1ydW5cIjogeyB0eXBlOiBcImJvb2xlYW5cIiB9LFxuICAgICAgICAgICAgY2k6IHsgdHlwZTogXCJib29sZWFuXCIgfSxcbiAgICAgICAgICAgIGhlbHA6IHsgdHlwZTogXCJib29sZWFuXCIgfSxcbiAgICAgICAgICAgIFwicHJpbnQtbG9nc1wiOiB7IHR5cGU6IFwiYm9vbGVhblwiIH0sXG4gICAgICAgICAgICBcImxvZy1sZXZlbFwiOiB7IHR5cGU6IFwic3RyaW5nXCIgfSxcbiAgICAgICAgICAgIHZlcmJvc2U6IHsgdHlwZTogXCJib29sZWFuXCIsIHNob3J0OiBcInZcIiB9LFxuICAgICAgICAgICAgdHVpOiB7IHR5cGU6IFwiYm9vbGVhblwiIH0sXG4gICAgICAgICAgICBcIm5vLXN0cmVhbVwiOiB7IHR5cGU6IFwiYm9vbGVhblwiIH0sXG4gICAgICAgICAgICBcIm5vLWxvb3BcIjogeyB0eXBlOiBcImJvb2xlYW5cIiB9LFxuICAgICAgICAgICAgY29tcGxldGlvbjogeyB0eXBlOiBcInN0cmluZ1wiIH0sXG4gICAgICAgICAgICBzaGlwOiB7IHR5cGU6IFwiYm9vbGVhblwiIH0sXG4gICAgICAgICAgICBkcmFmdDogeyB0eXBlOiBcImJvb2xlYW5cIiB9LFxuICAgICAgICAgICAgXCJtYXgtY3ljbGVzXCI6IHsgdHlwZTogXCJzdHJpbmdcIiB9LFxuICAgICAgICAgICAgXCJzdHVjay10aHJlc2hvbGRcIjogeyB0eXBlOiBcInN0cmluZ1wiIH0sXG4gICAgICAgICAgICBjaGVja3BvaW50OiB7IHR5cGU6IFwic3RyaW5nXCIgfSxcbiAgICAgICAgICAgIFwiZGVidWctd29ya1wiOiB7IHR5cGU6IFwiYm9vbGVhblwiIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGFsbG93UG9zaXRpb25hbHM6IHRydWUsXG4gICAgfSk7XG5cbiAgICBjb25zdCBmbGFnczogUmFscGhGbGFncyA9IHtcbiAgICAgICAgd29ya2Zsb3c6IHBvc2l0aW9uYWxzWzBdLFxuICAgICAgICBtYXhJdGVyczogdmFsdWVzW1wibWF4LWl0ZXJzXCJdXG4gICAgICAgICAgICA/IE51bWJlci5wYXJzZUludCh2YWx1ZXNbXCJtYXgtaXRlcnNcIl0pXG4gICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ2F0ZXM6IHZhbHVlcy5nYXRlc1xuICAgICAgICAgICAgPyB2YWx1ZXMuZ2F0ZXMuc3BsaXQoXCIsXCIpLm1hcCgoZykgPT4gZy50cmltKCkpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgcmV2aWV3OiB2YWx1ZXMucmV2aWV3IGFzIFJhbHBoRmxhZ3NbXCJyZXZpZXdcIl0sXG4gICAgICAgIHJlc3VtZTogdmFsdWVzLnJlc3VtZSxcbiAgICAgICAgcnVuSWQ6IHZhbHVlc1tcInJ1bi1pZFwiXSxcbiAgICAgICAgZHJ5UnVuOiB2YWx1ZXNbXCJkcnktcnVuXCJdLFxuICAgICAgICBjaTogdmFsdWVzLmNpLFxuICAgICAgICBoZWxwOiB2YWx1ZXMuaGVscCxcbiAgICAgICAgcHJpbnRMb2dzOiB2YWx1ZXNbXCJwcmludC1sb2dzXCJdLFxuICAgICAgICBsb2dMZXZlbDpcbiAgICAgICAgICAgICh2YWx1ZXNbXCJsb2ctbGV2ZWxcIl0gYXMgTG9nTGV2ZWwpID8/XG4gICAgICAgICAgICAodmFsdWVzLnZlcmJvc2UgPyBcIkRFQlVHXCIgOiB1bmRlZmluZWQpLFxuICAgICAgICB2ZXJib3NlOiB2YWx1ZXMudmVyYm9zZSxcbiAgICAgICAgdHVpOiB2YWx1ZXMudHVpLFxuICAgICAgICBub1N0cmVhbTogdmFsdWVzW1wibm8tc3RyZWFtXCJdLFxuICAgICAgICBsb29wOiAhdmFsdWVzW1wibm8tbG9vcFwiXSxcbiAgICAgICAgbm9Mb29wOiB2YWx1ZXNbXCJuby1sb29wXCJdLFxuICAgICAgICBjb21wbGV0aW9uUHJvbWlzZTogdmFsdWVzLmNvbXBsZXRpb24sXG4gICAgICAgIHNoaXA6IHZhbHVlcy5zaGlwLFxuICAgICAgICBkcmFmdDogdmFsdWVzLmRyYWZ0LFxuICAgICAgICBtYXhDeWNsZXM6IHZhbHVlc1tcIm1heC1jeWNsZXNcIl1cbiAgICAgICAgICAgID8gTnVtYmVyLnBhcnNlSW50KHZhbHVlc1tcIm1heC1jeWNsZXNcIl0pXG4gICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3R1Y2tUaHJlc2hvbGQ6IHZhbHVlc1tcInN0dWNrLXRocmVzaG9sZFwiXVxuICAgICAgICAgICAgPyBOdW1iZXIucGFyc2VJbnQodmFsdWVzW1wic3R1Y2stdGhyZXNob2xkXCJdKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIGNoZWNrcG9pbnRGcmVxdWVuY3k6IHZhbHVlcy5jaGVja3BvaW50XG4gICAgICAgICAgICA/IE51bWJlci5wYXJzZUludCh2YWx1ZXMuY2hlY2twb2ludClcbiAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICBkZWJ1Z1dvcms6IHZhbHVlc1tcImRlYnVnLXdvcmtcIl0sXG4gICAgfTtcblxuICAgIC8vIFJldHVybiB0aGUgZmxhZ3MgcGx1cyB0aGUgcmVtYWluaW5nIHBvc2l0aW9uYWxzIChmb3IgZnV0dXJlIGV4dGVuc2liaWxpdHkpXG4gICAgcmV0dXJuIHsgZmxhZ3MsIHJlbWFpbmluZzogcG9zaXRpb25hbHMuc2xpY2UoMSkgfTtcbn1cblxuLyoqXG4gKiBSdW4gdGhlIFJhbHBoIENMSVxuICovXG5hc3luYyBmdW5jdGlvbiBydW5SYWxwaChhcmdzOiBzdHJpbmdbXSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IHsgZmxhZ3MgfSA9IHBhcnNlUmFscGhGbGFncyhhcmdzKTtcblxuICAgIC8vIFNob3cgaGVscFxuICAgIGlmIChmbGFncy5oZWxwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFJBTFBIX0hFTFBfVEVYVCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIGxvZ2dpbmdcbiAgICBhd2FpdCBMb2cuaW5pdCh7XG4gICAgICAgIHByaW50OiBmbGFncy5wcmludExvZ3MgPz8gZmFsc2UsXG4gICAgICAgIGxldmVsOiBmbGFncy5sb2dMZXZlbCA/PyBcIklORk9cIixcbiAgICAgICAgbG9nRGlyOiBcIi5haS1lbmcvbG9nc1wiLFxuICAgIH0pO1xuXG4gICAgTG9nLkRlZmF1bHQuaW5mbyhcImFpLWVuZyByYWxwaCBzdGFydGluZ1wiLCB7XG4gICAgICAgIGZsYWdzOiBKU09OLnN0cmluZ2lmeShmbGFncyksXG4gICAgfSk7XG5cbiAgICAvLyBMb2FkIGNvbmZpZ1xuICAgIGNvbnN0IGNvbmZpZyA9IGF3YWl0IGxvYWRDb25maWcoZmxhZ3MpO1xuXG4gICAgLy8gVFVJIG1vZGUgcmVxdWlyZXMgZHluYW1pYyBpbXBvcnQgLSBmb3Igbm93LCBzaG93IGluZm8gYW5kIGZhbGwgYmFjayB0byBDTElcbiAgICBpZiAoZmxhZ3MudHVpKSB7XG4gICAgICAgIFVJLmluZm8oXCJUVUkgbW9kZSByZXF1ZXN0ZWQgLSBmYWxsaW5nIGJhY2sgdG8gQ0xJIG1vZGVcIik7XG4gICAgICAgIFVJLmluZm8oXCIoVFVJIHJlcXVpcmVzOiBidW4gcnVuIC0td2F0Y2ggb3IgZnVsbCBUVUkgc2V0dXApXCIpO1xuICAgIH1cbiAgICBhd2FpdCBydW5DbGkoY29uZmlnLCBmbGFncyk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIG1haW4oKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gR2V0IHJhdyBhcmdzIChldmVyeXRoaW5nIGFmdGVyIHRoZSBwcm9ncmFtIG5hbWUpXG4gICAgICAgIGNvbnN0IHJhd0FyZ3MgPSBwcm9jZXNzLmFyZ3Yuc2xpY2UoMik7XG5cbiAgICAgICAgLy8gSGFuZGxlIG5vIGFyZ3VtZW50c1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICByYXdBcmdzLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAgICAgcmF3QXJnc1swXSA9PT0gXCItLWhlbHBcIiB8fFxuICAgICAgICAgICAgcmF3QXJnc1swXSA9PT0gXCItaFwiXG4gICAgICAgICkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coVE9QX0hFTFBfVEVYVCk7XG4gICAgICAgICAgICBwcm9jZXNzLmV4aXQoMCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdWJjb21tYW5kID0gcmF3QXJnc1swXTtcbiAgICAgICAgY29uc3Qgc3ViY29tbWFuZEFyZ3MgPSByYXdBcmdzLnNsaWNlKDEpO1xuXG4gICAgICAgIC8vIFJvdXRlIHRvIHN1YmNvbW1hbmRcbiAgICAgICAgc3dpdGNoIChzdWJjb21tYW5kKSB7XG4gICAgICAgICAgICBjYXNlIFwiaW5pdFwiOlxuICAgICAgICAgICAgICAgIGF3YWl0IHJ1bkluaXQoc3ViY29tbWFuZEFyZ3MpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwiaW5zdGFsbFwiOlxuICAgICAgICAgICAgY2FzZSBcImlcIjpcbiAgICAgICAgICAgICAgICBhd2FpdCBydW5JbnN0YWxsKHN1YmNvbW1hbmRBcmdzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcInJhbHBoXCI6XG4gICAgICAgICAgICBjYXNlIFwiclwiOlxuICAgICAgICAgICAgICAgIGF3YWl0IHJ1blJhbHBoKHN1YmNvbW1hbmRBcmdzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcIi0taGVscFwiOlxuICAgICAgICAgICAgY2FzZSBcIi1oXCI6XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coVE9QX0hFTFBfVEVYVCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gRGVmYXVsdCB0byByYWxwaDogdHJlYXQgdGhlIHN1YmNvbW1hbmQgYXMgdGhlIHByb21wdC93b3JrZmxvd1xuICAgICAgICAgICAgICAgIC8vIGFuZCBwYXNzIHRoZSBlbnRpcmUgb3JpZ2luYWwgYXJncyB0byByYWxwaFxuICAgICAgICAgICAgICAgIGF3YWl0IHJ1blJhbHBoKHJhd0FyZ3MpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgVUkuZXJyb3IoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpKTtcbiAgICAgICAgcHJvY2Vzcy5leGl0KDEpO1xuICAgIH1cbn1cblxuLy8gRXhwb3J0IG1haW4gZm9yIHVzZSBhcyBhIG1vZHVsZVxuZXhwb3J0IHsgbWFpbiBhcyBydW5NYWluIH07XG5cbi8vIE5vdGU6IFRoZSBDTEkgc2hpbSAoZGlzdC9jbGkvcnVuLmpzKSBoYW5kbGVzIGRpcmVjdCBleGVjdXRpb24uXG4vLyBUaGlzIGZpbGUgc2hvdWxkIG9ubHkgYmUgcnVuIHZpYSBpbXBvcnQgZnJvbSB0aGUgc2hpbS5cbiIsCiAgICAiLyoqXG4gKiBDb25maWd1cmF0aW9uIExvYWRlciBmb3IgYWktZW5nIHJhbHBoXG4gKi9cblxuaW1wb3J0IHsgcmVhZEZpbGUgfSBmcm9tIFwibm9kZTpmcy9wcm9taXNlc1wiO1xuaW1wb3J0IHsgam9pbiB9IGZyb20gXCJub2RlOnBhdGhcIjtcbmltcG9ydCB7IGZpbGVVUkxUb1BhdGggfSBmcm9tIFwibm9kZTp1cmxcIjtcbmltcG9ydCBZQU1MIGZyb20gXCJ5YW1sXCI7XG5pbXBvcnQgdHlwZSB7IFJhbHBoRmxhZ3MgfSBmcm9tIFwiLi4vY2xpL2ZsYWdzXCI7XG5pbXBvcnQgdHlwZSB7IEFpRW5nQ29uZmlnLCBERUZBVUxUX0NPTkZJRyB9IGZyb20gXCIuL3NjaGVtYVwiO1xuaW1wb3J0IHsgREVGQVVMVF9DT05GSUcgYXMgSEFSRENPREVEX0RFRkFVTFRTIH0gZnJvbSBcIi4vc2NoZW1hXCI7XG5cbi8vIFVzZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5IHdoZXJlIGNvbW1hbmQgaXMgY2FsbGVkIGZyb21cbi8vIFRoaXMgZW5zdXJlcyAuYWktZW5nL2NvbmZpZy55YW1sIGlzIGxvYWRlZCBmcm9tIHVzZXIncyBwcm9qZWN0IGRpcmVjdG9yeVxuY29uc3QgUk9PVCA9IHByb2Nlc3MuZW52LlRFU1RfUk9PVCA/PyBwcm9jZXNzLmN3ZCgpO1xuXG4vKipcbiAqIEVudmlyb25tZW50IHZhcmlhYmxlIHRvIGNvbmZpZyBrZXkgbWFwcGluZ1xuICovXG5jb25zdCBFTlZfVkFSX01BUFBJTkc6IFJlY29yZDxzdHJpbmcsIGtleW9mIEFpRW5nQ29uZmlnPiA9IHtcbiAgICAvLyBPcGVuQ29kZVxuICAgIE9QRU5DT0RFX1VSTDogXCJvcGVuY29kZVwiLFxuICAgIE9QRU5DT0RFX0RJUkVDVE9SWTogXCJvcGVuY29kZVwiLFxuICAgIE9QRU5DT0RFX1BST01QVF9USU1FT1VUX01TOiBcIm9wZW5jb2RlXCIsXG4gICAgLy8gRGlzY29yZCAobm9uLXNlY3JldClcbiAgICBESVNDT1JEX0JPVF9VU0VSTkFNRTogXCJub3RpZmljYXRpb25zXCIsXG4gICAgRElTQ09SRF9CT1RfQVZBVEFSX1VSTDogXCJub3RpZmljYXRpb25zXCIsXG4gICAgLy8gVUlcbiAgICBBSV9FTkdfU0lMRU5UOiBcInVpXCIsXG4gICAgLy8gTG9vcFxuICAgIEFJX0VOR19DWUNMRV9SRVRSSUVTOiBcImxvb3BcIixcbiAgICAvLyBEZWJ1Z1xuICAgIEFJX0VOR19ERUJVR19XT1JLOiBcImRlYnVnXCIsXG4gICAgLy8gR2F0ZXMgKGNvbW1hbmRzKVxuICAgIEFJX0VOR19URVNUX0NNRDogXCJnYXRlc1wiLFxuICAgIEFJX0VOR19MSU5UX0NNRDogXCJnYXRlc1wiLFxuICAgIEFJX0VOR19BQ0NFUFRBTkNFX0NNRDogXCJnYXRlc1wiLFxuICAgIEFJX0VOR19UWVBFQ0hFQ0tfQ01EOiBcImdhdGVzXCIsXG4gICAgQUlfRU5HX0JVSUxEX0NNRDogXCJnYXRlc1wiLFxufTtcblxuLyoqXG4gKiBHZXQgbmVzdGVkIHZhbHVlIGZyb20gb2JqZWN0IHVzaW5nIGRvdCBub3RhdGlvblxuICovXG5mdW5jdGlvbiBnZXROZXN0ZWRWYWx1ZShvYmo6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LCBwYXRoOiBzdHJpbmcpOiB1bmtub3duIHtcbiAgICByZXR1cm4gcGF0aC5zcGxpdChcIi5cIikucmVkdWNlPHVua25vd24+KChjdXJyZW50LCBrZXkpID0+IHtcbiAgICAgICAgaWYgKGN1cnJlbnQgJiYgdHlwZW9mIGN1cnJlbnQgPT09IFwib2JqZWN0XCIgJiYga2V5IGluIGN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiAoY3VycmVudCBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPilba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sIG9iaik7XG59XG5cbi8qKlxuICogU2V0IG5lc3RlZCB2YWx1ZSBpbiBvYmplY3QgdXNpbmcgZG90IG5vdGF0aW9uXG4gKi9cbmZ1bmN0aW9uIHNldE5lc3RlZFZhbHVlKFxuICAgIG9iajogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIHZhbHVlOiB1bmtub3duLFxuKTogdm9pZCB7XG4gICAgY29uc3Qga2V5cyA9IHBhdGguc3BsaXQoXCIuXCIpO1xuICAgIGNvbnN0IGxhc3RLZXkgPSBrZXlzLnBvcCgpITtcbiAgICBjb25zdCB0YXJnZXQgPSBrZXlzLnJlZHVjZTxSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oKGN1cnJlbnQsIGtleSkgPT4ge1xuICAgICAgICBpZiAoIWN1cnJlbnRba2V5XSB8fCB0eXBlb2YgY3VycmVudFtrZXldICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBjdXJyZW50W2tleV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudFtrZXldIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICAgIH0sIG9iaik7XG4gICAgdGFyZ2V0W2xhc3RLZXldID0gdmFsdWU7XG59XG5cbi8qKlxuICogQXBwbHkgZW52aXJvbm1lbnQgdmFyaWFibGUgb3ZlcnJpZGVzIHRvIGNvbmZpZ1xuICovXG5mdW5jdGlvbiBhcHBseUVudk92ZXJyaWRlcyhjb25maWc6IEFpRW5nQ29uZmlnKTogdm9pZCB7XG4gICAgLy8gT3BlbkNvZGUgb3ZlcnJpZGVzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk9QRU5DT0RFX1VSTCkge1xuICAgICAgICBjb25maWcub3BlbmNvZGUuc2VydmVyVXJsID0gcHJvY2Vzcy5lbnYuT1BFTkNPREVfVVJMO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuT1BFTkNPREVfRElSRUNUT1JZKSB7XG4gICAgICAgIGNvbmZpZy5vcGVuY29kZS5kaXJlY3RvcnkgPSBwcm9jZXNzLmVudi5PUEVOQ09ERV9ESVJFQ1RPUlk7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5PUEVOQ09ERV9QUk9NUFRfVElNRU9VVF9NUykge1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gTnVtYmVyLnBhcnNlSW50KFxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuT1BFTkNPREVfUFJPTVBUX1RJTUVPVVRfTVMsXG4gICAgICAgICAgICAxMCxcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTih0aW1lb3V0KSkge1xuICAgICAgICAgICAgY29uZmlnLm9wZW5jb2RlLnByb21wdFRpbWVvdXRNcyA9IHRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEaXNjb3JkIG92ZXJyaWRlcyAobm9uLXNlY3JldClcbiAgICBpZiAocHJvY2Vzcy5lbnYuRElTQ09SRF9CT1RfVVNFUk5BTUUpIHtcbiAgICAgICAgY29uZmlnLm5vdGlmaWNhdGlvbnMuZGlzY29yZC51c2VybmFtZSA9XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5ESVNDT1JEX0JPVF9VU0VSTkFNRTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52LkRJU0NPUkRfQk9UX0FWQVRBUl9VUkwpIHtcbiAgICAgICAgY29uZmlnLm5vdGlmaWNhdGlvbnMuZGlzY29yZC5hdmF0YXJVcmwgPVxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuRElTQ09SRF9CT1RfQVZBVEFSX1VSTDtcbiAgICB9XG5cbiAgICAvLyBVSSBvdmVycmlkZVxuICAgIGlmIChwcm9jZXNzLmVudi5BSV9FTkdfU0lMRU5UKSB7XG4gICAgICAgIGNvbmZpZy51aS5zaWxlbnQgPVxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuQUlfRU5HX1NJTEVOVCA9PT0gXCIxXCIgfHxcbiAgICAgICAgICAgIHByb2Nlc3MuZW52LkFJX0VOR19TSUxFTlQgPT09IFwidHJ1ZVwiO1xuICAgIH1cblxuICAgIC8vIExvb3Agb3ZlcnJpZGVzXG4gICAgaWYgKHByb2Nlc3MuZW52LkFJX0VOR19DWUNMRV9SRVRSSUVTKSB7XG4gICAgICAgIGNvbnN0IHJldHJpZXMgPSBOdW1iZXIucGFyc2VJbnQocHJvY2Vzcy5lbnYuQUlfRU5HX0NZQ0xFX1JFVFJJRVMsIDEwKTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4ocmV0cmllcykpIHtcbiAgICAgICAgICAgIGNvbmZpZy5sb29wLmN5Y2xlUmV0cmllcyA9IHJldHJpZXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWJ1ZyBvdmVycmlkZXNcbiAgICBpZiAocHJvY2Vzcy5lbnYuQUlfRU5HX0RFQlVHX1dPUkspIHtcbiAgICAgICAgY29uZmlnLmRlYnVnLndvcmsgPVxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuQUlfRU5HX0RFQlVHX1dPUksgPT09IFwiMVwiIHx8XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5BSV9FTkdfREVCVUdfV09SSyA9PT0gXCJ0cnVlXCI7XG4gICAgfVxuXG4gICAgLy8gR2F0ZSBjb21tYW5kIG92ZXJyaWRlc1xuICAgIGlmIChwcm9jZXNzLmVudi5BSV9FTkdfVEVTVF9DTUQpIHtcbiAgICAgICAgY29uZmlnLmdhdGVzLnRlc3QuY29tbWFuZCA9IHByb2Nlc3MuZW52LkFJX0VOR19URVNUX0NNRDtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52LkFJX0VOR19MSU5UX0NNRCkge1xuICAgICAgICBjb25maWcuZ2F0ZXMubGludC5jb21tYW5kID0gcHJvY2Vzcy5lbnYuQUlfRU5HX0xJTlRfQ01EO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuQUlfRU5HX0FDQ0VQVEFOQ0VfQ01EKSB7XG4gICAgICAgIGNvbmZpZy5nYXRlcy5hY2NlcHRhbmNlLmNvbW1hbmQgPSBwcm9jZXNzLmVudi5BSV9FTkdfQUNDRVBUQU5DRV9DTUQ7XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5BSV9FTkdfVFlQRUNIRUNLX0NNRCkge1xuICAgICAgICBjb25maWcuZ2F0ZXMudHlwZWNoZWNrLmNvbW1hbmQgPSBwcm9jZXNzLmVudi5BSV9FTkdfVFlQRUNIRUNLX0NNRDtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52LkFJX0VOR19CVUlMRF9DTUQpIHtcbiAgICAgICAgY29uZmlnLmdhdGVzLmJ1aWxkLmNvbW1hbmQgPSBwcm9jZXNzLmVudi5BSV9FTkdfQlVJTERfQ01EO1xuICAgIH1cbn1cblxuLyoqXG4gKiBEZWVwIG1lcmdlIHR3byBvYmplY3RzICh0YXJnZXQgPC0gc291cmNlKVxuICovXG5mdW5jdGlvbiBkZWVwTWVyZ2U8VCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIHVua25vd24+PihcbiAgICB0YXJnZXQ6IFQsXG4gICAgc291cmNlOiBQYXJ0aWFsPFQ+LFxuKTogVCB7XG4gICAgY29uc3QgcmVzdWx0ID0geyAuLi50YXJnZXQgfSBhcyBUO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNvdXJjZSkgYXMgQXJyYXk8a2V5b2YgVD4pIHtcbiAgICAgICAgY29uc3Qgc291cmNlVmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgY29uc3QgdGFyZ2V0VmFsdWUgPSB0YXJnZXRba2V5XTtcblxuICAgICAgICBpZiAoc291cmNlVmFsdWUgPT09IHVuZGVmaW5lZCkgY29udGludWU7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgc291cmNlVmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiBzb3VyY2VWYWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkoc291cmNlVmFsdWUpXG4gICAgICAgICkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHRhcmdldFZhbHVlICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHRhcmdldFZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkodGFyZ2V0VmFsdWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gZGVlcE1lcmdlKFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRWYWx1ZSBhcyBhbnksXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZVZhbHVlIGFzIGFueSxcbiAgICAgICAgICAgICAgICApIGFzIGFueTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBzb3VyY2VWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gc291cmNlVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBNZXJnZSBnYXRlIGNvbW1hbmQgY29uZmlncyAoaGFuZGxlIGxlZ2FjeSBzdHJpbmcgZm9ybWF0KVxuICovXG5mdW5jdGlvbiBtZXJnZUdhdGVDb25maWcoXG4gICAgZXhpc3Rpbmc6IHsgY29tbWFuZDogc3RyaW5nIH0sXG4gICAgaW5jb21pbmc6IHN0cmluZyB8IHsgY29tbWFuZD86IHN0cmluZyB9LFxuKTogeyBjb21tYW5kOiBzdHJpbmcgfSB7XG4gICAgaWYgKHR5cGVvZiBpbmNvbWluZyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4geyBjb21tYW5kOiBpbmNvbWluZyB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjb21tYW5kOiBpbmNvbWluZy5jb21tYW5kID8/IGV4aXN0aW5nLmNvbW1hbmQsXG4gICAgfTtcbn1cblxuLyoqXG4gKiBMb2FkIGNvbmZpZ3VyYXRpb24gZnJvbSAuYWktZW5nL2NvbmZpZy55YW1sXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkQ29uZmlnKGZsYWdzOiBSYWxwaEZsYWdzKTogUHJvbWlzZTxBaUVuZ0NvbmZpZz4ge1xuICAgIC8vIFN0YXJ0IHdpdGggZGVmYXVsdCBjb25maWdcbiAgICBjb25zdCBjb25maWc6IEFpRW5nQ29uZmlnID0ge1xuICAgICAgICB2ZXJzaW9uOiBIQVJEQ09ERURfREVGQVVMVFMudmVyc2lvbixcbiAgICAgICAgcnVubmVyOiB7IC4uLkhBUkRDT0RFRF9ERUZBVUxUUy5ydW5uZXIgfSxcbiAgICAgICAgbG9vcDogeyAuLi5IQVJEQ09ERURfREVGQVVMVFMubG9vcCB9LFxuICAgICAgICBkZWJ1ZzogeyAuLi5IQVJEQ09ERURfREVGQVVMVFMuZGVidWcgfSxcbiAgICAgICAgb3BlbmNvZGU6IHsgLi4uSEFSRENPREVEX0RFRkFVTFRTLm9wZW5jb2RlIH0sXG4gICAgICAgIGFudGhyb3BpYzogeyAuLi5IQVJEQ09ERURfREVGQVVMVFMuYW50aHJvcGljIH0sXG4gICAgICAgIGdhdGVzOiB7XG4gICAgICAgICAgICBsaW50OiB7IC4uLkhBUkRDT0RFRF9ERUZBVUxUUy5nYXRlcy5saW50IH0sXG4gICAgICAgICAgICB0eXBlY2hlY2s6IHsgLi4uSEFSRENPREVEX0RFRkFVTFRTLmdhdGVzLnR5cGVjaGVjayB9LFxuICAgICAgICAgICAgdGVzdDogeyAuLi5IQVJEQ09ERURfREVGQVVMVFMuZ2F0ZXMudGVzdCB9LFxuICAgICAgICAgICAgYnVpbGQ6IHsgLi4uSEFSRENPREVEX0RFRkFVTFRTLmdhdGVzLmJ1aWxkIH0sXG4gICAgICAgICAgICBhY2NlcHRhbmNlOiB7IC4uLkhBUkRDT0RFRF9ERUZBVUxUUy5nYXRlcy5hY2NlcHRhbmNlIH0sXG4gICAgICAgIH0sXG4gICAgICAgIG1vZGVsczogeyAuLi5IQVJEQ09ERURfREVGQVVMVFMubW9kZWxzIH0sXG4gICAgICAgIG5vdGlmaWNhdGlvbnM6IHtcbiAgICAgICAgICAgIGRpc2NvcmQ6IHsgLi4uSEFSRENPREVEX0RFRkFVTFRTLm5vdGlmaWNhdGlvbnMuZGlzY29yZCB9LFxuICAgICAgICB9LFxuICAgICAgICB1aTogeyAuLi5IQVJEQ09ERURfREVGQVVMVFMudWkgfSxcbiAgICB9O1xuXG4gICAgLy8gVHJ5IHRvIGxvYWQgZnJvbSBjb25maWcgZmlsZVxuICAgIGNvbnN0IGNvbmZpZ1BhdGggPSBqb2luKFJPT1QsIFwiLmFpLWVuZ1wiLCBcImNvbmZpZy55YW1sXCIpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZ0NvbnRlbnQgPSBhd2FpdCByZWFkRmlsZShjb25maWdQYXRoLCBcInV0Zi04XCIpO1xuICAgICAgICBjb25zdCB1c2VyQ29uZmlnID0gWUFNTC5wYXJzZShjb25maWdDb250ZW50KTtcblxuICAgICAgICBpZiAodXNlckNvbmZpZy52ZXJzaW9uKSB7XG4gICAgICAgICAgICBjb25maWcudmVyc2lvbiA9IHVzZXJDb25maWcudmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlckNvbmZpZy5ydW5uZXIpIHtcbiAgICAgICAgICAgIGNvbmZpZy5ydW5uZXIgPSB7IC4uLmNvbmZpZy5ydW5uZXIsIC4uLnVzZXJDb25maWcucnVubmVyIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzZXJDb25maWcubG9vcCkge1xuICAgICAgICAgICAgY29uZmlnLmxvb3AgPSB7IC4uLmNvbmZpZy5sb29wLCAuLi51c2VyQ29uZmlnLmxvb3AgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlckNvbmZpZy5kZWJ1Zykge1xuICAgICAgICAgICAgY29uZmlnLmRlYnVnID0geyAuLi5jb25maWcuZGVidWcsIC4uLnVzZXJDb25maWcuZGVidWcgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlckNvbmZpZy5vcGVuY29kZSkge1xuICAgICAgICAgICAgY29uZmlnLm9wZW5jb2RlID0geyAuLi5jb25maWcub3BlbmNvZGUsIC4uLnVzZXJDb25maWcub3BlbmNvZGUgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlckNvbmZpZy5hbnRocm9waWMpIHtcbiAgICAgICAgICAgIGNvbmZpZy5hbnRocm9waWMgPSB7IC4uLmNvbmZpZy5hbnRocm9waWMsIC4uLnVzZXJDb25maWcuYW50aHJvcGljIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzZXJDb25maWcuZ2F0ZXMpIHtcbiAgICAgICAgICAgIGlmICh1c2VyQ29uZmlnLmdhdGVzLmxpbnQpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuZ2F0ZXMubGludCA9IG1lcmdlR2F0ZUNvbmZpZyhcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmdhdGVzLmxpbnQsXG4gICAgICAgICAgICAgICAgICAgIHVzZXJDb25maWcuZ2F0ZXMubGludCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVzZXJDb25maWcuZ2F0ZXMudHlwZWNoZWNrKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLmdhdGVzLnR5cGVjaGVjayA9IG1lcmdlR2F0ZUNvbmZpZyhcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmdhdGVzLnR5cGVjaGVjayxcbiAgICAgICAgICAgICAgICAgICAgdXNlckNvbmZpZy5nYXRlcy50eXBlY2hlY2ssXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1c2VyQ29uZmlnLmdhdGVzLnRlc3QpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuZ2F0ZXMudGVzdCA9IG1lcmdlR2F0ZUNvbmZpZyhcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLmdhdGVzLnRlc3QsXG4gICAgICAgICAgICAgICAgICAgIHVzZXJDb25maWcuZ2F0ZXMudGVzdCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVzZXJDb25maWcuZ2F0ZXMuYnVpbGQpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuZ2F0ZXMuYnVpbGQgPSBtZXJnZUdhdGVDb25maWcoXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5nYXRlcy5idWlsZCxcbiAgICAgICAgICAgICAgICAgICAgdXNlckNvbmZpZy5nYXRlcy5idWlsZCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVzZXJDb25maWcuZ2F0ZXMuYWNjZXB0YW5jZSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5nYXRlcy5hY2NlcHRhbmNlID0gbWVyZ2VHYXRlQ29uZmlnKFxuICAgICAgICAgICAgICAgICAgICBjb25maWcuZ2F0ZXMuYWNjZXB0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgdXNlckNvbmZpZy5nYXRlcy5hY2NlcHRhbmNlLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzZXJDb25maWcubW9kZWxzKSB7XG4gICAgICAgICAgICBjb25maWcubW9kZWxzID0geyAuLi5jb25maWcubW9kZWxzLCAuLi51c2VyQ29uZmlnLm1vZGVscyB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VyQ29uZmlnLm5vdGlmaWNhdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICh1c2VyQ29uZmlnLm5vdGlmaWNhdGlvbnMuZGlzY29yZCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5ub3RpZmljYXRpb25zLmRpc2NvcmQgPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbmZpZy5ub3RpZmljYXRpb25zLmRpc2NvcmQsXG4gICAgICAgICAgICAgICAgICAgIC4uLnVzZXJDb25maWcubm90aWZpY2F0aW9ucy5kaXNjb3JkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzZXJDb25maWcudWkpIHtcbiAgICAgICAgICAgIGNvbmZpZy51aSA9IHsgLi4uY29uZmlnLnVpLCAuLi51c2VyQ29uZmlnLnVpIH07XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBDb25maWcgZmlsZSBub3QgZm91bmQgb3IgaW52YWxpZCAtIHVzZSBkZWZhdWx0c1xuICAgICAgICBpZiAoIShlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJFTk9FTlRcIikpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgYFdhcm5pbmc6IEZhaWxlZCB0byBsb2FkIGNvbmZpZyBmcm9tICR7Y29uZmlnUGF0aH0sIHVzaW5nIGRlZmF1bHRzYCxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBcHBseSBlbnZpcm9ubWVudCB2YXJpYWJsZSBvdmVycmlkZXMgKGVudiB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgeWFtbClcbiAgICBhcHBseUVudk92ZXJyaWRlcyhjb25maWcpO1xuXG4gICAgLy8gT3ZlcnJpZGUgd2l0aCBDTEkgZmxhZ3MgKGhpZ2hlc3QgcHJpb3JpdHkpXG4gICAgaWYgKGZsYWdzLm1heEl0ZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uZmlnLnJ1bm5lci5tYXhJdGVycyA9IGZsYWdzLm1heEl0ZXJzO1xuICAgIH1cbiAgICBpZiAoZmxhZ3MucmV2aWV3ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uZmlnLnJ1bm5lci5yZXZpZXcgPSBmbGFncy5yZXZpZXc7XG4gICAgfVxuICAgIGlmIChmbGFncy5tYXhDeWNsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25maWcubG9vcC5tYXhDeWNsZXMgPSBmbGFncy5tYXhDeWNsZXM7XG4gICAgfVxuICAgIGlmIChmbGFncy5zdHVja1RocmVzaG9sZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbmZpZy5sb29wLnN0dWNrVGhyZXNob2xkID0gZmxhZ3Muc3R1Y2tUaHJlc2hvbGQ7XG4gICAgfVxuICAgIGlmIChmbGFncy5jaGVja3BvaW50RnJlcXVlbmN5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uZmlnLmxvb3AuY2hlY2twb2ludEZyZXF1ZW5jeSA9IGZsYWdzLmNoZWNrcG9pbnRGcmVxdWVuY3k7XG4gICAgfVxuICAgIGlmIChmbGFncy5wcmludExvZ3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25maWcucnVubmVyLnByaW50TG9ncyA9IGZsYWdzLnByaW50TG9ncztcbiAgICB9XG4gICAgaWYgKGZsYWdzLmxvZ0xldmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uZmlnLnJ1bm5lci5sb2dMZXZlbCA9IGZsYWdzLmxvZ0xldmVsO1xuICAgIH1cbiAgICBpZiAoZmxhZ3MudmVyYm9zZSkge1xuICAgICAgICBjb25maWcucnVubmVyLmxvZ0xldmVsID0gXCJERUJVR1wiO1xuICAgIH1cbiAgICBpZiAoZmxhZ3Mud29ya2luZ0RpciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbmZpZy5vcGVuY29kZS5kaXJlY3RvcnkgPSBmbGFncy53b3JraW5nRGlyO1xuICAgIH1cbiAgICBpZiAoZmxhZ3MuZHJ5UnVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZHJ5UnVuIGNvdWxkIGJlIHVzZWQgYnkgZ2F0ZXMgb3Igb3RoZXIgY29tcG9uZW50c1xuICAgIH1cblxuICAgIHJldHVybiBjb25maWc7XG59XG4iLAogICAgIi8qKlxuICogQUkgRW5naW5lZXJpbmcgU3lzdGVtIENvbmZpZ3VyYXRpb24gU2NoZW1hXG4gKi9cblxuLyoqXG4gKiBSdW5uZXIgQ29uZmlndXJhdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJ1bm5lckNvbmZpZyB7XG4gICAgLyoqIEJhY2tlbmQgdG8gdXNlIGZvciBleGVjdXRpb24gKi9cbiAgICBiYWNrZW5kOiBcIm9wZW5jb2RlXCIgfCBcImFudGhyb3BpY1wiO1xuICAgIC8qKiBSZXZpZXcgbW9kZSBmb3IgQUkgcmV2aWV3cyAqL1xuICAgIHJldmlldzogXCJub25lXCIgfCBcIm9wZW5jb2RlXCIgfCBcImFudGhyb3BpY1wiIHwgXCJib3RoXCI7XG4gICAgLyoqIERpcmVjdG9yeSBmb3IgcnVuIGFydGlmYWN0cyAqL1xuICAgIGFydGlmYWN0c0Rpcjogc3RyaW5nO1xuICAgIC8qKiBNYXhpbXVtIGl0ZXJhdGlvbnMgcGVyIHJ1biAqL1xuICAgIG1heEl0ZXJzOiBudW1iZXI7XG4gICAgLyoqIFByaW50IGxvZ3MgdG8gc3RkZXJyICovXG4gICAgcHJpbnRMb2dzPzogYm9vbGVhbjtcbiAgICAvKiogTG9nIGxldmVsICovXG4gICAgbG9nTGV2ZWw/OiBcIkRFQlVHXCIgfCBcIklORk9cIiB8IFwiV0FSTlwiIHwgXCJFUlJPUlwiO1xufVxuXG4vKipcbiAqIExvb3AgQ29uZmlndXJhdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIExvb3BDb25maWcge1xuICAgIC8qKiBNYXhpbXVtIG51bWJlciBvZiBsb29wIGN5Y2xlcyAqL1xuICAgIG1heEN5Y2xlczogbnVtYmVyO1xuICAgIC8qKiBOdW1iZXIgb2YgcmV0cnkgYXR0ZW1wdHMgcGVyIGN5Y2xlIG9uIGZhaWx1cmUgKi9cbiAgICBjeWNsZVJldHJpZXM6IG51bWJlcjtcbiAgICAvKiogQ2hlY2twb2ludCBmcmVxdWVuY3kgKHNhdmUgc3RhdGUgZXZlcnkgTiBjeWNsZXMpICovXG4gICAgY2hlY2twb2ludEZyZXF1ZW5jeTogbnVtYmVyO1xuICAgIC8qKiBTdHVjayBkZXRlY3Rpb24gdGhyZXNob2xkIC0gYWJvcnQgYWZ0ZXIgTiBjeWNsZXMgd2l0aCBubyBwcm9ncmVzcyAqL1xuICAgIHN0dWNrVGhyZXNob2xkOiBudW1iZXI7XG59XG5cbi8qKlxuICogRGVidWcgQ29uZmlndXJhdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIERlYnVnQ29uZmlnIHtcbiAgICAvKiogUHJpbnQgZXZlcnkgdG9vbCBpbnZvY2F0aW9uIGlucHV0L291dHB1dCB0byBjb25zb2xlIGFuZCBsb2dzICovXG4gICAgd29yazogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBPcGVuQ29kZSBDb25maWd1cmF0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgT3BlbkNvZGVDb25maWcge1xuICAgIC8qKiBNb2RlbCB0byB1c2UgZm9yIE9wZW5Db2RlICovXG4gICAgbW9kZWw6IHN0cmluZztcbiAgICAvKiogVGVtcGVyYXR1cmUgZm9yIGdlbmVyYXRpb24gKi9cbiAgICB0ZW1wZXJhdHVyZTogbnVtYmVyO1xuICAgIC8qKiBFeGlzdGluZyBzZXJ2ZXIgVVJMIChvcHRpb25hbCAtIHdpbGwgc3Bhd24gaWYgbm90IHByb3ZpZGVkKSAqL1xuICAgIHNlcnZlclVybD86IHN0cmluZztcbiAgICAvKiogV29ya2luZyBkaXJlY3RvcnkgZm9yIE9wZW5Db2RlIHNlc3Npb24gKi9cbiAgICBkaXJlY3Rvcnk/OiBzdHJpbmc7XG4gICAgLyoqIFByb21wdCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyAqL1xuICAgIHByb21wdFRpbWVvdXRNcz86IG51bWJlcjtcbn1cblxuLyoqXG4gKiBBbnRocm9waWMgQ29uZmlndXJhdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFudGhyb3BpY0NvbmZpZyB7XG4gICAgLyoqIFdoZXRoZXIgQW50aHJvcGljIGJhY2tlbmQgaXMgZW5hYmxlZCAqL1xuICAgIGVuYWJsZWQ6IGJvb2xlYW47XG4gICAgLyoqIE1vZGVsIHRvIHVzZSBmb3IgQW50aHJvcGljICovXG4gICAgbW9kZWw6IHN0cmluZztcbn1cblxuLyoqXG4gKiBHYXRlIENvbW1hbmQgQ29uZmlndXJhdGlvblxuICovXG5leHBvcnQgaW50ZXJmYWNlIEdhdGVDb21tYW5kQ29uZmlnIHtcbiAgICAvKiogQ29tbWFuZCB0byBleGVjdXRlIGZvciB0aGlzIGdhdGUgKi9cbiAgICBjb21tYW5kOiBzdHJpbmc7XG59XG5cbi8qKlxuICogUXVhbGl0eSBHYXRlcyBDb25maWd1cmF0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgR2F0ZXNDb25maWcge1xuICAgIC8qKiBMaW50IGdhdGUgY29uZmlndXJhdGlvbiAqL1xuICAgIGxpbnQ6IEdhdGVDb21tYW5kQ29uZmlnO1xuICAgIC8qKiBUeXBlIGNoZWNrIGdhdGUgY29uZmlndXJhdGlvbiAqL1xuICAgIHR5cGVjaGVjazogR2F0ZUNvbW1hbmRDb25maWc7XG4gICAgLyoqIFRlc3QgZ2F0ZSBjb25maWd1cmF0aW9uICovXG4gICAgdGVzdDogR2F0ZUNvbW1hbmRDb25maWc7XG4gICAgLyoqIEJ1aWxkIGdhdGUgY29uZmlndXJhdGlvbiAqL1xuICAgIGJ1aWxkOiBHYXRlQ29tbWFuZENvbmZpZztcbiAgICAvKiogQWNjZXB0YW5jZSBnYXRlIGNvbmZpZ3VyYXRpb24gKGUuZy4sIGdpdCBkaWZmIC0tbmFtZS1vbmx5KSAqL1xuICAgIGFjY2VwdGFuY2U6IEdhdGVDb21tYW5kQ29uZmlnO1xufVxuXG4vKipcbiAqIE1vZGVscyBDb25maWd1cmF0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTW9kZWxzQ29uZmlnIHtcbiAgICAvKiogTW9kZWwgZm9yIHJlc2VhcmNoIHRhc2tzICovXG4gICAgcmVzZWFyY2g6IHN0cmluZztcbiAgICAvKiogTW9kZWwgZm9yIHBsYW5uaW5nIHRhc2tzICovXG4gICAgcGxhbm5pbmc6IHN0cmluZztcbiAgICAvKiogTW9kZWwgZm9yIGNvZGViYXNlIGV4cGxvcmF0aW9uICovXG4gICAgZXhwbG9yYXRpb246IHN0cmluZztcbiAgICAvKiogTW9kZWwgZm9yIGNvZGluZy9pbXBsZW1lbnRhdGlvbiAqL1xuICAgIGNvZGluZzogc3RyaW5nO1xuICAgIC8qKiBEZWZhdWx0IGZhbGxiYWNrIG1vZGVsICovXG4gICAgZGVmYXVsdDogc3RyaW5nO1xufVxuXG4vKipcbiAqIE5vdGlmaWNhdGlvbiBDb25maWd1cmF0aW9uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTm90aWZpY2F0aW9uc0NvbmZpZyB7XG4gICAgLyoqIERpc2NvcmQgbm90aWZpY2F0aW9uIHNldHRpbmdzICovXG4gICAgZGlzY29yZDoge1xuICAgICAgICAvKiogRW5hYmxlIERpc2NvcmQgbm90aWZpY2F0aW9ucyAqL1xuICAgICAgICBlbmFibGVkOiBib29sZWFuO1xuICAgICAgICAvKiogQm90IHVzZXJuYW1lICovXG4gICAgICAgIHVzZXJuYW1lOiBzdHJpbmc7XG4gICAgICAgIC8qKiBCb3QgYXZhdGFyIFVSTCAqL1xuICAgICAgICBhdmF0YXJVcmw/OiBzdHJpbmc7XG4gICAgICAgIC8qKiBXZWJob29rIFVSTCAoc2hvdWxkIGNvbWUgZnJvbSBlbnYsIG5ldmVyIGhhcmRjb2RlZCkgKi9cbiAgICAgICAgd2ViaG9vaz86IHtcbiAgICAgICAgICAgIC8qKiBTb3VyY2UgdHlwZSAtIG9ubHkgJ2Vudicgc3VwcG9ydGVkIGZvciBzZWNyZXRzICovXG4gICAgICAgICAgICBzb3VyY2U6IFwiZW52XCI7XG4gICAgICAgICAgICAvKiogRW52aXJvbm1lbnQgdmFyaWFibGUgbmFtZSBmb3IgdGhlIHdlYmhvb2sgVVJMICovXG4gICAgICAgICAgICBlbnZWYXI6IHN0cmluZztcbiAgICAgICAgfTtcbiAgICB9O1xufVxuXG4vKipcbiAqIFVJIENvbmZpZ3VyYXRpb25cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVaUNvbmZpZyB7XG4gICAgLyoqIFN1cHByZXNzIG5vaXN5IHdhcm5pbmdzL2xvZ3MgKi9cbiAgICBzaWxlbnQ6IGJvb2xlYW47XG59XG5cbi8qKlxuICogTWFpbiBDb25maWd1cmF0aW9uIFNjaGVtYVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFpRW5nQ29uZmlnIHtcbiAgICAvKiogQ29uZmlndXJhdGlvbiB2ZXJzaW9uICovXG4gICAgdmVyc2lvbjogbnVtYmVyO1xuICAgIC8qKiBSdW5uZXIgY29uZmlndXJhdGlvbiAqL1xuICAgIHJ1bm5lcjogUnVubmVyQ29uZmlnO1xuICAgIC8qKiBMb29wIGNvbmZpZ3VyYXRpb24gKi9cbiAgICBsb29wOiBMb29wQ29uZmlnO1xuICAgIC8qKiBEZWJ1ZyBjb25maWd1cmF0aW9uICovXG4gICAgZGVidWc6IERlYnVnQ29uZmlnO1xuICAgIC8qKiBPcGVuQ29kZSBjb25maWd1cmF0aW9uICovXG4gICAgb3BlbmNvZGU6IE9wZW5Db2RlQ29uZmlnO1xuICAgIC8qKiBBbnRocm9waWMgY29uZmlndXJhdGlvbiAqL1xuICAgIGFudGhyb3BpYzogQW50aHJvcGljQ29uZmlnO1xuICAgIC8qKiBRdWFsaXR5IGdhdGVzIGNvbmZpZ3VyYXRpb24gKi9cbiAgICBnYXRlczogR2F0ZXNDb25maWc7XG4gICAgLyoqIE1vZGVscyBjb25maWd1cmF0aW9uICovXG4gICAgbW9kZWxzOiBNb2RlbHNDb25maWc7XG4gICAgLyoqIE5vdGlmaWNhdGlvbnMgY29uZmlndXJhdGlvbiAqL1xuICAgIG5vdGlmaWNhdGlvbnM6IE5vdGlmaWNhdGlvbnNDb25maWc7XG4gICAgLyoqIFVJIGNvbmZpZ3VyYXRpb24gKi9cbiAgICB1aTogVWlDb25maWc7XG59XG5cbi8qKlxuICogRGVmYXVsdCBjb25maWd1cmF0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBERUZBVUxUX0NPTkZJRzogQWlFbmdDb25maWcgPSB7XG4gICAgdmVyc2lvbjogMSxcbiAgICBydW5uZXI6IHtcbiAgICAgICAgYmFja2VuZDogXCJvcGVuY29kZVwiLFxuICAgICAgICByZXZpZXc6IFwib3BlbmNvZGVcIixcbiAgICAgICAgYXJ0aWZhY3RzRGlyOiBcIi5haS1lbmcvcnVuc1wiLFxuICAgICAgICBtYXhJdGVyczogMyxcbiAgICAgICAgcHJpbnRMb2dzOiBmYWxzZSxcbiAgICAgICAgbG9nTGV2ZWw6IFwiSU5GT1wiLFxuICAgIH0sXG4gICAgbG9vcDoge1xuICAgICAgICBtYXhDeWNsZXM6IDUwLFxuICAgICAgICBjeWNsZVJldHJpZXM6IDIsXG4gICAgICAgIGNoZWNrcG9pbnRGcmVxdWVuY3k6IDEsXG4gICAgICAgIHN0dWNrVGhyZXNob2xkOiA1LFxuICAgIH0sXG4gICAgZGVidWc6IHtcbiAgICAgICAgd29yazogZmFsc2UsXG4gICAgfSxcbiAgICBvcGVuY29kZToge1xuICAgICAgICBtb2RlbDogXCJjbGF1ZGUtMy01LXNvbm5ldC1sYXRlc3RcIixcbiAgICAgICAgdGVtcGVyYXR1cmU6IDAuMixcbiAgICAgICAgc2VydmVyVXJsOiB1bmRlZmluZWQsXG4gICAgICAgIGRpcmVjdG9yeTogdW5kZWZpbmVkLFxuICAgICAgICBwcm9tcHRUaW1lb3V0TXM6IDEyMDAwMCxcbiAgICB9LFxuICAgIGFudGhyb3BpYzoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgbW9kZWw6IFwiY2xhdWRlLTMtNS1zb25uZXQtbGF0ZXN0XCIsXG4gICAgfSxcbiAgICBnYXRlczoge1xuICAgICAgICBsaW50OiB7IGNvbW1hbmQ6IFwiYnVuIHJ1biBsaW50XCIgfSxcbiAgICAgICAgdHlwZWNoZWNrOiB7IGNvbW1hbmQ6IFwiYnVuIHJ1biB0eXBlY2hlY2tcIiB9LFxuICAgICAgICB0ZXN0OiB7IGNvbW1hbmQ6IFwiYnVuIHRlc3RcIiB9LFxuICAgICAgICBidWlsZDogeyBjb21tYW5kOiBcImJ1biBydW4gYnVpbGRcIiB9LFxuICAgICAgICBhY2NlcHRhbmNlOiB7IGNvbW1hbmQ6IFwiZ2l0IGRpZmYgLS1uYW1lLW9ubHlcIiB9LFxuICAgIH0sXG4gICAgbW9kZWxzOiB7XG4gICAgICAgIHJlc2VhcmNoOiBcImdpdGh1Yi1jb3BpbG90L2dwdC01LjJcIixcbiAgICAgICAgcGxhbm5pbmc6IFwiZ2l0aHViLWNvcGlsb3QvZ3B0LTUuMlwiLFxuICAgICAgICBleHBsb3JhdGlvbjogXCJnaXRodWItY29waWxvdC9ncHQtNS4yXCIsXG4gICAgICAgIGNvZGluZzogXCJnaXRodWItY29waWxvdC9ncHQtNS4yXCIsXG4gICAgICAgIGRlZmF1bHQ6IFwiZ2l0aHViLWNvcGlsb3QvZ3B0LTUuMlwiLFxuICAgIH0sXG4gICAgbm90aWZpY2F0aW9uczoge1xuICAgICAgICBkaXNjb3JkOiB7XG4gICAgICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHVzZXJuYW1lOiBcIlJhbHBoXCIsXG4gICAgICAgICAgICBhdmF0YXJVcmw6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHdlYmhvb2s6IHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IFwiZW52XCIsXG4gICAgICAgICAgICAgICAgZW52VmFyOiBcIkRJU0NPUkRfV0VCSE9PS19VUkxcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB1aToge1xuICAgICAgICBzaWxlbnQ6IGZhbHNlLFxuICAgIH0sXG59O1xuIiwKICAgICJpbXBvcnQgZnMgZnJvbSBcIm5vZGU6ZnMvcHJvbWlzZXNcIjtcbi8qKlxuICogU3RydWN0dXJlZCBsb2dnaW5nIGZvciBhaS1lbmcgcmFscGhcbiAqXG4gKiBTdXBwb3J0cyBib3RoIHN0ZGVyciBvdXRwdXQgKHdpdGggLS1wcmludC1sb2dzKSBhbmQgZmlsZS1iYXNlZCBsb2dnaW5nXG4gKi9cbmltcG9ydCBwYXRoIGZyb20gXCJub2RlOnBhdGhcIjtcblxuZXhwb3J0IG5hbWVzcGFjZSBMb2cge1xuICAgIGV4cG9ydCB0eXBlIExldmVsID0gXCJERUJVR1wiIHwgXCJJTkZPXCIgfCBcIldBUk5cIiB8IFwiRVJST1JcIjtcblxuICAgIGNvbnN0IGxldmVsUHJpb3JpdHk6IFJlY29yZDxMZXZlbCwgbnVtYmVyPiA9IHtcbiAgICAgICAgREVCVUc6IDAsXG4gICAgICAgIElORk86IDEsXG4gICAgICAgIFdBUk46IDIsXG4gICAgICAgIEVSUk9SOiAzLFxuICAgIH07XG5cbiAgICBsZXQgY3VycmVudExldmVsOiBMZXZlbCA9IFwiSU5GT1wiO1xuICAgIGxldCBsb2dQYXRoID0gXCJcIjtcbiAgICBsZXQgd3JpdGU6IChtc2c6IHN0cmluZykgPT4gYW55ID0gKG1zZykgPT4gcHJvY2Vzcy5zdGRlcnIud3JpdGUobXNnKTtcblxuICAgIGZ1bmN0aW9uIHNob3VsZExvZyhsZXZlbDogTGV2ZWwpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGxldmVsUHJpb3JpdHlbbGV2ZWxdID49IGxldmVsUHJpb3JpdHlbY3VycmVudExldmVsXTtcbiAgICB9XG5cbiAgICBleHBvcnQgaW50ZXJmYWNlIE9wdGlvbnMge1xuICAgICAgICBwcmludDogYm9vbGVhbjsgLy8gV2hlbiB0cnVlLCB3cml0ZSB0byBzdGRlcnJcbiAgICAgICAgbGV2ZWw/OiBMZXZlbDtcbiAgICAgICAgbG9nRGlyPzogc3RyaW5nOyAvLyBEaXJlY3RvcnkgZm9yIGxvZyBmaWxlc1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBmaWxlKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBsb2dQYXRoO1xuICAgIH1cblxuICAgIGV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbml0KG9wdGlvbnM6IE9wdGlvbnMpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgaWYgKG9wdGlvbnMubGV2ZWwpIGN1cnJlbnRMZXZlbCA9IG9wdGlvbnMubGV2ZWw7XG5cbiAgICAgICAgLy8gQnVpbGQgdGhlIHdyaXRlIGZ1bmN0aW9uIHRoYXQgb3V0cHV0cyB0byBCT1RIIHN0ZGVyciBBTkQgZmlsZVxuICAgICAgICBjb25zdCBzdGRlcnJXcml0ZXIgPSAobXNnOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIHByb2Nlc3Muc3RkZXJyLndyaXRlKG1zZyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG9wdGlvbnMubG9nRGlyKSB7XG4gICAgICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpXG4gICAgICAgICAgICAgICAgLnRvSVNPU3RyaW5nKClcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvWzouXS9nLCBcIi1cIilcbiAgICAgICAgICAgICAgICAuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgICAgbG9nUGF0aCA9IHBhdGguam9pbihvcHRpb25zLmxvZ0RpciwgYHJhbHBoLSR7dGltZXN0YW1wfS5sb2dgKTtcbiAgICAgICAgICAgIGF3YWl0IGZzLm1rZGlyKG9wdGlvbnMubG9nRGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcblxuICAgICAgICAgICAgY29uc3QgZmlsZSA9IEJ1bi5maWxlKGxvZ1BhdGgpO1xuICAgICAgICAgICAgY29uc3QgZmlsZVdyaXRlciA9IGZpbGUud3JpdGVyKCk7XG5cbiAgICAgICAgICAgIC8vIEFsd2F5cyB3cml0ZSB0byBzdGRlcnIgaWYgcHJpbnQgaXMgZW5hYmxlZFxuICAgICAgICAgICAgLy8gQWxzbyBhbHdheXMgd3JpdGUgdG8gZmlsZSBpZiBsb2dEaXIgaXMgcHJvdmlkZWRcbiAgICAgICAgICAgIHdyaXRlID0gKG1zZykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnByaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ZGVycldyaXRlcihtc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaWxlV3JpdGVyLndyaXRlKG1zZyk7XG4gICAgICAgICAgICAgICAgZmlsZVdyaXRlci5mbHVzaCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLnByaW50KSB7XG4gICAgICAgICAgICAvLyBPbmx5IHByaW50IHRvIHN0ZGVyclxuICAgICAgICAgICAgd3JpdGUgPSBzdGRlcnJXcml0ZXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBleHBvcnQgaW50ZXJmYWNlIExvZ2dlciB7XG4gICAgICAgIGRlYnVnKG1lc3NhZ2U6IHN0cmluZywgZXh0cmE/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogdm9pZDtcbiAgICAgICAgaW5mbyhtZXNzYWdlOiBzdHJpbmcsIGV4dHJhPzogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQ7XG4gICAgICAgIHdhcm4obWVzc2FnZTogc3RyaW5nLCBleHRyYT86IFJlY29yZDxzdHJpbmcsIGFueT4pOiB2b2lkO1xuICAgICAgICBlcnJvcihtZXNzYWdlOiBzdHJpbmcsIGV4dHJhPzogUmVjb3JkPHN0cmluZywgYW55Pik6IHZvaWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0RXh0cmEoZXh0cmE/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogc3RyaW5nIHtcbiAgICAgICAgaWYgKCFleHRyYSkgcmV0dXJuIFwiXCI7XG4gICAgICAgIGNvbnN0IGV4dHJhU3RyID0gT2JqZWN0LmVudHJpZXMoZXh0cmEpXG4gICAgICAgICAgICAubWFwKFxuICAgICAgICAgICAgICAgIChbaywgdl0pID0+XG4gICAgICAgICAgICAgICAgICAgIGAke2t9PSR7dHlwZW9mIHYgPT09IFwib2JqZWN0XCIgPyBKU09OLnN0cmluZ2lmeSh2KSA6IHZ9YCxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5qb2luKFwiIFwiKTtcbiAgICAgICAgcmV0dXJuIGV4dHJhU3RyID8gYCAke2V4dHJhU3RyfWAgOiBcIlwiO1xuICAgIH1cblxuICAgIGV4cG9ydCBmdW5jdGlvbiBjcmVhdGUodGFncz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pOiBMb2dnZXIge1xuICAgICAgICBjb25zdCB0YWdTdHIgPSB0YWdzXG4gICAgICAgICAgICA/IE9iamVjdC5lbnRyaWVzKHRhZ3MpXG4gICAgICAgICAgICAgICAgICAubWFwKChbaywgdl0pID0+IGAke2t9PSR7dn1gKVxuICAgICAgICAgICAgICAgICAgLmpvaW4oXCIgXCIpXG4gICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgIGNvbnN0IHRhZ1N0cldpdGhTcGFjZSA9IHRhZ1N0ciA/IGAke3RhZ1N0cn0gYCA6IFwiXCI7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlYnVnKG1lc3NhZ2U6IHN0cmluZywgZXh0cmE/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZExvZyhcIkRFQlVHXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgYERFQlVHICR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfSAke3RhZ1N0cn0ke21lc3NhZ2V9JHtmb3JtYXRFeHRyYShleHRyYSl9XFxuYCxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5mbyhtZXNzYWdlOiBzdHJpbmcsIGV4dHJhPzogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRMb2coXCJJTkZPXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgYElORk8gICR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfSAke3RhZ1N0cn0ke21lc3NhZ2V9JHtmb3JtYXRFeHRyYShleHRyYSl9XFxuYCxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgd2FybihtZXNzYWdlOiBzdHJpbmcsIGV4dHJhPzogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRMb2coXCJXQVJOXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgYFdBUk4gICR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfSAke3RhZ1N0cn0ke21lc3NhZ2V9JHtmb3JtYXRFeHRyYShleHRyYSl9XFxuYCxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3IobWVzc2FnZTogc3RyaW5nLCBleHRyYT86IFJlY29yZDxzdHJpbmcsIGFueT4pIHtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkTG9nKFwiRVJST1JcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICBgRVJST1IgJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9ICR7dGFnU3RyfSR7bWVzc2FnZX0ke2Zvcm1hdEV4dHJhKGV4dHJhKX1cXG5gLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZXhwb3J0IGNvbnN0IERlZmF1bHQgPSBjcmVhdGUoeyBzZXJ2aWNlOiBcInJhbHBoXCIgfSk7XG59XG4iLAogICAgImltcG9ydHtjdXJzb3IgYXMgbCxlcmFzZSBhcyBifWZyb21cInNpc3RlcmFuc2lcIjtpbXBvcnR7c3RkaW4gYXMgaixzdGRvdXQgYXMgTX1mcm9tXCJub2RlOnByb2Nlc3NcIjtpbXBvcnQqYXMgZyBmcm9tXCJub2RlOnJlYWRsaW5lXCI7aW1wb3J0IE8gZnJvbVwibm9kZTpyZWFkbGluZVwiO2ltcG9ydHtXcml0YWJsZSBhcyBYfWZyb21cIm5vZGU6c3RyZWFtXCI7aW1wb3J0IHYgZnJvbVwicGljb2NvbG9yc1wiO2Z1bmN0aW9uIEREKHtvbmx5Rmlyc3Q6ZT0hMX09e30pe2NvbnN0IHQ9W1wiW1xcXFx1MDAxQlxcXFx1MDA5Ql1bW1xcXFxdKCkjOz9dKig/Oig/Oig/Oig/OjtbLWEtekEtWlxcXFxkXFxcXC8jJi46PT8lQH5fXSspKnxbYS16QS1aXFxcXGRdKyg/OjtbLWEtekEtWlxcXFxkXFxcXC8jJi46PT8lQH5fXSopKik/KD86XFxcXHUwMDA3fFxcXFx1MDAxQlxcXFx1MDA1Q3xcXFxcdTAwOUMpKVwiLFwiKD86KD86XFxcXGR7MSw0fSg/OjtcXFxcZHswLDR9KSopP1tcXFxcZEEtUFItVFpjZi1ucS11eT0+PH5dKSlcIl0uam9pbihcInxcIik7cmV0dXJuIG5ldyBSZWdFeHAodCxlP3ZvaWQgMDpcImdcIil9Y29uc3QgdUQ9REQoKTtmdW5jdGlvbiBQKGUpe2lmKHR5cGVvZiBlIT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGEgXFxgc3RyaW5nXFxgLCBnb3QgXFxgJHt0eXBlb2YgZX1cXGBgKTtyZXR1cm4gZS5yZXBsYWNlKHVELFwiXCIpfWZ1bmN0aW9uIEwoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZSYmT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsXCJkZWZhdWx0XCIpP2UuZGVmYXVsdDplfXZhciBXPXtleHBvcnRzOnt9fTsoZnVuY3Rpb24oZSl7dmFyIHU9e307ZS5leHBvcnRzPXUsdS5lYXN0QXNpYW5XaWR0aD1mdW5jdGlvbihGKXt2YXIgcz1GLmNoYXJDb2RlQXQoMCksaT1GLmxlbmd0aD09Mj9GLmNoYXJDb2RlQXQoMSk6MCxEPXM7cmV0dXJuIDU1Mjk2PD1zJiZzPD01NjMxOSYmNTYzMjA8PWkmJmk8PTU3MzQzJiYocyY9MTAyMyxpJj0xMDIzLEQ9czw8MTB8aSxEKz02NTUzNiksRD09MTIyODh8fDY1MjgxPD1EJiZEPD02NTM3Nnx8NjU1MDQ8PUQmJkQ8PTY1NTEwP1wiRlwiOkQ9PTgzNjF8fDY1Mzc3PD1EJiZEPD02NTQ3MHx8NjU0NzQ8PUQmJkQ8PTY1NDc5fHw2NTQ4Mjw9RCYmRDw9NjU0ODd8fDY1NDkwPD1EJiZEPD02NTQ5NXx8NjU0OTg8PUQmJkQ8PTY1NTAwfHw2NTUxMjw9RCYmRDw9NjU1MTg/XCJIXCI6NDM1Mjw9RCYmRDw9NDQ0N3x8NDUxNTw9RCYmRDw9NDUxOXx8NDYwMjw9RCYmRDw9NDYwN3x8OTAwMTw9RCYmRDw9OTAwMnx8MTE5MDQ8PUQmJkQ8PTExOTI5fHwxMTkzMTw9RCYmRDw9MTIwMTl8fDEyMDMyPD1EJiZEPD0xMjI0NXx8MTIyNzI8PUQmJkQ8PTEyMjgzfHwxMjI4OTw9RCYmRDw9MTIzNTB8fDEyMzUzPD1EJiZEPD0xMjQzOHx8MTI0NDE8PUQmJkQ8PTEyNTQzfHwxMjU0OTw9RCYmRDw9MTI1ODl8fDEyNTkzPD1EJiZEPD0xMjY4Nnx8MTI2ODg8PUQmJkQ8PTEyNzMwfHwxMjczNjw9RCYmRDw9MTI3NzF8fDEyNzg0PD1EJiZEPD0xMjgzMHx8MTI4MzI8PUQmJkQ8PTEyODcxfHwxMjg4MDw9RCYmRDw9MTMwNTR8fDEzMDU2PD1EJiZEPD0xOTkwM3x8MTk5Njg8PUQmJkQ8PTQyMTI0fHw0MjEyODw9RCYmRDw9NDIxODJ8fDQzMzYwPD1EJiZEPD00MzM4OHx8NDQwMzI8PUQmJkQ8PTU1MjAzfHw1NTIxNjw9RCYmRDw9NTUyMzh8fDU1MjQzPD1EJiZEPD01NTI5MXx8NjM3NDQ8PUQmJkQ8PTY0MjU1fHw2NTA0MDw9RCYmRDw9NjUwNDl8fDY1MDcyPD1EJiZEPD02NTEwNnx8NjUxMDg8PUQmJkQ8PTY1MTI2fHw2NTEyODw9RCYmRDw9NjUxMzF8fDExMDU5Mjw9RCYmRDw9MTEwNTkzfHwxMjc0ODg8PUQmJkQ8PTEyNzQ5MHx8MTI3NTA0PD1EJiZEPD0xMjc1NDZ8fDEyNzU1Mjw9RCYmRDw9MTI3NTYwfHwxMjc1Njg8PUQmJkQ8PTEyNzU2OXx8MTMxMDcyPD1EJiZEPD0xOTQzNjd8fDE3Nzk4NDw9RCYmRDw9MTk2NjA1fHwxOTY2MDg8PUQmJkQ8PTI2MjE0MT9cIldcIjozMjw9RCYmRDw9MTI2fHwxNjI8PUQmJkQ8PTE2M3x8MTY1PD1EJiZEPD0xNjZ8fEQ9PTE3Mnx8RD09MTc1fHwxMDIxNDw9RCYmRDw9MTAyMjF8fDEwNjI5PD1EJiZEPD0xMDYzMD9cIk5hXCI6RD09MTYxfHxEPT0xNjR8fDE2Nzw9RCYmRDw9MTY4fHxEPT0xNzB8fDE3Mzw9RCYmRDw9MTc0fHwxNzY8PUQmJkQ8PTE4MHx8MTgyPD1EJiZEPD0xODZ8fDE4ODw9RCYmRDw9MTkxfHxEPT0xOTh8fEQ9PTIwOHx8MjE1PD1EJiZEPD0yMTZ8fDIyMjw9RCYmRDw9MjI1fHxEPT0yMzB8fDIzMjw9RCYmRDw9MjM0fHwyMzY8PUQmJkQ8PTIzN3x8RD09MjQwfHwyNDI8PUQmJkQ8PTI0M3x8MjQ3PD1EJiZEPD0yNTB8fEQ9PTI1Mnx8RD09MjU0fHxEPT0yNTd8fEQ9PTI3M3x8RD09Mjc1fHxEPT0yODN8fDI5NDw9RCYmRDw9Mjk1fHxEPT0yOTl8fDMwNTw9RCYmRDw9MzA3fHxEPT0zMTJ8fDMxOTw9RCYmRDw9MzIyfHxEPT0zMjR8fDMyODw9RCYmRDw9MzMxfHxEPT0zMzN8fDMzODw9RCYmRDw9MzM5fHwzNTg8PUQmJkQ8PTM1OXx8RD09MzYzfHxEPT00NjJ8fEQ9PTQ2NHx8RD09NDY2fHxEPT00Njh8fEQ9PTQ3MHx8RD09NDcyfHxEPT00NzR8fEQ9PTQ3Nnx8RD09NTkzfHxEPT02MDl8fEQ9PTcwOHx8RD09NzExfHw3MTM8PUQmJkQ8PTcxNXx8RD09NzE3fHxEPT03MjB8fDcyODw9RCYmRDw9NzMxfHxEPT03MzN8fEQ9PTczNXx8NzY4PD1EJiZEPD04Nzl8fDkxMzw9RCYmRDw9OTI5fHw5MzE8PUQmJkQ8PTkzN3x8OTQ1PD1EJiZEPD05NjF8fDk2Mzw9RCYmRDw9OTY5fHxEPT0xMDI1fHwxMDQwPD1EJiZEPD0xMTAzfHxEPT0xMTA1fHxEPT04MjA4fHw4MjExPD1EJiZEPD04MjE0fHw4MjE2PD1EJiZEPD04MjE3fHw4MjIwPD1EJiZEPD04MjIxfHw4MjI0PD1EJiZEPD04MjI2fHw4MjI4PD1EJiZEPD04MjMxfHxEPT04MjQwfHw4MjQyPD1EJiZEPD04MjQzfHxEPT04MjQ1fHxEPT04MjUxfHxEPT04MjU0fHxEPT04MzA4fHxEPT04MzE5fHw4MzIxPD1EJiZEPD04MzI0fHxEPT04MzY0fHxEPT04NDUxfHxEPT04NDUzfHxEPT04NDU3fHxEPT04NDY3fHxEPT04NDcwfHw4NDgxPD1EJiZEPD04NDgyfHxEPT04NDg2fHxEPT04NDkxfHw4NTMxPD1EJiZEPD04NTMyfHw4NTM5PD1EJiZEPD04NTQyfHw4NTQ0PD1EJiZEPD04NTU1fHw4NTYwPD1EJiZEPD04NTY5fHxEPT04NTg1fHw4NTkyPD1EJiZEPD04NjAxfHw4NjMyPD1EJiZEPD04NjMzfHxEPT04NjU4fHxEPT04NjYwfHxEPT04Njc5fHxEPT04NzA0fHw4NzA2PD1EJiZEPD04NzA3fHw4NzExPD1EJiZEPD04NzEyfHxEPT04NzE1fHxEPT04NzE5fHxEPT04NzIxfHxEPT04NzI1fHxEPT04NzMwfHw4NzMzPD1EJiZEPD04NzM2fHxEPT04NzM5fHxEPT04NzQxfHw4NzQzPD1EJiZEPD04NzQ4fHxEPT04NzUwfHw4NzU2PD1EJiZEPD04NzU5fHw4NzY0PD1EJiZEPD04NzY1fHxEPT04Nzc2fHxEPT04NzgwfHxEPT04Nzg2fHw4ODAwPD1EJiZEPD04ODAxfHw4ODA0PD1EJiZEPD04ODA3fHw4ODEwPD1EJiZEPD04ODExfHw4ODE0PD1EJiZEPD04ODE1fHw4ODM0PD1EJiZEPD04ODM1fHw4ODM4PD1EJiZEPD04ODM5fHxEPT04ODUzfHxEPT04ODU3fHxEPT04ODY5fHxEPT04ODk1fHxEPT04OTc4fHw5MzEyPD1EJiZEPD05NDQ5fHw5NDUxPD1EJiZEPD05NTQ3fHw5NTUyPD1EJiZEPD05NTg3fHw5NjAwPD1EJiZEPD05NjE1fHw5NjE4PD1EJiZEPD05NjIxfHw5NjMyPD1EJiZEPD05NjMzfHw5NjM1PD1EJiZEPD05NjQxfHw5NjUwPD1EJiZEPD05NjUxfHw5NjU0PD1EJiZEPD05NjU1fHw5NjYwPD1EJiZEPD05NjYxfHw5NjY0PD1EJiZEPD05NjY1fHw5NjcwPD1EJiZEPD05NjcyfHxEPT05Njc1fHw5Njc4PD1EJiZEPD05NjgxfHw5Njk4PD1EJiZEPD05NzAxfHxEPT05NzExfHw5NzMzPD1EJiZEPD05NzM0fHxEPT05NzM3fHw5NzQyPD1EJiZEPD05NzQzfHw5NzQ4PD1EJiZEPD05NzQ5fHxEPT05NzU2fHxEPT05NzU4fHxEPT05NzkyfHxEPT05Nzk0fHw5ODI0PD1EJiZEPD05ODI1fHw5ODI3PD1EJiZEPD05ODI5fHw5ODMxPD1EJiZEPD05ODM0fHw5ODM2PD1EJiZEPD05ODM3fHxEPT05ODM5fHw5ODg2PD1EJiZEPD05ODg3fHw5OTE4PD1EJiZEPD05OTE5fHw5OTI0PD1EJiZEPD05OTMzfHw5OTM1PD1EJiZEPD05OTUzfHxEPT05OTU1fHw5OTYwPD1EJiZEPD05OTgzfHxEPT0xMDA0NXx8RD09MTAwNzF8fDEwMTAyPD1EJiZEPD0xMDExMXx8MTEwOTM8PUQmJkQ8PTExMDk3fHwxMjg3Mjw9RCYmRDw9MTI4Nzl8fDU3MzQ0PD1EJiZEPD02Mzc0M3x8NjUwMjQ8PUQmJkQ8PTY1MDM5fHxEPT02NTUzM3x8MTI3MjMyPD1EJiZEPD0xMjcyNDJ8fDEyNzI0ODw9RCYmRDw9MTI3Mjc3fHwxMjcyODA8PUQmJkQ8PTEyNzMzN3x8MTI3MzQ0PD1EJiZEPD0xMjczODZ8fDkxNzc2MDw9RCYmRDw9OTE3OTk5fHw5ODMwNDA8PUQmJkQ8PTEwNDg1NzN8fDEwNDg1NzY8PUQmJkQ8PTExMTQxMDk/XCJBXCI6XCJOXCJ9LHUuY2hhcmFjdGVyTGVuZ3RoPWZ1bmN0aW9uKEYpe3ZhciBzPXRoaXMuZWFzdEFzaWFuV2lkdGgoRik7cmV0dXJuIHM9PVwiRlwifHxzPT1cIldcInx8cz09XCJBXCI/MjoxfTtmdW5jdGlvbiB0KEYpe3JldHVybiBGLm1hdGNoKC9bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdfFteXFx1RDgwMC1cXHVERkZGXS9nKXx8W119dS5sZW5ndGg9ZnVuY3Rpb24oRil7Zm9yKHZhciBzPXQoRiksaT0wLEQ9MDtEPHMubGVuZ3RoO0QrKylpPWkrdGhpcy5jaGFyYWN0ZXJMZW5ndGgoc1tEXSk7cmV0dXJuIGl9LHUuc2xpY2U9ZnVuY3Rpb24oRixzLGkpe3RleHRMZW49dS5sZW5ndGgoRikscz1zfHwwLGk9aXx8MSxzPDAmJihzPXRleHRMZW4rcyksaTwwJiYoaT10ZXh0TGVuK2kpO2Zvcih2YXIgRD1cIlwiLEM9MCxuPXQoRiksRT0wO0U8bi5sZW5ndGg7RSsrKXt2YXIgYT1uW0VdLG89dS5sZW5ndGgoYSk7aWYoQz49cy0obz09Mj8xOjApKWlmKEMrbzw9aSlEKz1hO2Vsc2UgYnJlYWs7Qys9b31yZXR1cm4gRH19KShXKTt2YXIgdEQ9Vy5leHBvcnRzO2NvbnN0IGVEPUwodEQpO3ZhciBGRD1mdW5jdGlvbigpe3JldHVybi9cXHVEODNDXFx1REZGNFxcdURCNDBcXHVEQzY3XFx1REI0MFxcdURDNjIoPzpcXHVEQjQwXFx1REM3N1xcdURCNDBcXHVEQzZDXFx1REI0MFxcdURDNzN8XFx1REI0MFxcdURDNzNcXHVEQjQwXFx1REM2M1xcdURCNDBcXHVEQzc0fFxcdURCNDBcXHVEQzY1XFx1REI0MFxcdURDNkVcXHVEQjQwXFx1REM2NylcXHVEQjQwXFx1REM3RnwoPzpcXHVEODNFXFx1REREMVxcdUQ4M0NcXHVERkZGXFx1MjAwRFxcdTI3NjRcXHVGRTBGXFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzhCXFx1MjAwRCk/XFx1RDgzRVxcdURERDF8XFx1RDgzRFxcdURDNjlcXHVEODNDXFx1REZGRlxcdTIwMERcXHVEODNFXFx1REQxRFxcdTIwMEQoPzpcXHVEODNEW1xcdURDNjhcXHVEQzY5XSkpKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkVdKXwoPzpcXHVEODNFXFx1REREMVxcdUQ4M0NcXHVERkZFXFx1MjAwRFxcdTI3NjRcXHVGRTBGXFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzhCXFx1MjAwRCk/XFx1RDgzRVxcdURERDF8XFx1RDgzRFxcdURDNjlcXHVEODNDXFx1REZGRVxcdTIwMERcXHVEODNFXFx1REQxRFxcdTIwMEQoPzpcXHVEODNEW1xcdURDNjhcXHVEQzY5XSkpKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkRcXHVERkZGXSl8KD86XFx1RDgzRVxcdURERDFcXHVEODNDXFx1REZGRFxcdTIwMERcXHUyNzY0XFx1RkUwRlxcdTIwMEQoPzpcXHVEODNEXFx1REM4QlxcdTIwMEQpP1xcdUQ4M0VcXHVEREQxfFxcdUQ4M0RcXHVEQzY5XFx1RDgzQ1xcdURGRkRcXHUyMDBEXFx1RDgzRVxcdUREMURcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pKSg/OlxcdUQ4M0NbXFx1REZGQlxcdURGRkNcXHVERkZFXFx1REZGRl0pfCg/OlxcdUQ4M0VcXHVEREQxXFx1RDgzQ1xcdURGRkNcXHUyMDBEXFx1Mjc2NFxcdUZFMEZcXHUyMDBEKD86XFx1RDgzRFxcdURDOEJcXHUyMDBEKT9cXHVEODNFXFx1REREMXxcXHVEODNEXFx1REM2OVxcdUQ4M0NcXHVERkZDXFx1MjAwRFxcdUQ4M0VcXHVERDFEXFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2OFxcdURDNjldKSkoPzpcXHVEODNDW1xcdURGRkJcXHVERkZELVxcdURGRkZdKXwoPzpcXHVEODNFXFx1REREMVxcdUQ4M0NcXHVERkZCXFx1MjAwRFxcdTI3NjRcXHVGRTBGXFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzhCXFx1MjAwRCk/XFx1RDgzRVxcdURERDF8XFx1RDgzRFxcdURDNjlcXHVEODNDXFx1REZGQlxcdTIwMERcXHVEODNFXFx1REQxRFxcdTIwMEQoPzpcXHVEODNEW1xcdURDNjhcXHVEQzY5XSkpKD86XFx1RDgzQ1tcXHVERkZDLVxcdURGRkZdKXxcXHVEODNEXFx1REM2OCg/OlxcdUQ4M0NcXHVERkZCKD86XFx1MjAwRCg/OlxcdTI3NjRcXHVGRTBGXFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzhCXFx1MjAwRFxcdUQ4M0RcXHVEQzY4KD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKXxcXHVEODNEXFx1REM2OCg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSkpfFxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY4KD86XFx1RDgzQ1tcXHVERkZDLVxcdURGRkZdKXxbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XVxcdUZFMEZ8XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKSk/fCg/OlxcdUQ4M0NbXFx1REZGQy1cXHVERkZGXSlcXHUyMDBEXFx1Mjc2NFxcdUZFMEZcXHUyMDBEKD86XFx1RDgzRFxcdURDOEJcXHUyMDBEXFx1RDgzRFxcdURDNjgoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfFxcdUQ4M0RcXHVEQzY4KD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKSl8XFx1MjAwRCg/OlxcdTI3NjRcXHVGRTBGXFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzhCXFx1MjAwRCk/XFx1RDgzRFxcdURDNjh8KD86XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pXFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzY2XFx1MjAwRFxcdUQ4M0RcXHVEQzY2fFxcdUQ4M0RcXHVEQzY3XFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2NlxcdURDNjddKSl8XFx1RDgzRFxcdURDNjZcXHUyMDBEXFx1RDgzRFxcdURDNjZ8XFx1RDgzRFxcdURDNjdcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY2XFx1REM2N10pfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1xcdURGRkZcXHUyMDBEKD86XFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjgoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRV0pfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1xcdURGRkVcXHUyMDBEKD86XFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjgoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRFxcdURGRkZdKXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdUQ4M0NcXHVERkZEXFx1MjAwRCg/OlxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY4KD86XFx1RDgzQ1tcXHVERkZCXFx1REZGQ1xcdURGRkVcXHVERkZGXSl8XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXxcXHVEODNDXFx1REZGQ1xcdTIwMEQoPzpcXHVEODNFXFx1REQxRFxcdTIwMERcXHVEODNEXFx1REM2OCg/OlxcdUQ4M0NbXFx1REZGQlxcdURGRkQtXFx1REZGRl0pfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8KD86XFx1RDgzQ1xcdURGRkZcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1RDgzQ1xcdURGRkVcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1RDgzQ1xcdURGRkRcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1RDgzQ1xcdURGRkNcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdKVxcdUZFMEZ8XFx1MjAwRCg/Oig/OlxcdUQ4M0RbXFx1REM2OFxcdURDNjldKVxcdTIwMEQoPzpcXHVEODNEW1xcdURDNjZcXHVEQzY3XSl8XFx1RDgzRFtcXHVEQzY2XFx1REM2N10pfFxcdUQ4M0NcXHVERkZGfFxcdUQ4M0NcXHVERkZFfFxcdUQ4M0NcXHVERkZEfFxcdUQ4M0NcXHVERkZDKT98KD86XFx1RDgzRFxcdURDNjkoPzpcXHVEODNDXFx1REZGQlxcdTIwMERcXHUyNzY0XFx1RkUwRlxcdTIwMEQoPzpcXHVEODNEXFx1REM4QlxcdTIwMEQoPzpcXHVEODNEW1xcdURDNjhcXHVEQzY5XSl8XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pfCg/OlxcdUQ4M0NbXFx1REZGQy1cXHVERkZGXSlcXHUyMDBEXFx1Mjc2NFxcdUZFMEZcXHUyMDBEKD86XFx1RDgzRFxcdURDOEJcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pfFxcdUQ4M0RbXFx1REM2OFxcdURDNjldKSl8XFx1RDgzRVxcdURERDEoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pXFx1MjAwRFxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0VcXHVEREQxKSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSl8XFx1RDgzRFxcdURDNjlcXHUyMDBEXFx1RDgzRFxcdURDNjlcXHUyMDBEKD86XFx1RDgzRFxcdURDNjZcXHUyMDBEXFx1RDgzRFxcdURDNjZ8XFx1RDgzRFxcdURDNjdcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY2XFx1REM2N10pKXxcXHVEODNEXFx1REM2OSg/OlxcdTIwMEQoPzpcXHUyNzY0XFx1RkUwRlxcdTIwMEQoPzpcXHVEODNEXFx1REM4QlxcdTIwMEQoPzpcXHVEODNEW1xcdURDNjhcXHVEQzY5XSl8XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1xcdURGRkZcXHUyMDBEKD86XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXxcXHVEODNDXFx1REZGRVxcdTIwMEQoPzpcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdUQ4M0NcXHVERkZEXFx1MjAwRCg/OlxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1xcdURGRkNcXHUyMDBEKD86XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXxcXHVEODNDXFx1REZGQlxcdTIwMEQoPzpcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pKXxcXHVEODNFXFx1REREMSg/OlxcdTIwMEQoPzpcXHVEODNFXFx1REQxRFxcdTIwMERcXHVEODNFXFx1REREMXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGODRcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXxcXHVEODNDXFx1REZGRlxcdTIwMEQoPzpcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGODRcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXxcXHVEODNDXFx1REZGRVxcdTIwMEQoPzpcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGODRcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXxcXHVEODNDXFx1REZGRFxcdTIwMEQoPzpcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGODRcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXxcXHVEODNDXFx1REZGQ1xcdTIwMEQoPzpcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGODRcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXxcXHVEODNDXFx1REZGQlxcdTIwMEQoPzpcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGODRcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKSl8XFx1RDgzRFxcdURDNjlcXHUyMDBEXFx1RDgzRFxcdURDNjZcXHUyMDBEXFx1RDgzRFxcdURDNjZ8XFx1RDgzRFxcdURDNjlcXHUyMDBEXFx1RDgzRFxcdURDNjlcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY2XFx1REM2N10pfFxcdUQ4M0RcXHVEQzY5XFx1MjAwRFxcdUQ4M0RcXHVEQzY3XFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2NlxcdURDNjddKXwoPzpcXHVEODNEXFx1REM0MVxcdUZFMEZcXHUyMDBEXFx1RDgzRFxcdURERTh8XFx1RDgzRVxcdURERDEoPzpcXHVEODNDXFx1REZGRlxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHVEODNDXFx1REZGRVxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHVEODNDXFx1REZGRFxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHVEODNDXFx1REZGQ1xcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHVEODNDXFx1REZGQlxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF0pfFxcdUQ4M0RcXHVEQzY5KD86XFx1RDgzQ1xcdURGRkZcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1RDgzQ1xcdURGRkVcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1RDgzQ1xcdURGRkRcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1RDgzQ1xcdURGRkNcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1RDgzQ1xcdURGRkJcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdKXxcXHVEODNEXFx1REUzNlxcdTIwMERcXHVEODNDXFx1REYyQnxcXHVEODNDXFx1REZGM1xcdUZFMEZcXHUyMDBEXFx1MjZBN3xcXHVEODNEXFx1REMzQlxcdTIwMERcXHUyNzQ0fCg/Oig/OlxcdUQ4M0NbXFx1REZDM1xcdURGQzRcXHVERkNBXXxcXHVEODNEW1xcdURDNkVcXHVEQzcwXFx1REM3MVxcdURDNzNcXHVEQzc3XFx1REM4MVxcdURDODJcXHVEQzg2XFx1REM4N1xcdURFNDUtXFx1REU0N1xcdURFNEJcXHVERTREXFx1REU0RVxcdURFQTNcXHVERUI0LVxcdURFQjZdfFxcdUQ4M0VbXFx1REQyNlxcdUREMzVcXHVERDM3LVxcdUREMzlcXHVERDNEXFx1REQzRVxcdUREQjhcXHVEREI5XFx1RERDRC1cXHVERENGXFx1RERENFxcdURERDYtXFx1RERERF0pKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKXxcXHVEODNEXFx1REM2RnxcXHVEODNFW1xcdUREM0NcXHVERERFXFx1RERERl0pXFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml18KD86XFx1MjZGOXxcXHVEODNDW1xcdURGQ0JcXHVERkNDXXxcXHVEODNEXFx1REQ3NSkoPzpcXHVGRTBGfFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSlcXHUyMDBEW1xcdTI2NDBcXHUyNjQyXXxcXHVEODNDXFx1REZGNFxcdTIwMERcXHUyNjIwfCg/OlxcdUQ4M0NbXFx1REZDM1xcdURGQzRcXHVERkNBXXxcXHVEODNEW1xcdURDNkVcXHVEQzcwXFx1REM3MVxcdURDNzNcXHVEQzc3XFx1REM4MVxcdURDODJcXHVEQzg2XFx1REM4N1xcdURFNDUtXFx1REU0N1xcdURFNEJcXHVERTREXFx1REU0RVxcdURFQTNcXHVERUI0LVxcdURFQjZdfFxcdUQ4M0VbXFx1REQyNlxcdUREMzVcXHVERDM3LVxcdUREMzlcXHVERDNEXFx1REQzRVxcdUREQjhcXHVEREI5XFx1RERDRC1cXHVERENGXFx1RERENFxcdURERDYtXFx1RERERF0pXFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml18W1xceEE5XFx4QUVcXHUyMDNDXFx1MjA0OVxcdTIxMjJcXHUyMTM5XFx1MjE5NC1cXHUyMTk5XFx1MjFBOVxcdTIxQUFcXHUyMzI4XFx1MjNDRlxcdTIzRUQtXFx1MjNFRlxcdTIzRjFcXHUyM0YyXFx1MjNGOC1cXHUyM0ZBXFx1MjRDMlxcdTI1QUFcXHUyNUFCXFx1MjVCNlxcdTI1QzBcXHUyNUZCXFx1MjVGQ1xcdTI2MDAtXFx1MjYwNFxcdTI2MEVcXHUyNjExXFx1MjYxOFxcdTI2MjBcXHUyNjIyXFx1MjYyM1xcdTI2MjZcXHUyNjJBXFx1MjYyRVxcdTI2MkZcXHUyNjM4LVxcdTI2M0FcXHUyNjQwXFx1MjY0MlxcdTI2NUZcXHUyNjYwXFx1MjY2M1xcdTI2NjVcXHUyNjY2XFx1MjY2OFxcdTI2N0JcXHUyNjdFXFx1MjY5MlxcdTI2OTQtXFx1MjY5N1xcdTI2OTlcXHUyNjlCXFx1MjY5Q1xcdTI2QTBcXHUyNkE3XFx1MjZCMFxcdTI2QjFcXHUyNkM4XFx1MjZDRlxcdTI2RDFcXHUyNkQzXFx1MjZFOVxcdTI2RjBcXHUyNkYxXFx1MjZGNFxcdTI2RjdcXHUyNkY4XFx1MjcwMlxcdTI3MDhcXHUyNzA5XFx1MjcwRlxcdTI3MTJcXHUyNzE0XFx1MjcxNlxcdTI3MURcXHUyNzIxXFx1MjczM1xcdTI3MzRcXHUyNzQ0XFx1Mjc0N1xcdTI3NjNcXHUyN0ExXFx1MjkzNFxcdTI5MzVcXHUyQjA1LVxcdTJCMDdcXHUzMDMwXFx1MzAzRFxcdTMyOTdcXHUzMjk5XXxcXHVEODNDW1xcdURENzBcXHVERDcxXFx1REQ3RVxcdUREN0ZcXHVERTAyXFx1REUzN1xcdURGMjFcXHVERjI0LVxcdURGMkNcXHVERjM2XFx1REY3RFxcdURGOTZcXHVERjk3XFx1REY5OS1cXHVERjlCXFx1REY5RVxcdURGOUZcXHVERkNEXFx1REZDRVxcdURGRDQtXFx1REZERlxcdURGRjVcXHVERkY3XXxcXHVEODNEW1xcdURDM0ZcXHVEQ0ZEXFx1REQ0OVxcdURENEFcXHVERDZGXFx1REQ3MFxcdURENzNcXHVERDc2LVxcdURENzlcXHVERDg3XFx1REQ4QS1cXHVERDhEXFx1RERBNVxcdUREQThcXHVEREIxXFx1RERCMlxcdUREQkNcXHVEREMyLVxcdUREQzRcXHVEREQxLVxcdURERDNcXHVERERDLVxcdUREREVcXHVEREUxXFx1RERFM1xcdURERThcXHVEREVGXFx1RERGM1xcdURERkFcXHVERUNCXFx1REVDRC1cXHVERUNGXFx1REVFMC1cXHVERUU1XFx1REVFOVxcdURFRjBcXHVERUYzXSlcXHVGRTBGfFxcdUQ4M0NcXHVERkYzXFx1RkUwRlxcdTIwMERcXHVEODNDXFx1REYwOHxcXHVEODNEXFx1REM2OVxcdTIwMERcXHVEODNEXFx1REM2N3xcXHVEODNEXFx1REM2OVxcdTIwMERcXHVEODNEXFx1REM2NnxcXHVEODNEXFx1REUzNVxcdTIwMERcXHVEODNEXFx1RENBQnxcXHVEODNEXFx1REUyRVxcdTIwMERcXHVEODNEXFx1RENBOHxcXHVEODNEXFx1REMxNVxcdTIwMERcXHVEODNFXFx1RERCQXxcXHVEODNFXFx1REREMSg/OlxcdUQ4M0NcXHVERkZGfFxcdUQ4M0NcXHVERkZFfFxcdUQ4M0NcXHVERkZEfFxcdUQ4M0NcXHVERkZDfFxcdUQ4M0NcXHVERkZCKT98XFx1RDgzRFxcdURDNjkoPzpcXHVEODNDXFx1REZGRnxcXHVEODNDXFx1REZGRXxcXHVEODNDXFx1REZGRHxcXHVEODNDXFx1REZGQ3xcXHVEODNDXFx1REZGQik/fFxcdUQ4M0NcXHVEREZEXFx1RDgzQ1xcdURERjB8XFx1RDgzQ1xcdURERjZcXHVEODNDXFx1RERFNnxcXHVEODNDXFx1RERGNFxcdUQ4M0NcXHVEREYyfFxcdUQ4M0RcXHVEQzA4XFx1MjAwRFxcdTJCMUJ8XFx1Mjc2NFxcdUZFMEZcXHUyMDBEKD86XFx1RDgzRFxcdUREMjV8XFx1RDgzRVxcdURFNzkpfFxcdUQ4M0RcXHVEQzQxXFx1RkUwRnxcXHVEODNDXFx1REZGM1xcdUZFMEZ8XFx1RDgzQ1xcdURERkYoPzpcXHVEODNDW1xcdURERTZcXHVEREYyXFx1RERGQ10pfFxcdUQ4M0NcXHVEREZFKD86XFx1RDgzQ1tcXHVEREVBXFx1RERGOV0pfFxcdUQ4M0NcXHVEREZDKD86XFx1RDgzQ1tcXHVEREVCXFx1RERGOF0pfFxcdUQ4M0NcXHVEREZCKD86XFx1RDgzQ1tcXHVEREU2XFx1RERFOFxcdURERUFcXHVEREVDXFx1RERFRVxcdURERjNcXHVEREZBXSl8XFx1RDgzQ1xcdURERkEoPzpcXHVEODNDW1xcdURERTZcXHVEREVDXFx1RERGMlxcdURERjNcXHVEREY4XFx1RERGRVxcdURERkZdKXxcXHVEODNDXFx1RERGOSg/OlxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREU5XFx1RERFQi1cXHVEREVEXFx1RERFRi1cXHVEREY0XFx1RERGN1xcdURERjlcXHVEREZCXFx1RERGQ1xcdURERkZdKXxcXHVEODNDXFx1RERGOCg/OlxcdUQ4M0NbXFx1RERFNi1cXHVEREVBXFx1RERFQy1cXHVEREY0XFx1RERGNy1cXHVEREY5XFx1RERGQlxcdURERkQtXFx1RERGRl0pfFxcdUQ4M0NcXHVEREY3KD86XFx1RDgzQ1tcXHVEREVBXFx1RERGNFxcdURERjhcXHVEREZBXFx1RERGQ10pfFxcdUQ4M0NcXHVEREY1KD86XFx1RDgzQ1tcXHVEREU2XFx1RERFQS1cXHVEREVEXFx1RERGMC1cXHVEREYzXFx1RERGNy1cXHVEREY5XFx1RERGQ1xcdURERkVdKXxcXHVEODNDXFx1RERGMyg/OlxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREVBLVxcdURERUNcXHVEREVFXFx1RERGMVxcdURERjRcXHVEREY1XFx1RERGN1xcdURERkFcXHVEREZGXSl8XFx1RDgzQ1xcdURERjIoPzpcXHVEODNDW1xcdURERTZcXHVEREU4LVxcdURERURcXHVEREYwLVxcdURERkZdKXxcXHVEODNDXFx1RERGMSg/OlxcdUQ4M0NbXFx1RERFNi1cXHVEREU4XFx1RERFRVxcdURERjBcXHVEREY3LVxcdURERkJcXHVEREZFXSl8XFx1RDgzQ1xcdURERjAoPzpcXHVEODNDW1xcdURERUFcXHVEREVDLVxcdURERUVcXHVEREYyXFx1RERGM1xcdURERjVcXHVEREY3XFx1RERGQ1xcdURERkVcXHVEREZGXSl8XFx1RDgzQ1xcdURERUYoPzpcXHVEODNDW1xcdURERUFcXHVEREYyXFx1RERGNFxcdURERjVdKXxcXHVEODNDXFx1RERFRSg/OlxcdUQ4M0NbXFx1RERFOC1cXHVEREVBXFx1RERGMS1cXHVEREY0XFx1RERGNi1cXHVEREY5XSl8XFx1RDgzQ1xcdURERUQoPzpcXHVEODNDW1xcdURERjBcXHVEREYyXFx1RERGM1xcdURERjdcXHVEREY5XFx1RERGQV0pfFxcdUQ4M0NcXHVEREVDKD86XFx1RDgzQ1tcXHVEREU2XFx1RERFN1xcdURERTktXFx1RERFRVxcdURERjEtXFx1RERGM1xcdURERjUtXFx1RERGQVxcdURERkNcXHVEREZFXSl8XFx1RDgzQ1xcdURERUIoPzpcXHVEODNDW1xcdURERUUtXFx1RERGMFxcdURERjJcXHVEREY0XFx1RERGN10pfFxcdUQ4M0NcXHVEREVBKD86XFx1RDgzQ1tcXHVEREU2XFx1RERFOFxcdURERUFcXHVEREVDXFx1RERFRFxcdURERjctXFx1RERGQV0pfFxcdUQ4M0NcXHVEREU5KD86XFx1RDgzQ1tcXHVEREVBXFx1RERFQ1xcdURERUZcXHVEREYwXFx1RERGMlxcdURERjRcXHVEREZGXSl8XFx1RDgzQ1xcdURERTgoPzpcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFOVxcdURERUItXFx1RERFRVxcdURERjAtXFx1RERGNVxcdURERjdcXHVEREZBLVxcdURERkZdKXxcXHVEODNDXFx1RERFNyg/OlxcdUQ4M0NbXFx1RERFNlxcdURERTdcXHVEREU5LVxcdURERUZcXHVEREYxLVxcdURERjRcXHVEREY2LVxcdURERjlcXHVEREZCXFx1RERGQ1xcdURERkVcXHVEREZGXSl8XFx1RDgzQ1xcdURERTYoPzpcXHVEODNDW1xcdURERTgtXFx1RERFQ1xcdURERUVcXHVEREYxXFx1RERGMlxcdURERjRcXHVEREY2LVxcdURERkFcXHVEREZDXFx1RERGRFxcdURERkZdKXxbI1xcKjAtOV1cXHVGRTBGXFx1MjBFM3xcXHUyNzY0XFx1RkUwRnwoPzpcXHVEODNDW1xcdURGQzNcXHVERkM0XFx1REZDQV18XFx1RDgzRFtcXHVEQzZFXFx1REM3MFxcdURDNzFcXHVEQzczXFx1REM3N1xcdURDODFcXHVEQzgyXFx1REM4NlxcdURDODdcXHVERTQ1LVxcdURFNDdcXHVERTRCXFx1REU0RFxcdURFNEVcXHVERUEzXFx1REVCNC1cXHVERUI2XXxcXHVEODNFW1xcdUREMjZcXHVERDM1XFx1REQzNy1cXHVERDM5XFx1REQzRFxcdUREM0VcXHVEREI4XFx1RERCOVxcdUREQ0QtXFx1RERDRlxcdURERDRcXHVEREQ2LVxcdURERERdKSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSl8KD86XFx1MjZGOXxcXHVEODNDW1xcdURGQ0JcXHVERkNDXXxcXHVEODNEXFx1REQ3NSkoPzpcXHVGRTBGfFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSl8XFx1RDgzQ1xcdURGRjR8KD86W1xcdTI3MEFcXHUyNzBCXXxcXHVEODNDW1xcdURGODVcXHVERkMyXFx1REZDN118XFx1RDgzRFtcXHVEQzQyXFx1REM0M1xcdURDNDYtXFx1REM1MFxcdURDNjZcXHVEQzY3XFx1REM2Qi1cXHVEQzZEXFx1REM3MlxcdURDNzQtXFx1REM3NlxcdURDNzhcXHVEQzdDXFx1REM4M1xcdURDODVcXHVEQzhGXFx1REM5MVxcdURDQUFcXHVERDdBXFx1REQ5NVxcdUREOTZcXHVERTRDXFx1REU0RlxcdURFQzBcXHVERUNDXXxcXHVEODNFW1xcdUREMENcXHVERDBGXFx1REQxOC1cXHVERDFDXFx1REQxRVxcdUREMUZcXHVERDMwLVxcdUREMzRcXHVERDM2XFx1REQ3N1xcdUREQjVcXHVEREI2XFx1RERCQlxcdURERDJcXHVEREQzXFx1RERENV0pKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKXwoPzpbXFx1MjYxRFxcdTI3MENcXHUyNzBEXXxcXHVEODNEW1xcdURENzRcXHVERDkwXSkoPzpcXHVGRTBGfFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSl8W1xcdTI3MEFcXHUyNzBCXXxcXHVEODNDW1xcdURGODVcXHVERkMyXFx1REZDN118XFx1RDgzRFtcXHVEQzA4XFx1REMxNVxcdURDM0JcXHVEQzQyXFx1REM0M1xcdURDNDYtXFx1REM1MFxcdURDNjZcXHVEQzY3XFx1REM2Qi1cXHVEQzZEXFx1REM3MlxcdURDNzQtXFx1REM3NlxcdURDNzhcXHVEQzdDXFx1REM4M1xcdURDODVcXHVEQzhGXFx1REM5MVxcdURDQUFcXHVERDdBXFx1REQ5NVxcdUREOTZcXHVERTJFXFx1REUzNVxcdURFMzZcXHVERTRDXFx1REU0RlxcdURFQzBcXHVERUNDXXxcXHVEODNFW1xcdUREMENcXHVERDBGXFx1REQxOC1cXHVERDFDXFx1REQxRVxcdUREMUZcXHVERDMwLVxcdUREMzRcXHVERDM2XFx1REQ3N1xcdUREQjVcXHVEREI2XFx1RERCQlxcdURERDJcXHVEREQzXFx1RERENV18XFx1RDgzQ1tcXHVERkMzXFx1REZDNFxcdURGQ0FdfFxcdUQ4M0RbXFx1REM2RVxcdURDNzBcXHVEQzcxXFx1REM3M1xcdURDNzdcXHVEQzgxXFx1REM4MlxcdURDODZcXHVEQzg3XFx1REU0NS1cXHVERTQ3XFx1REU0QlxcdURFNERcXHVERTRFXFx1REVBM1xcdURFQjQtXFx1REVCNl18XFx1RDgzRVtcXHVERDI2XFx1REQzNVxcdUREMzctXFx1REQzOVxcdUREM0RcXHVERDNFXFx1RERCOFxcdUREQjlcXHVERENELVxcdUREQ0ZcXHVEREQ0XFx1RERENi1cXHVEREREXXxcXHVEODNEXFx1REM2RnxcXHVEODNFW1xcdUREM0NcXHVERERFXFx1RERERl18W1xcdTIzMUFcXHUyMzFCXFx1MjNFOS1cXHUyM0VDXFx1MjNGMFxcdTIzRjNcXHUyNUZEXFx1MjVGRVxcdTI2MTRcXHUyNjE1XFx1MjY0OC1cXHUyNjUzXFx1MjY3RlxcdTI2OTNcXHUyNkExXFx1MjZBQVxcdTI2QUJcXHUyNkJEXFx1MjZCRVxcdTI2QzRcXHUyNkM1XFx1MjZDRVxcdTI2RDRcXHUyNkVBXFx1MjZGMlxcdTI2RjNcXHUyNkY1XFx1MjZGQVxcdTI2RkRcXHUyNzA1XFx1MjcyOFxcdTI3NENcXHUyNzRFXFx1Mjc1My1cXHUyNzU1XFx1Mjc1N1xcdTI3OTUtXFx1Mjc5N1xcdTI3QjBcXHUyN0JGXFx1MkIxQlxcdTJCMUNcXHUyQjUwXFx1MkI1NV18XFx1RDgzQ1tcXHVEQzA0XFx1RENDRlxcdUREOEVcXHVERDkxLVxcdUREOUFcXHVERTAxXFx1REUxQVxcdURFMkZcXHVERTMyLVxcdURFMzZcXHVERTM4LVxcdURFM0FcXHVERTUwXFx1REU1MVxcdURGMDAtXFx1REYyMFxcdURGMkQtXFx1REYzNVxcdURGMzctXFx1REY3Q1xcdURGN0UtXFx1REY4NFxcdURGODYtXFx1REY5M1xcdURGQTAtXFx1REZDMVxcdURGQzVcXHVERkM2XFx1REZDOFxcdURGQzlcXHVERkNGLVxcdURGRDNcXHVERkUwLVxcdURGRjBcXHVERkY4LVxcdURGRkZdfFxcdUQ4M0RbXFx1REMwMC1cXHVEQzA3XFx1REMwOS1cXHVEQzE0XFx1REMxNi1cXHVEQzNBXFx1REMzQy1cXHVEQzNFXFx1REM0MFxcdURDNDRcXHVEQzQ1XFx1REM1MS1cXHVEQzY1XFx1REM2QVxcdURDNzktXFx1REM3QlxcdURDN0QtXFx1REM4MFxcdURDODRcXHVEQzg4LVxcdURDOEVcXHVEQzkwXFx1REM5Mi1cXHVEQ0E5XFx1RENBQi1cXHVEQ0ZDXFx1RENGRi1cXHVERDNEXFx1REQ0Qi1cXHVERDRFXFx1REQ1MC1cXHVERDY3XFx1RERBNFxcdURERkItXFx1REUyRFxcdURFMkYtXFx1REUzNFxcdURFMzctXFx1REU0NFxcdURFNDgtXFx1REU0QVxcdURFODAtXFx1REVBMlxcdURFQTQtXFx1REVCM1xcdURFQjctXFx1REVCRlxcdURFQzEtXFx1REVDNVxcdURFRDAtXFx1REVEMlxcdURFRDUtXFx1REVEN1xcdURFRUJcXHVERUVDXFx1REVGNC1cXHVERUZDXFx1REZFMC1cXHVERkVCXXxcXHVEODNFW1xcdUREMERcXHVERDBFXFx1REQxMC1cXHVERDE3XFx1REQxRFxcdUREMjAtXFx1REQyNVxcdUREMjctXFx1REQyRlxcdUREM0FcXHVERDNGLVxcdURENDVcXHVERDQ3LVxcdURENzZcXHVERDc4XFx1REQ3QS1cXHVEREI0XFx1RERCN1xcdUREQkFcXHVEREJDLVxcdUREQ0JcXHVEREQwXFx1RERFMC1cXHVEREZGXFx1REU3MC1cXHVERTc0XFx1REU3OC1cXHVERTdBXFx1REU4MC1cXHVERTg2XFx1REU5MC1cXHVERUE4XFx1REVCMC1cXHVERUI2XFx1REVDMC1cXHVERUMyXFx1REVEMC1cXHVERUQ2XXwoPzpbXFx1MjMxQVxcdTIzMUJcXHUyM0U5LVxcdTIzRUNcXHUyM0YwXFx1MjNGM1xcdTI1RkRcXHUyNUZFXFx1MjYxNFxcdTI2MTVcXHUyNjQ4LVxcdTI2NTNcXHUyNjdGXFx1MjY5M1xcdTI2QTFcXHUyNkFBXFx1MjZBQlxcdTI2QkRcXHUyNkJFXFx1MjZDNFxcdTI2QzVcXHUyNkNFXFx1MjZENFxcdTI2RUFcXHUyNkYyXFx1MjZGM1xcdTI2RjVcXHUyNkZBXFx1MjZGRFxcdTI3MDVcXHUyNzBBXFx1MjcwQlxcdTI3MjhcXHUyNzRDXFx1Mjc0RVxcdTI3NTMtXFx1Mjc1NVxcdTI3NTdcXHUyNzk1LVxcdTI3OTdcXHUyN0IwXFx1MjdCRlxcdTJCMUJcXHUyQjFDXFx1MkI1MFxcdTJCNTVdfFxcdUQ4M0NbXFx1REMwNFxcdURDQ0ZcXHVERDhFXFx1REQ5MS1cXHVERDlBXFx1RERFNi1cXHVEREZGXFx1REUwMVxcdURFMUFcXHVERTJGXFx1REUzMi1cXHVERTM2XFx1REUzOC1cXHVERTNBXFx1REU1MFxcdURFNTFcXHVERjAwLVxcdURGMjBcXHVERjJELVxcdURGMzVcXHVERjM3LVxcdURGN0NcXHVERjdFLVxcdURGOTNcXHVERkEwLVxcdURGQ0FcXHVERkNGLVxcdURGRDNcXHVERkUwLVxcdURGRjBcXHVERkY0XFx1REZGOC1cXHVERkZGXXxcXHVEODNEW1xcdURDMDAtXFx1REMzRVxcdURDNDBcXHVEQzQyLVxcdURDRkNcXHVEQ0ZGLVxcdUREM0RcXHVERDRCLVxcdURENEVcXHVERDUwLVxcdURENjdcXHVERDdBXFx1REQ5NVxcdUREOTZcXHVEREE0XFx1RERGQi1cXHVERTRGXFx1REU4MC1cXHVERUM1XFx1REVDQ1xcdURFRDAtXFx1REVEMlxcdURFRDUtXFx1REVEN1xcdURFRUJcXHVERUVDXFx1REVGNC1cXHVERUZDXFx1REZFMC1cXHVERkVCXXxcXHVEODNFW1xcdUREMEMtXFx1REQzQVxcdUREM0MtXFx1REQ0NVxcdURENDctXFx1REQ3OFxcdUREN0EtXFx1RERDQlxcdUREQ0QtXFx1RERGRlxcdURFNzAtXFx1REU3NFxcdURFNzgtXFx1REU3QVxcdURFODAtXFx1REU4NlxcdURFOTAtXFx1REVBOFxcdURFQjAtXFx1REVCNlxcdURFQzAtXFx1REVDMlxcdURFRDAtXFx1REVENl0pfCg/OlsjXFwqMC05XFx4QTlcXHhBRVxcdTIwM0NcXHUyMDQ5XFx1MjEyMlxcdTIxMzlcXHUyMTk0LVxcdTIxOTlcXHUyMUE5XFx1MjFBQVxcdTIzMUFcXHUyMzFCXFx1MjMyOFxcdTIzQ0ZcXHUyM0U5LVxcdTIzRjNcXHUyM0Y4LVxcdTIzRkFcXHUyNEMyXFx1MjVBQVxcdTI1QUJcXHUyNUI2XFx1MjVDMFxcdTI1RkItXFx1MjVGRVxcdTI2MDAtXFx1MjYwNFxcdTI2MEVcXHUyNjExXFx1MjYxNFxcdTI2MTVcXHUyNjE4XFx1MjYxRFxcdTI2MjBcXHUyNjIyXFx1MjYyM1xcdTI2MjZcXHUyNjJBXFx1MjYyRVxcdTI2MkZcXHUyNjM4LVxcdTI2M0FcXHUyNjQwXFx1MjY0MlxcdTI2NDgtXFx1MjY1M1xcdTI2NUZcXHUyNjYwXFx1MjY2M1xcdTI2NjVcXHUyNjY2XFx1MjY2OFxcdTI2N0JcXHUyNjdFXFx1MjY3RlxcdTI2OTItXFx1MjY5N1xcdTI2OTlcXHUyNjlCXFx1MjY5Q1xcdTI2QTBcXHUyNkExXFx1MjZBN1xcdTI2QUFcXHUyNkFCXFx1MjZCMFxcdTI2QjFcXHUyNkJEXFx1MjZCRVxcdTI2QzRcXHUyNkM1XFx1MjZDOFxcdTI2Q0VcXHUyNkNGXFx1MjZEMVxcdTI2RDNcXHUyNkQ0XFx1MjZFOVxcdTI2RUFcXHUyNkYwLVxcdTI2RjVcXHUyNkY3LVxcdTI2RkFcXHUyNkZEXFx1MjcwMlxcdTI3MDVcXHUyNzA4LVxcdTI3MERcXHUyNzBGXFx1MjcxMlxcdTI3MTRcXHUyNzE2XFx1MjcxRFxcdTI3MjFcXHUyNzI4XFx1MjczM1xcdTI3MzRcXHUyNzQ0XFx1Mjc0N1xcdTI3NENcXHUyNzRFXFx1Mjc1My1cXHUyNzU1XFx1Mjc1N1xcdTI3NjNcXHUyNzY0XFx1Mjc5NS1cXHUyNzk3XFx1MjdBMVxcdTI3QjBcXHUyN0JGXFx1MjkzNFxcdTI5MzVcXHUyQjA1LVxcdTJCMDdcXHUyQjFCXFx1MkIxQ1xcdTJCNTBcXHUyQjU1XFx1MzAzMFxcdTMwM0RcXHUzMjk3XFx1MzI5OV18XFx1RDgzQ1tcXHVEQzA0XFx1RENDRlxcdURENzBcXHVERDcxXFx1REQ3RVxcdUREN0ZcXHVERDhFXFx1REQ5MS1cXHVERDlBXFx1RERFNi1cXHVEREZGXFx1REUwMVxcdURFMDJcXHVERTFBXFx1REUyRlxcdURFMzItXFx1REUzQVxcdURFNTBcXHVERTUxXFx1REYwMC1cXHVERjIxXFx1REYyNC1cXHVERjkzXFx1REY5NlxcdURGOTdcXHVERjk5LVxcdURGOUJcXHVERjlFLVxcdURGRjBcXHVERkYzLVxcdURGRjVcXHVERkY3LVxcdURGRkZdfFxcdUQ4M0RbXFx1REMwMC1cXHVEQ0ZEXFx1RENGRi1cXHVERDNEXFx1REQ0OS1cXHVERDRFXFx1REQ1MC1cXHVERDY3XFx1REQ2RlxcdURENzBcXHVERDczLVxcdUREN0FcXHVERDg3XFx1REQ4QS1cXHVERDhEXFx1REQ5MFxcdUREOTVcXHVERDk2XFx1RERBNFxcdUREQTVcXHVEREE4XFx1RERCMVxcdUREQjJcXHVEREJDXFx1RERDMi1cXHVEREM0XFx1REREMS1cXHVEREQzXFx1REREQy1cXHVERERFXFx1RERFMVxcdURERTNcXHVEREU4XFx1RERFRlxcdURERjNcXHVEREZBLVxcdURFNEZcXHVERTgwLVxcdURFQzVcXHVERUNCLVxcdURFRDJcXHVERUQ1LVxcdURFRDdcXHVERUUwLVxcdURFRTVcXHVERUU5XFx1REVFQlxcdURFRUNcXHVERUYwXFx1REVGMy1cXHVERUZDXFx1REZFMC1cXHVERkVCXXxcXHVEODNFW1xcdUREMEMtXFx1REQzQVxcdUREM0MtXFx1REQ0NVxcdURENDctXFx1REQ3OFxcdUREN0EtXFx1RERDQlxcdUREQ0QtXFx1RERGRlxcdURFNzAtXFx1REU3NFxcdURFNzgtXFx1REU3QVxcdURFODAtXFx1REU4NlxcdURFOTAtXFx1REVBOFxcdURFQjAtXFx1REVCNlxcdURFQzAtXFx1REVDMlxcdURFRDAtXFx1REVENl0pXFx1RkUwRnwoPzpbXFx1MjYxRFxcdTI2RjlcXHUyNzBBLVxcdTI3MERdfFxcdUQ4M0NbXFx1REY4NVxcdURGQzItXFx1REZDNFxcdURGQzdcXHVERkNBLVxcdURGQ0NdfFxcdUQ4M0RbXFx1REM0MlxcdURDNDNcXHVEQzQ2LVxcdURDNTBcXHVEQzY2LVxcdURDNzhcXHVEQzdDXFx1REM4MS1cXHVEQzgzXFx1REM4NS1cXHVEQzg3XFx1REM4RlxcdURDOTFcXHVEQ0FBXFx1REQ3NFxcdURENzVcXHVERDdBXFx1REQ5MFxcdUREOTVcXHVERDk2XFx1REU0NS1cXHVERTQ3XFx1REU0Qi1cXHVERTRGXFx1REVBM1xcdURFQjQtXFx1REVCNlxcdURFQzBcXHVERUNDXXxcXHVEODNFW1xcdUREMENcXHVERDBGXFx1REQxOC1cXHVERDFGXFx1REQyNlxcdUREMzAtXFx1REQzOVxcdUREM0MtXFx1REQzRVxcdURENzdcXHVEREI1XFx1RERCNlxcdUREQjhcXHVEREI5XFx1RERCQlxcdUREQ0QtXFx1RERDRlxcdURERDEtXFx1RERERF0pL2d9O2NvbnN0IHNEPUwoRkQpO2Z1bmN0aW9uIHAoZSx1PXt9KXtpZih0eXBlb2YgZSE9XCJzdHJpbmdcInx8ZS5sZW5ndGg9PT0wfHwodT17YW1iaWd1b3VzSXNOYXJyb3c6ITAsLi4udX0sZT1QKGUpLGUubGVuZ3RoPT09MCkpcmV0dXJuIDA7ZT1lLnJlcGxhY2Uoc0QoKSxcIiAgXCIpO2NvbnN0IHQ9dS5hbWJpZ3VvdXNJc05hcnJvdz8xOjI7bGV0IEY9MDtmb3IoY29uc3QgcyBvZiBlKXtjb25zdCBpPXMuY29kZVBvaW50QXQoMCk7aWYoaTw9MzF8fGk+PTEyNyYmaTw9MTU5fHxpPj03NjgmJmk8PTg3OSljb250aW51ZTtzd2l0Y2goZUQuZWFzdEFzaWFuV2lkdGgocykpe2Nhc2VcIkZcIjpjYXNlXCJXXCI6Ris9MjticmVhaztjYXNlXCJBXCI6Ris9dDticmVhaztkZWZhdWx0OkYrPTF9fXJldHVybiBGfWNvbnN0IHc9MTAsTj0oZT0wKT0+dT0+YFxceDFCWyR7dStlfW1gLEk9KGU9MCk9PnU9PmBcXHgxQlskezM4K2V9OzU7JHt1fW1gLFI9KGU9MCk9Pih1LHQsRik9PmBcXHgxQlskezM4K2V9OzI7JHt1fTske3R9OyR7Rn1tYCxyPXttb2RpZmllcjp7cmVzZXQ6WzAsMF0sYm9sZDpbMSwyMl0sZGltOlsyLDIyXSxpdGFsaWM6WzMsMjNdLHVuZGVybGluZTpbNCwyNF0sb3ZlcmxpbmU6WzUzLDU1XSxpbnZlcnNlOls3LDI3XSxoaWRkZW46WzgsMjhdLHN0cmlrZXRocm91Z2g6WzksMjldfSxjb2xvcjp7YmxhY2s6WzMwLDM5XSxyZWQ6WzMxLDM5XSxncmVlbjpbMzIsMzldLHllbGxvdzpbMzMsMzldLGJsdWU6WzM0LDM5XSxtYWdlbnRhOlszNSwzOV0sY3lhbjpbMzYsMzldLHdoaXRlOlszNywzOV0sYmxhY2tCcmlnaHQ6WzkwLDM5XSxncmF5Ols5MCwzOV0sZ3JleTpbOTAsMzldLHJlZEJyaWdodDpbOTEsMzldLGdyZWVuQnJpZ2h0Ols5MiwzOV0seWVsbG93QnJpZ2h0Ols5MywzOV0sYmx1ZUJyaWdodDpbOTQsMzldLG1hZ2VudGFCcmlnaHQ6Wzk1LDM5XSxjeWFuQnJpZ2h0Ols5NiwzOV0sd2hpdGVCcmlnaHQ6Wzk3LDM5XX0sYmdDb2xvcjp7YmdCbGFjazpbNDAsNDldLGJnUmVkOls0MSw0OV0sYmdHcmVlbjpbNDIsNDldLGJnWWVsbG93Ols0Myw0OV0sYmdCbHVlOls0NCw0OV0sYmdNYWdlbnRhOls0NSw0OV0sYmdDeWFuOls0Niw0OV0sYmdXaGl0ZTpbNDcsNDldLGJnQmxhY2tCcmlnaHQ6WzEwMCw0OV0sYmdHcmF5OlsxMDAsNDldLGJnR3JleTpbMTAwLDQ5XSxiZ1JlZEJyaWdodDpbMTAxLDQ5XSxiZ0dyZWVuQnJpZ2h0OlsxMDIsNDldLGJnWWVsbG93QnJpZ2h0OlsxMDMsNDldLGJnQmx1ZUJyaWdodDpbMTA0LDQ5XSxiZ01hZ2VudGFCcmlnaHQ6WzEwNSw0OV0sYmdDeWFuQnJpZ2h0OlsxMDYsNDldLGJnV2hpdGVCcmlnaHQ6WzEwNyw0OV19fTtPYmplY3Qua2V5cyhyLm1vZGlmaWVyKTtjb25zdCBpRD1PYmplY3Qua2V5cyhyLmNvbG9yKSxDRD1PYmplY3Qua2V5cyhyLmJnQ29sb3IpO1suLi5pRCwuLi5DRF07ZnVuY3Rpb24gckQoKXtjb25zdCBlPW5ldyBNYXA7Zm9yKGNvbnN0W3UsdF1vZiBPYmplY3QuZW50cmllcyhyKSl7Zm9yKGNvbnN0W0Ysc11vZiBPYmplY3QuZW50cmllcyh0KSlyW0ZdPXtvcGVuOmBcXHgxQlske3NbMF19bWAsY2xvc2U6YFxceDFCWyR7c1sxXX1tYH0sdFtGXT1yW0ZdLGUuc2V0KHNbMF0sc1sxXSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsdSx7dmFsdWU6dCxlbnVtZXJhYmxlOiExfSl9cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiY29kZXNcIix7dmFsdWU6ZSxlbnVtZXJhYmxlOiExfSksci5jb2xvci5jbG9zZT1cIlxceDFCWzM5bVwiLHIuYmdDb2xvci5jbG9zZT1cIlxceDFCWzQ5bVwiLHIuY29sb3IuYW5zaT1OKCksci5jb2xvci5hbnNpMjU2PUkoKSxyLmNvbG9yLmFuc2kxNm09UigpLHIuYmdDb2xvci5hbnNpPU4odyksci5iZ0NvbG9yLmFuc2kyNTY9SSh3KSxyLmJnQ29sb3IuYW5zaTE2bT1SKHcpLE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHIse3JnYlRvQW5zaTI1Njp7dmFsdWU6KHUsdCxGKT0+dT09PXQmJnQ9PT1GP3U8OD8xNjp1PjI0OD8yMzE6TWF0aC5yb3VuZCgodS04KS8yNDcqMjQpKzIzMjoxNiszNipNYXRoLnJvdW5kKHUvMjU1KjUpKzYqTWF0aC5yb3VuZCh0LzI1NSo1KStNYXRoLnJvdW5kKEYvMjU1KjUpLGVudW1lcmFibGU6ITF9LGhleFRvUmdiOnt2YWx1ZTp1PT57Y29uc3QgdD0vW2EtZlxcZF17Nn18W2EtZlxcZF17M30vaS5leGVjKHUudG9TdHJpbmcoMTYpKTtpZighdClyZXR1cm5bMCwwLDBdO2xldFtGXT10O0YubGVuZ3RoPT09MyYmKEY9Wy4uLkZdLm1hcChpPT5pK2kpLmpvaW4oXCJcIikpO2NvbnN0IHM9TnVtYmVyLnBhcnNlSW50KEYsMTYpO3JldHVybltzPj4xNiYyNTUscz4+OCYyNTUscyYyNTVdfSxlbnVtZXJhYmxlOiExfSxoZXhUb0Fuc2kyNTY6e3ZhbHVlOnU9PnIucmdiVG9BbnNpMjU2KC4uLnIuaGV4VG9SZ2IodSkpLGVudW1lcmFibGU6ITF9LGFuc2kyNTZUb0Fuc2k6e3ZhbHVlOnU9PntpZih1PDgpcmV0dXJuIDMwK3U7aWYodTwxNilyZXR1cm4gOTArKHUtOCk7bGV0IHQsRixzO2lmKHU+PTIzMil0PSgodS0yMzIpKjEwKzgpLzI1NSxGPXQscz10O2Vsc2V7dS09MTY7Y29uc3QgQz11JTM2O3Q9TWF0aC5mbG9vcih1LzM2KS81LEY9TWF0aC5mbG9vcihDLzYpLzUscz1DJTYvNX1jb25zdCBpPU1hdGgubWF4KHQsRixzKSoyO2lmKGk9PT0wKXJldHVybiAzMDtsZXQgRD0zMCsoTWF0aC5yb3VuZChzKTw8MnxNYXRoLnJvdW5kKEYpPDwxfE1hdGgucm91bmQodCkpO3JldHVybiBpPT09MiYmKEQrPTYwKSxEfSxlbnVtZXJhYmxlOiExfSxyZ2JUb0Fuc2k6e3ZhbHVlOih1LHQsRik9PnIuYW5zaTI1NlRvQW5zaShyLnJnYlRvQW5zaTI1Nih1LHQsRikpLGVudW1lcmFibGU6ITF9LGhleFRvQW5zaTp7dmFsdWU6dT0+ci5hbnNpMjU2VG9BbnNpKHIuaGV4VG9BbnNpMjU2KHUpKSxlbnVtZXJhYmxlOiExfX0pLHJ9Y29uc3QgRUQ9ckQoKSxkPW5ldyBTZXQoW1wiXFx4MUJcIixcIlxceDlCXCJdKSxvRD0zOSx5PVwiXFx4MDdcIixWPVwiW1wiLG5EPVwiXVwiLEc9XCJtXCIsXz1gJHtuRH04OztgLHo9ZT0+YCR7ZC52YWx1ZXMoKS5uZXh0KCkudmFsdWV9JHtWfSR7ZX0ke0d9YCxLPWU9PmAke2QudmFsdWVzKCkubmV4dCgpLnZhbHVlfSR7X30ke2V9JHt5fWAsYUQ9ZT0+ZS5zcGxpdChcIiBcIikubWFwKHU9PnAodSkpLGs9KGUsdSx0KT0+e2NvbnN0IEY9Wy4uLnVdO2xldCBzPSExLGk9ITEsRD1wKFAoZVtlLmxlbmd0aC0xXSkpO2Zvcihjb25zdFtDLG5db2YgRi5lbnRyaWVzKCkpe2NvbnN0IEU9cChuKTtpZihEK0U8PXQ/ZVtlLmxlbmd0aC0xXSs9bjooZS5wdXNoKG4pLEQ9MCksZC5oYXMobikmJihzPSEwLGk9Ri5zbGljZShDKzEpLmpvaW4oXCJcIikuc3RhcnRzV2l0aChfKSkscyl7aT9uPT09eSYmKHM9ITEsaT0hMSk6bj09PUcmJihzPSExKTtjb250aW51ZX1EKz1FLEQ9PT10JiZDPEYubGVuZ3RoLTEmJihlLnB1c2goXCJcIiksRD0wKX0hRCYmZVtlLmxlbmd0aC0xXS5sZW5ndGg+MCYmZS5sZW5ndGg+MSYmKGVbZS5sZW5ndGgtMl0rPWUucG9wKCkpfSxoRD1lPT57Y29uc3QgdT1lLnNwbGl0KFwiIFwiKTtsZXQgdD11Lmxlbmd0aDtmb3IoO3Q+MCYmIShwKHVbdC0xXSk+MCk7KXQtLTtyZXR1cm4gdD09PXUubGVuZ3RoP2U6dS5zbGljZSgwLHQpLmpvaW4oXCIgXCIpK3Uuc2xpY2UodCkuam9pbihcIlwiKX0sbEQ9KGUsdSx0PXt9KT0+e2lmKHQudHJpbSE9PSExJiZlLnRyaW0oKT09PVwiXCIpcmV0dXJuXCJcIjtsZXQgRj1cIlwiLHMsaTtjb25zdCBEPWFEKGUpO2xldCBDPVtcIlwiXTtmb3IoY29uc3RbRSxhXW9mIGUuc3BsaXQoXCIgXCIpLmVudHJpZXMoKSl7dC50cmltIT09ITEmJihDW0MubGVuZ3RoLTFdPUNbQy5sZW5ndGgtMV0udHJpbVN0YXJ0KCkpO2xldCBvPXAoQ1tDLmxlbmd0aC0xXSk7aWYoRSE9PTAmJihvPj11JiYodC53b3JkV3JhcD09PSExfHx0LnRyaW09PT0hMSkmJihDLnB1c2goXCJcIiksbz0wKSwobz4wfHx0LnRyaW09PT0hMSkmJihDW0MubGVuZ3RoLTFdKz1cIiBcIixvKyspKSx0LmhhcmQmJkRbRV0+dSl7Y29uc3QgYz11LW8sZj0xK01hdGguZmxvb3IoKERbRV0tYy0xKS91KTtNYXRoLmZsb29yKChEW0VdLTEpL3UpPGYmJkMucHVzaChcIlwiKSxrKEMsYSx1KTtjb250aW51ZX1pZihvK0RbRV0+dSYmbz4wJiZEW0VdPjApe2lmKHQud29yZFdyYXA9PT0hMSYmbzx1KXtrKEMsYSx1KTtjb250aW51ZX1DLnB1c2goXCJcIil9aWYobytEW0VdPnUmJnQud29yZFdyYXA9PT0hMSl7ayhDLGEsdSk7Y29udGludWV9Q1tDLmxlbmd0aC0xXSs9YX10LnRyaW0hPT0hMSYmKEM9Qy5tYXAoRT0+aEQoRSkpKTtjb25zdCBuPVsuLi5DLmpvaW4oYFxuYCldO2Zvcihjb25zdFtFLGFdb2Ygbi5lbnRyaWVzKCkpe2lmKEYrPWEsZC5oYXMoYSkpe2NvbnN0e2dyb3VwczpjfT1uZXcgUmVnRXhwKGAoPzpcXFxcJHtWfSg/PGNvZGU+XFxcXGQrKW18XFxcXCR7X30oPzx1cmk+LiopJHt5fSlgKS5leGVjKG4uc2xpY2UoRSkuam9pbihcIlwiKSl8fHtncm91cHM6e319O2lmKGMuY29kZSE9PXZvaWQgMCl7Y29uc3QgZj1OdW1iZXIucGFyc2VGbG9hdChjLmNvZGUpO3M9Zj09PW9EP3ZvaWQgMDpmfWVsc2UgYy51cmkhPT12b2lkIDAmJihpPWMudXJpLmxlbmd0aD09PTA/dm9pZCAwOmMudXJpKX1jb25zdCBvPUVELmNvZGVzLmdldChOdW1iZXIocykpO25bRSsxXT09PWBcbmA/KGkmJihGKz1LKFwiXCIpKSxzJiZvJiYoRis9eihvKSkpOmE9PT1gXG5gJiYocyYmbyYmKEYrPXoocykpLGkmJihGKz1LKGkpKSl9cmV0dXJuIEZ9O2Z1bmN0aW9uIFkoZSx1LHQpe3JldHVybiBTdHJpbmcoZSkubm9ybWFsaXplKCkucmVwbGFjZSgvXFxyXFxuL2csYFxuYCkuc3BsaXQoYFxuYCkubWFwKEY9PmxEKEYsdSx0KSkuam9pbihgXG5gKX1jb25zdCB4RD1bXCJ1cFwiLFwiZG93blwiLFwibGVmdFwiLFwicmlnaHRcIixcInNwYWNlXCIsXCJlbnRlclwiLFwiY2FuY2VsXCJdLEI9e2FjdGlvbnM6bmV3IFNldCh4RCksYWxpYXNlczpuZXcgTWFwKFtbXCJrXCIsXCJ1cFwiXSxbXCJqXCIsXCJkb3duXCJdLFtcImhcIixcImxlZnRcIl0sW1wibFwiLFwicmlnaHRcIl0sW1wiXHUwMDAzXCIsXCJjYW5jZWxcIl0sW1wiZXNjYXBlXCIsXCJjYW5jZWxcIl1dKX07ZnVuY3Rpb24gY0QoZSl7Zm9yKGNvbnN0IHUgaW4gZSl7Y29uc3QgdD11O2lmKCFPYmplY3QuaGFzT3duKGUsdCkpY29udGludWU7Y29uc3QgRj1lW3RdO3N3aXRjaCh0KXtjYXNlXCJhbGlhc2VzXCI6e2Zvcihjb25zdCBzIGluIEYpT2JqZWN0Lmhhc093bihGLHMpJiYoQi5hbGlhc2VzLmhhcyhzKXx8Qi5hbGlhc2VzLnNldChzLEZbc10pKTticmVha319fX1mdW5jdGlvbiAkKGUsdSl7aWYodHlwZW9mIGU9PVwic3RyaW5nXCIpcmV0dXJuIEIuYWxpYXNlcy5nZXQoZSk9PT11O2Zvcihjb25zdCB0IG9mIGUpaWYodCE9PXZvaWQgMCYmJCh0LHUpKXJldHVybiEwO3JldHVybiExfWZ1bmN0aW9uIEJEKGUsdSl7aWYoZT09PXUpcmV0dXJuO2NvbnN0IHQ9ZS5zcGxpdChgXG5gKSxGPXUuc3BsaXQoYFxuYCkscz1bXTtmb3IobGV0IGk9MDtpPE1hdGgubWF4KHQubGVuZ3RoLEYubGVuZ3RoKTtpKyspdFtpXSE9PUZbaV0mJnMucHVzaChpKTtyZXR1cm4gc31jb25zdCBBRD1nbG9iYWxUaGlzLnByb2Nlc3MucGxhdGZvcm0uc3RhcnRzV2l0aChcIndpblwiKSxTPVN5bWJvbChcImNsYWNrOmNhbmNlbFwiKTtmdW5jdGlvbiBwRChlKXtyZXR1cm4gZT09PVN9ZnVuY3Rpb24gbShlLHUpe2NvbnN0IHQ9ZTt0LmlzVFRZJiZ0LnNldFJhd01vZGUodSl9ZnVuY3Rpb24gZkQoe2lucHV0OmU9aixvdXRwdXQ6dT1NLG92ZXJ3cml0ZTp0PSEwLGhpZGVDdXJzb3I6Rj0hMH09e30pe2NvbnN0IHM9Zy5jcmVhdGVJbnRlcmZhY2Uoe2lucHV0OmUsb3V0cHV0OnUscHJvbXB0OlwiXCIsdGFiU2l6ZToxfSk7Zy5lbWl0S2V5cHJlc3NFdmVudHMoZSxzKSxlLmlzVFRZJiZlLnNldFJhd01vZGUoITApO2NvbnN0IGk9KEQse25hbWU6QyxzZXF1ZW5jZTpufSk9Pntjb25zdCBFPVN0cmluZyhEKTtpZigkKFtFLEMsbl0sXCJjYW5jZWxcIikpe0YmJnUud3JpdGUobC5zaG93KSxwcm9jZXNzLmV4aXQoMCk7cmV0dXJufWlmKCF0KXJldHVybjtjb25zdCBhPUM9PT1cInJldHVyblwiPzA6LTEsbz1DPT09XCJyZXR1cm5cIj8tMTowO2cubW92ZUN1cnNvcih1LGEsbywoKT0+e2cuY2xlYXJMaW5lKHUsMSwoKT0+e2Uub25jZShcImtleXByZXNzXCIsaSl9KX0pfTtyZXR1cm4gRiYmdS53cml0ZShsLmhpZGUpLGUub25jZShcImtleXByZXNzXCIsaSksKCk9PntlLm9mZihcImtleXByZXNzXCIsaSksRiYmdS53cml0ZShsLnNob3cpLGUuaXNUVFkmJiFBRCYmZS5zZXRSYXdNb2RlKCExKSxzLnRlcm1pbmFsPSExLHMuY2xvc2UoKX19dmFyIGdEPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSx2RD0oZSx1LHQpPT51IGluIGU/Z0QoZSx1LHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp0fSk6ZVt1XT10LGg9KGUsdSx0KT0+KHZEKGUsdHlwZW9mIHUhPVwic3ltYm9sXCI/dStcIlwiOnUsdCksdCk7Y2xhc3MgeHtjb25zdHJ1Y3Rvcih1LHQ9ITApe2godGhpcyxcImlucHV0XCIpLGgodGhpcyxcIm91dHB1dFwiKSxoKHRoaXMsXCJfYWJvcnRTaWduYWxcIiksaCh0aGlzLFwicmxcIiksaCh0aGlzLFwib3B0c1wiKSxoKHRoaXMsXCJfcmVuZGVyXCIpLGgodGhpcyxcIl90cmFja1wiLCExKSxoKHRoaXMsXCJfcHJldkZyYW1lXCIsXCJcIiksaCh0aGlzLFwiX3N1YnNjcmliZXJzXCIsbmV3IE1hcCksaCh0aGlzLFwiX2N1cnNvclwiLDApLGgodGhpcyxcInN0YXRlXCIsXCJpbml0aWFsXCIpLGgodGhpcyxcImVycm9yXCIsXCJcIiksaCh0aGlzLFwidmFsdWVcIik7Y29uc3R7aW5wdXQ6Rj1qLG91dHB1dDpzPU0scmVuZGVyOmksc2lnbmFsOkQsLi4uQ309dTt0aGlzLm9wdHM9Qyx0aGlzLm9uS2V5cHJlc3M9dGhpcy5vbktleXByZXNzLmJpbmQodGhpcyksdGhpcy5jbG9zZT10aGlzLmNsb3NlLmJpbmQodGhpcyksdGhpcy5yZW5kZXI9dGhpcy5yZW5kZXIuYmluZCh0aGlzKSx0aGlzLl9yZW5kZXI9aS5iaW5kKHRoaXMpLHRoaXMuX3RyYWNrPXQsdGhpcy5fYWJvcnRTaWduYWw9RCx0aGlzLmlucHV0PUYsdGhpcy5vdXRwdXQ9c311bnN1YnNjcmliZSgpe3RoaXMuX3N1YnNjcmliZXJzLmNsZWFyKCl9c2V0U3Vic2NyaWJlcih1LHQpe2NvbnN0IEY9dGhpcy5fc3Vic2NyaWJlcnMuZ2V0KHUpPz9bXTtGLnB1c2godCksdGhpcy5fc3Vic2NyaWJlcnMuc2V0KHUsRil9b24odSx0KXt0aGlzLnNldFN1YnNjcmliZXIodSx7Y2I6dH0pfW9uY2UodSx0KXt0aGlzLnNldFN1YnNjcmliZXIodSx7Y2I6dCxvbmNlOiEwfSl9ZW1pdCh1LC4uLnQpe2NvbnN0IEY9dGhpcy5fc3Vic2NyaWJlcnMuZ2V0KHUpPz9bXSxzPVtdO2Zvcihjb25zdCBpIG9mIEYpaS5jYiguLi50KSxpLm9uY2UmJnMucHVzaCgoKT0+Ri5zcGxpY2UoRi5pbmRleE9mKGkpLDEpKTtmb3IoY29uc3QgaSBvZiBzKWkoKX1wcm9tcHQoKXtyZXR1cm4gbmV3IFByb21pc2UoKHUsdCk9PntpZih0aGlzLl9hYm9ydFNpZ25hbCl7aWYodGhpcy5fYWJvcnRTaWduYWwuYWJvcnRlZClyZXR1cm4gdGhpcy5zdGF0ZT1cImNhbmNlbFwiLHRoaXMuY2xvc2UoKSx1KFMpO3RoaXMuX2Fib3J0U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCgpPT57dGhpcy5zdGF0ZT1cImNhbmNlbFwiLHRoaXMuY2xvc2UoKX0se29uY2U6ITB9KX1jb25zdCBGPW5ldyBYO0YuX3dyaXRlPShzLGksRCk9Pnt0aGlzLl90cmFjayYmKHRoaXMudmFsdWU9dGhpcy5ybD8ubGluZS5yZXBsYWNlKC9cXHQvZyxcIlwiKSx0aGlzLl9jdXJzb3I9dGhpcy5ybD8uY3Vyc29yPz8wLHRoaXMuZW1pdChcInZhbHVlXCIsdGhpcy52YWx1ZSkpLEQoKX0sdGhpcy5pbnB1dC5waXBlKEYpLHRoaXMucmw9Ty5jcmVhdGVJbnRlcmZhY2Uoe2lucHV0OnRoaXMuaW5wdXQsb3V0cHV0OkYsdGFiU2l6ZToyLHByb21wdDpcIlwiLGVzY2FwZUNvZGVUaW1lb3V0OjUwLHRlcm1pbmFsOiEwfSksTy5lbWl0S2V5cHJlc3NFdmVudHModGhpcy5pbnB1dCx0aGlzLnJsKSx0aGlzLnJsLnByb21wdCgpLHRoaXMub3B0cy5pbml0aWFsVmFsdWUhPT12b2lkIDAmJnRoaXMuX3RyYWNrJiZ0aGlzLnJsLndyaXRlKHRoaXMub3B0cy5pbml0aWFsVmFsdWUpLHRoaXMuaW5wdXQub24oXCJrZXlwcmVzc1wiLHRoaXMub25LZXlwcmVzcyksbSh0aGlzLmlucHV0LCEwKSx0aGlzLm91dHB1dC5vbihcInJlc2l6ZVwiLHRoaXMucmVuZGVyKSx0aGlzLnJlbmRlcigpLHRoaXMub25jZShcInN1Ym1pdFwiLCgpPT57dGhpcy5vdXRwdXQud3JpdGUobC5zaG93KSx0aGlzLm91dHB1dC5vZmYoXCJyZXNpemVcIix0aGlzLnJlbmRlciksbSh0aGlzLmlucHV0LCExKSx1KHRoaXMudmFsdWUpfSksdGhpcy5vbmNlKFwiY2FuY2VsXCIsKCk9Pnt0aGlzLm91dHB1dC53cml0ZShsLnNob3cpLHRoaXMub3V0cHV0Lm9mZihcInJlc2l6ZVwiLHRoaXMucmVuZGVyKSxtKHRoaXMuaW5wdXQsITEpLHUoUyl9KX0pfW9uS2V5cHJlc3ModSx0KXtpZih0aGlzLnN0YXRlPT09XCJlcnJvclwiJiYodGhpcy5zdGF0ZT1cImFjdGl2ZVwiKSx0Py5uYW1lJiYoIXRoaXMuX3RyYWNrJiZCLmFsaWFzZXMuaGFzKHQubmFtZSkmJnRoaXMuZW1pdChcImN1cnNvclwiLEIuYWxpYXNlcy5nZXQodC5uYW1lKSksQi5hY3Rpb25zLmhhcyh0Lm5hbWUpJiZ0aGlzLmVtaXQoXCJjdXJzb3JcIix0Lm5hbWUpKSx1JiYodS50b0xvd2VyQ2FzZSgpPT09XCJ5XCJ8fHUudG9Mb3dlckNhc2UoKT09PVwiblwiKSYmdGhpcy5lbWl0KFwiY29uZmlybVwiLHUudG9Mb3dlckNhc2UoKT09PVwieVwiKSx1PT09XCJcdFwiJiZ0aGlzLm9wdHMucGxhY2Vob2xkZXImJih0aGlzLnZhbHVlfHwodGhpcy5ybD8ud3JpdGUodGhpcy5vcHRzLnBsYWNlaG9sZGVyKSx0aGlzLmVtaXQoXCJ2YWx1ZVwiLHRoaXMub3B0cy5wbGFjZWhvbGRlcikpKSx1JiZ0aGlzLmVtaXQoXCJrZXlcIix1LnRvTG93ZXJDYXNlKCkpLHQ/Lm5hbWU9PT1cInJldHVyblwiKXtpZih0aGlzLm9wdHMudmFsaWRhdGUpe2NvbnN0IEY9dGhpcy5vcHRzLnZhbGlkYXRlKHRoaXMudmFsdWUpO0YmJih0aGlzLmVycm9yPUYgaW5zdGFuY2VvZiBFcnJvcj9GLm1lc3NhZ2U6Rix0aGlzLnN0YXRlPVwiZXJyb3JcIix0aGlzLnJsPy53cml0ZSh0aGlzLnZhbHVlKSl9dGhpcy5zdGF0ZSE9PVwiZXJyb3JcIiYmKHRoaXMuc3RhdGU9XCJzdWJtaXRcIil9JChbdSx0Py5uYW1lLHQ/LnNlcXVlbmNlXSxcImNhbmNlbFwiKSYmKHRoaXMuc3RhdGU9XCJjYW5jZWxcIiksKHRoaXMuc3RhdGU9PT1cInN1Ym1pdFwifHx0aGlzLnN0YXRlPT09XCJjYW5jZWxcIikmJnRoaXMuZW1pdChcImZpbmFsaXplXCIpLHRoaXMucmVuZGVyKCksKHRoaXMuc3RhdGU9PT1cInN1Ym1pdFwifHx0aGlzLnN0YXRlPT09XCJjYW5jZWxcIikmJnRoaXMuY2xvc2UoKX1jbG9zZSgpe3RoaXMuaW5wdXQudW5waXBlKCksdGhpcy5pbnB1dC5yZW1vdmVMaXN0ZW5lcihcImtleXByZXNzXCIsdGhpcy5vbktleXByZXNzKSx0aGlzLm91dHB1dC53cml0ZShgXG5gKSxtKHRoaXMuaW5wdXQsITEpLHRoaXMucmw/LmNsb3NlKCksdGhpcy5ybD12b2lkIDAsdGhpcy5lbWl0KGAke3RoaXMuc3RhdGV9YCx0aGlzLnZhbHVlKSx0aGlzLnVuc3Vic2NyaWJlKCl9cmVzdG9yZUN1cnNvcigpe2NvbnN0IHU9WSh0aGlzLl9wcmV2RnJhbWUscHJvY2Vzcy5zdGRvdXQuY29sdW1ucyx7aGFyZDohMH0pLnNwbGl0KGBcbmApLmxlbmd0aC0xO3RoaXMub3V0cHV0LndyaXRlKGwubW92ZSgtOTk5LHUqLTEpKX1yZW5kZXIoKXtjb25zdCB1PVkodGhpcy5fcmVuZGVyKHRoaXMpPz9cIlwiLHByb2Nlc3Muc3Rkb3V0LmNvbHVtbnMse2hhcmQ6ITB9KTtpZih1IT09dGhpcy5fcHJldkZyYW1lKXtpZih0aGlzLnN0YXRlPT09XCJpbml0aWFsXCIpdGhpcy5vdXRwdXQud3JpdGUobC5oaWRlKTtlbHNle2NvbnN0IHQ9QkQodGhpcy5fcHJldkZyYW1lLHUpO2lmKHRoaXMucmVzdG9yZUN1cnNvcigpLHQmJnQ/Lmxlbmd0aD09PTEpe2NvbnN0IEY9dFswXTt0aGlzLm91dHB1dC53cml0ZShsLm1vdmUoMCxGKSksdGhpcy5vdXRwdXQud3JpdGUoYi5saW5lcygxKSk7Y29uc3Qgcz11LnNwbGl0KGBcbmApO3RoaXMub3V0cHV0LndyaXRlKHNbRl0pLHRoaXMuX3ByZXZGcmFtZT11LHRoaXMub3V0cHV0LndyaXRlKGwubW92ZSgwLHMubGVuZ3RoLUYtMSkpO3JldHVybn1pZih0JiZ0Py5sZW5ndGg+MSl7Y29uc3QgRj10WzBdO3RoaXMub3V0cHV0LndyaXRlKGwubW92ZSgwLEYpKSx0aGlzLm91dHB1dC53cml0ZShiLmRvd24oKSk7Y29uc3Qgcz11LnNwbGl0KGBcbmApLnNsaWNlKEYpO3RoaXMub3V0cHV0LndyaXRlKHMuam9pbihgXG5gKSksdGhpcy5fcHJldkZyYW1lPXU7cmV0dXJufXRoaXMub3V0cHV0LndyaXRlKGIuZG93bigpKX10aGlzLm91dHB1dC53cml0ZSh1KSx0aGlzLnN0YXRlPT09XCJpbml0aWFsXCImJih0aGlzLnN0YXRlPVwiYWN0aXZlXCIpLHRoaXMuX3ByZXZGcmFtZT11fX19Y2xhc3MgZEQgZXh0ZW5kcyB4e2dldCBjdXJzb3IoKXtyZXR1cm4gdGhpcy52YWx1ZT8wOjF9Z2V0IF92YWx1ZSgpe3JldHVybiB0aGlzLmN1cnNvcj09PTB9Y29uc3RydWN0b3IodSl7c3VwZXIodSwhMSksdGhpcy52YWx1ZT0hIXUuaW5pdGlhbFZhbHVlLHRoaXMub24oXCJ2YWx1ZVwiLCgpPT57dGhpcy52YWx1ZT10aGlzLl92YWx1ZX0pLHRoaXMub24oXCJjb25maXJtXCIsdD0+e3RoaXMub3V0cHV0LndyaXRlKGwubW92ZSgwLC0xKSksdGhpcy52YWx1ZT10LHRoaXMuc3RhdGU9XCJzdWJtaXRcIix0aGlzLmNsb3NlKCl9KSx0aGlzLm9uKFwiY3Vyc29yXCIsKCk9Pnt0aGlzLnZhbHVlPSF0aGlzLnZhbHVlfSl9fXZhciBtRD1PYmplY3QuZGVmaW5lUHJvcGVydHksYkQ9KGUsdSx0KT0+dSBpbiBlP21EKGUsdSx7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dH0pOmVbdV09dCxaPShlLHUsdCk9PihiRChlLHR5cGVvZiB1IT1cInN5bWJvbFwiP3UrXCJcIjp1LHQpLHQpLHE9KGUsdSx0KT0+e2lmKCF1LmhhcyhlKSl0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgXCIrdCl9LFQ9KGUsdSx0KT0+KHEoZSx1LFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIiksdD90LmNhbGwoZSk6dS5nZXQoZSkpLHdEPShlLHUsdCk9PntpZih1LmhhcyhlKSl0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgYWRkIHRoZSBzYW1lIHByaXZhdGUgbWVtYmVyIG1vcmUgdGhhbiBvbmNlXCIpO3UgaW5zdGFuY2VvZiBXZWFrU2V0P3UuYWRkKGUpOnUuc2V0KGUsdCl9LHlEPShlLHUsdCxGKT0+KHEoZSx1LFwid3JpdGUgdG8gcHJpdmF0ZSBmaWVsZFwiKSxGP0YuY2FsbChlLHQpOnUuc2V0KGUsdCksdCksQTtsZXQgX0Q9Y2xhc3MgZXh0ZW5kcyB4e2NvbnN0cnVjdG9yKHUpe3N1cGVyKHUsITEpLFoodGhpcyxcIm9wdGlvbnNcIiksWih0aGlzLFwiY3Vyc29yXCIsMCksd0QodGhpcyxBLHZvaWQgMCk7Y29uc3R7b3B0aW9uczp0fT11O3lEKHRoaXMsQSx1LnNlbGVjdGFibGVHcm91cHMhPT0hMSksdGhpcy5vcHRpb25zPU9iamVjdC5lbnRyaWVzKHQpLmZsYXRNYXAoKFtGLHNdKT0+W3t2YWx1ZTpGLGdyb3VwOiEwLGxhYmVsOkZ9LC4uLnMubWFwKGk9Pih7Li4uaSxncm91cDpGfSkpXSksdGhpcy52YWx1ZT1bLi4udS5pbml0aWFsVmFsdWVzPz9bXV0sdGhpcy5jdXJzb3I9TWF0aC5tYXgodGhpcy5vcHRpb25zLmZpbmRJbmRleCgoe3ZhbHVlOkZ9KT0+Rj09PXUuY3Vyc29yQXQpLFQodGhpcyxBKT8wOjEpLHRoaXMub24oXCJjdXJzb3JcIixGPT57c3dpdGNoKEYpe2Nhc2VcImxlZnRcIjpjYXNlXCJ1cFwiOnt0aGlzLmN1cnNvcj10aGlzLmN1cnNvcj09PTA/dGhpcy5vcHRpb25zLmxlbmd0aC0xOnRoaXMuY3Vyc29yLTE7Y29uc3Qgcz10aGlzLm9wdGlvbnNbdGhpcy5jdXJzb3JdPy5ncm91cD09PSEwOyFUKHRoaXMsQSkmJnMmJih0aGlzLmN1cnNvcj10aGlzLmN1cnNvcj09PTA/dGhpcy5vcHRpb25zLmxlbmd0aC0xOnRoaXMuY3Vyc29yLTEpO2JyZWFrfWNhc2VcImRvd25cIjpjYXNlXCJyaWdodFwiOnt0aGlzLmN1cnNvcj10aGlzLmN1cnNvcj09PXRoaXMub3B0aW9ucy5sZW5ndGgtMT8wOnRoaXMuY3Vyc29yKzE7Y29uc3Qgcz10aGlzLm9wdGlvbnNbdGhpcy5jdXJzb3JdPy5ncm91cD09PSEwOyFUKHRoaXMsQSkmJnMmJih0aGlzLmN1cnNvcj10aGlzLmN1cnNvcj09PXRoaXMub3B0aW9ucy5sZW5ndGgtMT8wOnRoaXMuY3Vyc29yKzEpO2JyZWFrfWNhc2VcInNwYWNlXCI6dGhpcy50b2dnbGVWYWx1ZSgpO2JyZWFrfX0pfWdldEdyb3VwSXRlbXModSl7cmV0dXJuIHRoaXMub3B0aW9ucy5maWx0ZXIodD0+dC5ncm91cD09PXUpfWlzR3JvdXBTZWxlY3RlZCh1KXtyZXR1cm4gdGhpcy5nZXRHcm91cEl0ZW1zKHUpLmV2ZXJ5KHQ9PnRoaXMudmFsdWUuaW5jbHVkZXModC52YWx1ZSkpfXRvZ2dsZVZhbHVlKCl7Y29uc3QgdT10aGlzLm9wdGlvbnNbdGhpcy5jdXJzb3JdO2lmKHUuZ3JvdXA9PT0hMCl7Y29uc3QgdD11LnZhbHVlLEY9dGhpcy5nZXRHcm91cEl0ZW1zKHQpO3RoaXMuaXNHcm91cFNlbGVjdGVkKHQpP3RoaXMudmFsdWU9dGhpcy52YWx1ZS5maWx0ZXIocz0+Ri5maW5kSW5kZXgoaT0+aS52YWx1ZT09PXMpPT09LTEpOnRoaXMudmFsdWU9Wy4uLnRoaXMudmFsdWUsLi4uRi5tYXAocz0+cy52YWx1ZSldLHRoaXMudmFsdWU9QXJyYXkuZnJvbShuZXcgU2V0KHRoaXMudmFsdWUpKX1lbHNle2NvbnN0IHQ9dGhpcy52YWx1ZS5pbmNsdWRlcyh1LnZhbHVlKTt0aGlzLnZhbHVlPXQ/dGhpcy52YWx1ZS5maWx0ZXIoRj0+RiE9PXUudmFsdWUpOlsuLi50aGlzLnZhbHVlLHUudmFsdWVdfX19O0E9bmV3IFdlYWtNYXA7dmFyIGtEPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSwkRD0oZSx1LHQpPT51IGluIGU/a0QoZSx1LHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp0fSk6ZVt1XT10LEg9KGUsdSx0KT0+KCREKGUsdHlwZW9mIHUhPVwic3ltYm9sXCI/dStcIlwiOnUsdCksdCk7bGV0IFNEPWNsYXNzIGV4dGVuZHMgeHtjb25zdHJ1Y3Rvcih1KXtzdXBlcih1LCExKSxIKHRoaXMsXCJvcHRpb25zXCIpLEgodGhpcyxcImN1cnNvclwiLDApLHRoaXMub3B0aW9ucz11Lm9wdGlvbnMsdGhpcy52YWx1ZT1bLi4udS5pbml0aWFsVmFsdWVzPz9bXV0sdGhpcy5jdXJzb3I9TWF0aC5tYXgodGhpcy5vcHRpb25zLmZpbmRJbmRleCgoe3ZhbHVlOnR9KT0+dD09PXUuY3Vyc29yQXQpLDApLHRoaXMub24oXCJrZXlcIix0PT57dD09PVwiYVwiJiZ0aGlzLnRvZ2dsZUFsbCgpfSksdGhpcy5vbihcImN1cnNvclwiLHQ9Pntzd2l0Y2godCl7Y2FzZVwibGVmdFwiOmNhc2VcInVwXCI6dGhpcy5jdXJzb3I9dGhpcy5jdXJzb3I9PT0wP3RoaXMub3B0aW9ucy5sZW5ndGgtMTp0aGlzLmN1cnNvci0xO2JyZWFrO2Nhc2VcImRvd25cIjpjYXNlXCJyaWdodFwiOnRoaXMuY3Vyc29yPXRoaXMuY3Vyc29yPT09dGhpcy5vcHRpb25zLmxlbmd0aC0xPzA6dGhpcy5jdXJzb3IrMTticmVhaztjYXNlXCJzcGFjZVwiOnRoaXMudG9nZ2xlVmFsdWUoKTticmVha319KX1nZXQgX3ZhbHVlKCl7cmV0dXJuIHRoaXMub3B0aW9uc1t0aGlzLmN1cnNvcl0udmFsdWV9dG9nZ2xlQWxsKCl7Y29uc3QgdT10aGlzLnZhbHVlLmxlbmd0aD09PXRoaXMub3B0aW9ucy5sZW5ndGg7dGhpcy52YWx1ZT11P1tdOnRoaXMub3B0aW9ucy5tYXAodD0+dC52YWx1ZSl9dG9nZ2xlVmFsdWUoKXtjb25zdCB1PXRoaXMudmFsdWUuaW5jbHVkZXModGhpcy5fdmFsdWUpO3RoaXMudmFsdWU9dT90aGlzLnZhbHVlLmZpbHRlcih0PT50IT09dGhpcy5fdmFsdWUpOlsuLi50aGlzLnZhbHVlLHRoaXMuX3ZhbHVlXX19O3ZhciBURD1PYmplY3QuZGVmaW5lUHJvcGVydHksakQ9KGUsdSx0KT0+dSBpbiBlP1REKGUsdSx7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6dH0pOmVbdV09dCxVPShlLHUsdCk9PihqRChlLHR5cGVvZiB1IT1cInN5bWJvbFwiP3UrXCJcIjp1LHQpLHQpO2NsYXNzIE1EIGV4dGVuZHMgeHtjb25zdHJ1Y3Rvcih7bWFzazp1LC4uLnR9KXtzdXBlcih0KSxVKHRoaXMsXCJ2YWx1ZVdpdGhDdXJzb3JcIixcIlwiKSxVKHRoaXMsXCJfbWFza1wiLFwiXFx1MjAyMlwiKSx0aGlzLl9tYXNrPXU/P1wiXFx1MjAyMlwiLHRoaXMub24oXCJmaW5hbGl6ZVwiLCgpPT57dGhpcy52YWx1ZVdpdGhDdXJzb3I9dGhpcy5tYXNrZWR9KSx0aGlzLm9uKFwidmFsdWVcIiwoKT0+e2lmKHRoaXMuY3Vyc29yPj10aGlzLnZhbHVlLmxlbmd0aCl0aGlzLnZhbHVlV2l0aEN1cnNvcj1gJHt0aGlzLm1hc2tlZH0ke3YuaW52ZXJzZSh2LmhpZGRlbihcIl9cIikpfWA7ZWxzZXtjb25zdCBGPXRoaXMubWFza2VkLnNsaWNlKDAsdGhpcy5jdXJzb3IpLHM9dGhpcy5tYXNrZWQuc2xpY2UodGhpcy5jdXJzb3IpO3RoaXMudmFsdWVXaXRoQ3Vyc29yPWAke0Z9JHt2LmludmVyc2Uoc1swXSl9JHtzLnNsaWNlKDEpfWB9fSl9Z2V0IGN1cnNvcigpe3JldHVybiB0aGlzLl9jdXJzb3J9Z2V0IG1hc2tlZCgpe3JldHVybiB0aGlzLnZhbHVlLnJlcGxhY2VBbGwoLy4vZyx0aGlzLl9tYXNrKX19dmFyIE9EPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSxQRD0oZSx1LHQpPT51IGluIGU/T0QoZSx1LHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTp0fSk6ZVt1XT10LEo9KGUsdSx0KT0+KFBEKGUsdHlwZW9mIHUhPVwic3ltYm9sXCI/dStcIlwiOnUsdCksdCk7Y2xhc3MgTEQgZXh0ZW5kcyB4e2NvbnN0cnVjdG9yKHUpe3N1cGVyKHUsITEpLEoodGhpcyxcIm9wdGlvbnNcIiksSih0aGlzLFwiY3Vyc29yXCIsMCksdGhpcy5vcHRpb25zPXUub3B0aW9ucyx0aGlzLmN1cnNvcj10aGlzLm9wdGlvbnMuZmluZEluZGV4KCh7dmFsdWU6dH0pPT50PT09dS5pbml0aWFsVmFsdWUpLHRoaXMuY3Vyc29yPT09LTEmJih0aGlzLmN1cnNvcj0wKSx0aGlzLmNoYW5nZVZhbHVlKCksdGhpcy5vbihcImN1cnNvclwiLHQ9Pntzd2l0Y2godCl7Y2FzZVwibGVmdFwiOmNhc2VcInVwXCI6dGhpcy5jdXJzb3I9dGhpcy5jdXJzb3I9PT0wP3RoaXMub3B0aW9ucy5sZW5ndGgtMTp0aGlzLmN1cnNvci0xO2JyZWFrO2Nhc2VcImRvd25cIjpjYXNlXCJyaWdodFwiOnRoaXMuY3Vyc29yPXRoaXMuY3Vyc29yPT09dGhpcy5vcHRpb25zLmxlbmd0aC0xPzA6dGhpcy5jdXJzb3IrMTticmVha310aGlzLmNoYW5nZVZhbHVlKCl9KX1nZXQgX3ZhbHVlKCl7cmV0dXJuIHRoaXMub3B0aW9uc1t0aGlzLmN1cnNvcl19Y2hhbmdlVmFsdWUoKXt0aGlzLnZhbHVlPXRoaXMuX3ZhbHVlLnZhbHVlfX12YXIgV0Q9T2JqZWN0LmRlZmluZVByb3BlcnR5LE5EPShlLHUsdCk9PnUgaW4gZT9XRChlLHUse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOnR9KTplW3VdPXQsUT0oZSx1LHQpPT4oTkQoZSx0eXBlb2YgdSE9XCJzeW1ib2xcIj91K1wiXCI6dSx0KSx0KTtjbGFzcyBJRCBleHRlbmRzIHh7Y29uc3RydWN0b3IodSl7c3VwZXIodSwhMSksUSh0aGlzLFwib3B0aW9uc1wiKSxRKHRoaXMsXCJjdXJzb3JcIiwwKSx0aGlzLm9wdGlvbnM9dS5vcHRpb25zO2NvbnN0IHQ9dGhpcy5vcHRpb25zLm1hcCgoe3ZhbHVlOltGXX0pPT5GPy50b0xvd2VyQ2FzZSgpKTt0aGlzLmN1cnNvcj1NYXRoLm1heCh0LmluZGV4T2YodS5pbml0aWFsVmFsdWUpLDApLHRoaXMub24oXCJrZXlcIixGPT57aWYoIXQuaW5jbHVkZXMoRikpcmV0dXJuO2NvbnN0IHM9dGhpcy5vcHRpb25zLmZpbmQoKHt2YWx1ZTpbaV19KT0+aT8udG9Mb3dlckNhc2UoKT09PUYpO3MmJih0aGlzLnZhbHVlPXMudmFsdWUsdGhpcy5zdGF0ZT1cInN1Ym1pdFwiLHRoaXMuZW1pdChcInN1Ym1pdFwiKSl9KX19Y2xhc3MgUkQgZXh0ZW5kcyB4e2dldCB2YWx1ZVdpdGhDdXJzb3IoKXtpZih0aGlzLnN0YXRlPT09XCJzdWJtaXRcIilyZXR1cm4gdGhpcy52YWx1ZTtpZih0aGlzLmN1cnNvcj49dGhpcy52YWx1ZS5sZW5ndGgpcmV0dXJuYCR7dGhpcy52YWx1ZX1cXHUyNTg4YDtjb25zdCB1PXRoaXMudmFsdWUuc2xpY2UoMCx0aGlzLmN1cnNvciksW3QsLi4uRl09dGhpcy52YWx1ZS5zbGljZSh0aGlzLmN1cnNvcik7cmV0dXJuYCR7dX0ke3YuaW52ZXJzZSh0KX0ke0Yuam9pbihcIlwiKX1gfWdldCBjdXJzb3IoKXtyZXR1cm4gdGhpcy5fY3Vyc29yfWNvbnN0cnVjdG9yKHUpe3N1cGVyKHUpLHRoaXMub24oXCJmaW5hbGl6ZVwiLCgpPT57dGhpcy52YWx1ZXx8KHRoaXMudmFsdWU9dS5kZWZhdWx0VmFsdWUpfSl9fWV4cG9ydHtkRCBhcyBDb25maXJtUHJvbXB0LF9EIGFzIEdyb3VwTXVsdGlTZWxlY3RQcm9tcHQsU0QgYXMgTXVsdGlTZWxlY3RQcm9tcHQsTUQgYXMgUGFzc3dvcmRQcm9tcHQseCBhcyBQcm9tcHQsSUQgYXMgU2VsZWN0S2V5UHJvbXB0LExEIGFzIFNlbGVjdFByb21wdCxSRCBhcyBUZXh0UHJvbXB0LGZEIGFzIGJsb2NrLHBEIGFzIGlzQ2FuY2VsLGNEIGFzIHVwZGF0ZVNldHRpbmdzfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiIsCiAgICAiaW1wb3J0e3N0cmlwVlRDb250cm9sQ2hhcmFjdGVycyBhcyBTfWZyb21cIm5vZGU6dXRpbFwiO2ltcG9ydHtUZXh0UHJvbXB0IGFzIFEsUGFzc3dvcmRQcm9tcHQgYXMgWCxDb25maXJtUHJvbXB0IGFzIFosU2VsZWN0UHJvbXB0IGFzIGVlLFNlbGVjdEtleVByb21wdCBhcyB0ZSxNdWx0aVNlbGVjdFByb21wdCBhcyByZSxHcm91cE11bHRpU2VsZWN0UHJvbXB0IGFzIHNlLGlzQ2FuY2VsIGFzIGllLGJsb2NrIGFzIG5lfWZyb21cIkBjbGFjay9jb3JlXCI7ZXhwb3J0e2lzQ2FuY2VsLHVwZGF0ZVNldHRpbmdzfWZyb21cIkBjbGFjay9jb3JlXCI7aW1wb3J0IHkgZnJvbVwibm9kZTpwcm9jZXNzXCI7aW1wb3J0IGUgZnJvbVwicGljb2NvbG9yc1wiO2ltcG9ydHtjdXJzb3IgYXMgb2UsZXJhc2UgYXMgYWV9ZnJvbVwic2lzdGVyYW5zaVwiO2Z1bmN0aW9uIGNlKCl7cmV0dXJuIHkucGxhdGZvcm0hPT1cIndpbjMyXCI/eS5lbnYuVEVSTSE9PVwibGludXhcIjohIXkuZW52LkNJfHwhIXkuZW52LldUX1NFU1NJT058fCEheS5lbnYuVEVSTUlOVVNfU1VCTElNRXx8eS5lbnYuQ29uRW11VGFzaz09PVwie2NtZDo6Q21kZXJ9XCJ8fHkuZW52LlRFUk1fUFJPR1JBTT09PVwiVGVybWludXMtU3VibGltZVwifHx5LmVudi5URVJNX1BST0dSQU09PT1cInZzY29kZVwifHx5LmVudi5URVJNPT09XCJ4dGVybS0yNTZjb2xvclwifHx5LmVudi5URVJNPT09XCJhbGFjcml0dHlcInx8eS5lbnYuVEVSTUlOQUxfRU1VTEFUT1I9PT1cIkpldEJyYWlucy1KZWRpVGVybVwifWNvbnN0IFY9Y2UoKSx1PSh0LG4pPT5WP3Q6bixsZT11KFwiXFx1MjVDNlwiLFwiKlwiKSxMPXUoXCJcXHUyNUEwXCIsXCJ4XCIpLFc9dShcIlxcdTI1QjJcIixcInhcIiksQz11KFwiXFx1MjVDN1wiLFwib1wiKSx1ZT11KFwiXFx1MjUwQ1wiLFwiVFwiKSxvPXUoXCJcXHUyNTAyXCIsXCJ8XCIpLGQ9dShcIlxcdTI1MTRcIixcIlxcdTIwMTRcIiksaz11KFwiXFx1MjVDRlwiLFwiPlwiKSxQPXUoXCJcXHUyNUNCXCIsXCIgXCIpLEE9dShcIlxcdTI1RkJcIixcIltcXHUyMDIyXVwiKSxUPXUoXCJcXHUyNUZDXCIsXCJbK11cIiksRj11KFwiXFx1MjVGQlwiLFwiWyBdXCIpLCRlPXUoXCJcXHUyNUFBXCIsXCJcXHUyMDIyXCIpLF89dShcIlxcdTI1MDBcIixcIi1cIiksbWU9dShcIlxcdTI1NkVcIixcIitcIiksZGU9dShcIlxcdTI1MUNcIixcIitcIikscGU9dShcIlxcdTI1NkZcIixcIitcIikscT11KFwiXFx1MjVDRlwiLFwiXFx1MjAyMlwiKSxEPXUoXCJcXHUyNUM2XCIsXCIqXCIpLFU9dShcIlxcdTI1QjJcIixcIiFcIiksSz11KFwiXFx1MjVBMFwiLFwieFwiKSxiPXQ9Pntzd2l0Y2godCl7Y2FzZVwiaW5pdGlhbFwiOmNhc2VcImFjdGl2ZVwiOnJldHVybiBlLmN5YW4obGUpO2Nhc2VcImNhbmNlbFwiOnJldHVybiBlLnJlZChMKTtjYXNlXCJlcnJvclwiOnJldHVybiBlLnllbGxvdyhXKTtjYXNlXCJzdWJtaXRcIjpyZXR1cm4gZS5ncmVlbihDKX19LEc9dD0+e2NvbnN0e2N1cnNvcjpuLG9wdGlvbnM6cixzdHlsZTppfT10LHM9dC5tYXhJdGVtcz8/TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLGM9TWF0aC5tYXgocHJvY2Vzcy5zdGRvdXQucm93cy00LDApLGE9TWF0aC5taW4oYyxNYXRoLm1heChzLDUpKTtsZXQgbD0wO24+PWwrYS0zP2w9TWF0aC5tYXgoTWF0aC5taW4obi1hKzMsci5sZW5ndGgtYSksMCk6bjxsKzImJihsPU1hdGgubWF4KG4tMiwwKSk7Y29uc3QgJD1hPHIubGVuZ3RoJiZsPjAsZz1hPHIubGVuZ3RoJiZsK2E8ci5sZW5ndGg7cmV0dXJuIHIuc2xpY2UobCxsK2EpLm1hcCgocCx2LGYpPT57Y29uc3Qgaj12PT09MCYmJCxFPXY9PT1mLmxlbmd0aC0xJiZnO3JldHVybiBqfHxFP2UuZGltKFwiLi4uXCIpOmkocCx2K2w9PT1uKX0pfSxoZT10PT5uZXcgUSh7dmFsaWRhdGU6dC52YWxpZGF0ZSxwbGFjZWhvbGRlcjp0LnBsYWNlaG9sZGVyLGRlZmF1bHRWYWx1ZTp0LmRlZmF1bHRWYWx1ZSxpbml0aWFsVmFsdWU6dC5pbml0aWFsVmFsdWUscmVuZGVyKCl7Y29uc3Qgbj1gJHtlLmdyYXkobyl9XG4ke2IodGhpcy5zdGF0ZSl9ICAke3QubWVzc2FnZX1cbmAscj10LnBsYWNlaG9sZGVyP2UuaW52ZXJzZSh0LnBsYWNlaG9sZGVyWzBdKStlLmRpbSh0LnBsYWNlaG9sZGVyLnNsaWNlKDEpKTplLmludmVyc2UoZS5oaWRkZW4oXCJfXCIpKSxpPXRoaXMudmFsdWU/dGhpcy52YWx1ZVdpdGhDdXJzb3I6cjtzd2l0Y2godGhpcy5zdGF0ZSl7Y2FzZVwiZXJyb3JcIjpyZXR1cm5gJHtuLnRyaW0oKX1cbiR7ZS55ZWxsb3cobyl9ICAke2l9XG4ke2UueWVsbG93KGQpfSAgJHtlLnllbGxvdyh0aGlzLmVycm9yKX1cbmA7Y2FzZVwic3VibWl0XCI6cmV0dXJuYCR7bn0ke2UuZ3JheShvKX0gICR7ZS5kaW0odGhpcy52YWx1ZXx8dC5wbGFjZWhvbGRlcil9YDtjYXNlXCJjYW5jZWxcIjpyZXR1cm5gJHtufSR7ZS5ncmF5KG8pfSAgJHtlLnN0cmlrZXRocm91Z2goZS5kaW0odGhpcy52YWx1ZT8/XCJcIikpfSR7dGhpcy52YWx1ZT8udHJpbSgpP2BcbiR7ZS5ncmF5KG8pfWA6XCJcIn1gO2RlZmF1bHQ6cmV0dXJuYCR7bn0ke2UuY3lhbihvKX0gICR7aX1cbiR7ZS5jeWFuKGQpfVxuYH19fSkucHJvbXB0KCksZ2U9dD0+bmV3IFgoe3ZhbGlkYXRlOnQudmFsaWRhdGUsbWFzazp0Lm1hc2s/PyRlLHJlbmRlcigpe2NvbnN0IG49YCR7ZS5ncmF5KG8pfVxuJHtiKHRoaXMuc3RhdGUpfSAgJHt0Lm1lc3NhZ2V9XG5gLHI9dGhpcy52YWx1ZVdpdGhDdXJzb3IsaT10aGlzLm1hc2tlZDtzd2l0Y2godGhpcy5zdGF0ZSl7Y2FzZVwiZXJyb3JcIjpyZXR1cm5gJHtuLnRyaW0oKX1cbiR7ZS55ZWxsb3cobyl9ICAke2l9XG4ke2UueWVsbG93KGQpfSAgJHtlLnllbGxvdyh0aGlzLmVycm9yKX1cbmA7Y2FzZVwic3VibWl0XCI6cmV0dXJuYCR7bn0ke2UuZ3JheShvKX0gICR7ZS5kaW0oaSl9YDtjYXNlXCJjYW5jZWxcIjpyZXR1cm5gJHtufSR7ZS5ncmF5KG8pfSAgJHtlLnN0cmlrZXRocm91Z2goZS5kaW0oaT8/XCJcIikpfSR7aT9gXG4ke2UuZ3JheShvKX1gOlwiXCJ9YDtkZWZhdWx0OnJldHVybmAke259JHtlLmN5YW4obyl9ICAke3J9XG4ke2UuY3lhbihkKX1cbmB9fX0pLnByb21wdCgpLHllPXQ9Pntjb25zdCBuPXQuYWN0aXZlPz9cIlllc1wiLHI9dC5pbmFjdGl2ZT8/XCJOb1wiO3JldHVybiBuZXcgWih7YWN0aXZlOm4saW5hY3RpdmU6cixpbml0aWFsVmFsdWU6dC5pbml0aWFsVmFsdWU/PyEwLHJlbmRlcigpe2NvbnN0IGk9YCR7ZS5ncmF5KG8pfVxuJHtiKHRoaXMuc3RhdGUpfSAgJHt0Lm1lc3NhZ2V9XG5gLHM9dGhpcy52YWx1ZT9uOnI7c3dpdGNoKHRoaXMuc3RhdGUpe2Nhc2VcInN1Ym1pdFwiOnJldHVybmAke2l9JHtlLmdyYXkobyl9ICAke2UuZGltKHMpfWA7Y2FzZVwiY2FuY2VsXCI6cmV0dXJuYCR7aX0ke2UuZ3JheShvKX0gICR7ZS5zdHJpa2V0aHJvdWdoKGUuZGltKHMpKX1cbiR7ZS5ncmF5KG8pfWA7ZGVmYXVsdDpyZXR1cm5gJHtpfSR7ZS5jeWFuKG8pfSAgJHt0aGlzLnZhbHVlP2Ake2UuZ3JlZW4oayl9ICR7bn1gOmAke2UuZGltKFApfSAke2UuZGltKG4pfWB9ICR7ZS5kaW0oXCIvXCIpfSAke3RoaXMudmFsdWU/YCR7ZS5kaW0oUCl9ICR7ZS5kaW0ocil9YDpgJHtlLmdyZWVuKGspfSAke3J9YH1cbiR7ZS5jeWFuKGQpfVxuYH19fSkucHJvbXB0KCl9LHZlPXQ9Pntjb25zdCBuPShyLGkpPT57Y29uc3Qgcz1yLmxhYmVsPz9TdHJpbmcoci52YWx1ZSk7c3dpdGNoKGkpe2Nhc2VcInNlbGVjdGVkXCI6cmV0dXJuYCR7ZS5kaW0ocyl9YDtjYXNlXCJhY3RpdmVcIjpyZXR1cm5gJHtlLmdyZWVuKGspfSAke3N9ICR7ci5oaW50P2UuZGltKGAoJHtyLmhpbnR9KWApOlwiXCJ9YDtjYXNlXCJjYW5jZWxsZWRcIjpyZXR1cm5gJHtlLnN0cmlrZXRocm91Z2goZS5kaW0ocykpfWA7ZGVmYXVsdDpyZXR1cm5gJHtlLmRpbShQKX0gJHtlLmRpbShzKX1gfX07cmV0dXJuIG5ldyBlZSh7b3B0aW9uczp0Lm9wdGlvbnMsaW5pdGlhbFZhbHVlOnQuaW5pdGlhbFZhbHVlLHJlbmRlcigpe2NvbnN0IHI9YCR7ZS5ncmF5KG8pfVxuJHtiKHRoaXMuc3RhdGUpfSAgJHt0Lm1lc3NhZ2V9XG5gO3N3aXRjaCh0aGlzLnN0YXRlKXtjYXNlXCJzdWJtaXRcIjpyZXR1cm5gJHtyfSR7ZS5ncmF5KG8pfSAgJHtuKHRoaXMub3B0aW9uc1t0aGlzLmN1cnNvcl0sXCJzZWxlY3RlZFwiKX1gO2Nhc2VcImNhbmNlbFwiOnJldHVybmAke3J9JHtlLmdyYXkobyl9ICAke24odGhpcy5vcHRpb25zW3RoaXMuY3Vyc29yXSxcImNhbmNlbGxlZFwiKX1cbiR7ZS5ncmF5KG8pfWA7ZGVmYXVsdDpyZXR1cm5gJHtyfSR7ZS5jeWFuKG8pfSAgJHtHKHtjdXJzb3I6dGhpcy5jdXJzb3Isb3B0aW9uczp0aGlzLm9wdGlvbnMsbWF4SXRlbXM6dC5tYXhJdGVtcyxzdHlsZTooaSxzKT0+bihpLHM/XCJhY3RpdmVcIjpcImluYWN0aXZlXCIpfSkuam9pbihgXG4ke2UuY3lhbihvKX0gIGApfVxuJHtlLmN5YW4oZCl9XG5gfX19KS5wcm9tcHQoKX0sd2U9dD0+e2NvbnN0IG49KHIsaT1cImluYWN0aXZlXCIpPT57Y29uc3Qgcz1yLmxhYmVsPz9TdHJpbmcoci52YWx1ZSk7cmV0dXJuIGk9PT1cInNlbGVjdGVkXCI/YCR7ZS5kaW0ocyl9YDppPT09XCJjYW5jZWxsZWRcIj9gJHtlLnN0cmlrZXRocm91Z2goZS5kaW0ocykpfWA6aT09PVwiYWN0aXZlXCI/YCR7ZS5iZ0N5YW4oZS5ncmF5KGAgJHtyLnZhbHVlfSBgKSl9ICR7c30gJHtyLmhpbnQ/ZS5kaW0oYCgke3IuaGludH0pYCk6XCJcIn1gOmAke2UuZ3JheShlLmJnV2hpdGUoZS5pbnZlcnNlKGAgJHtyLnZhbHVlfSBgKSkpfSAke3N9ICR7ci5oaW50P2UuZGltKGAoJHtyLmhpbnR9KWApOlwiXCJ9YH07cmV0dXJuIG5ldyB0ZSh7b3B0aW9uczp0Lm9wdGlvbnMsaW5pdGlhbFZhbHVlOnQuaW5pdGlhbFZhbHVlLHJlbmRlcigpe2NvbnN0IHI9YCR7ZS5ncmF5KG8pfVxuJHtiKHRoaXMuc3RhdGUpfSAgJHt0Lm1lc3NhZ2V9XG5gO3N3aXRjaCh0aGlzLnN0YXRlKXtjYXNlXCJzdWJtaXRcIjpyZXR1cm5gJHtyfSR7ZS5ncmF5KG8pfSAgJHtuKHRoaXMub3B0aW9ucy5maW5kKGk9PmkudmFsdWU9PT10aGlzLnZhbHVlKT8/dC5vcHRpb25zWzBdLFwic2VsZWN0ZWRcIil9YDtjYXNlXCJjYW5jZWxcIjpyZXR1cm5gJHtyfSR7ZS5ncmF5KG8pfSAgJHtuKHRoaXMub3B0aW9uc1swXSxcImNhbmNlbGxlZFwiKX1cbiR7ZS5ncmF5KG8pfWA7ZGVmYXVsdDpyZXR1cm5gJHtyfSR7ZS5jeWFuKG8pfSAgJHt0aGlzLm9wdGlvbnMubWFwKChpLHMpPT5uKGkscz09PXRoaXMuY3Vyc29yP1wiYWN0aXZlXCI6XCJpbmFjdGl2ZVwiKSkuam9pbihgXG4ke2UuY3lhbihvKX0gIGApfVxuJHtlLmN5YW4oZCl9XG5gfX19KS5wcm9tcHQoKX0sZmU9dD0+e2NvbnN0IG49KHIsaSk9Pntjb25zdCBzPXIubGFiZWw/P1N0cmluZyhyLnZhbHVlKTtyZXR1cm4gaT09PVwiYWN0aXZlXCI/YCR7ZS5jeWFuKEEpfSAke3N9ICR7ci5oaW50P2UuZGltKGAoJHtyLmhpbnR9KWApOlwiXCJ9YDppPT09XCJzZWxlY3RlZFwiP2Ake2UuZ3JlZW4oVCl9ICR7ZS5kaW0ocyl9ICR7ci5oaW50P2UuZGltKGAoJHtyLmhpbnR9KWApOlwiXCJ9YDppPT09XCJjYW5jZWxsZWRcIj9gJHtlLnN0cmlrZXRocm91Z2goZS5kaW0ocykpfWA6aT09PVwiYWN0aXZlLXNlbGVjdGVkXCI/YCR7ZS5ncmVlbihUKX0gJHtzfSAke3IuaGludD9lLmRpbShgKCR7ci5oaW50fSlgKTpcIlwifWA6aT09PVwic3VibWl0dGVkXCI/YCR7ZS5kaW0ocyl9YDpgJHtlLmRpbShGKX0gJHtlLmRpbShzKX1gfTtyZXR1cm4gbmV3IHJlKHtvcHRpb25zOnQub3B0aW9ucyxpbml0aWFsVmFsdWVzOnQuaW5pdGlhbFZhbHVlcyxyZXF1aXJlZDp0LnJlcXVpcmVkPz8hMCxjdXJzb3JBdDp0LmN1cnNvckF0LHZhbGlkYXRlKHIpe2lmKHRoaXMucmVxdWlyZWQmJnIubGVuZ3RoPT09MClyZXR1cm5gUGxlYXNlIHNlbGVjdCBhdCBsZWFzdCBvbmUgb3B0aW9uLlxuJHtlLnJlc2V0KGUuZGltKGBQcmVzcyAke2UuZ3JheShlLmJnV2hpdGUoZS5pbnZlcnNlKFwiIHNwYWNlIFwiKSkpfSB0byBzZWxlY3QsICR7ZS5ncmF5KGUuYmdXaGl0ZShlLmludmVyc2UoXCIgZW50ZXIgXCIpKSl9IHRvIHN1Ym1pdGApKX1gfSxyZW5kZXIoKXtjb25zdCByPWAke2UuZ3JheShvKX1cbiR7Yih0aGlzLnN0YXRlKX0gICR7dC5tZXNzYWdlfVxuYCxpPShzLGMpPT57Y29uc3QgYT10aGlzLnZhbHVlLmluY2x1ZGVzKHMudmFsdWUpO3JldHVybiBjJiZhP24ocyxcImFjdGl2ZS1zZWxlY3RlZFwiKTphP24ocyxcInNlbGVjdGVkXCIpOm4ocyxjP1wiYWN0aXZlXCI6XCJpbmFjdGl2ZVwiKX07c3dpdGNoKHRoaXMuc3RhdGUpe2Nhc2VcInN1Ym1pdFwiOnJldHVybmAke3J9JHtlLmdyYXkobyl9ICAke3RoaXMub3B0aW9ucy5maWx0ZXIoKHt2YWx1ZTpzfSk9PnRoaXMudmFsdWUuaW5jbHVkZXMocykpLm1hcChzPT5uKHMsXCJzdWJtaXR0ZWRcIikpLmpvaW4oZS5kaW0oXCIsIFwiKSl8fGUuZGltKFwibm9uZVwiKX1gO2Nhc2VcImNhbmNlbFwiOntjb25zdCBzPXRoaXMub3B0aW9ucy5maWx0ZXIoKHt2YWx1ZTpjfSk9PnRoaXMudmFsdWUuaW5jbHVkZXMoYykpLm1hcChjPT5uKGMsXCJjYW5jZWxsZWRcIikpLmpvaW4oZS5kaW0oXCIsIFwiKSk7cmV0dXJuYCR7cn0ke2UuZ3JheShvKX0gICR7cy50cmltKCk/YCR7c31cbiR7ZS5ncmF5KG8pfWA6XCJcIn1gfWNhc2VcImVycm9yXCI6e2NvbnN0IHM9dGhpcy5lcnJvci5zcGxpdChgXG5gKS5tYXAoKGMsYSk9PmE9PT0wP2Ake2UueWVsbG93KGQpfSAgJHtlLnllbGxvdyhjKX1gOmAgICAke2N9YCkuam9pbihgXG5gKTtyZXR1cm5gJHtyK2UueWVsbG93KG8pfSAgJHtHKHtvcHRpb25zOnRoaXMub3B0aW9ucyxjdXJzb3I6dGhpcy5jdXJzb3IsbWF4SXRlbXM6dC5tYXhJdGVtcyxzdHlsZTppfSkuam9pbihgXG4ke2UueWVsbG93KG8pfSAgYCl9XG4ke3N9XG5gfWRlZmF1bHQ6cmV0dXJuYCR7cn0ke2UuY3lhbihvKX0gICR7Ryh7b3B0aW9uczp0aGlzLm9wdGlvbnMsY3Vyc29yOnRoaXMuY3Vyc29yLG1heEl0ZW1zOnQubWF4SXRlbXMsc3R5bGU6aX0pLmpvaW4oYFxuJHtlLmN5YW4obyl9ICBgKX1cbiR7ZS5jeWFuKGQpfVxuYH19fSkucHJvbXB0KCl9LGJlPXQ9Pntjb25zdHtzZWxlY3RhYmxlR3JvdXBzOm49ITB9PXQscj0oaSxzLGM9W10pPT57Y29uc3QgYT1pLmxhYmVsPz9TdHJpbmcoaS52YWx1ZSksbD10eXBlb2YgaS5ncm91cD09XCJzdHJpbmdcIiwkPWwmJihjW2MuaW5kZXhPZihpKSsxXT8/e2dyb3VwOiEwfSksZz1sJiYkLmdyb3VwPT09ITAscD1sP24/YCR7Zz9kOm99IGA6XCIgIFwiOlwiXCI7aWYocz09PVwiYWN0aXZlXCIpcmV0dXJuYCR7ZS5kaW0ocCl9JHtlLmN5YW4oQSl9ICR7YX0gJHtpLmhpbnQ/ZS5kaW0oYCgke2kuaGludH0pYCk6XCJcIn1gO2lmKHM9PT1cImdyb3VwLWFjdGl2ZVwiKXJldHVybmAke3B9JHtlLmN5YW4oQSl9ICR7ZS5kaW0oYSl9YDtpZihzPT09XCJncm91cC1hY3RpdmUtc2VsZWN0ZWRcIilyZXR1cm5gJHtwfSR7ZS5ncmVlbihUKX0gJHtlLmRpbShhKX1gO2lmKHM9PT1cInNlbGVjdGVkXCIpe2NvbnN0IGY9bHx8bj9lLmdyZWVuKFQpOlwiXCI7cmV0dXJuYCR7ZS5kaW0ocCl9JHtmfSAke2UuZGltKGEpfSAke2kuaGludD9lLmRpbShgKCR7aS5oaW50fSlgKTpcIlwifWB9aWYocz09PVwiY2FuY2VsbGVkXCIpcmV0dXJuYCR7ZS5zdHJpa2V0aHJvdWdoKGUuZGltKGEpKX1gO2lmKHM9PT1cImFjdGl2ZS1zZWxlY3RlZFwiKXJldHVybmAke2UuZGltKHApfSR7ZS5ncmVlbihUKX0gJHthfSAke2kuaGludD9lLmRpbShgKCR7aS5oaW50fSlgKTpcIlwifWA7aWYocz09PVwic3VibWl0dGVkXCIpcmV0dXJuYCR7ZS5kaW0oYSl9YDtjb25zdCB2PWx8fG4/ZS5kaW0oRik6XCJcIjtyZXR1cm5gJHtlLmRpbShwKX0ke3Z9ICR7ZS5kaW0oYSl9YH07cmV0dXJuIG5ldyBzZSh7b3B0aW9uczp0Lm9wdGlvbnMsaW5pdGlhbFZhbHVlczp0LmluaXRpYWxWYWx1ZXMscmVxdWlyZWQ6dC5yZXF1aXJlZD8/ITAsY3Vyc29yQXQ6dC5jdXJzb3JBdCxzZWxlY3RhYmxlR3JvdXBzOm4sdmFsaWRhdGUoaSl7aWYodGhpcy5yZXF1aXJlZCYmaS5sZW5ndGg9PT0wKXJldHVybmBQbGVhc2Ugc2VsZWN0IGF0IGxlYXN0IG9uZSBvcHRpb24uXG4ke2UucmVzZXQoZS5kaW0oYFByZXNzICR7ZS5ncmF5KGUuYmdXaGl0ZShlLmludmVyc2UoXCIgc3BhY2UgXCIpKSl9IHRvIHNlbGVjdCwgJHtlLmdyYXkoZS5iZ1doaXRlKGUuaW52ZXJzZShcIiBlbnRlciBcIikpKX0gdG8gc3VibWl0YCkpfWB9LHJlbmRlcigpe2NvbnN0IGk9YCR7ZS5ncmF5KG8pfVxuJHtiKHRoaXMuc3RhdGUpfSAgJHt0Lm1lc3NhZ2V9XG5gO3N3aXRjaCh0aGlzLnN0YXRlKXtjYXNlXCJzdWJtaXRcIjpyZXR1cm5gJHtpfSR7ZS5ncmF5KG8pfSAgJHt0aGlzLm9wdGlvbnMuZmlsdGVyKCh7dmFsdWU6c30pPT50aGlzLnZhbHVlLmluY2x1ZGVzKHMpKS5tYXAocz0+cihzLFwic3VibWl0dGVkXCIpKS5qb2luKGUuZGltKFwiLCBcIikpfWA7Y2FzZVwiY2FuY2VsXCI6e2NvbnN0IHM9dGhpcy5vcHRpb25zLmZpbHRlcigoe3ZhbHVlOmN9KT0+dGhpcy52YWx1ZS5pbmNsdWRlcyhjKSkubWFwKGM9PnIoYyxcImNhbmNlbGxlZFwiKSkuam9pbihlLmRpbShcIiwgXCIpKTtyZXR1cm5gJHtpfSR7ZS5ncmF5KG8pfSAgJHtzLnRyaW0oKT9gJHtzfVxuJHtlLmdyYXkobyl9YDpcIlwifWB9Y2FzZVwiZXJyb3JcIjp7Y29uc3Qgcz10aGlzLmVycm9yLnNwbGl0KGBcbmApLm1hcCgoYyxhKT0+YT09PTA/YCR7ZS55ZWxsb3coZCl9ICAke2UueWVsbG93KGMpfWA6YCAgICR7Y31gKS5qb2luKGBcbmApO3JldHVybmAke2l9JHtlLnllbGxvdyhvKX0gICR7dGhpcy5vcHRpb25zLm1hcCgoYyxhLGwpPT57Y29uc3QgJD10aGlzLnZhbHVlLmluY2x1ZGVzKGMudmFsdWUpfHxjLmdyb3VwPT09ITAmJnRoaXMuaXNHcm91cFNlbGVjdGVkKGAke2MudmFsdWV9YCksZz1hPT09dGhpcy5jdXJzb3I7cmV0dXJuIWcmJnR5cGVvZiBjLmdyb3VwPT1cInN0cmluZ1wiJiZ0aGlzLm9wdGlvbnNbdGhpcy5jdXJzb3JdLnZhbHVlPT09Yy5ncm91cD9yKGMsJD9cImdyb3VwLWFjdGl2ZS1zZWxlY3RlZFwiOlwiZ3JvdXAtYWN0aXZlXCIsbCk6ZyYmJD9yKGMsXCJhY3RpdmUtc2VsZWN0ZWRcIixsKTokP3IoYyxcInNlbGVjdGVkXCIsbCk6cihjLGc/XCJhY3RpdmVcIjpcImluYWN0aXZlXCIsbCl9KS5qb2luKGBcbiR7ZS55ZWxsb3cobyl9ICBgKX1cbiR7c31cbmB9ZGVmYXVsdDpyZXR1cm5gJHtpfSR7ZS5jeWFuKG8pfSAgJHt0aGlzLm9wdGlvbnMubWFwKChzLGMsYSk9Pntjb25zdCBsPXRoaXMudmFsdWUuaW5jbHVkZXMocy52YWx1ZSl8fHMuZ3JvdXA9PT0hMCYmdGhpcy5pc0dyb3VwU2VsZWN0ZWQoYCR7cy52YWx1ZX1gKSwkPWM9PT10aGlzLmN1cnNvcjtyZXR1cm4hJCYmdHlwZW9mIHMuZ3JvdXA9PVwic3RyaW5nXCImJnRoaXMub3B0aW9uc1t0aGlzLmN1cnNvcl0udmFsdWU9PT1zLmdyb3VwP3IocyxsP1wiZ3JvdXAtYWN0aXZlLXNlbGVjdGVkXCI6XCJncm91cC1hY3RpdmVcIixhKTokJiZsP3IocyxcImFjdGl2ZS1zZWxlY3RlZFwiLGEpOmw/cihzLFwic2VsZWN0ZWRcIixhKTpyKHMsJD9cImFjdGl2ZVwiOlwiaW5hY3RpdmVcIixhKX0pLmpvaW4oYFxuJHtlLmN5YW4obyl9ICBgKX1cbiR7ZS5jeWFuKGQpfVxuYH19fSkucHJvbXB0KCl9LE1lPSh0PVwiXCIsbj1cIlwiKT0+e2NvbnN0IHI9YFxuJHt0fVxuYC5zcGxpdChgXG5gKSxpPVMobikubGVuZ3RoLHM9TWF0aC5tYXgoci5yZWR1Y2UoKGEsbCk9Pntjb25zdCAkPVMobCk7cmV0dXJuICQubGVuZ3RoPmE/JC5sZW5ndGg6YX0sMCksaSkrMixjPXIubWFwKGE9PmAke2UuZ3JheShvKX0gICR7ZS5kaW0oYSl9JHtcIiBcIi5yZXBlYXQocy1TKGEpLmxlbmd0aCl9JHtlLmdyYXkobyl9YCkuam9pbihgXG5gKTtwcm9jZXNzLnN0ZG91dC53cml0ZShgJHtlLmdyYXkobyl9XG4ke2UuZ3JlZW4oQyl9ICAke2UucmVzZXQobil9ICR7ZS5ncmF5KF8ucmVwZWF0KE1hdGgubWF4KHMtaS0xLDEpKSttZSl9XG4ke2N9XG4ke2UuZ3JheShkZStfLnJlcGVhdChzKzIpK3BlKX1cbmApfSx4ZT0odD1cIlwiKT0+e3Byb2Nlc3Muc3Rkb3V0LndyaXRlKGAke2UuZ3JheShkKX0gICR7ZS5yZWQodCl9XG5cbmApfSxJZT0odD1cIlwiKT0+e3Byb2Nlc3Muc3Rkb3V0LndyaXRlKGAke2UuZ3JheSh1ZSl9ICAke3R9XG5gKX0sU2U9KHQ9XCJcIik9Pntwcm9jZXNzLnN0ZG91dC53cml0ZShgJHtlLmdyYXkobyl9XG4ke2UuZ3JheShkKX0gICR7dH1cblxuYCl9LE09e21lc3NhZ2U6KHQ9XCJcIix7c3ltYm9sOm49ZS5ncmF5KG8pfT17fSk9Pntjb25zdCByPVtgJHtlLmdyYXkobyl9YF07aWYodCl7Y29uc3RbaSwuLi5zXT10LnNwbGl0KGBcbmApO3IucHVzaChgJHtufSAgJHtpfWAsLi4ucy5tYXAoYz0+YCR7ZS5ncmF5KG8pfSAgJHtjfWApKX1wcm9jZXNzLnN0ZG91dC53cml0ZShgJHtyLmpvaW4oYFxuYCl9XG5gKX0saW5mbzp0PT57TS5tZXNzYWdlKHQse3N5bWJvbDplLmJsdWUocSl9KX0sc3VjY2Vzczp0PT57TS5tZXNzYWdlKHQse3N5bWJvbDplLmdyZWVuKEQpfSl9LHN0ZXA6dD0+e00ubWVzc2FnZSh0LHtzeW1ib2w6ZS5ncmVlbihDKX0pfSx3YXJuOnQ9PntNLm1lc3NhZ2UodCx7c3ltYm9sOmUueWVsbG93KFUpfSl9LHdhcm5pbmc6dD0+e00ud2Fybih0KX0sZXJyb3I6dD0+e00ubWVzc2FnZSh0LHtzeW1ib2w6ZS5yZWQoSyl9KX19LEo9YCR7ZS5ncmF5KG8pfSAgYCx4PXttZXNzYWdlOmFzeW5jKHQse3N5bWJvbDpuPWUuZ3JheShvKX09e30pPT57cHJvY2Vzcy5zdGRvdXQud3JpdGUoYCR7ZS5ncmF5KG8pfVxuJHtufSAgYCk7bGV0IHI9Mztmb3IgYXdhaXQobGV0IGkgb2YgdCl7aT1pLnJlcGxhY2UoL1xcbi9nLGBcbiR7Sn1gKSxpLmluY2x1ZGVzKGBcbmApJiYocj0zK1MoaS5zbGljZShpLmxhc3RJbmRleE9mKGBcbmApKSkubGVuZ3RoKTtjb25zdCBzPVMoaSkubGVuZ3RoO3Irczxwcm9jZXNzLnN0ZG91dC5jb2x1bW5zPyhyKz1zLHByb2Nlc3Muc3Rkb3V0LndyaXRlKGkpKToocHJvY2Vzcy5zdGRvdXQud3JpdGUoYFxuJHtKfSR7aS50cmltU3RhcnQoKX1gKSxyPTMrUyhpLnRyaW1TdGFydCgpKS5sZW5ndGgpfXByb2Nlc3Muc3Rkb3V0LndyaXRlKGBcbmApfSxpbmZvOnQ9PngubWVzc2FnZSh0LHtzeW1ib2w6ZS5ibHVlKHEpfSksc3VjY2Vzczp0PT54Lm1lc3NhZ2UodCx7c3ltYm9sOmUuZ3JlZW4oRCl9KSxzdGVwOnQ9PngubWVzc2FnZSh0LHtzeW1ib2w6ZS5ncmVlbihDKX0pLHdhcm46dD0+eC5tZXNzYWdlKHQse3N5bWJvbDplLnllbGxvdyhVKX0pLHdhcm5pbmc6dD0+eC53YXJuKHQpLGVycm9yOnQ9PngubWVzc2FnZSh0LHtzeW1ib2w6ZS5yZWQoSyl9KX0sWT0oe2luZGljYXRvcjp0PVwiZG90c1wifT17fSk9Pntjb25zdCBuPVY/W1wiXFx1MjVEMlwiLFwiXFx1MjVEMFwiLFwiXFx1MjVEM1wiLFwiXFx1MjVEMVwiXTpbXCJcXHUyMDIyXCIsXCJvXCIsXCJPXCIsXCIwXCJdLHI9Vj84MDoxMjAsaT1wcm9jZXNzLmVudi5DST09PVwidHJ1ZVwiO2xldCBzLGMsYT0hMSxsPVwiXCIsJCxnPXBlcmZvcm1hbmNlLm5vdygpO2NvbnN0IHA9bT0+e2NvbnN0IGg9bT4xP1wiU29tZXRoaW5nIHdlbnQgd3JvbmdcIjpcIkNhbmNlbGVkXCI7YSYmTihoLG0pfSx2PSgpPT5wKDIpLGY9KCk9PnAoMSksaj0oKT0+e3Byb2Nlc3Mub24oXCJ1bmNhdWdodEV4Y2VwdGlvbk1vbml0b3JcIix2KSxwcm9jZXNzLm9uKFwidW5oYW5kbGVkUmVqZWN0aW9uXCIsdikscHJvY2Vzcy5vbihcIlNJR0lOVFwiLGYpLHByb2Nlc3Mub24oXCJTSUdURVJNXCIsZikscHJvY2Vzcy5vbihcImV4aXRcIixwKX0sRT0oKT0+e3Byb2Nlc3MucmVtb3ZlTGlzdGVuZXIoXCJ1bmNhdWdodEV4Y2VwdGlvbk1vbml0b3JcIix2KSxwcm9jZXNzLnJlbW92ZUxpc3RlbmVyKFwidW5oYW5kbGVkUmVqZWN0aW9uXCIsdikscHJvY2Vzcy5yZW1vdmVMaXN0ZW5lcihcIlNJR0lOVFwiLGYpLHByb2Nlc3MucmVtb3ZlTGlzdGVuZXIoXCJTSUdURVJNXCIsZikscHJvY2Vzcy5yZW1vdmVMaXN0ZW5lcihcImV4aXRcIixwKX0sQj0oKT0+e2lmKCQ9PT12b2lkIDApcmV0dXJuO2kmJnByb2Nlc3Muc3Rkb3V0LndyaXRlKGBcbmApO2NvbnN0IG09JC5zcGxpdChgXG5gKTtwcm9jZXNzLnN0ZG91dC53cml0ZShvZS5tb3ZlKC05OTksbS5sZW5ndGgtMSkpLHByb2Nlc3Muc3Rkb3V0LndyaXRlKGFlLmRvd24obS5sZW5ndGgpKX0sUj1tPT5tLnJlcGxhY2UoL1xcLiskLyxcIlwiKSxPPW09Pntjb25zdCBoPShwZXJmb3JtYW5jZS5ub3coKS1tKS8xZTMsdz1NYXRoLmZsb29yKGgvNjApLEk9TWF0aC5mbG9vcihoJTYwKTtyZXR1cm4gdz4wP2BbJHt3fW0gJHtJfXNdYDpgWyR7SX1zXWB9LEg9KG09XCJcIik9PnthPSEwLHM9bmUoKSxsPVIobSksZz1wZXJmb3JtYW5jZS5ub3coKSxwcm9jZXNzLnN0ZG91dC53cml0ZShgJHtlLmdyYXkobyl9XG5gKTtsZXQgaD0wLHc9MDtqKCksYz1zZXRJbnRlcnZhbCgoKT0+e2lmKGkmJmw9PT0kKXJldHVybjtCKCksJD1sO2NvbnN0IEk9ZS5tYWdlbnRhKG5baF0pO2lmKGkpcHJvY2Vzcy5zdGRvdXQud3JpdGUoYCR7SX0gICR7bH0uLi5gKTtlbHNlIGlmKHQ9PT1cInRpbWVyXCIpcHJvY2Vzcy5zdGRvdXQud3JpdGUoYCR7SX0gICR7bH0gJHtPKGcpfWApO2Vsc2V7Y29uc3Qgej1cIi5cIi5yZXBlYXQoTWF0aC5mbG9vcih3KSkuc2xpY2UoMCwzKTtwcm9jZXNzLnN0ZG91dC53cml0ZShgJHtJfSAgJHtsfSR7en1gKX1oPWgrMTxuLmxlbmd0aD9oKzE6MCx3PXc8bi5sZW5ndGg/dysuMTI1OjB9LHIpfSxOPShtPVwiXCIsaD0wKT0+e2E9ITEsY2xlYXJJbnRlcnZhbChjKSxCKCk7Y29uc3Qgdz1oPT09MD9lLmdyZWVuKEMpOmg9PT0xP2UucmVkKEwpOmUucmVkKFcpO2w9UihtPz9sKSx0PT09XCJ0aW1lclwiP3Byb2Nlc3Muc3Rkb3V0LndyaXRlKGAke3d9ICAke2x9ICR7TyhnKX1cbmApOnByb2Nlc3Muc3Rkb3V0LndyaXRlKGAke3d9ICAke2x9XG5gKSxFKCkscygpfTtyZXR1cm57c3RhcnQ6SCxzdG9wOk4sbWVzc2FnZToobT1cIlwiKT0+e2w9UihtPz9sKX19fSxDZT1hc3luYyh0LG4pPT57Y29uc3Qgcj17fSxpPU9iamVjdC5rZXlzKHQpO2Zvcihjb25zdCBzIG9mIGkpe2NvbnN0IGM9dFtzXSxhPWF3YWl0IGMoe3Jlc3VsdHM6cn0pPy5jYXRjaChsPT57dGhyb3cgbH0pO2lmKHR5cGVvZiBuPy5vbkNhbmNlbD09XCJmdW5jdGlvblwiJiZpZShhKSl7cltzXT1cImNhbmNlbGVkXCIsbi5vbkNhbmNlbCh7cmVzdWx0czpyfSk7Y29udGludWV9cltzXT1hfXJldHVybiByfSxUZT1hc3luYyB0PT57Zm9yKGNvbnN0IG4gb2YgdCl7aWYobi5lbmFibGVkPT09ITEpY29udGludWU7Y29uc3Qgcj1ZKCk7ci5zdGFydChuLnRpdGxlKTtjb25zdCBpPWF3YWl0IG4udGFzayhyLm1lc3NhZ2UpO3Iuc3RvcChpfHxuLnRpdGxlKX19O2V4cG9ydHt4ZSBhcyBjYW5jZWwseWUgYXMgY29uZmlybSxDZSBhcyBncm91cCxiZSBhcyBncm91cE11bHRpc2VsZWN0LEllIGFzIGludHJvLE0gYXMgbG9nLGZlIGFzIG11bHRpc2VsZWN0LE1lIGFzIG5vdGUsU2UgYXMgb3V0cm8sZ2UgYXMgcGFzc3dvcmQsdmUgYXMgc2VsZWN0LHdlIGFzIHNlbGVjdEtleSxZIGFzIHNwaW5uZXIseCBhcyBzdHJlYW0sVGUgYXMgdGFza3MsaGUgYXMgdGV4dH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLAogICAgIi8qKlxuICogT3BlbkNvZGUgU0RLIEJhY2tlbmQgV3JhcHBlclxuICpcbiAqIFByb3ZpZGVzIHNlc3Npb24gbWFuYWdlbWVudCBhbmQgbWVzc2FnZSBzZW5kaW5nIGNhcGFiaWxpdGllc1xuICogZm9yIGFpLWVuZyByYWxwaCBydW5uZXIgdXNpbmcgT3BlbkNvZGUgU0RLLlxuICovXG5cbmltcG9ydCB7IGNyZWF0ZVNlcnZlciB9IGZyb20gXCJub2RlOm5ldFwiO1xuaW1wb3J0IHtcbiAgICB0eXBlIE9wZW5jb2RlQ2xpZW50LFxuICAgIGNyZWF0ZU9wZW5jb2RlLFxuICAgIGNyZWF0ZU9wZW5jb2RlQ2xpZW50LFxufSBmcm9tIFwiQG9wZW5jb2RlLWFpL3Nka1wiO1xuaW1wb3J0IHsgTG9nIH0gZnJvbSBcIi4uLy4uL3V0aWwvbG9nXCI7XG5cbmNvbnN0IGxvZyA9IExvZy5jcmVhdGUoeyBzZXJ2aWNlOiBcIm9wZW5jb2RlLWNsaWVudFwiIH0pO1xuXG4vKipcbiAqIFJlc3BvbnNlIGludGVyZmFjZSBmb3IgbWVzc2FnZXNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNZXNzYWdlUmVzcG9uc2Uge1xuICAgIGNvbnRlbnQ6IHN0cmluZztcbn1cblxuLyoqXG4gKiBTdHJlYW1pbmcgcmVzcG9uc2UgaW50ZXJmYWNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3RyZWFtaW5nUmVzcG9uc2Uge1xuICAgIC8qKiBSZWFkYWJsZSBzdHJlYW0gb2YgcmVzcG9uc2UgY2h1bmtzICovXG4gICAgc3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PjtcbiAgICAvKiogUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGNvbXBsZXRlIHJlc3BvbnNlIHdoZW4gc3RyZWFtIGVuZHMgKi9cbiAgICBjb21wbGV0ZTogUHJvbWlzZTxNZXNzYWdlUmVzcG9uc2U+O1xufVxuXG4vKipcbiAqIFNlc3Npb24gaW50ZXJmYWNlIGZvciBhaS1lbmcgcnVubmVyXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2Vzc2lvbiB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBzZW5kTWVzc2FnZTogKG1lc3NhZ2U6IHN0cmluZykgPT4gUHJvbWlzZTxNZXNzYWdlUmVzcG9uc2U+O1xuICAgIHNlbmRNZXNzYWdlU3RyZWFtOiAobWVzc2FnZTogc3RyaW5nKSA9PiBQcm9taXNlPFN0cmVhbWluZ1Jlc3BvbnNlPjtcbiAgICBjbG9zZTogKCkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgICAvKiogVG9vbCBpbnZvY2F0aW9ucyBjYXB0dXJlZCBkdXJpbmcgdGhpcyBzZXNzaW9uICovXG4gICAgX3Rvb2xJbnZvY2F0aW9ucz86IEFycmF5PHtcbiAgICAgICAgaWQ6IHN0cmluZztcbiAgICAgICAgbmFtZTogc3RyaW5nO1xuICAgICAgICBpbnB1dD86IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICAgICAgICBvdXRwdXQ/OiBzdHJpbmc7XG4gICAgICAgIHN0YXR1czogXCJva1wiIHwgXCJlcnJvclwiO1xuICAgICAgICBlcnJvcj86IHN0cmluZztcbiAgICAgICAgc3RhcnRlZEF0Pzogc3RyaW5nO1xuICAgICAgICBjb21wbGV0ZWRBdD86IHN0cmluZztcbiAgICB9Pjtcbn1cblxuLyoqXG4gKiBDbGllbnQgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2xpZW50Q29uZmlnIHtcbiAgICAvKiogQ3VzdG9tIGNsaWVudCBpbnN0YW5jZSAoZm9yIHRlc3RpbmcpICovXG4gICAgY2xpZW50PzogT3BlbmNvZGVDbGllbnQ7XG4gICAgLyoqIENvbm5lY3Rpb24gdGltZW91dCBpbiBtaWxsaXNlY29uZHMgKGRlZmF1bHQ6IDEwMDAwKSAqL1xuICAgIHRpbWVvdXQ/OiBudW1iZXI7XG4gICAgLyoqIFJldHJ5IGF0dGVtcHRzIGZvciBmYWlsZWQgb3BlcmF0aW9ucyAqL1xuICAgIHJldHJ5QXR0ZW1wdHM/OiBudW1iZXI7XG4gICAgLyoqIFByb21wdCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyAodXNlZCBhcyBhbiBpZGxlIHRpbWVvdXQgZm9yIHN0cmVhbWluZykgKi9cbiAgICBwcm9tcHRUaW1lb3V0PzogbnVtYmVyO1xuICAgIC8qKiBEaXJlY3Rvcnkvd29ya3RyZWUgY29udGV4dCB0byBydW4gT3BlbkNvZGUgaW4gKGRlZmF1bHRzIHRvIHByb2Nlc3MuY3dkKCkpICovXG4gICAgZGlyZWN0b3J5Pzogc3RyaW5nO1xuICAgIC8qKiBVUkwgb2YgZXhpc3RpbmcgT3BlbkNvZGUgc2VydmVyIHRvIHJldXNlIChpZiBwcm92aWRlZCwgd29uJ3Qgc3Bhd24gbmV3IHNlcnZlcikgKi9cbiAgICBleGlzdGluZ1NlcnZlclVybD86IHN0cmluZztcbiAgICAvKiogU2VydmVyIHN0YXJ0dXAgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgKGRlZmF1bHQ6IDEwMDAwKSAqL1xuICAgIHNlcnZlclN0YXJ0dXBUaW1lb3V0PzogbnVtYmVyO1xuICAgIC8qKiBOT1RFOiB3b3JraW5nRGlyIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBTREtcbiAgICAgKiBTcGF3bmVkIE9wZW5Db2RlIHNlcnZlcnMgd2lsbCB1c2UgdGhlIGNhbGxpbmcgZGlyZWN0b3J5IGJ5IGRlZmF1bHQgKHByb2Nlc3MuY3dkKCkpXG4gICAgICogVXNlIE9QRU5DT0RFX1VSTCB0byBjb25uZWN0IHRvIGEgZGlmZmVyZW50IE9wZW5Db2RlIGluc3RhbmNlIGluc3RlYWRcbiAgICAgKi9cbn1cblxuLyoqXG4gKiBPcGVuQ29kZSBDbGllbnQgV3JhcHBlclxuICpcbiAqIFdyYXBzIE9wZW5Db2RlIFNESyB0byBwcm92aWRlIHNlc3Npb24gbWFuYWdlbWVudFxuICogYW5kIGVycm9yIGhhbmRsaW5nIGZvciByYWxwaCBydW5uZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBPcGVuQ29kZUNsaWVudCB7XG4gICAgcHJpdmF0ZSBjbGllbnQ6IE9wZW5jb2RlQ2xpZW50O1xuICAgIHByaXZhdGUgdGltZW91dDogbnVtYmVyO1xuICAgIHByaXZhdGUgcmV0cnlBdHRlbXB0czogbnVtYmVyO1xuICAgIHByaXZhdGUgYWN0aXZlU2Vzc2lvbnM6IE1hcDxzdHJpbmcsIFNlc3Npb24+O1xuICAgIHByaXZhdGUgcHJvbXB0VGltZW91dDogbnVtYmVyO1xuICAgIHByaXZhdGUgZGlyZWN0b3J5OiBzdHJpbmcgPSBwcm9jZXNzLmN3ZCgpO1xuICAgIHByaXZhdGUgc2VydmVyOiB7IHVybDogc3RyaW5nOyBjbG9zZTogKCkgPT4gdm9pZCB9IHwgbnVsbCA9IG51bGw7XG4gICAgcHJpdmF0ZSBzZXJ2ZXJTdGFydHVwVGltZW91dDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBjb25zdHJ1Y3RvciAtIHVzZSBzdGF0aWMgY3JlYXRlKCkgZmFjdG9yeSBtZXRob2QgaW5zdGVhZFxuICAgICAqL1xuICAgIHByaXZhdGUgY29uc3RydWN0b3IoXG4gICAgICAgIGNsaWVudDogT3BlbmNvZGVDbGllbnQsXG4gICAgICAgIHNlcnZlcjogeyB1cmw6IHN0cmluZzsgY2xvc2U6ICgpID0+IHZvaWQgfSB8IG51bGwsXG4gICAgICAgIGNvbmZpZzogQ2xpZW50Q29uZmlnID0ge30sXG4gICAgKSB7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgICAgICB0aGlzLnNlcnZlciA9IHNlcnZlcjtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gY29uZmlnLnRpbWVvdXQgfHwgMzAwMDA7XG4gICAgICAgIHRoaXMucmV0cnlBdHRlbXB0cyA9IGNvbmZpZy5yZXRyeUF0dGVtcHRzIHx8IDM7XG5cbiAgICAgICAgY29uc3QgZW52UHJvbXB0VGltZW91dCA9IE51bWJlci5wYXJzZUludChcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk9QRU5DT0RFX1BST01QVF9USU1FT1VUX01TID8/IFwiXCIsXG4gICAgICAgICAgICAxMCxcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRQcm9tcHRUaW1lb3V0ID0gTnVtYmVyLmlzRmluaXRlKGVudlByb21wdFRpbWVvdXQpXG4gICAgICAgICAgICA/IGVudlByb21wdFRpbWVvdXRcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIC8vIEZvciBzdHJlYW1pbmcsIHRoaXMgYWN0cyBhcyBhbiBpZGxlIHRpbWVvdXQgKHJlc2V0IG9uIHN0cmVhbWVkIGV2ZW50cylcbiAgICAgICAgdGhpcy5wcm9tcHRUaW1lb3V0ID1cbiAgICAgICAgICAgIGNvbmZpZy5wcm9tcHRUaW1lb3V0ID8/IHJlc29sdmVkUHJvbXB0VGltZW91dCA/PyAxMjAwMDA7IC8vIDEyMCBzZWNvbmRzIGRlZmF1bHRcblxuICAgICAgICB0aGlzLmRpcmVjdG9yeSA9XG4gICAgICAgICAgICBjb25maWcuZGlyZWN0b3J5IHx8IHByb2Nlc3MuZW52Lk9QRU5DT0RFX0RJUkVDVE9SWSB8fCBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgICAgIHRoaXMuc2VydmVyU3RhcnR1cFRpbWVvdXQgPSBjb25maWcuc2VydmVyU3RhcnR1cFRpbWVvdXQgfHwgMTAwMDA7IC8vIDEwIHNlY29uZHMgZGVmYXVsdFxuICAgICAgICB0aGlzLmFjdGl2ZVNlc3Npb25zID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIGxvZy5kZWJ1ZyhcIk9wZW5Db2RlQ2xpZW50IGluaXRpYWxpemVkXCIsIHtcbiAgICAgICAgICAgIGhhc093blNlcnZlcjogISF0aGlzLnNlcnZlcixcbiAgICAgICAgICAgIHRpbWVvdXQ6IHRoaXMudGltZW91dCxcbiAgICAgICAgICAgIHNlcnZlclN0YXJ0dXBUaW1lb3V0OiB0aGlzLnNlcnZlclN0YXJ0dXBUaW1lb3V0LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYW4gYXZhaWxhYmxlIHBvcnQgZm9yIE9wZW5Db2RlIHNlcnZlclxuICAgICAqXG4gICAgICogSU1QT1JUQU5UOiBBbHdheXMgYXZvaWQgcG9ydCA0MDk2IHRvIHByZXZlbnQgY29uZmxpY3RzIHdpdGggdXNlcidzIGV4aXN0aW5nIHNlcnZlclxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIGFzeW5jIGdldEF2YWlsYWJsZVBvcnQoKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGRlZmF1bHQgcG9ydCBpcyBpbiB1c2UgYW5kIGxvZyBhY2NvcmRpbmdseVxuICAgICAgICAgICAgY29uc3QgZGVmYXVsdFBvcnQgPSA0MDk2O1xuICAgICAgICAgICAgY29uc3QgaXNEZWZhdWx0QXZhaWxhYmxlID1cbiAgICAgICAgICAgICAgICBhd2FpdCBPcGVuQ29kZUNsaWVudC5pc1BvcnRBdmFpbGFibGUoZGVmYXVsdFBvcnQpO1xuXG4gICAgICAgICAgICBpZiAoIWlzRGVmYXVsdEF2YWlsYWJsZSkge1xuICAgICAgICAgICAgICAgIGxvZy5pbmZvKFxuICAgICAgICAgICAgICAgICAgICBcIkV4aXN0aW5nIHNlcnZlciBkZXRlY3RlZCBvbiBwb3J0IDQwOTY7IHNwYXduaW5nIGlzb2xhdGVkIHNlcnZlciBvbiBkeW5hbWljIHBvcnRcIixcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2cuZGVidWcoXG4gICAgICAgICAgICAgICAgICAgIFwiRGVmYXVsdCBwb3J0IDQwOTYgaXMgYXZhaWxhYmxlIGJ1dCBhdm9pZGluZyBpdCBmb3IgaXNvbGF0aW9uXCIsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWx3YXlzIHVzZSBkeW5hbWljIHBvcnQgdG8gYXZvaWQgY29uZmxpY3RzIHdpdGggdXNlcidzIGV4aXN0aW5nIHNlcnZlclxuICAgICAgICAgICAgY29uc3QgZHluYW1pY1BvcnQgPSBhd2FpdCBPcGVuQ29kZUNsaWVudC5maW5kQXZhaWxhYmxlUG9ydCgpO1xuICAgICAgICAgICAgbG9nLmluZm8oXG4gICAgICAgICAgICAgICAgYFNwYXduaW5nIGlzb2xhdGVkIHNlcnZlciBvbiBkeW5hbWljIHBvcnQ6ICR7ZHluYW1pY1BvcnR9YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gZHluYW1pY1BvcnQ7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvck1zZyA9XG4gICAgICAgICAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgICAgICAgbG9nLmVycm9yKFwiRmFpbGVkIHRvIHNlbGVjdCBPcGVuQ29kZSBzZXJ2ZXIgcG9ydFwiLCB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yTXNnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYEZhaWxlZCB0byBzZWxlY3QgT3BlbkNvZGUgc2VydmVyIHBvcnQ6ICR7ZXJyb3JNc2d9YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHNwZWNpZmljIHBvcnQgaXMgYXZhaWxhYmxlXG4gICAgICovXG4gICAgcHJpdmF0ZSBzdGF0aWMgYXN5bmMgaXNQb3J0QXZhaWxhYmxlKHBvcnQ6IG51bWJlcik6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZlciA9IGNyZWF0ZVNlcnZlcigpO1xuXG4gICAgICAgICAgICBzZXJ2ZXIubGlzdGVuKHBvcnQsICgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXJ2ZXIub25jZShcImNsb3NlXCIsICgpID0+IHJlc29sdmUodHJ1ZSkpO1xuICAgICAgICAgICAgICAgIHNlcnZlci5jbG9zZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHNlcnZlci5vbihcImVycm9yXCIsICgpID0+IHJlc29sdmUoZmFsc2UpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZCBhbiBhdmFpbGFibGUgcG9ydCBkeW5hbWljYWxseVxuICAgICAqL1xuICAgIHByaXZhdGUgc3RhdGljIGFzeW5jIGZpbmRBdmFpbGFibGVQb3J0KCk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXIgPSBjcmVhdGVTZXJ2ZXIoKTtcblxuICAgICAgICAgICAgc2VydmVyLmxpc3RlbigwLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHNlcnZlci5hZGRyZXNzKCk7XG4gICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MgJiYgdHlwZW9mIGFkZHJlc3MgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyLm9uY2UoXCJjbG9zZVwiLCAoKSA9PiByZXNvbHZlKGFkZHJlc3MucG9ydCkpO1xuICAgICAgICAgICAgICAgICAgICBzZXJ2ZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiRmFpbGVkIHRvIGdldCBzZXJ2ZXIgYWRkcmVzc1wiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHNlcnZlci5vbihcImVycm9yXCIsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0YXRpYyBmYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYW4gT3BlbkNvZGVDbGllbnRcbiAgICAgKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY2xpZW50IHdpdGggZWl0aGVyOlxuICAgICAqIDEuIEEgZnJlc2ggT3BlbkNvZGUgc2VydmVyIChkZWZhdWx0IGJlaGF2aW9yKVxuICAgICAqIDIuIEFuIGV4aXN0aW5nIHNlcnZlciBVUkwgKGlmIGV4aXN0aW5nU2VydmVyVXJsIGlzIHByb3ZpZGVkKVxuICAgICAqIDMuIEEgY3VzdG9tIGNsaWVudCBpbnN0YW5jZSAoZm9yIHRlc3RpbmcpXG4gICAgICpcbiAgICAgKiBOb3RlOiBTcGF3bmVkIE9wZW5Db2RlIHNlcnZlcnMgd2lsbCB1c2UgdG8gY2FsbGluZyBkaXJlY3RvcnkgYnkgZGVmYXVsdCAocHJvY2Vzcy5jd2QoKSlcbiAgICAgKiBVc2UgT1BFTkNPREVfVVJMIHRvIGNvbm5lY3QgdG8gYSBkaWZmZXJlbnQgT3BlbkNvZGUgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlKGNvbmZpZzogQ2xpZW50Q29uZmlnID0ge30pOiBQcm9taXNlPE9wZW5Db2RlQ2xpZW50PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBJZiBjdXN0b20gY2xpZW50IHByb3ZpZGVkIChmb3IgdGVzdGluZyksIHVzZSBpdCBkaXJlY3RseVxuICAgICAgICAgICAgaWYgKGNvbmZpZy5jbGllbnQpIHtcbiAgICAgICAgICAgICAgICBsb2cuaW5mbyhcIkNyZWF0aW5nIE9wZW5Db2RlQ2xpZW50IHdpdGggY3VzdG9tIGNsaWVudCBpbnN0YW5jZVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE9wZW5Db2RlQ2xpZW50KGNvbmZpZy5jbGllbnQsIG51bGwsIGNvbmZpZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGV4aXN0aW5nIHNlcnZlciBVUkwgcHJvdmlkZWQsIGNvbm5lY3QgdG8gaXRcbiAgICAgICAgICAgIGlmIChjb25maWcuZXhpc3RpbmdTZXJ2ZXJVcmwpIHtcbiAgICAgICAgICAgICAgICBsb2cuaW5mbyhcIkNvbm5lY3RpbmcgdG8gZXhpc3RpbmcgT3BlbkNvZGUgc2VydmVyXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBjb25maWcuZXhpc3RpbmdTZXJ2ZXJVcmwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gY3JlYXRlT3BlbmNvZGVDbGllbnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZVVybDogY29uZmlnLmV4aXN0aW5nU2VydmVyVXJsLFxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBWZXJpZnkgY29ubmVjdGlvbiBieSBtYWtpbmcgYSB0ZXN0IHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgbG9nLmRlYnVnKFwiVmVyaWZ5aW5nIGNvbm5lY3Rpb24gdG8gZXhpc3Rpbmcgc2VydmVyLi4uXCIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBXZSdsbCBza2lwIHZlcmlmaWNhdGlvbiBmb3Igbm93IHRvIGF2b2lkIHVubmVjZXNzYXJ5IEFQSSBjYWxsc1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY29ubmVjdGlvbiB3aWxsIGJlIHZlcmlmaWVkIHdoZW4gZmlyc3Qgc2Vzc2lvbiBpcyBjcmVhdGVkXG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBPcGVuQ29kZUNsaWVudChjbGllbnQsIG51bGwsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNc2cgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBsb2cuZXJyb3IoXCJGYWlsZWQgdG8gY29ubmVjdCB0byBleGlzdGluZyBzZXJ2ZXJcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBjb25maWcuZXhpc3RpbmdTZXJ2ZXJVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JNc2csXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIERlZmF1bHQ6IHNwYXduIGEgbmV3IE9wZW5Db2RlIHNlcnZlclxuICAgICAgICAgICAgLy8gTm90ZTogU3Bhd25lZCBzZXJ2ZXJzIHdpbGwgdXNlIHRvIGNhbGxpbmcgZGlyZWN0b3J5IGJ5IGRlZmF1bHRcbiAgICAgICAgICAgIC8vIFVzZSBPUEVOQ09ERV9VUkwgdG8gY29ubmVjdCB0byBhIGRpZmZlcmVudCBPcGVuQ29kZSBpbnN0YW5jZVxuICAgICAgICAgICAgbG9nLmluZm8oXCJTcGF3bmluZyBuZXcgT3BlbkNvZGUgc2VydmVyLi4uXCIsIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0OiBjb25maWcuc2VydmVyU3RhcnR1cFRpbWVvdXQgfHwgMTAwMDAsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgYXZhaWxhYmxlUG9ydCA9IGF3YWl0IE9wZW5Db2RlQ2xpZW50LmdldEF2YWlsYWJsZVBvcnQoKTtcblxuICAgICAgICAgICAgY29uc3QgeyBjbGllbnQsIHNlcnZlciB9ID0gYXdhaXQgY3JlYXRlT3BlbmNvZGUoe1xuICAgICAgICAgICAgICAgIHRpbWVvdXQ6IGNvbmZpZy5zZXJ2ZXJTdGFydHVwVGltZW91dCB8fCAxMDAwMCxcbiAgICAgICAgICAgICAgICBwb3J0OiBhdmFpbGFibGVQb3J0LFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGxvZy5pbmZvKFwiT3BlbkNvZGUgc2VydmVyIHN0YXJ0ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBPcGVuQ29kZUNsaWVudChjbGllbnQsIHNlcnZlciwgY29uZmlnKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTXNnID1cbiAgICAgICAgICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICAgICAgICBsb2cuZXJyb3IoXCJGYWlsZWQgdG8gY3JlYXRlIE9wZW5Db2RlQ2xpZW50XCIsIHsgZXJyb3I6IGVycm9yTXNnIH0pO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIE9wZW5Db2RlQ2xpZW50OiAke2Vycm9yTXNnfWApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IE9wZW5Db2RlIHNlc3Npb24gd2l0aCBhIGdpdmVuIHByb21wdFxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZVNlc3Npb24ocHJvbXB0OiBzdHJpbmcpOiBQcm9taXNlPFNlc3Npb24+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBzZXNzaW9uIHVzaW5nIFNES1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jbGllbnQuc2Vzc2lvbi5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiYWktZW5nIHJhbHBoIHNlc3Npb25cIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghcmVzdWx0LmRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIGBGYWlsZWQgdG8gY3JlYXRlIE9wZW5Db2RlIHNlc3Npb246ICR7SlNPTi5zdHJpbmdpZnkocmVzdWx0LmVycm9yKX1gLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHNka1Nlc3Npb24gPSByZXN1bHQuZGF0YTtcblxuICAgICAgICAgICAgLy8gRGVmZXIgdGhlIGluaXRpYWwgcHJvbXB0IHVudGlsIHRoZSBmaXJzdCBtZXNzYWdlIGlzIHNlbnQuXG4gICAgICAgICAgICAvLyBUaGlzIGF2b2lkcyBibG9ja2luZyBzZXNzaW9uIGNyZWF0aW9uIGFuZCBlbmFibGVzIHN0cmVhbWluZyBvdXRwdXRcbiAgICAgICAgICAgIC8vIGV2ZW4gd2hlbiB0aGUgaW5pdGlhbCBwcm9tcHQgaXMgbGFyZ2Ugb3Igc2xvdyB0byBwcm9jZXNzLlxuICAgICAgICAgICAgbGV0IHBlbmRpbmdJbml0aWFsUHJvbXB0ID0gcHJvbXB0LnRyaW0oKTtcbiAgICAgICAgICAgIGNvbnN0IGJ1aWxkRmlyc3RNZXNzYWdlID0gKG1lc3NhZ2U6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcGVuZGluZ0luaXRpYWxQcm9tcHQpIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbWJpbmVkID0gYCR7cGVuZGluZ0luaXRpYWxQcm9tcHR9XFxuXFxuLS0tXFxuXFxuJHttZXNzYWdlfWA7XG4gICAgICAgICAgICAgICAgcGVuZGluZ0luaXRpYWxQcm9tcHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21iaW5lZDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdG9vbCBpbnZvY2F0aW9ucyB0cmFja2VyXG4gICAgICAgICAgICBjb25zdCB0b29sSW52b2NhdGlvbnM6IFNlc3Npb25bXCJfdG9vbEludm9jYXRpb25zXCJdID0gW107XG5cbiAgICAgICAgICAgIC8vIFdyYXAgd2l0aCBvdXIgc2Vzc2lvbiBpbnRlcmZhY2VcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb246IFNlc3Npb24gPSB7XG4gICAgICAgICAgICAgICAgaWQ6IHNka1Nlc3Npb24uaWQgfHwgdGhpcy5nZW5lcmF0ZVNlc3Npb25JZCgpLFxuICAgICAgICAgICAgICAgIF90b29sSW52b2NhdGlvbnM6IHRvb2xJbnZvY2F0aW9ucyxcbiAgICAgICAgICAgICAgICBzZW5kTWVzc2FnZTogYXN5bmMgKG1lc3NhZ2U6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVTZW5kTWVzc2FnZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHNka1Nlc3Npb24uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBidWlsZEZpcnN0TWVzc2FnZShtZXNzYWdlKSxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNlbmRNZXNzYWdlU3RyZWFtOiBhc3luYyAobWVzc2FnZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlbmRNZXNzYWdlU3RyZWFtKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2RrU2Vzc2lvbi5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1aWxkRmlyc3RNZXNzYWdlKG1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbEludm9jYXRpb25zLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2xvc2U6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2Vzc2lvbkNsb3NlKHNka1Nlc3Npb24uaWQpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBTdG9yZSBhY3RpdmUgc2Vzc2lvblxuICAgICAgICAgICAgdGhpcy5hY3RpdmVTZXNzaW9ucy5zZXQoc2Vzc2lvbi5pZCwgc2Vzc2lvbik7XG5cbiAgICAgICAgICAgIHJldHVybiBzZXNzaW9uO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID1cbiAgICAgICAgICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYEZhaWxlZCB0byBjcmVhdGUgT3BlbkNvZGUgc2Vzc2lvbjogJHtlcnJvck1lc3NhZ2V9YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgbWVzc2FnZSB0byBhbiBleGlzdGluZyBzZXNzaW9uXG4gICAgICovXG4gICAgYXN5bmMgc2VuZE1lc3NhZ2UoXG4gICAgICAgIHNlc3Npb25JZDogc3RyaW5nLFxuICAgICAgICBtZXNzYWdlOiBzdHJpbmcsXG4gICAgKTogUHJvbWlzZTxNZXNzYWdlUmVzcG9uc2U+IHtcbiAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IHRoaXMuYWN0aXZlU2Vzc2lvbnMuZ2V0KHNlc3Npb25JZCk7XG5cbiAgICAgICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlc3Npb24gbm90IGZvdW5kOiAke3Nlc3Npb25JZH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVNlbmRNZXNzYWdlKHNlc3Npb25JZCwgbWVzc2FnZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2UgYW4gYWN0aXZlIHNlc3Npb25cbiAgICAgKi9cbiAgICBhc3luYyBjbG9zZVNlc3Npb24oc2Vzc2lvbklkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IHRoaXMuYWN0aXZlU2Vzc2lvbnMuZ2V0KHNlc3Npb25JZCk7XG5cbiAgICAgICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNlc3Npb24gbm90IGZvdW5kOiAke3Nlc3Npb25JZH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IHRoaXMuaGFuZGxlU2Vzc2lvbkNsb3NlKHNlc3Npb25JZCk7XG4gICAgICAgIHRoaXMuYWN0aXZlU2Vzc2lvbnMuZGVsZXRlKHNlc3Npb25JZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBhY3RpdmUgc2Vzc2lvbiBJRHNcbiAgICAgKi9cbiAgICBnZXRBY3RpdmVTZXNzaW9ucygpOiBzdHJpbmdbXSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuYWN0aXZlU2Vzc2lvbnMua2V5cygpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHNlc3Npb24gaXMgYWN0aXZlXG4gICAgICovXG4gICAgaXNTZXNzaW9uQWN0aXZlKHNlc3Npb25JZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVNlc3Npb25zLmhhcyhzZXNzaW9uSWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb3NlIGFsbCBhY3RpdmUgc2Vzc2lvbnNcbiAgICAgKi9cbiAgICBhc3luYyBjbG9zZUFsbFNlc3Npb25zKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBjbG9zZVByb21pc2VzID0gQXJyYXkuZnJvbSh0aGlzLmFjdGl2ZVNlc3Npb25zLmtleXMoKSkubWFwKFxuICAgICAgICAgICAgKHNlc3Npb25JZCkgPT5cbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNlc3Npb25DbG9zZShzZXNzaW9uSWQpLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1zZyA9XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGxvZy53YXJuKFwiRXJyb3IgY2xvc2luZyBzZXNzaW9uXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvck1zZyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICk7XG5cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoY2xvc2VQcm9taXNlcyk7XG4gICAgICAgIHRoaXMuYWN0aXZlU2Vzc2lvbnMuY2xlYXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgc2VuZGluZyBhIG1lc3NhZ2Ugd2l0aCBzdHJlYW1pbmcgc3VwcG9ydFxuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgaGFuZGxlU2VuZE1lc3NhZ2VTdHJlYW0oXG4gICAgICAgIHNlc3Npb25JZDogc3RyaW5nLFxuICAgICAgICBtZXNzYWdlOiBzdHJpbmcsXG4gICAgICAgIHRvb2xJbnZvY2F0aW9ucz86IFNlc3Npb25bXCJfdG9vbEludm9jYXRpb25zXCJdLFxuICAgICk6IFByb21pc2U8U3RyZWFtaW5nUmVzcG9uc2U+IHtcbiAgICAgICAgbGV0IGxhc3RFcnJvcjogRXJyb3IgfCBudWxsID0gbnVsbDtcblxuICAgICAgICBjb25zdCBzdXBwb3J0c0V2ZW50U3RyZWFtaW5nID1cbiAgICAgICAgICAgIHR5cGVvZiAodGhpcy5jbGllbnQgYXMgYW55KT8uc2Vzc2lvbj8ucHJvbXB0QXN5bmMgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgdHlwZW9mICh0aGlzLmNsaWVudCBhcyBhbnkpPy5ldmVudD8uc3Vic2NyaWJlID09PSBcImZ1bmN0aW9uXCI7XG5cbiAgICAgICAgZm9yIChsZXQgYXR0ZW1wdCA9IDE7IGF0dGVtcHQgPD0gdGhpcy5yZXRyeUF0dGVtcHRzOyBhdHRlbXB0KyspIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgVHJhbnNmb3JtU3RyZWFtIHRvIGhhbmRsZSB0aGUgc3RyZWFtaW5nIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IFRyYW5zZm9ybVN0cmVhbTxVaW50OEFycmF5LCBVaW50OEFycmF5PigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHdyaXRlciA9IHN0cmVhbS53cml0YWJsZS5nZXRXcml0ZXIoKTtcblxuICAgICAgICAgICAgICAgIC8vIFRyYWNrIGZpbmFsaXphdGlvbiB0byBwcmV2ZW50IGRvdWJsZS1jbG9zZS9hYm9ydFxuICAgICAgICAgICAgICAgIGxldCBmaW5hbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zdCBjbG9zZU9uY2UgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaW5hbGl6ZWQpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgZmluYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHdyaXRlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBlcnJvcnMgZHVyaW5nIGNsb3NlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGFib3J0T25jZSA9IGFzeW5jIChlcnI6IHVua25vd24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmFsaXplZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBmaW5hbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgd3JpdGVyLmFib3J0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGVycm9ycyBkdXJpbmcgYWJvcnRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBGYWxsYmFjazogaWYgdGhlIGNsaWVudCBkb2Vzbid0IHN1cHBvcnQgcHJvbXB0X2FzeW5jICsgU1NFLCBrZWVwIHRoZVxuICAgICAgICAgICAgICAgIC8vIGxlZ2FjeSBiZWhhdmlvciAoYnVmZmVyIHRoZW4gc2ltdWxhdGUgc3RyZWFtaW5nKS5cbiAgICAgICAgICAgICAgICBpZiAoIXN1cHBvcnRzRXZlbnRTdHJlYW1pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvbXB0UHJvbWlzZSA9IHRoaXMuY2xpZW50LnNlc3Npb24ucHJvbXB0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlSUQ6IHRoaXMuZ2VuZXJhdGVNZXNzYWdlSWQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdG9yeTogdGhpcy5kaXJlY3RvcnksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9IGFzIGFueSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyZWFtaW5nVGFzayA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb21wdFByb21pc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBJbnZhbGlkIHJlc3BvbnNlIGZyb20gT3BlbkNvZGU6ICR7SlNPTi5zdHJpbmdpZnkocmVzdWx0LmVycm9yKX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gcmVzdWx0LmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dFBhcnQgPSByZXNwb25zZS5wYXJ0cz8uZmluZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHBhcnQ6IGFueSkgPT4gcGFydC50eXBlID09PSBcInRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmluYWxDb250ZW50ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRleHRQYXJ0IGFzIGFueSk/LnRleHQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJObyBjb250ZW50IHJlY2VpdmVkXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaW11bGF0ZSBzdHJlYW1pbmcgYnkgd3JpdGluZyBjaHVua3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVua3MgPSB0aGlzLnNwbGl0SW50b0NodW5rcyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxDb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB3cml0ZXIud3JpdGUoZW5jb2Rlci5lbmNvZGUoY2h1bmspKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIDUwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBjbG9zZU9uY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBjb250ZW50OiBmaW5hbENvbnRlbnQgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgYWJvcnRPbmNlKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkoKTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtOiBzdHJlYW0ucmVhZGFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogc3RyZWFtaW5nVGFzayxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSZWFsIHN0cmVhbWluZzogdXNlIHByb21wdF9hc3luYyBhbmQgY29uc3VtZSB0aGUgZXZlbnQgU1NFIHN0cmVhbS5cbiAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaWRsZVRpbWVvdXRFcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgYFByb21wdCBpZGxlIHRpbWVvdXQgYWZ0ZXIgJHt0aGlzLnByb21wdFRpbWVvdXR9bXNgLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFyZFRpbWVvdXRFcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgYFByb21wdCBoYXJkIHRpbWVvdXQgYWZ0ZXIgJHt0aGlzLnByb21wdFRpbWVvdXQgKiA1fW1zYCxcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgICAgICAgICBsZXQgaWRsZVRpbWVyOiBSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0PiB8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBsZXQgaGFyZFRpbWVyOiBSZXR1cm5UeXBlPHR5cGVvZiBzZXRUaW1lb3V0PiB8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBsZXQgYnl0ZXNXcml0dGVuID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgbGFzdFByb2dyZXNzVGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgbGV0IGlkbGVUaW1lZE91dCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLy8gSGFyZCB0aW1lb3V0IC0gbmV2ZXIgcmVzZXRzXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRIYXJkVGltZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXJkVGltZXIpIGNsZWFyVGltZW91dChoYXJkVGltZXIpO1xuICAgICAgICAgICAgICAgICAgICBoYXJkVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy53YXJuKFwiSGFyZCB0aW1lb3V0IHJlYWNoZWQsIGFib3J0aW5nXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dE1zOiB0aGlzLnByb21wdFRpbWVvdXQgKiA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoaGFyZFRpbWVvdXRFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5wcm9tcHRUaW1lb3V0ICogNSk7IC8vIDV4IGlkbGUgdGltZW91dCBhcyBoYXJkIGNlaWxpbmdcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gSWRsZSB0aW1lciAtIHJlc2V0cyBvbmx5IG9uIHJlbGV2YW50IHByb2dyZXNzXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzZXRJZGxlVGltZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZGxlVGltZXIpIGNsZWFyVGltZW91dChpZGxlVGltZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZGxlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkbGVUaW1lZE91dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cud2FybihcIklkbGUgdGltZW91dCByZWFjaGVkLCBhYm9ydGluZ1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXRNczogdGhpcy5wcm9tcHRUaW1lb3V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzV3JpdHRlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0UHJvZ3Jlc3NNc0FnbzogRGF0ZS5ub3coKSAtIGxhc3RQcm9ncmVzc1RpbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5hYm9ydChpZGxlVGltZW91dEVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLnByb21wdFRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBjb25zdCBzdHJlYW1pbmdUYXNrID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0SGFyZFRpbWVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNldElkbGVUaW1lcigpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1c2VyTWVzc2FnZUlkID0gdGhpcy5nZW5lcmF0ZU1lc3NhZ2VJZCgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoXCJTZW5kaW5nIHByb21wdCB0byBPcGVuQ29kZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VMZW5ndGg6IG1lc3NhZ2UubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJNZXNzYWdlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgKHRoaXMuY2xpZW50IGFzIGFueSkuc2Vzc2lvbi5wcm9tcHRBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlSUQ6IHVzZXJNZXNzYWdlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBzZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rvcnk6IHRoaXMuZGlyZWN0b3J5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoXCJTdWJzY3JpYmluZyB0byBldmVudHNcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rvcnk6IHRoaXMuZGlyZWN0b3J5LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50c1Jlc3VsdCA9IGF3YWl0IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaWVudCBhcyBhbnlcbiAgICAgICAgICAgICAgICAgICAgICAgICkuZXZlbnQuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rvcnk6IHRoaXMuZGlyZWN0b3J5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYXNzaXN0YW50TWVzc2FnZUlkOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb250ZW50ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbWl0dGVkVGV4dCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXZlbnRDb3VudCA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZyhcIlN0YXJ0aW5nIGV2ZW50IHN0cmVhbSBwcm9jZXNzaW5nXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBldmVudCBvZiBldmVudHNSZXN1bHQuc3RyZWFtIGFzIEFzeW5jR2VuZXJhdG9yPGFueT4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudENvdW50Kys7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBWZXJib3NlIGRlYnVnIGxvZ2dpbmcgZm9yIGFsbCBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoXCJSZWNlaXZlZCBldmVudFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRUeXBlOiBldmVudD8udHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzUHJvcGVydGllczogISFldmVudD8ucHJvcGVydGllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlckFib3J0ZWQ6IGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkNvbnRyb2xsZXIgYWJvcnRlZCwgYnJlYWtpbmcgZXZlbnQgbG9vcFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudENvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVudCB8fCB0eXBlb2YgZXZlbnQgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nLmRlYnVnKFwiU2tpcHBpbmcgbm9uLW9iamVjdCBldmVudFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudENvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IFwibWVzc2FnZS51cGRhdGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5mbyA9IChldmVudCBhcyBhbnkpLnByb3BlcnRpZXM/LmluZm87XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nLmRlYnVnKFwiTWVzc2FnZSB1cGRhdGVkIGV2ZW50XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Q291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvUm9sZTogaW5mbz8ucm9sZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm9TZXNzaW9uSWQ6IGluZm8/LnNlc3Npb25JRCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm9QYXJlbnRJZDogaW5mbz8ucGFyZW50SUQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvSWQ6IGluZm8/LmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNSZWxldmFudFNlc3Npb246XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mbz8uc2Vzc2lvbklEID09PSBzZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0Fzc2lzdGFudDogaW5mbz8ucm9sZSA9PT0gXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUmVwbHlUb1VzZXI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mbz8ucGFyZW50SUQgPT09IHVzZXJNZXNzYWdlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByaW1hcnkgaWRlbnRpZmljYXRpb246IGV4YWN0IG1hdGNoIG9uIHBhcmVudElEXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm8/LnJvbGUgPT09IFwiYXNzaXN0YW50XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm8/LnNlc3Npb25JRCA9PT0gc2Vzc2lvbklkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvPy5wYXJlbnRJRCA9PT0gdXNlck1lc3NhZ2VJZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2lzdGFudE1lc3NhZ2VJZCA9IGluZm8uaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJJZGVudGlmaWVkIGFzc2lzdGFudCBtZXNzYWdlIChleGFjdCBwYXJlbnRJRCBtYXRjaClcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzaXN0YW50TWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrOiBpZiB3ZSBoYXZlbid0IGlkZW50aWZpZWQgYW4gYXNzaXN0YW50IG1lc3NhZ2UgeWV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhY2NlcHQgYXNzaXN0YW50IG1lc3NhZ2VzIGluIHRoZSBzYW1lIHNlc3Npb24gZXZlbiBpZiBwYXJlbnRJRCBkb2Vzbid0IG1hdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaGFuZGxlcyBjYXNlcyB3aGVyZSBwYXJlbnRJRCBpcyB1bmRlZmluZWQgb3IgaGFzIGEgZGlmZmVyZW50IGZvcm1hdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFhc3Npc3RhbnRNZXNzYWdlSWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm8/LnJvbGUgPT09IFwiYXNzaXN0YW50XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm8/LnNlc3Npb25JRCA9PT0gc2Vzc2lvbklkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nLmRlYnVnKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiSWRlbnRpZmllZCBhc3Npc3RhbnQgbWVzc2FnZSAoZmFsbGJhY2sgLSBubyBleGFjdCBwYXJlbnRJRCBtYXRjaClcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzaXN0YW50TWVzc2FnZUlkOiBpbmZvLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvUGFyZW50SWQ6IGluZm8/LnBhcmVudElELFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyTWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzaXN0YW50TWVzc2FnZUlkID0gaW5mby5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IGlkbGUgdGltZXIgb24gQU5ZIGFzc2lzdGFudCBtZXNzYWdlIGFjdGl2aXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgcHJldmVudHMgdGltZW91dHMgd2hlbiBjb3JyZWxhdGlvbiBpcyBhbWJpZ3VvdXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mbz8ucm9sZSA9PT0gXCJhc3Npc3RhbnRcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mbz8uc2Vzc2lvbklEID09PSBzZXNzaW9uSWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0UHJvZ3Jlc3NUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0SWRsZVRpbWVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3Npc3RhbnRNZXNzYWdlSWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm8/LmlkID09PSBhc3Npc3RhbnRNZXNzYWdlSWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5mbz8uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJOYW1lID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mby5lcnJvci5uYW1lIHx8IFwiT3BlbkNvZGVFcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm8uZXJyb3IuZGF0YT8ubWVzc2FnZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm8uZXJyb3IuZGF0YSB8fCB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQXNzaXN0YW50IGVycm9yIGluIG1lc3NhZ2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JOYW1lOiBlcnJOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlOiBlcnJNc2csXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAke2Vyck5hbWV9OiAke2Vyck1zZ31gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmZvPy50aW1lPy5jb21wbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQXNzaXN0YW50IG1lc3NhZ2UgY29tcGxldGVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2lzdGFudE1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZEF0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm8udGltZS5jb21wbGV0ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSBcIm1lc3NhZ2UucGFydC51cGRhdGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSByZXNldCB0aW1lciBhbmQgdHJhY2sgcHJvZ3Jlc3MgZm9yIHJlbGV2YW50IHVwZGF0ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFydCA9IChldmVudCBhcyBhbnkpLnByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8ucGFydCBhcyBhbnk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nLmRlYnVnKFwiTWVzc2FnZSBwYXJ0IHVwZGF0ZWRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc1BhcnQ6ICEhcGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRUeXBlOiBwYXJ0Py50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydFNlc3Npb25JZDogcGFydD8uc2Vzc2lvbklELFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydE1lc3NhZ2VJZDogcGFydD8ubWVzc2FnZUlELFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzaXN0YW50TWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNSZWxldmFudDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3Npc3RhbnRNZXNzYWdlSWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0Py5zZXNzaW9uSUQgPT09IHNlc3Npb25JZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnQ/Lm1lc3NhZ2VJRCA9PT0gYXNzaXN0YW50TWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFzc2lzdGFudE1lc3NhZ2VJZCkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIHRvb2wgcGFydHMgKGNhcHR1cmUgdG9vbCBpbnZvY2F0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnQ/LnR5cGUgPT09IFwidG9vbFwiICYmIHRvb2xJbnZvY2F0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9vbElkID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0LnRvb2xJZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnQuaWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgdG9vbC0ke2V2ZW50Q291bnR9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xOYW1lID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0LnRvb2xOYW1lIHx8IHBhcnQubmFtZSB8fCBcInVua25vd25cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xJbnB1dCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydC5pbnB1dCB8fCBwYXJ0LnBhcmFtZXRlcnMgfHwge307XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBuZXcgdG9vbCBjYWxsIG9yIGFuIHVwZGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdUb29sSW5kZXggPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xJbnZvY2F0aW9ucy5maW5kSW5kZXgoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0KSA9PiB0LmlkID09PSB0b29sSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nVG9vbEluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgZXhpc3RpbmcgdG9vbCBpbnZvY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sSW52b2NhdGlvbnNbZXhpc3RpbmdUb29sSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLm91dHB1dCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnQucmVzdWx0ID8/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnQub3V0cHV0ID8/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLm91dHB1dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5zdGF0dXMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0LnN0YXR1cyA9PT0gXCJlcnJvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFwiZXJyb3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIm9rXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcuZXJyb3IgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0LmVycm9yID8/IGV4aXN0aW5nLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmNvbXBsZXRlZEF0ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydC5jb21wbGV0ZWRBdCA/PyBub3c7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoXCJUb29sIGludm9jYXRpb24gdXBkYXRlZFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBleGlzdGluZy5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5ldyB0b29sIGludm9jYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b29sSW52b2NhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRvb2xJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiB0b29sSW5wdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogcGFydC5yZXN1bHQgPz8gcGFydC5vdXRwdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnQuc3RhdHVzID09PSBcImVycm9yXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChcImVycm9yXCIgYXMgY29uc3QpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoXCJva1wiIGFzIGNvbnN0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHBhcnQuZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ZWRBdDogcGFydC5zdGFydGVkQXQgPz8gbm93LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWRBdDogcGFydC5jb21wbGV0ZWRBdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xJbnZvY2F0aW9ucy5wdXNoKHRvb2xJbnZvY2F0aW9uKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZyhcIlRvb2wgaW52b2NhdGlvbiBzdGFydGVkXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sSW5wdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICkuc2xpY2UoMCwgMjAwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3Qgc2tpcCBub24tcmVsZXZhbnQgdG9vbCBwYXJ0cyAtIHdlIHdhbnQgdG8gY2FwdHVyZSBhbGwgdG9vbCBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciB0aGUgYXNzaXN0YW50IG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0LnNlc3Npb25JRCAhPT0gc2Vzc2lvbklkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydC5tZXNzYWdlSUQgIT09IGFzc2lzdGFudE1lc3NhZ2VJZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RpbGwgdHJhY2sgaXQgYnV0IGRvbid0IHByb2Nlc3MgZm9yIG91dHB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBpZGxlIHRpbWVyIG9uIHRvb2wgcHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0UHJvZ3Jlc3NUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNldElkbGVUaW1lcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFydCB8fCBwYXJ0LnR5cGUgIT09IFwidGV4dFwiKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnQuc2Vzc2lvbklEICE9PSBzZXNzaW9uSWQpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFydC5tZXNzYWdlSUQgIT09IGFzc2lzdGFudE1lc3NhZ2VJZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhd0RlbHRhID0gKGV2ZW50IGFzIGFueSkucHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPy5kZWx0YTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGVsdGFUZXh0OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJlZmVyIGRpZmZpbmcgYWdhaW5zdCB0aGUgZnVsbCBgcGFydC50ZXh0YCB3aGVuIHByZXNlbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvbWUgT3BlbkNvZGUgc2VydmVyIHZlcnNpb25zIGVtaXQgbXVsdGlwbGUgdGV4dCBwYXJ0cyBvciBzZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBkZWx0YWAgYXMgdGhlICpmdWxsKiB0ZXh0LCB3aGljaCB3b3VsZCBkdXBsaWNhdGUgb3V0cHV0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQudGV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IHBhcnQudGV4dDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQuc3RhcnRzV2l0aChlbWl0dGVkVGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YVRleHQgPSBuZXh0LnNsaWNlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbWl0dGVkVGV4dC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbWl0dGVkVGV4dCA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVtaXR0ZWRUZXh0LnN0YXJ0c1dpdGgobmV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGFsZS9kdXBsaWNhdGUgdXBkYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFUZXh0ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFsbGJhY2s6IHRyZWF0IGFzIGFkZGl0aXZlIGNodW5rXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFUZXh0ID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbWl0dGVkVGV4dCArPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiByYXdEZWx0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFUZXh0ID0gcmF3RGVsdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbWl0dGVkVGV4dCArPSByYXdEZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGVsdGFUZXh0KSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgcHJvZ3Jlc3MgdHJhY2tpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFByb2dyZXNzVGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzV3JpdHRlbiArPSBkZWx0YVRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNldElkbGVUaW1lcigpOyAvLyBPbmx5IHJlc2V0IG9uIGFjdHVhbCBjb250ZW50IHByb2dyZXNzXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nLmRlYnVnKFwiV3JpdGluZyBkZWx0YSB0byBzdHJlYW1cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFMZW5ndGg6IGRlbHRhVGV4dC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3RhbEJ5dGVzV3JpdHRlbjogYnl0ZXNXcml0dGVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudExlbmd0aDogY29udGVudC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gZGVsdGFUZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB3cml0ZXIud3JpdGUoZW5jb2Rlci5lbmNvZGUoZGVsdGFUZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2cuZGVidWcoXCJFdmVudCBzdHJlYW0gZW5kZWRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudENvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsQnl0ZXNXcml0dGVuOiBieXRlc1dyaXR0ZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudExlbmd0aDogY29udGVudC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlckFib3J0ZWQ6IGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWRsZVRpbWVkT3V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2lzdGFudE1lc3NhZ2VJZEZvdW5kOiAhIWFzc2lzdGFudE1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBjbG9zZU9uY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogY29udGVudCB8fCBcIk5vIGNvbnRlbnQgcmVjZWl2ZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWFnbm9zdGljczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlc1dyaXR0ZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRMZW5ndGg6IGNvbnRlbnQubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGxlVGltZWRPdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2lzdGFudE1lc3NhZ2VJZEZvdW5kOiAhIWFzc2lzdGFudE1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRDb3VudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5lcnJvcihcIlN0cmVhbWluZyB0YXNrIGVycm9yXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBTdHJpbmcoZXJyb3IpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXJBYm9ydGVkOiBjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzV3JpdHRlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZGxlVGltZWRPdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzaXN0YW50TWVzc2FnZUlkRm91bmQ6ICEhYXNzaXN0YW50TWVzc2FnZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhYm9ydGVkLCBub3JtYWxpemUgdG8gb3VyIHRpbWVvdXQgZXJyb3IgQU5EIGVuc3VyZSBzdHJlYW0gaXMgZmluYWxpemVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IGFib3J0T25jZShpZGxlVGltZW91dEVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBpZGxlVGltZW91dEVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgYWJvcnRPbmNlKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkbGVUaW1lcikgY2xlYXJUaW1lb3V0KGlkbGVUaW1lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFyZFRpbWVyKSBjbGVhclRpbWVvdXQoaGFyZFRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW06IHN0cmVhbS5yZWFkYWJsZSxcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGU6IHN0cmVhbWluZ1Rhc2ssXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbGFzdEVycm9yID1cbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKFN0cmluZyhlcnJvcikpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaXNSYXRlTGltaXQgPSB0aGlzLmlzUmF0ZUxpbWl0RXJyb3IobGFzdEVycm9yKTtcblxuICAgICAgICAgICAgICAgIGlmIChhdHRlbXB0ID09PSB0aGlzLnJldHJ5QXR0ZW1wdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgZGVsYXkgPSB0aGlzLmdldEJhY2tvZmZEZWxheShhdHRlbXB0LCBpc1JhdGVMaW1pdCk7XG5cbiAgICAgICAgICAgICAgICBsb2cud2FybihcIk9wZW5Db2RlIGF0dGVtcHQgZmFpbGVkOyByZXRyeWluZ1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHQsXG4gICAgICAgICAgICAgICAgICAgIHJldHJ5QXR0ZW1wdHM6IHRoaXMucmV0cnlBdHRlbXB0cyxcbiAgICAgICAgICAgICAgICAgICAgZGVsYXlNczogZGVsYXksXG4gICAgICAgICAgICAgICAgICAgIGlzUmF0ZUxpbWl0LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogbGFzdEVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEZhaWxlZCB0byBzdHJlYW0gbWVzc2FnZSBhZnRlciAke3RoaXMucmV0cnlBdHRlbXB0c30gYXR0ZW1wdHM6ICR7bGFzdEVycm9yPy5tZXNzYWdlIHx8IFwiVW5rbm93biBlcnJvclwifWAsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3BsaXQgdGV4dCBpbnRvIGNodW5rcyBmb3Igc3RyZWFtaW5nIHNpbXVsYXRpb25cbiAgICAgKi9cbiAgICBwcml2YXRlIHNwbGl0SW50b0NodW5rcyh0ZXh0OiBzdHJpbmcsIGNodW5rU2l6ZTogbnVtYmVyKTogc3RyaW5nW10ge1xuICAgICAgICBjb25zdCBjaHVua3M6IHN0cmluZ1tdID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkgKz0gY2h1bmtTaXplKSB7XG4gICAgICAgICAgICBjaHVua3MucHVzaCh0ZXh0LnNsaWNlKGksIGkgKyBjaHVua1NpemUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2h1bmtzLmxlbmd0aCA+IDAgPyBjaHVua3MgOiBbdGV4dF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIHNlbmRpbmcgYSBtZXNzYWdlIHdpdGggZXJyb3IgaGFuZGxpbmcgYW5kIHJldHJpZXNcbiAgICAgKi9cbiAgICBwcml2YXRlIGFzeW5jIGhhbmRsZVNlbmRNZXNzYWdlKFxuICAgICAgICBzZXNzaW9uSWQ6IHN0cmluZyxcbiAgICAgICAgbWVzc2FnZTogc3RyaW5nLFxuICAgICk6IFByb21pc2U8TWVzc2FnZVJlc3BvbnNlPiB7XG4gICAgICAgIGxldCBsYXN0RXJyb3I6IEVycm9yIHwgbnVsbCA9IG51bGw7XG5cbiAgICAgICAgZm9yIChsZXQgYXR0ZW1wdCA9IDE7IGF0dGVtcHQgPD0gdGhpcy5yZXRyeUF0dGVtcHRzOyBhdHRlbXB0KyspIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZW91dEVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBgUHJvbXB0IHRpbWVvdXQgYWZ0ZXIgJHt0aGlzLnByb21wdFRpbWVvdXR9bXNgLFxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmFib3J0KHRpbWVvdXRFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0aGlzLnByb21wdFRpbWVvdXQpO1xuXG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdDogYW55O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IHRoaXMuY2xpZW50LnNlc3Npb24ucHJvbXB0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlSUQ6IHRoaXMuZ2VuZXJhdGVNZXNzYWdlSWQoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0czogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHNlc3Npb25JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdG9yeTogdGhpcy5kaXJlY3RvcnksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgfSBhcyBhbnkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB0aW1lb3V0RXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGBJbnZhbGlkIHJlc3BvbnNlIGZyb20gT3BlbkNvZGU6ICR7SlNPTi5zdHJpbmdpZnkocmVzdWx0LmVycm9yKX1gLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgY29udGVudCBmcm9tIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSByZXN1bHQuZGF0YTtcblxuICAgICAgICAgICAgICAgIC8vIEZpbmQgdGV4dCBjb250ZW50IGZyb20gcmVzcG9uc2UgcGFydHNcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0UGFydCA9IHJlc3BvbnNlLnBhcnRzPy5maW5kKFxuICAgICAgICAgICAgICAgICAgICAocGFydDogYW55KSA9PiBwYXJ0LnR5cGUgPT09IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY29udGVudDogdGV4dFBhcnQ/LnRleHQgfHwgXCJObyBjb250ZW50IHJlY2VpdmVkXCIgfTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbGFzdEVycm9yID1cbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKFN0cmluZyhlcnJvcikpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIHJhdGUgbGltaXQgZXJyb3JcbiAgICAgICAgICAgICAgICBjb25zdCBpc1JhdGVMaW1pdCA9IHRoaXMuaXNSYXRlTGltaXRFcnJvcihsYXN0RXJyb3IpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGF0dGVtcHQgPT09IHRoaXMucmV0cnlBdHRlbXB0cykge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBXYWl0IGJlZm9yZSByZXRyeWluZyB3aXRoIGV4cG9uZW50aWFsIGJhY2tvZmZcbiAgICAgICAgICAgICAgICBjb25zdCBkZWxheSA9IHRoaXMuZ2V0QmFja29mZkRlbGF5KGF0dGVtcHQsIGlzUmF0ZUxpbWl0KTtcblxuICAgICAgICAgICAgICAgIGxvZy53YXJuKFwiT3BlbkNvZGUgYXR0ZW1wdCBmYWlsZWQ7IHJldHJ5aW5nXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdCxcbiAgICAgICAgICAgICAgICAgICAgcmV0cnlBdHRlbXB0czogdGhpcy5yZXRyeUF0dGVtcHRzLFxuICAgICAgICAgICAgICAgICAgICBkZWxheU1zOiBkZWxheSxcbiAgICAgICAgICAgICAgICAgICAgaXNSYXRlTGltaXQsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBsYXN0RXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgRmFpbGVkIHRvIHNlbmQgbWVzc2FnZSBhZnRlciAke3RoaXMucmV0cnlBdHRlbXB0c30gYXR0ZW1wdHM6ICR7bGFzdEVycm9yPy5tZXNzYWdlIHx8IFwiVW5rbm93biBlcnJvclwifWAsXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgZXJyb3IgaXMgYSByYXRlIGxpbWl0IGVycm9yXG4gICAgICovXG4gICAgcHJpdmF0ZSBpc1JhdGVMaW1pdEVycm9yKGVycm9yOiBFcnJvcik6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBlcnIgPSBlcnJvciBhcyBhbnk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBlcnIuc3RhdHVzID09PSA0MjkgfHxcbiAgICAgICAgICAgIC9yYXRlIGxpbWl0fHF1b3RhfG92ZXJsb2FkZWR8Y2FwYWNpdHkvaS50ZXN0KGVycm9yLm1lc3NhZ2UpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGJhY2tvZmYgZGVsYXkgd2l0aCBqaXR0ZXJcbiAgICAgKi9cbiAgICBwcml2YXRlIGdldEJhY2tvZmZEZWxheShhdHRlbXB0OiBudW1iZXIsIGlzUmF0ZUxpbWl0OiBib29sZWFuKTogbnVtYmVyIHtcbiAgICAgICAgY29uc3QgYmFzZSA9IGlzUmF0ZUxpbWl0ID8gNTAwMCA6IDEwMDA7IC8vIDVzIGZvciByYXRlIGxpbWl0LCAxcyBvdGhlcndpc2VcbiAgICAgICAgY29uc3QgZXhwb25lbnRpYWwgPSBiYXNlICogMiAqKiAoYXR0ZW1wdCAtIDEpO1xuICAgICAgICBjb25zdCBqaXR0ZXIgPSBNYXRoLnJhbmRvbSgpICogMTAwMDsgLy8gQWRkIHVwIHRvIDFzIGppdHRlclxuICAgICAgICByZXR1cm4gTWF0aC5taW4oZXhwb25lbnRpYWwgKyBqaXR0ZXIsIDYwMDAwKTsgLy8gbWF4IDYwc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBzZXNzaW9uIGNsb3N1cmUgd2l0aCBlcnJvciBoYW5kbGluZ1xuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgaGFuZGxlU2Vzc2lvbkNsb3NlKHNlc3Npb25JZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBOb3RlOiBPcGVuQ29kZSBTREsgbWlnaHQgbm90IGhhdmUgYW4gZXhwbGljaXQgY2xvc2UgbWV0aG9kXG4gICAgICAgICAgICAvLyBGb3Igbm93LCB3ZSdsbCBqdXN0IHJlbW92ZSBmcm9tIG91ciBhY3RpdmUgc2Vzc2lvbnNcbiAgICAgICAgICAgIC8vIEluIGEgcmVhbCBpbXBsZW1lbnRhdGlvbiwgd2UnZCBjYWxsIFNESydzIGRlbGV0ZSBtZXRob2QgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICBsb2cuZGVidWcoXCJTZXNzaW9uIGNsb3NlZFwiLCB7IHNlc3Npb25JZCB9KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9XG4gICAgICAgICAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgICAgICAgbG9nLndhcm4oXCJGYWlsZWQgdG8gY2xvc2Ugc2Vzc2lvblwiLCB7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvck1lc3NhZ2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGEgdW5pcXVlIHNlc3Npb24gSUQgaWYgU0RLIGRvZXNuJ3QgcHJvdmlkZSBvbmVcbiAgICAgKi9cbiAgICBwcml2YXRlIGdlbmVyYXRlU2Vzc2lvbklkKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBgc2Vzc2lvbi0ke0RhdGUubm93KCl9LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSBwcm9wZXJseSBmb3JtYXR0ZWQgbWVzc2FnZSBJRCB3aXRoIG1zZ18gcHJlZml4XG4gICAgICogRm9ybWF0OiBtc2dfPHRpbWVzdGFtcD5fPHJhbmRvbT5cbiAgICAgKi9cbiAgICBwcml2YXRlIGdlbmVyYXRlTWVzc2FnZUlkKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBgbXNnXyR7RGF0ZS5ub3coKX1fJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgOCl9YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhbnVwIG1ldGhvZCB0byBjbG9zZSBhbGwgc2Vzc2lvbnMgYW5kIHNlcnZlclxuICAgICAqL1xuICAgIGFzeW5jIGNsZWFudXAoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsb2cuZGVidWcoXCJTdGFydGluZyBjbGVhbnVwLi4uXCIsIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVTZXNzaW9uczogdGhpcy5hY3RpdmVTZXNzaW9ucy5zaXplLFxuICAgICAgICAgICAgICAgIGhhc1NlcnZlcjogISF0aGlzLnNlcnZlcixcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBDbG9zZSBhbGwgYWN0aXZlIHNlc3Npb25zXG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNsb3NlQWxsU2Vzc2lvbnMoKTtcblxuICAgICAgICAgICAgLy8gU3RvcCB0aGUgT3BlbkNvZGUgc2VydmVyIGlmIHdlIHN0YXJ0ZWQgb25lXG4gICAgICAgICAgICBpZiAodGhpcy5zZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICBsb2cuaW5mbyhcIkNsb3Npbmcgc3Bhd25lZCBPcGVuQ29kZSBzZXJ2ZXJcIik7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBsb2cuaW5mbyhcIk9wZW5Db2RlIHNlcnZlciBjbG9zZWQgc3VjY2Vzc2Z1bGx5XCIpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTXNnID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nLmVycm9yKFwiRXJyb3IgY2xvc2luZyBPcGVuQ29kZSBzZXJ2ZXJcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yTXNnLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZyhcbiAgICAgICAgICAgICAgICAgICAgXCJObyBzcGF3bmVkIHNlcnZlciB0byBjbG9zZSAoY29ubmVjdGVkIHRvIGV4aXN0aW5nIHNlcnZlcilcIixcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsb2cuaW5mbyhcIkNsZWFudXAgY29tcGxldGVcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvck1zZyA9XG4gICAgICAgICAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgICAgICAgbG9nLmVycm9yKFwiRXJyb3IgZHVyaW5nIE9wZW5Db2RlIGNsaWVudCBjbGVhbnVwXCIsIHtcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JNc2csXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsCiAgICAiLy8gVGhpcyBmaWxlIGlzIGF1dG8tZ2VuZXJhdGVkIGJ5IEBoZXktYXBpL29wZW5hcGktdHNcbmV4cG9ydCBjb25zdCBjcmVhdGVTc2VDbGllbnQgPSAoeyBvblNzZUVycm9yLCBvblNzZUV2ZW50LCByZXNwb25zZVRyYW5zZm9ybWVyLCByZXNwb25zZVZhbGlkYXRvciwgc3NlRGVmYXVsdFJldHJ5RGVsYXksIHNzZU1heFJldHJ5QXR0ZW1wdHMsIHNzZU1heFJldHJ5RGVsYXksIHNzZVNsZWVwRm4sIHVybCwgLi4ub3B0aW9ucyB9KSA9PiB7XG4gICAgbGV0IGxhc3RFdmVudElkO1xuICAgIGNvbnN0IHNsZWVwID0gc3NlU2xlZXBGbiA/PyAoKG1zKSA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpKTtcbiAgICBjb25zdCBjcmVhdGVTdHJlYW0gPSBhc3luYyBmdW5jdGlvbiogKCkge1xuICAgICAgICBsZXQgcmV0cnlEZWxheSA9IHNzZURlZmF1bHRSZXRyeURlbGF5ID8/IDMwMDA7XG4gICAgICAgIGxldCBhdHRlbXB0ID0gMDtcbiAgICAgICAgY29uc3Qgc2lnbmFsID0gb3B0aW9ucy5zaWduYWwgPz8gbmV3IEFib3J0Q29udHJvbGxlcigpLnNpZ25hbDtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmIChzaWduYWwuYWJvcnRlZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGF0dGVtcHQrKztcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLmhlYWRlcnNcbiAgICAgICAgICAgICAgICA6IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgICAgICBpZiAobGFzdEV2ZW50SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMuc2V0KFwiTGFzdC1FdmVudC1JRFwiLCBsYXN0RXZlbnRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCB7IC4uLm9wdGlvbnMsIGhlYWRlcnMsIHNpZ25hbCB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNTRSBmYWlsZWQ6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5ib2R5KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBib2R5IGluIFNTRSByZXNwb25zZVwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LnBpcGVUaHJvdWdoKG5ldyBUZXh0RGVjb2RlclN0cmVhbSgpKS5nZXRSZWFkZXIoKTtcbiAgICAgICAgICAgICAgICBsZXQgYnVmZmVyID0gXCJcIjtcbiAgICAgICAgICAgICAgICBjb25zdCBhYm9ydEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0SGFuZGxlcik7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciArPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rcyA9IGJ1ZmZlci5zcGxpdChcIlxcblxcblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGNodW5rcy5wb3AoKSA/PyBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5lcyA9IGNodW5rLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFMaW5lcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBldmVudE5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUxpbmVzLnB1c2gobGluZS5yZXBsYWNlKC9eZGF0YTpcXHMqLywgXCJcIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxpbmUuc3RhcnRzV2l0aChcImV2ZW50OlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnROYW1lID0gbGluZS5yZXBsYWNlKC9eZXZlbnQ6XFxzKi8sIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxpbmUuc3RhcnRzV2l0aChcImlkOlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEV2ZW50SWQgPSBsaW5lLnJlcGxhY2UoL15pZDpcXHMqLywgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobGluZS5zdGFydHNXaXRoKFwicmV0cnk6XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBOdW1iZXIucGFyc2VJbnQobGluZS5yZXBsYWNlKC9ecmV0cnk6XFxzKi8sIFwiXCIpLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc05hTihwYXJzZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlEZWxheSA9IHBhcnNlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGFyc2VkSnNvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhTGluZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhd0RhdGEgPSBkYXRhTGluZXMuam9pbihcIlxcblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKHJhd0RhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkSnNvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHJhd0RhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlZEpzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlVmFsaWRhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCByZXNwb25zZVZhbGlkYXRvcihkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VUcmFuc2Zvcm1lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGF3YWl0IHJlc3BvbnNlVHJhbnNmb3JtZXIoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Tc2VFdmVudD8uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGxhc3RFdmVudElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRyeTogcmV0cnlEZWxheSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YUxpbmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIGV4aXQgbG9vcCBvbiBub3JtYWwgY29tcGxldGlvblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gY29ubmVjdGlvbiBmYWlsZWQgb3IgYWJvcnRlZDsgcmV0cnkgYWZ0ZXIgZGVsYXlcbiAgICAgICAgICAgICAgICBvblNzZUVycm9yPy4oZXJyb3IpO1xuICAgICAgICAgICAgICAgIGlmIChzc2VNYXhSZXRyeUF0dGVtcHRzICE9PSB1bmRlZmluZWQgJiYgYXR0ZW1wdCA+PSBzc2VNYXhSZXRyeUF0dGVtcHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBzdG9wIGFmdGVyIGZpcmluZyBlcnJvclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBleHBvbmVudGlhbCBiYWNrb2ZmOiBkb3VibGUgcmV0cnkgZWFjaCBhdHRlbXB0LCBjYXAgYXQgMzBzXG4gICAgICAgICAgICAgICAgY29uc3QgYmFja29mZiA9IE1hdGgubWluKHJldHJ5RGVsYXkgKiAyICoqIChhdHRlbXB0IC0gMSksIHNzZU1heFJldHJ5RGVsYXkgPz8gMzAwMDApO1xuICAgICAgICAgICAgICAgIGF3YWl0IHNsZWVwKGJhY2tvZmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzdHJlYW0gPSBjcmVhdGVTdHJlYW0oKTtcbiAgICByZXR1cm4geyBzdHJlYW0gfTtcbn07XG4iLAogICAgIi8vIFRoaXMgZmlsZSBpcyBhdXRvLWdlbmVyYXRlZCBieSBAaGV5LWFwaS9vcGVuYXBpLXRzXG5leHBvcnQgY29uc3QgZ2V0QXV0aFRva2VuID0gYXN5bmMgKGF1dGgsIGNhbGxiYWNrKSA9PiB7XG4gICAgY29uc3QgdG9rZW4gPSB0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIiA/IGF3YWl0IGNhbGxiYWNrKGF1dGgpIDogY2FsbGJhY2s7XG4gICAgaWYgKCF0b2tlbikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChhdXRoLnNjaGVtZSA9PT0gXCJiZWFyZXJcIikge1xuICAgICAgICByZXR1cm4gYEJlYXJlciAke3Rva2VufWA7XG4gICAgfVxuICAgIGlmIChhdXRoLnNjaGVtZSA9PT0gXCJiYXNpY1wiKSB7XG4gICAgICAgIHJldHVybiBgQmFzaWMgJHtidG9hKHRva2VuKX1gO1xuICAgIH1cbiAgICByZXR1cm4gdG9rZW47XG59O1xuIiwKICAgICIvLyBUaGlzIGZpbGUgaXMgYXV0by1nZW5lcmF0ZWQgYnkgQGhleS1hcGkvb3BlbmFwaS10c1xuY29uc3Qgc2VyaWFsaXplRm9ybURhdGFQYWlyID0gKGRhdGEsIGtleSwgdmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHZhbHVlIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICBkYXRhLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIGRhdGEuYXBwZW5kKGtleSwgdmFsdWUudG9JU09TdHJpbmcoKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkYXRhLmFwcGVuZChrZXksIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgfVxufTtcbmNvbnN0IHNlcmlhbGl6ZVVybFNlYXJjaFBhcmFtc1BhaXIgPSAoZGF0YSwga2V5LCB2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZGF0YS5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkYXRhLmFwcGVuZChrZXksIEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBmb3JtRGF0YUJvZHlTZXJpYWxpemVyID0ge1xuICAgIGJvZHlTZXJpYWxpemVyOiAoYm9keSkgPT4ge1xuICAgICAgICBjb25zdCBkYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGJvZHkpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKCh2KSA9PiBzZXJpYWxpemVGb3JtRGF0YVBhaXIoZGF0YSwga2V5LCB2KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVGb3JtRGF0YVBhaXIoZGF0YSwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxufTtcbmV4cG9ydCBjb25zdCBqc29uQm9keVNlcmlhbGl6ZXIgPSB7XG4gICAgYm9keVNlcmlhbGl6ZXI6IChib2R5KSA9PiBKU09OLnN0cmluZ2lmeShib2R5LCAoX2tleSwgdmFsdWUpID0+ICh0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIgPyB2YWx1ZS50b1N0cmluZygpIDogdmFsdWUpKSxcbn07XG5leHBvcnQgY29uc3QgdXJsU2VhcmNoUGFyYW1zQm9keVNlcmlhbGl6ZXIgPSB7XG4gICAgYm9keVNlcmlhbGl6ZXI6IChib2R5KSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGJvZHkpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKCh2KSA9PiBzZXJpYWxpemVVcmxTZWFyY2hQYXJhbXNQYWlyKGRhdGEsIGtleSwgdikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplVXJsU2VhcmNoUGFyYW1zUGFpcihkYXRhLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfSxcbn07XG4iLAogICAgIi8vIFRoaXMgZmlsZSBpcyBhdXRvLWdlbmVyYXRlZCBieSBAaGV5LWFwaS9vcGVuYXBpLXRzXG5leHBvcnQgY29uc3Qgc2VwYXJhdG9yQXJyYXlFeHBsb2RlID0gKHN0eWxlKSA9PiB7XG4gICAgc3dpdGNoIChzdHlsZSkge1xuICAgICAgICBjYXNlIFwibGFiZWxcIjpcbiAgICAgICAgICAgIHJldHVybiBcIi5cIjtcbiAgICAgICAgY2FzZSBcIm1hdHJpeFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiO1wiO1xuICAgICAgICBjYXNlIFwic2ltcGxlXCI6XG4gICAgICAgICAgICByZXR1cm4gXCIsXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gXCImXCI7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBzZXBhcmF0b3JBcnJheU5vRXhwbG9kZSA9IChzdHlsZSkgPT4ge1xuICAgIHN3aXRjaCAoc3R5bGUpIHtcbiAgICAgICAgY2FzZSBcImZvcm1cIjpcbiAgICAgICAgICAgIHJldHVybiBcIixcIjtcbiAgICAgICAgY2FzZSBcInBpcGVEZWxpbWl0ZWRcIjpcbiAgICAgICAgICAgIHJldHVybiBcInxcIjtcbiAgICAgICAgY2FzZSBcInNwYWNlRGVsaW1pdGVkXCI6XG4gICAgICAgICAgICByZXR1cm4gXCIlMjBcIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBcIixcIjtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IHNlcGFyYXRvck9iamVjdEV4cGxvZGUgPSAoc3R5bGUpID0+IHtcbiAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgICAgIGNhc2UgXCJsYWJlbFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiLlwiO1xuICAgICAgICBjYXNlIFwibWF0cml4XCI6XG4gICAgICAgICAgICByZXR1cm4gXCI7XCI7XG4gICAgICAgIGNhc2UgXCJzaW1wbGVcIjpcbiAgICAgICAgICAgIHJldHVybiBcIixcIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBcIiZcIjtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IHNlcmlhbGl6ZUFycmF5UGFyYW0gPSAoeyBhbGxvd1Jlc2VydmVkLCBleHBsb2RlLCBuYW1lLCBzdHlsZSwgdmFsdWUsIH0pID0+IHtcbiAgICBpZiAoIWV4cGxvZGUpIHtcbiAgICAgICAgY29uc3Qgam9pbmVkVmFsdWVzID0gKGFsbG93UmVzZXJ2ZWQgPyB2YWx1ZSA6IHZhbHVlLm1hcCgodikgPT4gZW5jb2RlVVJJQ29tcG9uZW50KHYpKSkuam9pbihzZXBhcmF0b3JBcnJheU5vRXhwbG9kZShzdHlsZSkpO1xuICAgICAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgICAgICAgICBjYXNlIFwibGFiZWxcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYC4ke2pvaW5lZFZhbHVlc31gO1xuICAgICAgICAgICAgY2FzZSBcIm1hdHJpeFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBgOyR7bmFtZX09JHtqb2luZWRWYWx1ZXN9YDtcbiAgICAgICAgICAgIGNhc2UgXCJzaW1wbGVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gam9pbmVkVmFsdWVzO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7bmFtZX09JHtqb2luZWRWYWx1ZXN9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzZXBhcmF0b3IgPSBzZXBhcmF0b3JBcnJheUV4cGxvZGUoc3R5bGUpO1xuICAgIGNvbnN0IGpvaW5lZFZhbHVlcyA9IHZhbHVlXG4gICAgICAgIC5tYXAoKHYpID0+IHtcbiAgICAgICAgaWYgKHN0eWxlID09PSBcImxhYmVsXCIgfHwgc3R5bGUgPT09IFwic2ltcGxlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBhbGxvd1Jlc2VydmVkID8gdiA6IGVuY29kZVVSSUNvbXBvbmVudCh2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VyaWFsaXplUHJpbWl0aXZlUGFyYW0oe1xuICAgICAgICAgICAgYWxsb3dSZXNlcnZlZCxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogdixcbiAgICAgICAgfSk7XG4gICAgfSlcbiAgICAgICAgLmpvaW4oc2VwYXJhdG9yKTtcbiAgICByZXR1cm4gc3R5bGUgPT09IFwibGFiZWxcIiB8fCBzdHlsZSA9PT0gXCJtYXRyaXhcIiA/IHNlcGFyYXRvciArIGpvaW5lZFZhbHVlcyA6IGpvaW5lZFZhbHVlcztcbn07XG5leHBvcnQgY29uc3Qgc2VyaWFsaXplUHJpbWl0aXZlUGFyYW0gPSAoeyBhbGxvd1Jlc2VydmVkLCBuYW1lLCB2YWx1ZSB9KSA9PiB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVlcGx5LW5lc3RlZCBhcnJheXMvb2JqZWN0cyBhcmVu4oCZdCBzdXBwb3J0ZWQuIFByb3ZpZGUgeW91ciBvd24gYHF1ZXJ5U2VyaWFsaXplcigpYCB0byBoYW5kbGUgdGhlc2UuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gYCR7bmFtZX09JHthbGxvd1Jlc2VydmVkID8gdmFsdWUgOiBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpfWA7XG59O1xuZXhwb3J0IGNvbnN0IHNlcmlhbGl6ZU9iamVjdFBhcmFtID0gKHsgYWxsb3dSZXNlcnZlZCwgZXhwbG9kZSwgbmFtZSwgc3R5bGUsIHZhbHVlLCB2YWx1ZU9ubHksIH0pID0+IHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZU9ubHkgPyB2YWx1ZS50b0lTT1N0cmluZygpIDogYCR7bmFtZX09JHt2YWx1ZS50b0lTT1N0cmluZygpfWA7XG4gICAgfVxuICAgIGlmIChzdHlsZSAhPT0gXCJkZWVwT2JqZWN0XCIgJiYgIWV4cGxvZGUpIHtcbiAgICAgICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgICAgICBPYmplY3QuZW50cmllcyh2YWx1ZSkuZm9yRWFjaCgoW2tleSwgdl0pID0+IHtcbiAgICAgICAgICAgIHZhbHVlcyA9IFsuLi52YWx1ZXMsIGtleSwgYWxsb3dSZXNlcnZlZCA/IHYgOiBlbmNvZGVVUklDb21wb25lbnQodildO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgam9pbmVkVmFsdWVzID0gdmFsdWVzLmpvaW4oXCIsXCIpO1xuICAgICAgICBzd2l0Y2ggKHN0eWxlKSB7XG4gICAgICAgICAgICBjYXNlIFwiZm9ybVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtuYW1lfT0ke2pvaW5lZFZhbHVlc31gO1xuICAgICAgICAgICAgY2FzZSBcImxhYmVsXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGAuJHtqb2luZWRWYWx1ZXN9YDtcbiAgICAgICAgICAgIGNhc2UgXCJtYXRyaXhcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYDske25hbWV9PSR7am9pbmVkVmFsdWVzfWA7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBqb2luZWRWYWx1ZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc2VwYXJhdG9yID0gc2VwYXJhdG9yT2JqZWN0RXhwbG9kZShzdHlsZSk7XG4gICAgY29uc3Qgam9pbmVkVmFsdWVzID0gT2JqZWN0LmVudHJpZXModmFsdWUpXG4gICAgICAgIC5tYXAoKFtrZXksIHZdKSA9PiBzZXJpYWxpemVQcmltaXRpdmVQYXJhbSh7XG4gICAgICAgIGFsbG93UmVzZXJ2ZWQsXG4gICAgICAgIG5hbWU6IHN0eWxlID09PSBcImRlZXBPYmplY3RcIiA/IGAke25hbWV9WyR7a2V5fV1gIDoga2V5LFxuICAgICAgICB2YWx1ZTogdixcbiAgICB9KSlcbiAgICAgICAgLmpvaW4oc2VwYXJhdG9yKTtcbiAgICByZXR1cm4gc3R5bGUgPT09IFwibGFiZWxcIiB8fCBzdHlsZSA9PT0gXCJtYXRyaXhcIiA/IHNlcGFyYXRvciArIGpvaW5lZFZhbHVlcyA6IGpvaW5lZFZhbHVlcztcbn07XG4iLAogICAgIi8vIFRoaXMgZmlsZSBpcyBhdXRvLWdlbmVyYXRlZCBieSBAaGV5LWFwaS9vcGVuYXBpLXRzXG5pbXBvcnQgeyBzZXJpYWxpemVBcnJheVBhcmFtLCBzZXJpYWxpemVPYmplY3RQYXJhbSwgc2VyaWFsaXplUHJpbWl0aXZlUGFyYW0sIH0gZnJvbSBcIi4vcGF0aFNlcmlhbGl6ZXIuZ2VuLmpzXCI7XG5leHBvcnQgY29uc3QgUEFUSF9QQVJBTV9SRSA9IC9cXHtbXnt9XStcXH0vZztcbmV4cG9ydCBjb25zdCBkZWZhdWx0UGF0aFNlcmlhbGl6ZXIgPSAoeyBwYXRoLCB1cmw6IF91cmwgfSkgPT4ge1xuICAgIGxldCB1cmwgPSBfdXJsO1xuICAgIGNvbnN0IG1hdGNoZXMgPSBfdXJsLm1hdGNoKFBBVEhfUEFSQU1fUkUpO1xuICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgICAgICAgICAgbGV0IGV4cGxvZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBuYW1lID0gbWF0Y2guc3Vic3RyaW5nKDEsIG1hdGNoLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgbGV0IHN0eWxlID0gXCJzaW1wbGVcIjtcbiAgICAgICAgICAgIGlmIChuYW1lLmVuZHNXaXRoKFwiKlwiKSkge1xuICAgICAgICAgICAgICAgIGV4cGxvZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZygwLCBuYW1lLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aChcIi5cIikpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgc3R5bGUgPSBcImxhYmVsXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lLnN0YXJ0c1dpdGgoXCI7XCIpKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgIHN0eWxlID0gXCJtYXRyaXhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGF0aFtuYW1lXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShtYXRjaCwgc2VyaWFsaXplQXJyYXlQYXJhbSh7IGV4cGxvZGUsIG5hbWUsIHN0eWxlLCB2YWx1ZSB9KSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UobWF0Y2gsIHNlcmlhbGl6ZU9iamVjdFBhcmFtKHtcbiAgICAgICAgICAgICAgICAgICAgZXhwbG9kZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVPbmx5OiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHlsZSA9PT0gXCJtYXRyaXhcIikge1xuICAgICAgICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKG1hdGNoLCBgOyR7c2VyaWFsaXplUHJpbWl0aXZlUGFyYW0oe1xuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgfSl9YCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXBsYWNlVmFsdWUgPSBlbmNvZGVVUklDb21wb25lbnQoc3R5bGUgPT09IFwibGFiZWxcIiA/IGAuJHt2YWx1ZX1gIDogdmFsdWUpO1xuICAgICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UobWF0Y2gsIHJlcGxhY2VWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbn07XG5leHBvcnQgY29uc3QgZ2V0VXJsID0gKHsgYmFzZVVybCwgcGF0aCwgcXVlcnksIHF1ZXJ5U2VyaWFsaXplciwgdXJsOiBfdXJsLCB9KSA9PiB7XG4gICAgY29uc3QgcGF0aFVybCA9IF91cmwuc3RhcnRzV2l0aChcIi9cIikgPyBfdXJsIDogYC8ke191cmx9YDtcbiAgICBsZXQgdXJsID0gKGJhc2VVcmwgPz8gXCJcIikgKyBwYXRoVXJsO1xuICAgIGlmIChwYXRoKSB7XG4gICAgICAgIHVybCA9IGRlZmF1bHRQYXRoU2VyaWFsaXplcih7IHBhdGgsIHVybCB9KTtcbiAgICB9XG4gICAgbGV0IHNlYXJjaCA9IHF1ZXJ5ID8gcXVlcnlTZXJpYWxpemVyKHF1ZXJ5KSA6IFwiXCI7XG4gICAgaWYgKHNlYXJjaC5zdGFydHNXaXRoKFwiP1wiKSkge1xuICAgICAgICBzZWFyY2ggPSBzZWFyY2guc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICBpZiAoc2VhcmNoKSB7XG4gICAgICAgIHVybCArPSBgPyR7c2VhcmNofWA7XG4gICAgfVxuICAgIHJldHVybiB1cmw7XG59O1xuIiwKICAgICIvLyBUaGlzIGZpbGUgaXMgYXV0by1nZW5lcmF0ZWQgYnkgQGhleS1hcGkvb3BlbmFwaS10c1xuaW1wb3J0IHsgZ2V0QXV0aFRva2VuIH0gZnJvbSBcIi4uL2NvcmUvYXV0aC5nZW4uanNcIjtcbmltcG9ydCB7IGpzb25Cb2R5U2VyaWFsaXplciB9IGZyb20gXCIuLi9jb3JlL2JvZHlTZXJpYWxpemVyLmdlbi5qc1wiO1xuaW1wb3J0IHsgc2VyaWFsaXplQXJyYXlQYXJhbSwgc2VyaWFsaXplT2JqZWN0UGFyYW0sIHNlcmlhbGl6ZVByaW1pdGl2ZVBhcmFtIH0gZnJvbSBcIi4uL2NvcmUvcGF0aFNlcmlhbGl6ZXIuZ2VuLmpzXCI7XG5pbXBvcnQgeyBnZXRVcmwgfSBmcm9tIFwiLi4vY29yZS91dGlscy5nZW4uanNcIjtcbmV4cG9ydCBjb25zdCBjcmVhdGVRdWVyeVNlcmlhbGl6ZXIgPSAoeyBhbGxvd1Jlc2VydmVkLCBhcnJheSwgb2JqZWN0IH0gPSB7fSkgPT4ge1xuICAgIGNvbnN0IHF1ZXJ5U2VyaWFsaXplciA9IChxdWVyeVBhcmFtcykgPT4ge1xuICAgICAgICBjb25zdCBzZWFyY2ggPSBbXTtcbiAgICAgICAgaWYgKHF1ZXJ5UGFyYW1zICYmIHR5cGVvZiBxdWVyeVBhcmFtcyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHF1ZXJ5UGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBxdWVyeVBhcmFtc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRBcnJheSA9IHNlcmlhbGl6ZUFycmF5UGFyYW0oe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dSZXNlcnZlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGxvZGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU6IFwiZm9ybVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5hcnJheSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXJpYWxpemVkQXJyYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2gucHVzaChzZXJpYWxpemVkQXJyYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZE9iamVjdCA9IHNlcmlhbGl6ZU9iamVjdFBhcmFtKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93UmVzZXJ2ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBsb2RlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBcImRlZXBPYmplY3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLm9iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXJpYWxpemVkT2JqZWN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoLnB1c2goc2VyaWFsaXplZE9iamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkUHJpbWl0aXZlID0gc2VyaWFsaXplUHJpbWl0aXZlUGFyYW0oe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dSZXNlcnZlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VyaWFsaXplZFByaW1pdGl2ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaC5wdXNoKHNlcmlhbGl6ZWRQcmltaXRpdmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VhcmNoLmpvaW4oXCImXCIpO1xuICAgIH07XG4gICAgcmV0dXJuIHF1ZXJ5U2VyaWFsaXplcjtcbn07XG4vKipcbiAqIEluZmVycyBwYXJzZUFzIHZhbHVlIGZyb20gcHJvdmlkZWQgQ29udGVudC1UeXBlIGhlYWRlci5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFBhcnNlQXMgPSAoY29udGVudFR5cGUpID0+IHtcbiAgICBpZiAoIWNvbnRlbnRUeXBlKSB7XG4gICAgICAgIC8vIElmIG5vIENvbnRlbnQtVHlwZSBoZWFkZXIgaXMgcHJvdmlkZWQsIHRoZSBiZXN0IHdlIGNhbiBkbyBpcyByZXR1cm4gdGhlIHJhdyByZXNwb25zZSBib2R5LFxuICAgICAgICAvLyB3aGljaCBpcyBlZmZlY3RpdmVseSB0aGUgc2FtZSBhcyB0aGUgJ3N0cmVhbScgb3B0aW9uLlxuICAgICAgICByZXR1cm4gXCJzdHJlYW1cIjtcbiAgICB9XG4gICAgY29uc3QgY2xlYW5Db250ZW50ID0gY29udGVudFR5cGUuc3BsaXQoXCI7XCIpWzBdPy50cmltKCk7XG4gICAgaWYgKCFjbGVhbkNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2xlYW5Db250ZW50LnN0YXJ0c1dpdGgoXCJhcHBsaWNhdGlvbi9qc29uXCIpIHx8IGNsZWFuQ29udGVudC5lbmRzV2l0aChcIitqc29uXCIpKSB7XG4gICAgICAgIHJldHVybiBcImpzb25cIjtcbiAgICB9XG4gICAgaWYgKGNsZWFuQ29udGVudCA9PT0gXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiZm9ybURhdGFcIjtcbiAgICB9XG4gICAgaWYgKFtcImFwcGxpY2F0aW9uL1wiLCBcImF1ZGlvL1wiLCBcImltYWdlL1wiLCBcInZpZGVvL1wiXS5zb21lKCh0eXBlKSA9PiBjbGVhbkNvbnRlbnQuc3RhcnRzV2l0aCh0eXBlKSkpIHtcbiAgICAgICAgcmV0dXJuIFwiYmxvYlwiO1xuICAgIH1cbiAgICBpZiAoY2xlYW5Db250ZW50LnN0YXJ0c1dpdGgoXCJ0ZXh0L1wiKSkge1xuICAgICAgICByZXR1cm4gXCJ0ZXh0XCI7XG4gICAgfVxuICAgIHJldHVybjtcbn07XG5jb25zdCBjaGVja0ZvckV4aXN0ZW5jZSA9IChvcHRpb25zLCBuYW1lKSA9PiB7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaGVhZGVycy5oYXMobmFtZSkgfHwgb3B0aW9ucy5xdWVyeT8uW25hbWVdIHx8IG9wdGlvbnMuaGVhZGVycy5nZXQoXCJDb29raWVcIik/LmluY2x1ZGVzKGAke25hbWV9PWApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuZXhwb3J0IGNvbnN0IHNldEF1dGhQYXJhbXMgPSBhc3luYyAoeyBzZWN1cml0eSwgLi4ub3B0aW9ucyB9KSA9PiB7XG4gICAgZm9yIChjb25zdCBhdXRoIG9mIHNlY3VyaXR5KSB7XG4gICAgICAgIGlmIChjaGVja0ZvckV4aXN0ZW5jZShvcHRpb25zLCBhdXRoLm5hbWUpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b2tlbiA9IGF3YWl0IGdldEF1dGhUb2tlbihhdXRoLCBvcHRpb25zLmF1dGgpO1xuICAgICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gYXV0aC5uYW1lID8/IFwiQXV0aG9yaXphdGlvblwiO1xuICAgICAgICBzd2l0Y2ggKGF1dGguaW4pIHtcbiAgICAgICAgICAgIGNhc2UgXCJxdWVyeVwiOlxuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5xdWVyeSkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnF1ZXJ5ID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdGlvbnMucXVlcnlbbmFtZV0gPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjb29raWVcIjpcbiAgICAgICAgICAgICAgICBvcHRpb25zLmhlYWRlcnMuYXBwZW5kKFwiQ29va2llXCIsIGAke25hbWV9PSR7dG9rZW59YCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiaGVhZGVyXCI6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIG9wdGlvbnMuaGVhZGVycy5zZXQobmFtZSwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBidWlsZFVybCA9IChvcHRpb25zKSA9PiBnZXRVcmwoe1xuICAgIGJhc2VVcmw6IG9wdGlvbnMuYmFzZVVybCxcbiAgICBwYXRoOiBvcHRpb25zLnBhdGgsXG4gICAgcXVlcnk6IG9wdGlvbnMucXVlcnksXG4gICAgcXVlcnlTZXJpYWxpemVyOiB0eXBlb2Ygb3B0aW9ucy5xdWVyeVNlcmlhbGl6ZXIgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/IG9wdGlvbnMucXVlcnlTZXJpYWxpemVyXG4gICAgICAgIDogY3JlYXRlUXVlcnlTZXJpYWxpemVyKG9wdGlvbnMucXVlcnlTZXJpYWxpemVyKSxcbiAgICB1cmw6IG9wdGlvbnMudXJsLFxufSk7XG5leHBvcnQgY29uc3QgbWVyZ2VDb25maWdzID0gKGEsIGIpID0+IHtcbiAgICBjb25zdCBjb25maWcgPSB7IC4uLmEsIC4uLmIgfTtcbiAgICBpZiAoY29uZmlnLmJhc2VVcmw/LmVuZHNXaXRoKFwiL1wiKSkge1xuICAgICAgICBjb25maWcuYmFzZVVybCA9IGNvbmZpZy5iYXNlVXJsLnN1YnN0cmluZygwLCBjb25maWcuYmFzZVVybC5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgY29uZmlnLmhlYWRlcnMgPSBtZXJnZUhlYWRlcnMoYS5oZWFkZXJzLCBiLmhlYWRlcnMpO1xuICAgIHJldHVybiBjb25maWc7XG59O1xuZXhwb3J0IGNvbnN0IG1lcmdlSGVhZGVycyA9ICguLi5oZWFkZXJzKSA9PiB7XG4gICAgY29uc3QgbWVyZ2VkSGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gICAgZm9yIChjb25zdCBoZWFkZXIgb2YgaGVhZGVycykge1xuICAgICAgICBpZiAoIWhlYWRlciB8fCB0eXBlb2YgaGVhZGVyICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpdGVyYXRvciA9IGhlYWRlciBpbnN0YW5jZW9mIEhlYWRlcnMgPyBoZWFkZXIuZW50cmllcygpIDogT2JqZWN0LmVudHJpZXMoaGVhZGVyKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgaXRlcmF0b3IpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG1lcmdlZEhlYWRlcnMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWRIZWFkZXJzLmFwcGVuZChrZXksIHYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBhc3N1bWUgb2JqZWN0IGhlYWRlcnMgYXJlIG1lYW50IHRvIGJlIEpTT04gc3RyaW5naWZpZWQsIGkuZS4gdGhlaXJcbiAgICAgICAgICAgICAgICAvLyBjb250ZW50IHZhbHVlIGluIE9wZW5BUEkgc3BlY2lmaWNhdGlvbiBpcyAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgICAgICAgICBtZXJnZWRIZWFkZXJzLnNldChrZXksIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiA/IEpTT04uc3RyaW5naWZ5KHZhbHVlKSA6IHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VkSGVhZGVycztcbn07XG5jbGFzcyBJbnRlcmNlcHRvcnMge1xuICAgIF9mbnM7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2ZucyA9IFtdO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5fZm5zID0gW107XG4gICAgfVxuICAgIGdldEludGVyY2VwdG9ySW5kZXgoaWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Zuc1tpZF0gPyBpZCA6IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Zucy5pbmRleE9mKGlkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBleGlzdHMoaWQpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmdldEludGVyY2VwdG9ySW5kZXgoaWQpO1xuICAgICAgICByZXR1cm4gISF0aGlzLl9mbnNbaW5kZXhdO1xuICAgIH1cbiAgICBlamVjdChpZCkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0SW50ZXJjZXB0b3JJbmRleChpZCk7XG4gICAgICAgIGlmICh0aGlzLl9mbnNbaW5kZXhdKSB7XG4gICAgICAgICAgICB0aGlzLl9mbnNbaW5kZXhdID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUoaWQsIGZuKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5nZXRJbnRlcmNlcHRvckluZGV4KGlkKTtcbiAgICAgICAgaWYgKHRoaXMuX2Zuc1tpbmRleF0pIHtcbiAgICAgICAgICAgIHRoaXMuX2Zuc1tpbmRleF0gPSBmbjtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1c2UoZm4pIHtcbiAgICAgICAgdGhpcy5fZm5zID0gWy4uLnRoaXMuX2ZucywgZm5dO1xuICAgICAgICByZXR1cm4gdGhpcy5fZm5zLmxlbmd0aCAtIDE7XG4gICAgfVxufVxuLy8gZG8gbm90IGFkZCBgTWlkZGxld2FyZWAgYXMgcmV0dXJuIHR5cGUgc28gd2UgY2FuIHVzZSBfZm5zIGludGVybmFsbHlcbmV4cG9ydCBjb25zdCBjcmVhdGVJbnRlcmNlcHRvcnMgPSAoKSA9PiAoe1xuICAgIGVycm9yOiBuZXcgSW50ZXJjZXB0b3JzKCksXG4gICAgcmVxdWVzdDogbmV3IEludGVyY2VwdG9ycygpLFxuICAgIHJlc3BvbnNlOiBuZXcgSW50ZXJjZXB0b3JzKCksXG59KTtcbmNvbnN0IGRlZmF1bHRRdWVyeVNlcmlhbGl6ZXIgPSBjcmVhdGVRdWVyeVNlcmlhbGl6ZXIoe1xuICAgIGFsbG93UmVzZXJ2ZWQ6IGZhbHNlLFxuICAgIGFycmF5OiB7XG4gICAgICAgIGV4cGxvZGU6IHRydWUsXG4gICAgICAgIHN0eWxlOiBcImZvcm1cIixcbiAgICB9LFxuICAgIG9iamVjdDoge1xuICAgICAgICBleHBsb2RlOiB0cnVlLFxuICAgICAgICBzdHlsZTogXCJkZWVwT2JqZWN0XCIsXG4gICAgfSxcbn0pO1xuY29uc3QgZGVmYXVsdEhlYWRlcnMgPSB7XG4gICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG59O1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUNvbmZpZyA9IChvdmVycmlkZSA9IHt9KSA9PiAoe1xuICAgIC4uLmpzb25Cb2R5U2VyaWFsaXplcixcbiAgICBoZWFkZXJzOiBkZWZhdWx0SGVhZGVycyxcbiAgICBwYXJzZUFzOiBcImF1dG9cIixcbiAgICBxdWVyeVNlcmlhbGl6ZXI6IGRlZmF1bHRRdWVyeVNlcmlhbGl6ZXIsXG4gICAgLi4ub3ZlcnJpZGUsXG59KTtcbiIsCiAgICAiLy8gVGhpcyBmaWxlIGlzIGF1dG8tZ2VuZXJhdGVkIGJ5IEBoZXktYXBpL29wZW5hcGktdHNcbmltcG9ydCB7IGNyZWF0ZVNzZUNsaWVudCB9IGZyb20gXCIuLi9jb3JlL3NlcnZlclNlbnRFdmVudHMuZ2VuLmpzXCI7XG5pbXBvcnQgeyBidWlsZFVybCwgY3JlYXRlQ29uZmlnLCBjcmVhdGVJbnRlcmNlcHRvcnMsIGdldFBhcnNlQXMsIG1lcmdlQ29uZmlncywgbWVyZ2VIZWFkZXJzLCBzZXRBdXRoUGFyYW1zLCB9IGZyb20gXCIuL3V0aWxzLmdlbi5qc1wiO1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUNsaWVudCA9IChjb25maWcgPSB7fSkgPT4ge1xuICAgIGxldCBfY29uZmlnID0gbWVyZ2VDb25maWdzKGNyZWF0ZUNvbmZpZygpLCBjb25maWcpO1xuICAgIGNvbnN0IGdldENvbmZpZyA9ICgpID0+ICh7IC4uLl9jb25maWcgfSk7XG4gICAgY29uc3Qgc2V0Q29uZmlnID0gKGNvbmZpZykgPT4ge1xuICAgICAgICBfY29uZmlnID0gbWVyZ2VDb25maWdzKF9jb25maWcsIGNvbmZpZyk7XG4gICAgICAgIHJldHVybiBnZXRDb25maWcoKTtcbiAgICB9O1xuICAgIGNvbnN0IGludGVyY2VwdG9ycyA9IGNyZWF0ZUludGVyY2VwdG9ycygpO1xuICAgIGNvbnN0IGJlZm9yZVJlcXVlc3QgPSBhc3luYyAob3B0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAgICAgLi4uX2NvbmZpZyxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBmZXRjaDogb3B0aW9ucy5mZXRjaCA/PyBfY29uZmlnLmZldGNoID8/IGdsb2JhbFRoaXMuZmV0Y2gsXG4gICAgICAgICAgICBoZWFkZXJzOiBtZXJnZUhlYWRlcnMoX2NvbmZpZy5oZWFkZXJzLCBvcHRpb25zLmhlYWRlcnMpLFxuICAgICAgICAgICAgc2VyaWFsaXplZEJvZHk6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdHMuc2VjdXJpdHkpIHtcbiAgICAgICAgICAgIGF3YWl0IHNldEF1dGhQYXJhbXMoe1xuICAgICAgICAgICAgICAgIC4uLm9wdHMsXG4gICAgICAgICAgICAgICAgc2VjdXJpdHk6IG9wdHMuc2VjdXJpdHksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5yZXF1ZXN0VmFsaWRhdG9yKSB7XG4gICAgICAgICAgICBhd2FpdCBvcHRzLnJlcXVlc3RWYWxpZGF0b3Iob3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMuYm9keSAmJiBvcHRzLmJvZHlTZXJpYWxpemVyKSB7XG4gICAgICAgICAgICBvcHRzLnNlcmlhbGl6ZWRCb2R5ID0gb3B0cy5ib2R5U2VyaWFsaXplcihvcHRzLmJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlbW92ZSBDb250ZW50LVR5cGUgaGVhZGVyIGlmIGJvZHkgaXMgZW1wdHkgdG8gYXZvaWQgc2VuZGluZyBpbnZhbGlkIHJlcXVlc3RzXG4gICAgICAgIGlmIChvcHRzLnNlcmlhbGl6ZWRCb2R5ID09PSB1bmRlZmluZWQgfHwgb3B0cy5zZXJpYWxpemVkQm9keSA9PT0gXCJcIikge1xuICAgICAgICAgICAgb3B0cy5oZWFkZXJzLmRlbGV0ZShcIkNvbnRlbnQtVHlwZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmwgPSBidWlsZFVybChvcHRzKTtcbiAgICAgICAgcmV0dXJuIHsgb3B0cywgdXJsIH07XG4gICAgfTtcbiAgICBjb25zdCByZXF1ZXN0ID0gYXN5bmMgKG9wdGlvbnMpID0+IHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB7IG9wdHMsIHVybCB9ID0gYXdhaXQgYmVmb3JlUmVxdWVzdChvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdEluaXQgPSB7XG4gICAgICAgICAgICByZWRpcmVjdDogXCJmb2xsb3dcIixcbiAgICAgICAgICAgIC4uLm9wdHMsXG4gICAgICAgICAgICBib2R5OiBvcHRzLnNlcmlhbGl6ZWRCb2R5LFxuICAgICAgICB9O1xuICAgICAgICBsZXQgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHVybCwgcmVxdWVzdEluaXQpO1xuICAgICAgICBmb3IgKGNvbnN0IGZuIG9mIGludGVyY2VwdG9ycy5yZXF1ZXN0Ll9mbnMpIHtcbiAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgIHJlcXVlc3QgPSBhd2FpdCBmbihyZXF1ZXN0LCBvcHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBmZXRjaCBtdXN0IGJlIGFzc2lnbmVkIGhlcmUsIG90aGVyd2lzZSBpdCB3b3VsZCB0aHJvdyB0aGUgZXJyb3I6XG4gICAgICAgIC8vIFR5cGVFcnJvcjogRmFpbGVkIHRvIGV4ZWN1dGUgJ2ZldGNoJyBvbiAnV2luZG93JzogSWxsZWdhbCBpbnZvY2F0aW9uXG4gICAgICAgIGNvbnN0IF9mZXRjaCA9IG9wdHMuZmV0Y2g7XG4gICAgICAgIGxldCByZXNwb25zZSA9IGF3YWl0IF9mZXRjaChyZXF1ZXN0KTtcbiAgICAgICAgZm9yIChjb25zdCBmbiBvZiBpbnRlcmNlcHRvcnMucmVzcG9uc2UuX2Zucykge1xuICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBmbihyZXNwb25zZSwgcmVxdWVzdCwgb3B0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwNCB8fCByZXNwb25zZS5oZWFkZXJzLmdldChcIkNvbnRlbnQtTGVuZ3RoXCIpID09PSBcIjBcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvcHRzLnJlc3BvbnNlU3R5bGUgPT09IFwiZGF0YVwiXG4gICAgICAgICAgICAgICAgICAgID8ge31cbiAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcnNlQXMgPSAob3B0cy5wYXJzZUFzID09PSBcImF1dG9cIiA/IGdldFBhcnNlQXMocmVzcG9uc2UuaGVhZGVycy5nZXQoXCJDb250ZW50LVR5cGVcIikpIDogb3B0cy5wYXJzZUFzKSA/PyBcImpzb25cIjtcbiAgICAgICAgICAgIGxldCBkYXRhO1xuICAgICAgICAgICAgc3dpdGNoIChwYXJzZUFzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImFycmF5QnVmZmVyXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImJsb2JcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZm9ybURhdGFcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwianNvblwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBhd2FpdCByZXNwb25zZVtwYXJzZUFzXSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwic3RyZWFtXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRzLnJlc3BvbnNlU3R5bGUgPT09IFwiZGF0YVwiXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlc3BvbnNlLmJvZHlcbiAgICAgICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHJlc3BvbnNlLmJvZHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJzZUFzID09PSBcImpzb25cIikge1xuICAgICAgICAgICAgICAgIGlmIChvcHRzLnJlc3BvbnNlVmFsaWRhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IG9wdHMucmVzcG9uc2VWYWxpZGF0b3IoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcHRzLnJlc3BvbnNlVHJhbnNmb3JtZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGF3YWl0IG9wdHMucmVzcG9uc2VUcmFuc2Zvcm1lcihkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3B0cy5yZXNwb25zZVN0eWxlID09PSBcImRhdGFcIlxuICAgICAgICAgICAgICAgID8gZGF0YVxuICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXh0RXJyb3IgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIGxldCBqc29uRXJyb3I7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBqc29uRXJyb3IgPSBKU09OLnBhcnNlKHRleHRFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9yID0ganNvbkVycm9yID8/IHRleHRFcnJvcjtcbiAgICAgICAgbGV0IGZpbmFsRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgZm9yIChjb25zdCBmbiBvZiBpbnRlcmNlcHRvcnMuZXJyb3IuX2Zucykge1xuICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgZmluYWxFcnJvciA9IChhd2FpdCBmbihlcnJvciwgcmVzcG9uc2UsIHJlcXVlc3QsIG9wdHMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbEVycm9yID0gZmluYWxFcnJvciB8fCB7fTtcbiAgICAgICAgaWYgKG9wdHMudGhyb3dPbkVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBmaW5hbEVycm9yO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IHdlIHByb2JhYmx5IHdhbnQgdG8gcmV0dXJuIGVycm9yIGFuZCBpbXByb3ZlIHR5cGVzXG4gICAgICAgIHJldHVybiBvcHRzLnJlc3BvbnNlU3R5bGUgPT09IFwiZGF0YVwiXG4gICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IGZpbmFsRXJyb3IsXG4gICAgICAgICAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IG1ha2VNZXRob2QgPSAobWV0aG9kKSA9PiB7XG4gICAgICAgIGNvbnN0IGZuID0gKG9wdGlvbnMpID0+IHJlcXVlc3QoeyAuLi5vcHRpb25zLCBtZXRob2QgfSk7XG4gICAgICAgIGZuLnNzZSA9IGFzeW5jIChvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG9wdHMsIHVybCB9ID0gYXdhaXQgYmVmb3JlUmVxdWVzdChvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVTc2VDbGllbnQoe1xuICAgICAgICAgICAgICAgIC4uLm9wdHMsXG4gICAgICAgICAgICAgICAgYm9keTogb3B0cy5ib2R5LFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IG9wdHMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmbjtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGJ1aWxkVXJsLFxuICAgICAgICBjb25uZWN0OiBtYWtlTWV0aG9kKFwiQ09OTkVDVFwiKSxcbiAgICAgICAgZGVsZXRlOiBtYWtlTWV0aG9kKFwiREVMRVRFXCIpLFxuICAgICAgICBnZXQ6IG1ha2VNZXRob2QoXCJHRVRcIiksXG4gICAgICAgIGdldENvbmZpZyxcbiAgICAgICAgaGVhZDogbWFrZU1ldGhvZChcIkhFQURcIiksXG4gICAgICAgIGludGVyY2VwdG9ycyxcbiAgICAgICAgb3B0aW9uczogbWFrZU1ldGhvZChcIk9QVElPTlNcIiksXG4gICAgICAgIHBhdGNoOiBtYWtlTWV0aG9kKFwiUEFUQ0hcIiksXG4gICAgICAgIHBvc3Q6IG1ha2VNZXRob2QoXCJQT1NUXCIpLFxuICAgICAgICBwdXQ6IG1ha2VNZXRob2QoXCJQVVRcIiksXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIHNldENvbmZpZyxcbiAgICAgICAgdHJhY2U6IG1ha2VNZXRob2QoXCJUUkFDRVwiKSxcbiAgICB9O1xufTtcbiIsCiAgICAiLy8gVGhpcyBmaWxlIGlzIGF1dG8tZ2VuZXJhdGVkIGJ5IEBoZXktYXBpL29wZW5hcGktdHNcbmNvbnN0IGV4dHJhUHJlZml4ZXNNYXAgPSB7XG4gICAgJGJvZHlfOiBcImJvZHlcIixcbiAgICAkaGVhZGVyc186IFwiaGVhZGVyc1wiLFxuICAgICRwYXRoXzogXCJwYXRoXCIsXG4gICAgJHF1ZXJ5XzogXCJxdWVyeVwiLFxufTtcbmNvbnN0IGV4dHJhUHJlZml4ZXMgPSBPYmplY3QuZW50cmllcyhleHRyYVByZWZpeGVzTWFwKTtcbmNvbnN0IGJ1aWxkS2V5TWFwID0gKGZpZWxkcywgbWFwKSA9PiB7XG4gICAgaWYgKCFtYXApIHtcbiAgICAgICAgbWFwID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNvbmZpZyBvZiBmaWVsZHMpIHtcbiAgICAgICAgaWYgKFwiaW5cIiBpbiBjb25maWcpIHtcbiAgICAgICAgICAgIGlmIChjb25maWcua2V5KSB7XG4gICAgICAgICAgICAgICAgbWFwLnNldChjb25maWcua2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGluOiBjb25maWcuaW4sXG4gICAgICAgICAgICAgICAgICAgIG1hcDogY29uZmlnLm1hcCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb25maWcuYXJncykge1xuICAgICAgICAgICAgYnVpbGRLZXlNYXAoY29uZmlnLmFyZ3MsIG1hcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbn07XG5jb25zdCBzdHJpcEVtcHR5U2xvdHMgPSAocGFyYW1zKSA9PiB7XG4gICAgZm9yIChjb25zdCBbc2xvdCwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcmFtcykpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiAhT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCkge1xuICAgICAgICAgICAgZGVsZXRlIHBhcmFtc1tzbG90XTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgYnVpbGRDbGllbnRQYXJhbXMgPSAoYXJncywgZmllbGRzKSA9PiB7XG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICBib2R5OiB7fSxcbiAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgIHBhdGg6IHt9LFxuICAgICAgICBxdWVyeToge30sXG4gICAgfTtcbiAgICBjb25zdCBtYXAgPSBidWlsZEtleU1hcChmaWVsZHMpO1xuICAgIGxldCBjb25maWc7XG4gICAgZm9yIChjb25zdCBbaW5kZXgsIGFyZ10gb2YgYXJncy5lbnRyaWVzKCkpIHtcbiAgICAgICAgaWYgKGZpZWxkc1tpbmRleF0pIHtcbiAgICAgICAgICAgIGNvbmZpZyA9IGZpZWxkc1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb25maWcpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcImluXCIgaW4gY29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlnLmtleSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gbWFwLmdldChjb25maWcua2V5KTtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gZmllbGQubWFwIHx8IGNvbmZpZy5rZXk7XG4gICAgICAgICAgICAgICAgcGFyYW1zW2ZpZWxkLmluXVtuYW1lXSA9IGFyZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5ib2R5ID0gYXJnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYXJnID8/IHt9KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gbWFwLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gZmllbGQubWFwIHx8IGtleTtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zW2ZpZWxkLmluXVtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXh0cmEgPSBleHRyYVByZWZpeGVzLmZpbmQoKFtwcmVmaXhdKSA9PiBrZXkuc3RhcnRzV2l0aChwcmVmaXgpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dHJhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbcHJlZml4LCBzbG90XSA9IGV4dHJhO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zW3Nsb3RdW2tleS5zbGljZShwcmVmaXgubGVuZ3RoKV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW3Nsb3QsIGFsbG93ZWRdIG9mIE9iamVjdC5lbnRyaWVzKGNvbmZpZy5hbGxvd0V4dHJhID8/IHt9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zW3Nsb3RdW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0cmlwRW1wdHlTbG90cyhwYXJhbXMpO1xuICAgIHJldHVybiBwYXJhbXM7XG59O1xuIiwKICAgICIvLyBUaGlzIGZpbGUgaXMgYXV0by1nZW5lcmF0ZWQgYnkgQGhleS1hcGkvb3BlbmFwaS10c1xuaW1wb3J0IHsgY3JlYXRlQ2xpZW50LCBjcmVhdGVDb25maWcgfSBmcm9tIFwiLi9jbGllbnQvaW5kZXguanNcIjtcbmV4cG9ydCBjb25zdCBjbGllbnQgPSBjcmVhdGVDbGllbnQoY3JlYXRlQ29uZmlnKHtcbiAgICBiYXNlVXJsOiBcImh0dHA6Ly9sb2NhbGhvc3Q6NDA5NlwiLFxufSkpO1xuIiwKICAgICIvLyBUaGlzIGZpbGUgaXMgYXV0by1nZW5lcmF0ZWQgYnkgQGhleS1hcGkvb3BlbmFwaS10c1xuaW1wb3J0IHsgY2xpZW50IGFzIF9oZXlBcGlDbGllbnQgfSBmcm9tIFwiLi9jbGllbnQuZ2VuLmpzXCI7XG5jbGFzcyBfSGV5QXBpQ2xpZW50IHtcbiAgICBfY2xpZW50ID0gX2hleUFwaUNsaWVudDtcbiAgICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgICAgIGlmIChhcmdzPy5jbGllbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NsaWVudCA9IGFyZ3MuY2xpZW50O1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgR2xvYmFsIGV4dGVuZHMgX0hleUFwaUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogR2V0IGV2ZW50c1xuICAgICAqL1xuICAgIGV2ZW50KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zPy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5nZXQuc3NlKHtcbiAgICAgICAgICAgIHVybDogXCIvZ2xvYmFsL2V2ZW50XCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBQcm9qZWN0IGV4dGVuZHMgX0hleUFwaUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogTGlzdCBhbGwgcHJvamVjdHNcbiAgICAgKi9cbiAgICBsaXN0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zPy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgdXJsOiBcIi9wcm9qZWN0XCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHByb2plY3RcbiAgICAgKi9cbiAgICBjdXJyZW50KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zPy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgdXJsOiBcIi9wcm9qZWN0L2N1cnJlbnRcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFB0eSBleHRlbmRzIF9IZXlBcGlDbGllbnQge1xuICAgIC8qKlxuICAgICAqIExpc3QgYWxsIFBUWSBzZXNzaW9uc1xuICAgICAqL1xuICAgIGxpc3Qob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnM/LmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLmdldCh7XG4gICAgICAgICAgICB1cmw6IFwiL3B0eVwiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBQVFkgc2Vzc2lvblxuICAgICAqL1xuICAgIGNyZWF0ZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucz8uY2xpZW50ID8/IHRoaXMuX2NsaWVudCkucG9zdCh7XG4gICAgICAgICAgICB1cmw6IFwiL3B0eVwiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zPy5oZWFkZXJzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIFBUWSBzZXNzaW9uXG4gICAgICovXG4gICAgcmVtb3ZlKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLmRlbGV0ZSh7XG4gICAgICAgICAgICB1cmw6IFwiL3B0eS97aWR9XCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IFBUWSBzZXNzaW9uIGluZm9cbiAgICAgKi9cbiAgICBnZXQob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IHRoaXMuX2NsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIHVybDogXCIvcHR5L3tpZH1cIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgUFRZIHNlc3Npb25cbiAgICAgKi9cbiAgICB1cGRhdGUob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IHRoaXMuX2NsaWVudCkucHV0KHtcbiAgICAgICAgICAgIHVybDogXCIvcHR5L3tpZH1cIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbm5lY3QgdG8gYSBQVFkgc2Vzc2lvblxuICAgICAqL1xuICAgIGNvbm5lY3Qob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IHRoaXMuX2NsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIHVybDogXCIvcHR5L3tpZH0vY29ubmVjdFwiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgQ29uZmlnIGV4dGVuZHMgX0hleUFwaUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogR2V0IGNvbmZpZyBpbmZvXG4gICAgICovXG4gICAgZ2V0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zPy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgdXJsOiBcIi9jb25maWdcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgY29uZmlnXG4gICAgICovXG4gICAgdXBkYXRlKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zPy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5wYXRjaCh7XG4gICAgICAgICAgICB1cmw6IFwiL2NvbmZpZ1wiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zPy5oZWFkZXJzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3QgYWxsIHByb3ZpZGVyc1xuICAgICAqL1xuICAgIHByb3ZpZGVycyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucz8uY2xpZW50ID8/IHRoaXMuX2NsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIHVybDogXCIvY29uZmlnL3Byb3ZpZGVyc1wiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgVG9vbCBleHRlbmRzIF9IZXlBcGlDbGllbnQge1xuICAgIC8qKlxuICAgICAqIExpc3QgYWxsIHRvb2wgSURzIChpbmNsdWRpbmcgYnVpbHQtaW4gYW5kIGR5bmFtaWNhbGx5IHJlZ2lzdGVyZWQpXG4gICAgICovXG4gICAgaWRzKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zPy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgdXJsOiBcIi9leHBlcmltZW50YWwvdG9vbC9pZHNcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IHRvb2xzIHdpdGggSlNPTiBzY2hlbWEgcGFyYW1ldGVycyBmb3IgYSBwcm92aWRlci9tb2RlbFxuICAgICAqL1xuICAgIGxpc3Qob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IHRoaXMuX2NsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIHVybDogXCIvZXhwZXJpbWVudGFsL3Rvb2xcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIEluc3RhbmNlIGV4dGVuZHMgX0hleUFwaUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogRGlzcG9zZSB0aGUgY3VycmVudCBpbnN0YW5jZVxuICAgICAqL1xuICAgIGRpc3Bvc2Uob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnM/LmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgdXJsOiBcIi9pbnN0YW5jZS9kaXNwb3NlXCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBQYXRoIGV4dGVuZHMgX0hleUFwaUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHBhdGhcbiAgICAgKi9cbiAgICBnZXQob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnM/LmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLmdldCh7XG4gICAgICAgICAgICB1cmw6IFwiL3BhdGhcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFZjcyBleHRlbmRzIF9IZXlBcGlDbGllbnQge1xuICAgIC8qKlxuICAgICAqIEdldCBWQ1MgaW5mbyBmb3IgdGhlIGN1cnJlbnQgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBnZXQob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnM/LmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLmdldCh7XG4gICAgICAgICAgICB1cmw6IFwiL3Zjc1wiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuY2xhc3MgU2Vzc2lvbiBleHRlbmRzIF9IZXlBcGlDbGllbnQge1xuICAgIC8qKlxuICAgICAqIExpc3QgYWxsIHNlc3Npb25zXG4gICAgICovXG4gICAgbGlzdChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucz8uY2xpZW50ID8/IHRoaXMuX2NsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIHVybDogXCIvc2Vzc2lvblwiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBzZXNzaW9uXG4gICAgICovXG4gICAgY3JlYXRlKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zPy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIHVybDogXCIvc2Vzc2lvblwiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zPy5oZWFkZXJzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBzZXNzaW9uIHN0YXR1c1xuICAgICAqL1xuICAgIHN0YXR1cyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucz8uY2xpZW50ID8/IHRoaXMuX2NsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIHVybDogXCIvc2Vzc2lvbi9zdGF0dXNcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSBzZXNzaW9uIGFuZCBhbGwgaXRzIGRhdGFcbiAgICAgKi9cbiAgICBkZWxldGUob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IHRoaXMuX2NsaWVudCkuZGVsZXRlKHtcbiAgICAgICAgICAgIHVybDogXCIvc2Vzc2lvbi97aWR9XCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHNlc3Npb25cbiAgICAgKi9cbiAgICBnZXQob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IHRoaXMuX2NsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIHVybDogXCIvc2Vzc2lvbi97aWR9XCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHNlc3Npb24gcHJvcGVydGllc1xuICAgICAqL1xuICAgIHVwZGF0ZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5wYXRjaCh7XG4gICAgICAgICAgICB1cmw6IFwiL3Nlc3Npb24ve2lkfVwiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgc2Vzc2lvbidzIGNoaWxkcmVuXG4gICAgICovXG4gICAgY2hpbGRyZW4ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IHRoaXMuX2NsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIHVybDogXCIvc2Vzc2lvbi97aWR9L2NoaWxkcmVuXCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB0b2RvIGxpc3QgZm9yIGEgc2Vzc2lvblxuICAgICAqL1xuICAgIHRvZG8ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IHRoaXMuX2NsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIHVybDogXCIvc2Vzc2lvbi97aWR9L3RvZG9cIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbmFseXplIHRoZSBhcHAgYW5kIGNyZWF0ZSBhbiBBR0VOVFMubWQgZmlsZVxuICAgICAqL1xuICAgIGluaXQob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IHRoaXMuX2NsaWVudCkucG9zdCh7XG4gICAgICAgICAgICB1cmw6IFwiL3Nlc3Npb24ve2lkfS9pbml0XCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3JrIGFuIGV4aXN0aW5nIHNlc3Npb24gYXQgYSBzcGVjaWZpYyBtZXNzYWdlXG4gICAgICovXG4gICAgZm9yayhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIHVybDogXCIvc2Vzc2lvbi97aWR9L2ZvcmtcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFib3J0IGEgc2Vzc2lvblxuICAgICAqL1xuICAgIGFib3J0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgdXJsOiBcIi9zZXNzaW9uL3tpZH0vYWJvcnRcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnNoYXJlIHRoZSBzZXNzaW9uXG4gICAgICovXG4gICAgdW5zaGFyZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5kZWxldGUoe1xuICAgICAgICAgICAgdXJsOiBcIi9zZXNzaW9uL3tpZH0vc2hhcmVcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaGFyZSBhIHNlc3Npb25cbiAgICAgKi9cbiAgICBzaGFyZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIHVybDogXCIvc2Vzc2lvbi97aWR9L3NoYXJlXCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkaWZmIGZvciB0aGlzIHNlc3Npb25cbiAgICAgKi9cbiAgICBkaWZmKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLmdldCh7XG4gICAgICAgICAgICB1cmw6IFwiL3Nlc3Npb24ve2lkfS9kaWZmXCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3VtbWFyaXplIHRoZSBzZXNzaW9uXG4gICAgICovXG4gICAgc3VtbWFyaXplKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgdXJsOiBcIi9zZXNzaW9uL3tpZH0vc3VtbWFyaXplXCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IG1lc3NhZ2VzIGZvciBhIHNlc3Npb25cbiAgICAgKi9cbiAgICBtZXNzYWdlcyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgdXJsOiBcIi9zZXNzaW9uL3tpZH0vbWVzc2FnZVwiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbmQgc2VuZCBhIG5ldyBtZXNzYWdlIHRvIGEgc2Vzc2lvblxuICAgICAqL1xuICAgIHByb21wdChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIHVybDogXCIvc2Vzc2lvbi97aWR9L21lc3NhZ2VcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIG1lc3NhZ2UgZnJvbSBhIHNlc3Npb25cbiAgICAgKi9cbiAgICBtZXNzYWdlKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLmdldCh7XG4gICAgICAgICAgICB1cmw6IFwiL3Nlc3Npb24ve2lkfS9tZXNzYWdlL3ttZXNzYWdlSUR9XCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuZCBzZW5kIGEgbmV3IG1lc3NhZ2UgdG8gYSBzZXNzaW9uLCBzdGFydCBpZiBuZWVkZWQgYW5kIHJldHVybiBpbW1lZGlhdGVseVxuICAgICAqL1xuICAgIHByb21wdEFzeW5jKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgdXJsOiBcIi9zZXNzaW9uL3tpZH0vcHJvbXB0X2FzeW5jXCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgbmV3IGNvbW1hbmQgdG8gYSBzZXNzaW9uXG4gICAgICovXG4gICAgY29tbWFuZChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIHVybDogXCIvc2Vzc2lvbi97aWR9L2NvbW1hbmRcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1biBhIHNoZWxsIGNvbW1hbmRcbiAgICAgKi9cbiAgICBzaGVsbChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIHVybDogXCIvc2Vzc2lvbi97aWR9L3NoZWxsXCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXZlcnQgYSBtZXNzYWdlXG4gICAgICovXG4gICAgcmV2ZXJ0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgdXJsOiBcIi9zZXNzaW9uL3tpZH0vcmV2ZXJ0XCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlIGFsbCByZXZlcnRlZCBtZXNzYWdlc1xuICAgICAqL1xuICAgIHVucmV2ZXJ0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgdXJsOiBcIi9zZXNzaW9uL3tpZH0vdW5yZXZlcnRcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIENvbW1hbmQgZXh0ZW5kcyBfSGV5QXBpQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBMaXN0IGFsbCBjb21tYW5kc1xuICAgICAqL1xuICAgIGxpc3Qob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnM/LmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLmdldCh7XG4gICAgICAgICAgICB1cmw6IFwiL2NvbW1hbmRcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIE9hdXRoIGV4dGVuZHMgX0hleUFwaUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogQXV0aG9yaXplIGEgcHJvdmlkZXIgdXNpbmcgT0F1dGhcbiAgICAgKi9cbiAgICBhdXRob3JpemUob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IHRoaXMuX2NsaWVudCkucG9zdCh7XG4gICAgICAgICAgICB1cmw6IFwiL3Byb3ZpZGVyL3tpZH0vb2F1dGgvYXV0aG9yaXplXCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgT0F1dGggY2FsbGJhY2sgZm9yIGEgcHJvdmlkZXJcbiAgICAgKi9cbiAgICBjYWxsYmFjayhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIHVybDogXCIvcHJvdmlkZXIve2lkfS9vYXV0aC9jYWxsYmFja1wiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLmhlYWRlcnMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBQcm92aWRlciBleHRlbmRzIF9IZXlBcGlDbGllbnQge1xuICAgIC8qKlxuICAgICAqIExpc3QgYWxsIHByb3ZpZGVyc1xuICAgICAqL1xuICAgIGxpc3Qob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnM/LmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLmdldCh7XG4gICAgICAgICAgICB1cmw6IFwiL3Byb3ZpZGVyXCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHByb3ZpZGVyIGF1dGhlbnRpY2F0aW9uIG1ldGhvZHNcbiAgICAgKi9cbiAgICBhdXRoKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zPy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgdXJsOiBcIi9wcm92aWRlci9hdXRoXCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgb2F1dGggPSBuZXcgT2F1dGgoeyBjbGllbnQ6IHRoaXMuX2NsaWVudCB9KTtcbn1cbmNsYXNzIEZpbmQgZXh0ZW5kcyBfSGV5QXBpQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBGaW5kIHRleHQgaW4gZmlsZXNcbiAgICAgKi9cbiAgICB0ZXh0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLmdldCh7XG4gICAgICAgICAgICB1cmw6IFwiL2ZpbmRcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kIGZpbGVzXG4gICAgICovXG4gICAgZmlsZXMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IHRoaXMuX2NsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIHVybDogXCIvZmluZC9maWxlXCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCB3b3Jrc3BhY2Ugc3ltYm9sc1xuICAgICAqL1xuICAgIHN5bWJvbHMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IHRoaXMuX2NsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIHVybDogXCIvZmluZC9zeW1ib2xcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIEZpbGUgZXh0ZW5kcyBfSGV5QXBpQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBMaXN0IGZpbGVzIGFuZCBkaXJlY3Rvcmllc1xuICAgICAqL1xuICAgIGxpc3Qob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IHRoaXMuX2NsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIHVybDogXCIvZmlsZVwiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBmaWxlXG4gICAgICovXG4gICAgcmVhZChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5nZXQoe1xuICAgICAgICAgICAgdXJsOiBcIi9maWxlL2NvbnRlbnRcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZmlsZSBzdGF0dXNcbiAgICAgKi9cbiAgICBzdGF0dXMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnM/LmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLmdldCh7XG4gICAgICAgICAgICB1cmw6IFwiL2ZpbGUvc3RhdHVzXCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBBcHAgZXh0ZW5kcyBfSGV5QXBpQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBXcml0ZSBhIGxvZyBlbnRyeSB0byB0aGUgc2VydmVyIGxvZ3NcbiAgICAgKi9cbiAgICBsb2cob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnM/LmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgdXJsOiBcIi9sb2dcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucz8uaGVhZGVycyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IGFsbCBhZ2VudHNcbiAgICAgKi9cbiAgICBhZ2VudHMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnM/LmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLmdldCh7XG4gICAgICAgICAgICB1cmw6IFwiL2FnZW50XCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBBdXRoIGV4dGVuZHMgX0hleUFwaUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIE9BdXRoIGNyZWRlbnRpYWxzIGZvciBhbiBNQ1Agc2VydmVyXG4gICAgICovXG4gICAgcmVtb3ZlKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLmRlbGV0ZSh7XG4gICAgICAgICAgICB1cmw6IFwiL21jcC97bmFtZX0vYXV0aFwiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0IE9BdXRoIGF1dGhlbnRpY2F0aW9uIGZsb3cgZm9yIGFuIE1DUCBzZXJ2ZXJcbiAgICAgKi9cbiAgICBzdGFydChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIHVybDogXCIvbWNwL3tuYW1lfS9hdXRoXCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcGxldGUgT0F1dGggYXV0aGVudGljYXRpb24gd2l0aCBhdXRob3JpemF0aW9uIGNvZGVcbiAgICAgKi9cbiAgICBjYWxsYmFjayhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIHVybDogXCIvbWNwL3tuYW1lfS9hdXRoL2NhbGxiYWNrXCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCBPQXV0aCBmbG93IGFuZCB3YWl0IGZvciBjYWxsYmFjayAob3BlbnMgYnJvd3NlcilcbiAgICAgKi9cbiAgICBhdXRoZW50aWNhdGUob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IHRoaXMuX2NsaWVudCkucG9zdCh7XG4gICAgICAgICAgICB1cmw6IFwiL21jcC97bmFtZX0vYXV0aC9hdXRoZW50aWNhdGVcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgYXV0aGVudGljYXRpb24gY3JlZGVudGlhbHNcbiAgICAgKi9cbiAgICBzZXQob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnMuY2xpZW50ID8/IHRoaXMuX2NsaWVudCkucHV0KHtcbiAgICAgICAgICAgIHVybDogXCIvYXV0aC97aWR9XCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIE1jcCBleHRlbmRzIF9IZXlBcGlDbGllbnQge1xuICAgIC8qKlxuICAgICAqIEdldCBNQ1Agc2VydmVyIHN0YXR1c1xuICAgICAqL1xuICAgIHN0YXR1cyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucz8uY2xpZW50ID8/IHRoaXMuX2NsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIHVybDogXCIvbWNwXCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIE1DUCBzZXJ2ZXIgZHluYW1pY2FsbHlcbiAgICAgKi9cbiAgICBhZGQob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnM/LmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgdXJsOiBcIi9tY3BcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucz8uaGVhZGVycyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25uZWN0IGFuIE1DUCBzZXJ2ZXJcbiAgICAgKi9cbiAgICBjb25uZWN0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgdXJsOiBcIi9tY3Ave25hbWV9L2Nvbm5lY3RcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0IGFuIE1DUCBzZXJ2ZXJcbiAgICAgKi9cbiAgICBkaXNjb25uZWN0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgdXJsOiBcIi9tY3Ave25hbWV9L2Rpc2Nvbm5lY3RcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhdXRoID0gbmV3IEF1dGgoeyBjbGllbnQ6IHRoaXMuX2NsaWVudCB9KTtcbn1cbmNsYXNzIExzcCBleHRlbmRzIF9IZXlBcGlDbGllbnQge1xuICAgIC8qKlxuICAgICAqIEdldCBMU1Agc2VydmVyIHN0YXR1c1xuICAgICAqL1xuICAgIHN0YXR1cyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucz8uY2xpZW50ID8/IHRoaXMuX2NsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIHVybDogXCIvbHNwXCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBGb3JtYXR0ZXIgZXh0ZW5kcyBfSGV5QXBpQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBHZXQgZm9ybWF0dGVyIHN0YXR1c1xuICAgICAqL1xuICAgIHN0YXR1cyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucz8uY2xpZW50ID8/IHRoaXMuX2NsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIHVybDogXCIvZm9ybWF0dGVyXCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBDb250cm9sIGV4dGVuZHMgX0hleUFwaUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuZXh0IFRVSSByZXF1ZXN0IGZyb20gdGhlIHF1ZXVlXG4gICAgICovXG4gICAgbmV4dChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucz8uY2xpZW50ID8/IHRoaXMuX2NsaWVudCkuZ2V0KHtcbiAgICAgICAgICAgIHVybDogXCIvdHVpL2NvbnRyb2wvbmV4dFwiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1Ym1pdCBhIHJlc3BvbnNlIHRvIHRoZSBUVUkgcmVxdWVzdCBxdWV1ZVxuICAgICAqL1xuICAgIHJlc3BvbnNlKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zPy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIHVybDogXCIvdHVpL2NvbnRyb2wvcmVzcG9uc2VcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucz8uaGVhZGVycyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFR1aSBleHRlbmRzIF9IZXlBcGlDbGllbnQge1xuICAgIC8qKlxuICAgICAqIEFwcGVuZCBwcm9tcHQgdG8gdGhlIFRVSVxuICAgICAqL1xuICAgIGFwcGVuZFByb21wdChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucz8uY2xpZW50ID8/IHRoaXMuX2NsaWVudCkucG9zdCh7XG4gICAgICAgICAgICB1cmw6IFwiL3R1aS9hcHBlbmQtcHJvbXB0XCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnM/LmhlYWRlcnMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3BlbiB0aGUgaGVscCBkaWFsb2dcbiAgICAgKi9cbiAgICBvcGVuSGVscChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucz8uY2xpZW50ID8/IHRoaXMuX2NsaWVudCkucG9zdCh7XG4gICAgICAgICAgICB1cmw6IFwiL3R1aS9vcGVuLWhlbHBcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVuIHRoZSBzZXNzaW9uIGRpYWxvZ1xuICAgICAqL1xuICAgIG9wZW5TZXNzaW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucz8uY2xpZW50ID8/IHRoaXMuX2NsaWVudCkucG9zdCh7XG4gICAgICAgICAgICB1cmw6IFwiL3R1aS9vcGVuLXNlc3Npb25zXCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3BlbiB0aGUgdGhlbWUgZGlhbG9nXG4gICAgICovXG4gICAgb3BlblRoZW1lcyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucz8uY2xpZW50ID8/IHRoaXMuX2NsaWVudCkucG9zdCh7XG4gICAgICAgICAgICB1cmw6IFwiL3R1aS9vcGVuLXRoZW1lc1wiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW4gdGhlIG1vZGVsIGRpYWxvZ1xuICAgICAqL1xuICAgIG9wZW5Nb2RlbHMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnM/LmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgdXJsOiBcIi90dWkvb3Blbi1tb2RlbHNcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJtaXQgdGhlIHByb21wdFxuICAgICAqL1xuICAgIHN1Ym1pdFByb21wdChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucz8uY2xpZW50ID8/IHRoaXMuX2NsaWVudCkucG9zdCh7XG4gICAgICAgICAgICB1cmw6IFwiL3R1aS9zdWJtaXQtcHJvbXB0XCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXIgdGhlIHByb21wdFxuICAgICAqL1xuICAgIGNsZWFyUHJvbXB0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zPy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIHVybDogXCIvdHVpL2NsZWFyLXByb21wdFwiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4ZWN1dGUgYSBUVUkgY29tbWFuZCAoZS5nLiBhZ2VudF9jeWNsZSlcbiAgICAgKi9cbiAgICBleGVjdXRlQ29tbWFuZChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucz8uY2xpZW50ID8/IHRoaXMuX2NsaWVudCkucG9zdCh7XG4gICAgICAgICAgICB1cmw6IFwiL3R1aS9leGVjdXRlLWNvbW1hbmRcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucz8uaGVhZGVycyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93IGEgdG9hc3Qgbm90aWZpY2F0aW9uIGluIHRoZSBUVUlcbiAgICAgKi9cbiAgICBzaG93VG9hc3Qob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gKG9wdGlvbnM/LmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgdXJsOiBcIi90dWkvc2hvdy10b2FzdFwiLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zPy5oZWFkZXJzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1Ymxpc2ggYSBUVUkgZXZlbnRcbiAgICAgKi9cbiAgICBwdWJsaXNoKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zPy5jbGllbnQgPz8gdGhpcy5fY2xpZW50KS5wb3N0KHtcbiAgICAgICAgICAgIHVybDogXCIvdHVpL3B1Ymxpc2hcIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucz8uaGVhZGVycyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb250cm9sID0gbmV3IENvbnRyb2woeyBjbGllbnQ6IHRoaXMuX2NsaWVudCB9KTtcbn1cbmNsYXNzIEV2ZW50IGV4dGVuZHMgX0hleUFwaUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogR2V0IGV2ZW50c1xuICAgICAqL1xuICAgIHN1YnNjcmliZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiAob3B0aW9ucz8uY2xpZW50ID8/IHRoaXMuX2NsaWVudCkuZ2V0LnNzZSh7XG4gICAgICAgICAgICB1cmw6IFwiL2V2ZW50XCIsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgT3BlbmNvZGVDbGllbnQgZXh0ZW5kcyBfSGV5QXBpQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBSZXNwb25kIHRvIGEgcGVybWlzc2lvbiByZXF1ZXN0XG4gICAgICovXG4gICAgcG9zdFNlc3Npb25JZFBlcm1pc3Npb25zUGVybWlzc2lvbklkKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIChvcHRpb25zLmNsaWVudCA/PyB0aGlzLl9jbGllbnQpLnBvc3Qoe1xuICAgICAgICAgICAgdXJsOiBcIi9zZXNzaW9uL3tpZH0vcGVybWlzc2lvbnMve3Blcm1pc3Npb25JRH1cIixcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdsb2JhbCA9IG5ldyBHbG9iYWwoeyBjbGllbnQ6IHRoaXMuX2NsaWVudCB9KTtcbiAgICBwcm9qZWN0ID0gbmV3IFByb2plY3QoeyBjbGllbnQ6IHRoaXMuX2NsaWVudCB9KTtcbiAgICBwdHkgPSBuZXcgUHR5KHsgY2xpZW50OiB0aGlzLl9jbGllbnQgfSk7XG4gICAgY29uZmlnID0gbmV3IENvbmZpZyh7IGNsaWVudDogdGhpcy5fY2xpZW50IH0pO1xuICAgIHRvb2wgPSBuZXcgVG9vbCh7IGNsaWVudDogdGhpcy5fY2xpZW50IH0pO1xuICAgIGluc3RhbmNlID0gbmV3IEluc3RhbmNlKHsgY2xpZW50OiB0aGlzLl9jbGllbnQgfSk7XG4gICAgcGF0aCA9IG5ldyBQYXRoKHsgY2xpZW50OiB0aGlzLl9jbGllbnQgfSk7XG4gICAgdmNzID0gbmV3IFZjcyh7IGNsaWVudDogdGhpcy5fY2xpZW50IH0pO1xuICAgIHNlc3Npb24gPSBuZXcgU2Vzc2lvbih7IGNsaWVudDogdGhpcy5fY2xpZW50IH0pO1xuICAgIGNvbW1hbmQgPSBuZXcgQ29tbWFuZCh7IGNsaWVudDogdGhpcy5fY2xpZW50IH0pO1xuICAgIHByb3ZpZGVyID0gbmV3IFByb3ZpZGVyKHsgY2xpZW50OiB0aGlzLl9jbGllbnQgfSk7XG4gICAgZmluZCA9IG5ldyBGaW5kKHsgY2xpZW50OiB0aGlzLl9jbGllbnQgfSk7XG4gICAgZmlsZSA9IG5ldyBGaWxlKHsgY2xpZW50OiB0aGlzLl9jbGllbnQgfSk7XG4gICAgYXBwID0gbmV3IEFwcCh7IGNsaWVudDogdGhpcy5fY2xpZW50IH0pO1xuICAgIG1jcCA9IG5ldyBNY3AoeyBjbGllbnQ6IHRoaXMuX2NsaWVudCB9KTtcbiAgICBsc3AgPSBuZXcgTHNwKHsgY2xpZW50OiB0aGlzLl9jbGllbnQgfSk7XG4gICAgZm9ybWF0dGVyID0gbmV3IEZvcm1hdHRlcih7IGNsaWVudDogdGhpcy5fY2xpZW50IH0pO1xuICAgIHR1aSA9IG5ldyBUdWkoeyBjbGllbnQ6IHRoaXMuX2NsaWVudCB9KTtcbiAgICBhdXRoID0gbmV3IEF1dGgoeyBjbGllbnQ6IHRoaXMuX2NsaWVudCB9KTtcbiAgICBldmVudCA9IG5ldyBFdmVudCh7IGNsaWVudDogdGhpcy5fY2xpZW50IH0pO1xufVxuIiwKICAgICJleHBvcnQgKiBmcm9tIFwiLi9nZW4vdHlwZXMuZ2VuLmpzXCI7XG5pbXBvcnQgeyBjcmVhdGVDbGllbnQgfSBmcm9tIFwiLi9nZW4vY2xpZW50L2NsaWVudC5nZW4uanNcIjtcbmltcG9ydCB7IE9wZW5jb2RlQ2xpZW50IH0gZnJvbSBcIi4vZ2VuL3Nkay5nZW4uanNcIjtcbmV4cG9ydCB7IE9wZW5jb2RlQ2xpZW50IH07XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlT3BlbmNvZGVDbGllbnQoY29uZmlnKSB7XG4gICAgaWYgKCFjb25maWc/LmZldGNoKSB7XG4gICAgICAgIGNvbnN0IGN1c3RvbUZldGNoID0gKHJlcSkgPT4ge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgcmVxLnRpbWVvdXQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBmZXRjaChyZXEpO1xuICAgICAgICB9O1xuICAgICAgICBjb25maWcgPSB7XG4gICAgICAgICAgICAuLi5jb25maWcsXG4gICAgICAgICAgICBmZXRjaDogY3VzdG9tRmV0Y2gsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChjb25maWc/LmRpcmVjdG9yeSkge1xuICAgICAgICBjb25maWcuaGVhZGVycyA9IHtcbiAgICAgICAgICAgIC4uLmNvbmZpZy5oZWFkZXJzLFxuICAgICAgICAgICAgXCJ4LW9wZW5jb2RlLWRpcmVjdG9yeVwiOiBjb25maWcuZGlyZWN0b3J5LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBjbGllbnQgPSBjcmVhdGVDbGllbnQoY29uZmlnKTtcbiAgICByZXR1cm4gbmV3IE9wZW5jb2RlQ2xpZW50KHsgY2xpZW50IH0pO1xufVxuIiwKICAgICJpbXBvcnQgeyBzcGF3biB9IGZyb20gXCJub2RlOmNoaWxkX3Byb2Nlc3NcIjtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVPcGVuY29kZVNlcnZlcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBob3N0bmFtZTogXCIxMjcuMC4wLjFcIixcbiAgICAgICAgcG9ydDogNDA5NixcbiAgICAgICAgdGltZW91dDogNTAwMCxcbiAgICB9LCBvcHRpb25zID8/IHt9KTtcbiAgICBjb25zdCBhcmdzID0gW2BzZXJ2ZWAsIGAtLWhvc3RuYW1lPSR7b3B0aW9ucy5ob3N0bmFtZX1gLCBgLS1wb3J0PSR7b3B0aW9ucy5wb3J0fWBdO1xuICAgIGlmIChvcHRpb25zLmNvbmZpZz8ubG9nTGV2ZWwpXG4gICAgICAgIGFyZ3MucHVzaChgLS1sb2ctbGV2ZWw9JHtvcHRpb25zLmNvbmZpZy5sb2dMZXZlbH1gKTtcbiAgICBjb25zdCBwcm9jID0gc3Bhd24oYG9wZW5jb2RlYCwgYXJncywge1xuICAgICAgICBzaWduYWw6IG9wdGlvbnMuc2lnbmFsLFxuICAgICAgICBlbnY6IHtcbiAgICAgICAgICAgIC4uLnByb2Nlc3MuZW52LFxuICAgICAgICAgICAgT1BFTkNPREVfQ09ORklHX0NPTlRFTlQ6IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuY29uZmlnID8/IHt9KSxcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBjb25zdCB1cmwgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGlkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBUaW1lb3V0IHdhaXRpbmcgZm9yIHNlcnZlciB0byBzdGFydCBhZnRlciAke29wdGlvbnMudGltZW91dH1tc2ApKTtcbiAgICAgICAgfSwgb3B0aW9ucy50aW1lb3V0KTtcbiAgICAgICAgbGV0IG91dHB1dCA9IFwiXCI7XG4gICAgICAgIHByb2Muc3Rkb3V0Py5vbihcImRhdGFcIiwgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICBvdXRwdXQgKz0gY2h1bmsudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gb3V0cHV0LnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUuc3RhcnRzV2l0aChcIm9wZW5jb2RlIHNlcnZlciBsaXN0ZW5pbmdcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSBsaW5lLm1hdGNoKC9vblxccysoaHR0cHM/OlxcL1xcL1teXFxzXSspLyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHNlcnZlciB1cmwgZnJvbSBvdXRwdXQ6ICR7bGluZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoaWQpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG1hdGNoWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHByb2Muc3RkZXJyPy5vbihcImRhdGFcIiwgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICBvdXRwdXQgKz0gY2h1bmsudG9TdHJpbmcoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByb2Mub24oXCJleGl0XCIsIChjb2RlKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoaWQpO1xuICAgICAgICAgICAgbGV0IG1zZyA9IGBTZXJ2ZXIgZXhpdGVkIHdpdGggY29kZSAke2NvZGV9YDtcbiAgICAgICAgICAgIGlmIChvdXRwdXQudHJpbSgpKSB7XG4gICAgICAgICAgICAgICAgbXNnICs9IGBcXG5TZXJ2ZXIgb3V0cHV0OiAke291dHB1dH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihtc2cpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByb2Mub24oXCJlcnJvclwiLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2lnbmFsKSB7XG4gICAgICAgICAgICBvcHRpb25zLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkFib3J0ZWRcIikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICB1cmwsXG4gICAgICAgIGNsb3NlKCkge1xuICAgICAgICAgICAgcHJvYy5raWxsKCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPcGVuY29kZVR1aShvcHRpb25zKSB7XG4gICAgY29uc3QgYXJncyA9IFtdO1xuICAgIGlmIChvcHRpb25zPy5wcm9qZWN0KSB7XG4gICAgICAgIGFyZ3MucHVzaChgLS1wcm9qZWN0PSR7b3B0aW9ucy5wcm9qZWN0fWApO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucz8ubW9kZWwpIHtcbiAgICAgICAgYXJncy5wdXNoKGAtLW1vZGVsPSR7b3B0aW9ucy5tb2RlbH1gKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnM/LnNlc3Npb24pIHtcbiAgICAgICAgYXJncy5wdXNoKGAtLXNlc3Npb249JHtvcHRpb25zLnNlc3Npb259YCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zPy5hZ2VudCkge1xuICAgICAgICBhcmdzLnB1c2goYC0tYWdlbnQ9JHtvcHRpb25zLmFnZW50fWApO1xuICAgIH1cbiAgICBjb25zdCBwcm9jID0gc3Bhd24oYG9wZW5jb2RlYCwgYXJncywge1xuICAgICAgICBzaWduYWw6IG9wdGlvbnM/LnNpZ25hbCxcbiAgICAgICAgc3RkaW86IFwiaW5oZXJpdFwiLFxuICAgICAgICBlbnY6IHtcbiAgICAgICAgICAgIC4uLnByb2Nlc3MuZW52LFxuICAgICAgICAgICAgT1BFTkNPREVfQ09ORklHX0NPTlRFTlQ6IEpTT04uc3RyaW5naWZ5KG9wdGlvbnM/LmNvbmZpZyA/PyB7fSksXG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgICAgICBwcm9jLmtpbGwoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuIiwKICAgICJleHBvcnQgKiBmcm9tIFwiLi9jbGllbnQuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3NlcnZlci5qc1wiO1xuaW1wb3J0IHsgY3JlYXRlT3BlbmNvZGVDbGllbnQgfSBmcm9tIFwiLi9jbGllbnQuanNcIjtcbmltcG9ydCB7IGNyZWF0ZU9wZW5jb2RlU2VydmVyIH0gZnJvbSBcIi4vc2VydmVyLmpzXCI7XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlT3BlbmNvZGUob3B0aW9ucykge1xuICAgIGNvbnN0IHNlcnZlciA9IGF3YWl0IGNyZWF0ZU9wZW5jb2RlU2VydmVyKHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICB9KTtcbiAgICBjb25zdCBjbGllbnQgPSBjcmVhdGVPcGVuY29kZUNsaWVudCh7XG4gICAgICAgIGJhc2VVcmw6IHNlcnZlci51cmwsXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2xpZW50LFxuICAgICAgICBzZXJ2ZXIsXG4gICAgfTtcbn1cbiIsCiAgICAiLyoqXG4gKiBSYWxwaCBMb29wIFJ1bm5lciAtIEJhc2gtbG9vcCBzdHlsZSBpdGVyYXRpb24gd2l0aCBmcmVzaCBjb250ZXh0IHBlciBjeWNsZVxuICpcbiAqIEltcGxlbWVudHMgdGhlIG9yaWdpbmFsIFJhbHBoIFdpZ2d1bSB2aXNpb246XG4gKiAtIEZyZXNoIE9wZW5Db2RlIHNlc3Npb24gcGVyIGl0ZXJhdGlvbiAobm8gdHJhbnNjcmlwdCBjYXJyeS1vdmVyKVxuICogLSBGaWxlIEkvTyBhcyBzdGF0ZSAoLmFpLWVuZy9ydW5zLzxydW5JZD4vLmZsb3cpXG4gKiAtIERldGVybWluaXN0aWMgcmUtYW5jaG9yaW5nIGZyb20gZGlzayBzdGF0ZSBlYWNoIGN5Y2xlXG4gKiAtIE11bHRpLXBoYXNlIHdvcmtmbG93IChyZXNlYXJjaCDihpIgc3BlY2lmeSDihpIgcGxhbiDihpIgd29yayDihpIgcmV2aWV3KVxuICogLSBRdWFsaXR5IGdhdGVzIHRoYXQgYmxvY2sgdW50aWwgcGFzc2VkXG4gKi9cblxuaW1wb3J0IHsgZXhlY1N5bmMgfSBmcm9tIFwibm9kZTpjaGlsZF9wcm9jZXNzXCI7XG5pbXBvcnQgeyBjcmVhdGVIYXNoIH0gZnJvbSBcIm5vZGU6Y3J5cHRvXCI7XG5pbXBvcnQgeyByZWFkRmlsZSwgcmVhZGRpciB9IGZyb20gXCJub2RlOmZzL3Byb21pc2VzXCI7XG5pbXBvcnQgeyBqb2luLCBwYXJzZSB9IGZyb20gXCJub2RlOnBhdGhcIjtcbmltcG9ydCB7IE9wZW5Db2RlQ2xpZW50LCB0eXBlIFNlc3Npb24gfSBmcm9tIFwiLi4vYmFja2VuZHMvb3BlbmNvZGUvY2xpZW50XCI7XG5pbXBvcnQgdHlwZSB7IFJhbHBoRmxhZ3MgfSBmcm9tIFwiLi4vY2xpL2ZsYWdzXCI7XG5pbXBvcnQgeyBVSSB9IGZyb20gXCIuLi9jbGkvdWlcIjtcbmltcG9ydCB0eXBlIHsgQWlFbmdDb25maWcsIEdhdGVDb21tYW5kQ29uZmlnIH0gZnJvbSBcIi4uL2NvbmZpZy9zY2hlbWFcIjtcbmltcG9ydCB7IFByb21wdE9wdGltaXplciB9IGZyb20gXCIuLi9wcm9tcHQtb3B0aW1pemF0aW9uL29wdGltaXplclwiO1xuaW1wb3J0IHR5cGUgeyBEaXNjb3JkV2ViaG9va0NsaWVudCB9IGZyb20gXCIuLi91dGlsL2Rpc2NvcmQtd2ViaG9va1wiO1xuaW1wb3J0IHsgY3JlYXRlRGlzY29yZFdlYmhvb2tGcm9tRW52IH0gZnJvbSBcIi4uL3V0aWwvZGlzY29yZC13ZWJob29rXCI7XG5pbXBvcnQgeyBMb2cgfSBmcm9tIFwiLi4vdXRpbC9sb2dcIjtcbmltcG9ydCB7IEZsb3dTdG9yZSwgdHlwZSBGbG93U3RvcmVPcHRpb25zIH0gZnJvbSBcIi4vZmxvdy1zdG9yZVwiO1xuaW1wb3J0IHR5cGUge1xuICAgIEN5Y2xlU3RhdGUsXG4gICAgR2F0ZVJlc3VsdCxcbiAgICBMb29wQ29uZmlnLFxuICAgIFRvb2xJbnZvY2F0aW9uLFxufSBmcm9tIFwiLi9mbG93LXR5cGVzXCI7XG5pbXBvcnQge1xuICAgIEZMT1dfU0NIRU1BX1ZFUlNJT04sXG4gICAgUGhhc2UsXG4gICAgUnVuU3RhdHVzLFxuICAgIFN0b3BSZWFzb24sXG59IGZyb20gXCIuL2Zsb3ctdHlwZXNcIjtcblxuY29uc3QgbG9nID0gTG9nLmNyZWF0ZSh7IHNlcnZpY2U6IFwicmFscGgtbG9vcFwiIH0pO1xuXG4vKiogRGVmYXVsdCBxdWFsaXR5IGdhdGVzICovXG5jb25zdCBERUZBVUxUX0dBVEVTID0gW1widGVzdFwiLCBcImxpbnRcIiwgXCJhY2NlcHRhbmNlXCJdO1xuXG4vKiogRGVmYXVsdCBtYXggY3ljbGVzICovXG5jb25zdCBERUZBVUxUX01BWF9DWUNMRVMgPSA1MDtcblxuLyoqIERlZmF1bHQgc3R1Y2sgdGhyZXNob2xkICovXG5jb25zdCBERUZBVUxUX1NUVUNLX1RIUkVTSE9MRCA9IDU7XG5cbi8qKiBEZWZhdWx0IGNoZWNrcG9pbnQgZnJlcXVlbmN5ICovXG5jb25zdCBERUZBVUxUX0NIRUNLUE9JTlRfRlJFUVVFTkNZID0gMTtcblxuLyoqIERlZmF1bHQgY3ljbGUgcmV0cmllcyAqL1xuY29uc3QgREVGQVVMVF9DWUNMRV9SRVRSSUVTID0gMjtcblxuLyoqIFNlY3JldHMgcGF0dGVybnMgdG8gcmVkYWN0IGluIGRlYnVnIG91dHB1dCAqL1xuY29uc3QgU0VDUkVUX1BBVFRFUk5TID0gW1xuICAgIC9hcGlbXy1dP2tleS9pLFxuICAgIC90b2tlbi9pLFxuICAgIC9zZWNyZXQvaSxcbiAgICAvcGFzc3dvcmQvaSxcbiAgICAvY3JlZGVudGlhbC9pLFxuICAgIC93ZWJob29rL2ksXG4gICAgL2F1dGgvaSxcbiAgICAvYmVhcmVyL2ksXG4gICAgL3ByaXZhdGVbXy1dP2tleS9pLFxuXTtcblxuLyoqXG4gKiBSZWRhY3Qgc2VjcmV0cyBmcm9tIGEgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIHJlZGFjdFNlY3JldHModGV4dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGxldCByZXN1bHQgPSB0ZXh0O1xuICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiBTRUNSRVRfUEFUVEVSTlMpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoXG4gICAgICAgICAgICBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgIGAke3BhdHRlcm4uc291cmNlfVtcIiddP1xcXFxzKls6PV1cXFxccypbXCInXT8oW15cIidcIixcXFxcc10rKWAsXG4gICAgICAgICAgICAgICAgXCJnaVwiLFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGAke3BhdHRlcm4uc291cmNlfT1cIltSRURBQ1RFRF1cImAsXG4gICAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVHJ1bmNhdGUgbG9uZyBvdXRwdXQgZm9yIGxvZ2dpbmdcbiAqL1xuZnVuY3Rpb24gdHJ1bmNhdGVPdXRwdXQodGV4dDogc3RyaW5nLCBtYXhMZW5ndGggPSAxMDAwKTogc3RyaW5nIHtcbiAgICBpZiAodGV4dC5sZW5ndGggPD0gbWF4TGVuZ3RoKSByZXR1cm4gdGV4dDtcbiAgICByZXR1cm4gYCR7dGV4dC5zdWJzdHJpbmcoMCwgbWF4TGVuZ3RoKX1cXG4uLi4gW3RydW5jYXRlZCAke3RleHQubGVuZ3RoIC0gbWF4TGVuZ3RofSBjaGFyc11gO1xufVxuXG4vKipcbiAqIFJhbHBoIExvb3AgUnVubmVyIC0gb3JjaGVzdHJhdGVzIGl0ZXJhdGlvbiBsb29wcyB3aXRoIGZyZXNoIHNlc3Npb25zXG4gKi9cbmV4cG9ydCBjbGFzcyBSYWxwaExvb3BSdW5uZXIge1xuICAgIHByaXZhdGUgY29uZmlnOiBMb29wQ29uZmlnO1xuICAgIHByaXZhdGUgZmxvd1N0b3JlOiBGbG93U3RvcmU7XG4gICAgcHJpdmF0ZSBmbGFnczogUmFscGhGbGFncztcbiAgICBwcml2YXRlIGJhc2VDb25maWc6IEFpRW5nQ29uZmlnO1xuICAgIHByaXZhdGUgb3B0aW1pemVyOiBQcm9tcHRPcHRpbWl6ZXI7XG4gICAgcHJpdmF0ZSBkaXNjb3JkV2ViaG9vazogRGlzY29yZFdlYmhvb2tDbGllbnQgfCBudWxsO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIGZsYWdzOiBSYWxwaEZsYWdzLFxuICAgICAgICBiYXNlQ29uZmlnOiBBaUVuZ0NvbmZpZyxcbiAgICAgICAgb3B0aW1pemVyOiBQcm9tcHRPcHRpbWl6ZXIsXG4gICAgKSB7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICAgICAgdGhpcy5iYXNlQ29uZmlnID0gYmFzZUNvbmZpZztcbiAgICAgICAgdGhpcy5vcHRpbWl6ZXIgPSBvcHRpbWl6ZXI7XG5cbiAgICAgICAgLy8gQnVpbGQgbG9vcCBjb25maWcgZnJvbSBmbGFnc1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHRoaXMuYnVpbGRMb29wQ29uZmlnKCk7XG4gICAgICAgIGNvbnN0IGZsb3dTdG9yZU9wdGlvbnM6IEZsb3dTdG9yZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICBmbG93RGlyOiB0aGlzLmNvbmZpZy5mbG93RGlyLFxuICAgICAgICAgICAgcnVuSWQ6IHRoaXMuY29uZmlnLnJ1bklkLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZsb3dTdG9yZSA9IG5ldyBGbG93U3RvcmUoZmxvd1N0b3JlT3B0aW9ucyk7XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBEaXNjb3JkIHdlYmhvb2sgZnJvbSBlbnZpcm9ubWVudFxuICAgICAgICB0aGlzLmRpc2NvcmRXZWJob29rID0gY3JlYXRlRGlzY29yZFdlYmhvb2tGcm9tRW52KCk7XG4gICAgfVxuXG4gICAgLyoqIEJ1aWxkIGxvb3AgY29uZmlnIGZyb20gZmxhZ3MgKi9cbiAgICBwcml2YXRlIGJ1aWxkTG9vcENvbmZpZygpOiBMb29wQ29uZmlnIHtcbiAgICAgICAgLy8gRGV0ZXJtaW5lIGNvbXBsZXRpb24gcHJvbWlzZSBiYXNlZCBvbiBtb2RlXG4gICAgICAgIGxldCBjb21wbGV0aW9uUHJvbWlzZSA9IHRoaXMuZmxhZ3MuY29tcGxldGlvblByb21pc2UgPz8gXCJcIjtcblxuICAgICAgICBpZiAodGhpcy5mbGFncy5zaGlwKSB7XG4gICAgICAgICAgICAvLyBTaGlwIG1vZGU6IGF1dG8tZXhpdCB3aGVuIGFnZW50IG91dHB1dHMgU0hJUFxuICAgICAgICAgICAgY29tcGxldGlvblByb21pc2UgPSBcIjxwcm9taXNlPlNISVA8L3Byb21pc2U+XCI7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5mbGFncy5kcmFmdCkge1xuICAgICAgICAgICAgLy8gRHJhZnQgbW9kZTogcnVuIGZvciBtYXgtY3ljbGVzLCBzdG9wIGZvciByZXZpZXcgKG5vIGF1dG8tZXhpdClcbiAgICAgICAgICAgIGNvbXBsZXRpb25Qcm9taXNlID0gXCJcIjtcbiAgICAgICAgfSBlbHNlIGlmICghY29tcGxldGlvblByb21pc2UpIHtcbiAgICAgICAgICAgIC8vIE5vIGZsYWcgc3BlY2lmaWVkIGFuZCBubyBjb21wbGV0aW9uIHByb21pc2U6IGRlZmF1bHQgdG8gZHJhZnQgbW9kZVxuICAgICAgICAgICAgY29tcGxldGlvblByb21pc2UgPSBcIlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2VuZXJhdGUgcnVuIElEIGlmIG5vdCByZXN1bWluZ1xuICAgICAgICBsZXQgcnVuSWQgPSB0aGlzLmZsYWdzLnJ1bklkO1xuICAgICAgICBpZiAoIXJ1bklkKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgZXhpc3RpbmcgZmxvdyBzdGF0ZVxuICAgICAgICAgICAgY29uc3QgZGVmYXVsdFJ1bklkID0gdGhpcy5nZW5lcmF0ZVJ1bklkKCk7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0Rmxvd0RpciA9IHRoaXMuZ2V0RGVmYXVsdEZsb3dEaXIoZGVmYXVsdFJ1bklkKTtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrU3RvcmUgPSBuZXcgRmxvd1N0b3JlKHtcbiAgICAgICAgICAgICAgICBmbG93RGlyOiB0aGlzLmZsYWdzLndvcmtpbmdEaXJcbiAgICAgICAgICAgICAgICAgICAgPyBqb2luKHRoaXMuZmxhZ3Mud29ya2luZ0RpciwgXCIuYWktZW5nXCIpXG4gICAgICAgICAgICAgICAgICAgIDogXCIuYWktZW5nXCIsXG4gICAgICAgICAgICAgICAgcnVuSWQ6IGRlZmF1bHRSdW5JZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcnVuSWQgPSBkZWZhdWx0UnVuSWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcnVuSWQsXG4gICAgICAgICAgICBwcm9tcHQ6IHRoaXMuZmxhZ3Mud29ya2Zsb3cgPz8gXCJcIixcbiAgICAgICAgICAgIGNvbXBsZXRpb25Qcm9taXNlLFxuICAgICAgICAgICAgbWF4Q3ljbGVzOiB0aGlzLmZsYWdzLm1heEN5Y2xlcyA/PyBERUZBVUxUX01BWF9DWUNMRVMsXG4gICAgICAgICAgICBzdHVja1RocmVzaG9sZDpcbiAgICAgICAgICAgICAgICB0aGlzLmZsYWdzLnN0dWNrVGhyZXNob2xkID8/IERFRkFVTFRfU1RVQ0tfVEhSRVNIT0xELFxuICAgICAgICAgICAgZ2F0ZXM6IHRoaXMuZmxhZ3MuZ2F0ZXMgPz8gREVGQVVMVF9HQVRFUyxcbiAgICAgICAgICAgIGNoZWNrcG9pbnRGcmVxdWVuY3k6XG4gICAgICAgICAgICAgICAgdGhpcy5mbGFncy5jaGVja3BvaW50RnJlcXVlbmN5ID8/IERFRkFVTFRfQ0hFQ0tQT0lOVF9GUkVRVUVOQ1ksXG4gICAgICAgICAgICBmbG93RGlyOiB0aGlzLmdldERlZmF1bHRGbG93RGlyKHJ1bklkKSxcbiAgICAgICAgICAgIGRyeVJ1bjogdGhpcy5mbGFncy5kcnlSdW4gPz8gZmFsc2UsXG4gICAgICAgICAgICBjeWNsZVJldHJpZXM6XG4gICAgICAgICAgICAgICAgdGhpcy5iYXNlQ29uZmlnLmxvb3A/LmN5Y2xlUmV0cmllcyA/PyBERUZBVUxUX0NZQ0xFX1JFVFJJRVMsXG4gICAgICAgICAgICBkZWJ1Z1dvcms6XG4gICAgICAgICAgICAgICAgdGhpcy5mbGFncy5kZWJ1Z1dvcmsgPz8gdGhpcy5iYXNlQ29uZmlnLmRlYnVnPy53b3JrID8/IGZhbHNlLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKiBHZXQgZGVmYXVsdCBmbG93IGRpcmVjdG9yeSBwYXRoICovXG4gICAgcHJpdmF0ZSBnZXREZWZhdWx0Rmxvd0RpcihydW5JZDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgYXJ0aWZhY3RzRGlyID0gdGhpcy5iYXNlQ29uZmlnLnJ1bm5lci5hcnRpZmFjdHNEaXI7XG4gICAgICAgIGlmICh0aGlzLmZsYWdzLndvcmtpbmdEaXIpIHtcbiAgICAgICAgICAgIHJldHVybiBqb2luKHRoaXMuZmxhZ3Mud29ya2luZ0RpciwgYXJ0aWZhY3RzRGlyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gam9pbihwcm9jZXNzLmN3ZCgpLCBhcnRpZmFjdHNEaXIpO1xuICAgIH1cblxuICAgIC8qKiBHZW5lcmF0ZSBhIHVuaXF1ZSBydW4gSUQgKi9cbiAgICBwcml2YXRlIGdlbmVyYXRlUnVuSWQoKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gRGF0ZS5ub3coKS50b1N0cmluZygzNik7XG4gICAgICAgIGNvbnN0IHJhbmRvbSA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCA4KTtcbiAgICAgICAgcmV0dXJuIGBydW4tJHt0aW1lc3RhbXB9LSR7cmFuZG9tfWA7XG4gICAgfVxuXG4gICAgLyoqIEdlbmVyYXRlIGEgaGFzaCBvZiBvdXRwdXQgZm9yIHN0dWNrIGRldGVjdGlvbiAqL1xuICAgIHByaXZhdGUgaGFzaE91dHB1dChvdXRwdXQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBjcmVhdGVIYXNoKFwic2hhMjU2XCIpXG4gICAgICAgICAgICAudXBkYXRlKG91dHB1dClcbiAgICAgICAgICAgIC5kaWdlc3QoXCJoZXhcIilcbiAgICAgICAgICAgIC5zdWJzdHJpbmcoMCwgMTYpO1xuICAgIH1cblxuICAgIC8qKiBSdW4gdGhlIGxvb3AgKi9cbiAgICBhc3luYyBydW4oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIFVJLmhlYWRlcihcIlJhbHBoIExvb3AgUnVubmVyXCIpO1xuXG4gICAgICAgIC8vIENoZWNrIGZvciByZXN1bWVcbiAgICAgICAgaWYgKHRoaXMuZmxhZ3MucmVzdW1lKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnJlc3VtZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RhcnQgZnJlc2ggcnVuXG4gICAgICAgIGF3YWl0IHRoaXMuc3RhcnRGcmVzaCgpO1xuICAgIH1cblxuICAgIC8qKiBTdGFydCBhIGZyZXNoIHJ1biAqL1xuICAgIHByaXZhdGUgYXN5bmMgc3RhcnRGcmVzaCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgbG9nLmluZm8oXCJTdGFydGluZyBmcmVzaCBSYWxwaCBsb29wXCIsIHtcbiAgICAgICAgICAgIHJ1bklkOiB0aGlzLmNvbmZpZy5ydW5JZCxcbiAgICAgICAgICAgIHByb21wdDogdGhpcy5jb25maWcucHJvbXB0LnN1YnN0cmluZygwLCAxMDApLFxuICAgICAgICAgICAgY29tcGxldGlvblByb21pc2U6IHRoaXMuY29uZmlnLmNvbXBsZXRpb25Qcm9taXNlLFxuICAgICAgICAgICAgbWF4Q3ljbGVzOiB0aGlzLmNvbmZpZy5tYXhDeWNsZXMsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEluaXRpYWxpemUgZmxvdyBzdG9yZVxuICAgICAgICB0aGlzLmZsb3dTdG9yZS5pbml0aWFsaXplKCk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGluaXRpYWwgc3RhdGVcbiAgICAgICAgY29uc3QgaW5pdGlhbFN0YXRlID0gdGhpcy5mbG93U3RvcmUuY3JlYXRlSW5pdGlhbFN0YXRlKHtcbiAgICAgICAgICAgIHByb21wdDogdGhpcy5jb25maWcucHJvbXB0LFxuICAgICAgICAgICAgY29tcGxldGlvblByb21pc2U6IHRoaXMuY29uZmlnLmNvbXBsZXRpb25Qcm9taXNlLFxuICAgICAgICAgICAgbWF4Q3ljbGVzOiB0aGlzLmNvbmZpZy5tYXhDeWNsZXMsXG4gICAgICAgICAgICBzdHVja1RocmVzaG9sZDogdGhpcy5jb25maWcuc3R1Y2tUaHJlc2hvbGQsXG4gICAgICAgICAgICBnYXRlczogdGhpcy5jb25maWcuZ2F0ZXMsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBzdGF0dXMgdG8gcnVubmluZ1xuICAgICAgICB0aGlzLmZsb3dTdG9yZS51cGRhdGVTdGF0dXMoUnVuU3RhdHVzLlJVTk5JTkcpO1xuXG4gICAgICAgIC8vIFJ1biB0aGUgbG9vcFxuICAgICAgICBhd2FpdCB0aGlzLnJ1bkxvb3AoKTtcbiAgICB9XG5cbiAgICAvKiogUmVzdW1lIGZyb20gcHJldmlvdXMgcnVuICovXG4gICAgcHJpdmF0ZSBhc3luYyByZXN1bWUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGxvZy5pbmZvKFwiUmVzdW1pbmcgUmFscGggbG9vcFwiLCB7IHJ1bklkOiB0aGlzLmNvbmZpZy5ydW5JZCB9KTtcblxuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZmxvd1N0b3JlLmxvYWQoKTtcbiAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGBObyBmbG93IHN0YXRlIGZvdW5kIGZvciBydW4gSUQ6ICR7dGhpcy5jb25maWcucnVuSWR9LiBDYW5ub3QgcmVzdW1lLmAsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRlLnN0YXR1cyA9PT0gUnVuU3RhdHVzLkNPTVBMRVRFRCkge1xuICAgICAgICAgICAgVUkud2FybihcIlRoaXMgcnVuIGhhcyBhbHJlYWR5IGNvbXBsZXRlZC5cIik7XG4gICAgICAgICAgICBVSS5pbmZvKGBTdG9wIHJlYXNvbjogJHtzdGF0ZS5zdG9wUmVhc29ufWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXRlLnN0YXR1cyA9PT0gUnVuU3RhdHVzLkZBSUxFRCkge1xuICAgICAgICAgICAgVUkud2FybihcIlRoaXMgcnVuIHByZXZpb3VzbHkgZmFpbGVkLlwiKTtcbiAgICAgICAgICAgIFVJLmluZm8oYEVycm9yOiAke3N0YXRlLmVycm9yfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVzdW1lIHRoZSBsb29wXG4gICAgICAgIGF3YWl0IHRoaXMucnVuTG9vcCgpO1xuICAgIH1cblxuICAgIC8qKiBNYWluIGxvb3AgZXhlY3V0aW9uICovXG4gICAgcHJpdmF0ZSBhc3luYyBydW5Mb29wKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZmxvd1N0b3JlLmxvYWQoKTtcbiAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZmxvdyBzdGF0ZSBmb3VuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIFVJLmluZm8oYFJ1biBJRDogJHt0aGlzLmNvbmZpZy5ydW5JZH1gKTtcbiAgICAgICAgVUkuaW5mbyhgRmxvdyBkaXJlY3Rvcnk6ICR7dGhpcy5mbG93U3RvcmUuYmFzZVBhdGh9YCk7XG4gICAgICAgIFVJLmluZm8oXG4gICAgICAgICAgICBgQ29tcGxldGlvbiBwcm9taXNlOiAke3RoaXMuY29uZmlnLmNvbXBsZXRpb25Qcm9taXNlIHx8IFwiKG5vbmUpXCJ9YCxcbiAgICAgICAgKTtcbiAgICAgICAgVUkuaW5mbyhgTWF4IGN5Y2xlczogJHt0aGlzLmNvbmZpZy5tYXhDeWNsZXN9YCk7XG4gICAgICAgIFVJLmluZm8oYEN5Y2xlIHJldHJpZXM6ICR7dGhpcy5jb25maWcuY3ljbGVSZXRyaWVzfWApO1xuICAgICAgICBVSS5pbmZvKGBTdHVjayB0aHJlc2hvbGQ6ICR7dGhpcy5jb25maWcuc3R1Y2tUaHJlc2hvbGR9YCk7XG4gICAgICAgIFVJLmluZm8oXG4gICAgICAgICAgICBgRGVidWcgd29yazogJHt0aGlzLmNvbmZpZy5kZWJ1Z1dvcmsgPyBcImVuYWJsZWRcIiA6IFwiZGlzYWJsZWRcIn1gLFxuICAgICAgICApO1xuICAgICAgICBVSS5wcmludGxuKCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgd2Ugc2hvdWxkIHNraXAgb3B0aW1pemF0aW9uIChhbHJlYWR5IGRvbmUgb24gaW5pdGlhbCBpbmdlc3QpXG4gICAgICAgIC8vIEZvciBsb29wIG1vZGUsIHdlIHNraXAgcmUtb3B0aW1pemF0aW9uIGVhY2ggY3ljbGVcblxuICAgICAgICAvLyBSdW4gY3ljbGVzXG4gICAgICAgIGZvciAoXG4gICAgICAgICAgICBsZXQgY3ljbGVOdW1iZXIgPSBzdGF0ZS5jdXJyZW50Q3ljbGUgKyAxO1xuICAgICAgICAgICAgY3ljbGVOdW1iZXIgPD0gdGhpcy5jb25maWcubWF4Q3ljbGVzO1xuICAgICAgICAgICAgY3ljbGVOdW1iZXIrK1xuICAgICAgICApIHtcbiAgICAgICAgICAgIFVJLmhlYWRlcihgQ3ljbGUgJHtjeWNsZU51bWJlcn0vJHt0aGlzLmNvbmZpZy5tYXhDeWNsZXN9YCk7XG5cbiAgICAgICAgICAgIC8vIE5vdGlmeSBEaXNjb3JkOiBjeWNsZSBzdGFydGVkXG4gICAgICAgICAgICBjb25zdCBydW5TdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgdGhpcy5kaXNjb3JkV2ViaG9vaz8ubm90aWZ5Q3ljbGVTdGFydChcbiAgICAgICAgICAgICAgICBjeWNsZU51bWJlcixcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5tYXhDeWNsZXMsXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcucHJvbXB0LFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gRXhlY3V0ZSBjeWNsZSB3aXRoIHJldHJ5IGxvZ2ljXG4gICAgICAgICAgICBsZXQgYXR0ZW1wdCA9IDA7XG4gICAgICAgICAgICBsZXQgcmVzdWx0OiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogYm9vbGVhbjtcbiAgICAgICAgICAgICAgICBjeWNsZVN0YXRlOiBDeWNsZVN0YXRlO1xuICAgICAgICAgICAgICAgIHN1bW1hcnk6IHN0cmluZztcbiAgICAgICAgICAgICAgICBzdG9wUmVhc29uPzogU3RvcFJlYXNvbjtcbiAgICAgICAgICAgIH0gfCBudWxsID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBsYXN0RXJyb3I6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgICAgICB3aGlsZSAoYXR0ZW1wdCA8PSB0aGlzLmNvbmZpZy5jeWNsZVJldHJpZXMpIHtcbiAgICAgICAgICAgICAgICBhdHRlbXB0Kys7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNSZXRyeSA9IGF0dGVtcHQgPiAxO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzUmV0cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgVUkuaW5mbyhcbiAgICAgICAgICAgICAgICAgICAgICAgIGBSZXRyeSBhdHRlbXB0ICR7YXR0ZW1wdH0vJHt0aGlzLmNvbmZpZy5jeWNsZVJldHJpZXMgKyAxfWAsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGxvZy5pbmZvKFwiUmV0cnlpbmcgY3ljbGVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3ljbGVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRlbXB0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEVycm9yLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgZnJlc2ggT3BlbkNvZGUgc2Vzc2lvbiBmb3IgdGhpcyBjeWNsZVxuICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IGF3YWl0IE9wZW5Db2RlQ2xpZW50LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlclN0YXJ0dXBUaW1lb3V0OiAxMDAwMCxcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlLWFuY2hvciBjb250ZXh0IGZyb20gZGlzayAod2l0aCByZXRyeSBmYWlsdXJlIGluamVjdGVkIGlmIHRoaXMgaXMgYSByZXRyeSlcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IGF3YWl0IHRoaXMuYnVpbGRSZUFuY2hvcmVkQ29udGV4dChcbiAgICAgICAgICAgICAgICAgICAgICAgIGN5Y2xlTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNSZXRyeSA/IChsYXN0RXJyb3IgPz8gdW5kZWZpbmVkKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBFeGVjdXRlIHRoZSBjeWNsZSB3aXRoIGZyZXNoIHNlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYXdhaXQgdGhpcy5leGVjdXRlQ3ljbGUoXG4gICAgICAgICAgICAgICAgICAgICAgICBjeWNsZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVjb3JkIHRoZSBjeWNsZVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmxvd1N0b3JlLnJlY29yZFN1Y2Nlc3NmdWxDeWNsZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuY3ljbGVTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3VtbWFyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGlmeSBEaXNjb3JkOiBjeWNsZSBjb21wbGV0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uTXMgPSBEYXRlLm5vdygpIC0gcnVuU3RhcnRUaW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNjb3JkV2ViaG9vaz8ubm90aWZ5Q3ljbGVDb21wbGV0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeWNsZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZsb3dTdG9yZS5sb2FkKCk/LmNvbXBsZXRlZEN5Y2xlcyA/P1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeWNsZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3VtbWFyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbk1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmxvd1N0b3JlLnJlY29yZEZhaWxlZEN5Y2xlKHJlc3VsdC5jeWNsZVN0YXRlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90aWZ5IERpc2NvcmQ6IGN5Y2xlIGZhaWxlZFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNjb3JkV2ViaG9vaz8ubm90aWZ5RXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3ljbGVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmN5Y2xlU3RhdGUucGhhc2VzW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jeWNsZVN0YXRlLnBoYXNlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKS5wb3AoKSBhcyBrZXlvZiB0eXBlb2YgcmVzdWx0LmN5Y2xlU3RhdGUucGhhc2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXT8ucGhhc2UgPz8gXCJ1bmtub3duXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmN5Y2xlU3RhdGUuZXJyb3IgPz8gXCJVbmtub3duIGVycm9yXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQnJlYWsgcmV0cnkgbG9vcCBvbiBzdWNjZXNzIG9yIG5vbi1yZXRyeWFibGUgZmFpbHVyZVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHdlIHNob3VsZCByZXRyeSB0aGlzIGZhaWx1cmVcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkUmV0cnkgPSB0aGlzLnNob3VsZFJldHJ5RmFpbHVyZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNob3VsZFJldHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxhc3RFcnJvciA9IHJlc3VsdC5zdW1tYXJ5O1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTXNnID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdEVycm9yID0gZXJyb3JNc2c7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2Ugc2hvdWxkIHJldHJ5IHRoaXMgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkUmV0cnkgPSB0aGlzLnNob3VsZFJldHJ5T25FcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRSZXRyeSAmJiBhdHRlbXB0IDw9IHRoaXMuY29uZmlnLmN5Y2xlUmV0cmllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nLndhcm4oXCJDeWNsZSBlcnJvciwgd2lsbCByZXRyeVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3ljbGVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JNc2csXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vbi1yZXRyeWFibGUgb3IgbWF4IHJldHJpZXMgZXhjZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYW4gdXAgdGhlIHNlc3Npb24gZm9yIHRoaXMgY3ljbGVcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgY2xpZW50LmNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHJlc3VsdCBpcyBudWxsIGFmdGVyIGFsbCByZXRyaWVzLCB3ZSBoYWQgYSBjYXRhc3Ryb3BoaWMgZmFpbHVyZVxuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2NvcmRXZWJob29rPy5ub3RpZnlTdHVja09yQWJvcnRlZChcbiAgICAgICAgICAgICAgICAgICAgY3ljbGVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIFwiRkFJTEVEX0FMTF9SRVRSSUVTXCIsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmhhbmRsZVN0b3AoXG4gICAgICAgICAgICAgICAgICAgIFN0b3BSZWFzb24uRVJST1IsXG4gICAgICAgICAgICAgICAgICAgIGBDeWNsZSAke2N5Y2xlTnVtYmVyfSBmYWlsZWQgYWZ0ZXIgJHt0aGlzLmNvbmZpZy5jeWNsZVJldHJpZXMgKyAxfSBhdHRlbXB0czogJHtsYXN0RXJyb3IgPz8gXCJ1bmtub3duIGVycm9yXCJ9YCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2hlY2sgc3RvcCBjb25kaXRpb25zXG4gICAgICAgICAgICBpZiAocmVzdWx0LnN0b3BSZWFzb24pIHtcbiAgICAgICAgICAgICAgICAvLyBOb3RpZnkgRGlzY29yZDogcnVuIHN0b3BwZWRcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmhhbmRsZVN0b3AocmVzdWx0LnN0b3BSZWFzb24sIHJlc3VsdC5zdW1tYXJ5KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHN0dWNrXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSB0aGlzLmZsb3dTdG9yZS5sb2FkKCk7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgY3VycmVudFN0YXRlICYmXG4gICAgICAgICAgICAgICAgY3VycmVudFN0YXRlLnN0dWNrQ291bnQgPj0gdGhpcy5jb25maWcuc3R1Y2tUaHJlc2hvbGRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIE5vdGlmeSBEaXNjb3JkOiBzdHVja1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzY29yZFdlYmhvb2s/Lm5vdGlmeVN0dWNrT3JBYm9ydGVkKGN5Y2xlTnVtYmVyLCBcIlNUVUNLXCIpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuaGFuZGxlU3RvcChcbiAgICAgICAgICAgICAgICAgICAgU3RvcFJlYXNvbi5TVFVDSyxcbiAgICAgICAgICAgICAgICAgICAgYE5vIHByb2dyZXNzIGZvciAke3RoaXMuY29uZmlnLnN0dWNrVGhyZXNob2xkfSBjb25zZWN1dGl2ZSBjeWNsZXNgLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTYXZlIGNoZWNrcG9pbnQgaWYgbmVlZGVkXG4gICAgICAgICAgICBpZiAoY3ljbGVOdW1iZXIgJSB0aGlzLmNvbmZpZy5jaGVja3BvaW50RnJlcXVlbmN5ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mbG93U3RvcmUuc2F2ZUNoZWNrcG9pbnQoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmxvd1N0b3JlLmxvYWQoKSEsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5jeWNsZVN0YXRlLnBoYXNlcyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBVSS5wcmludGxuKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYXggY3ljbGVzIHJlYWNoZWQgLSBub3RpZnkgRGlzY29yZFxuICAgICAgICB0aGlzLmRpc2NvcmRXZWJob29rPy5ub3RpZnlSdW5Db21wbGV0ZShcbiAgICAgICAgICAgIHN0YXRlLmNvbXBsZXRlZEN5Y2xlcyxcbiAgICAgICAgICAgIERhdGUubm93KCkgLSBuZXcgRGF0ZShzdGF0ZS5jcmVhdGVkQXQpLmdldFRpbWUoKSxcbiAgICAgICAgICAgIGBDb21wbGV0ZWQgJHtzdGF0ZS5jb21wbGV0ZWRDeWNsZXN9IGN5Y2xlcyAobWF4ICR7dGhpcy5jb25maWcubWF4Q3ljbGVzfSlgLFxuICAgICAgICApO1xuICAgICAgICBhd2FpdCB0aGlzLmhhbmRsZVN0b3AoU3RvcFJlYXNvbi5NQVhfQ1lDTEVTLCBcIk1heGltdW0gY3ljbGVzIHJlYWNoZWRcIik7XG4gICAgfVxuXG4gICAgLyoqIERldGVybWluZSBpZiBhIGZhaWx1cmUgc2hvdWxkIHRyaWdnZXIgYSByZXRyeSAqL1xuICAgIHByaXZhdGUgc2hvdWxkUmV0cnlGYWlsdXJlKHJlc3VsdDoge1xuICAgICAgICBzdWNjZXNzOiBib29sZWFuO1xuICAgICAgICBjeWNsZVN0YXRlOiBDeWNsZVN0YXRlO1xuICAgICAgICBzdW1tYXJ5OiBzdHJpbmc7XG4gICAgfSk6IGJvb2xlYW4ge1xuICAgICAgICAvLyBDaGVjayBmb3IgZ2F0ZSBmYWlsdXJlc1xuICAgICAgICBjb25zdCBmYWlsZWRHYXRlcyA9IHJlc3VsdC5jeWNsZVN0YXRlLmdhdGVSZXN1bHRzLmZpbHRlcihcbiAgICAgICAgICAgIChnKSA9PiAhZy5wYXNzZWQsXG4gICAgICAgICk7XG4gICAgICAgIGlmIChmYWlsZWRHYXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciBlbXB0eSB3b3JrIHJlc3BvbnNlIChvdXIgYWNjZXB0YW5jZSBydWxlKVxuICAgICAgICBjb25zdCB3b3JrUGhhc2UgPSByZXN1bHQuY3ljbGVTdGF0ZS5waGFzZXNbUGhhc2UuV09SS107XG4gICAgICAgIGlmICh3b3JrUGhhc2UgJiYgIXdvcmtQaGFzZS5yZXNwb25zZS50cmltKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKiBEZXRlcm1pbmUgaWYgYW4gZXJyb3Igc2hvdWxkIHRyaWdnZXIgYSByZXRyeSAqL1xuICAgIHByaXZhdGUgc2hvdWxkUmV0cnlPbkVycm9yKGVycm9yOiB1bmtub3duKTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAvLyBSZXRyeSBvbiB0aW1lb3V0XG4gICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcInRpbWVvdXRcIikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJldHJ5IG9uIHN0cmVhbSBlcnJvcnNcbiAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwic3RyZWFtXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXRyeSBvbiBPcGVuQ29kZSBjb25uZWN0aW9uIGVycm9yc1xuICAgICAgICAgICAgaWYgKGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJPcGVuQ29kZVwiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKiogQnVpbGQgcmUtYW5jaG9yZWQgY29udGV4dCBmb3IgYSBjeWNsZSAqL1xuICAgIHByaXZhdGUgYXN5bmMgYnVpbGRSZUFuY2hvcmVkQ29udGV4dChcbiAgICAgICAgY3ljbGVOdW1iZXI6IG51bWJlcixcbiAgICAgICAgcmV0cnlGYWlsdXJlPzogc3RyaW5nLFxuICAgICk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgICAgIGNvbnN0IGNvbnRleHRQYXJ0czogc3RyaW5nW10gPSBbXTtcblxuICAgICAgICAvLyBBbHdheXMgc3RhcnQgd2l0aCB0aGUgb3JpZ2luYWwgcHJvbXB0XG4gICAgICAgIGNvbnRleHRQYXJ0cy5wdXNoKGAjIE9yaWdpbmFsIFRhc2tcXG5cXG4ke3RoaXMuY29uZmlnLnByb21wdH1cXG5gKTtcblxuICAgICAgICAvLyBBZGQgcmV0cnkgZmFpbHVyZSBpbmZvIGlmIHRoaXMgaXMgYSByZXRyeVxuICAgICAgICBpZiAocmV0cnlGYWlsdXJlKSB7XG4gICAgICAgICAgICBjb250ZXh0UGFydHMucHVzaChcbiAgICAgICAgICAgICAgICBgIyBQcmV2aW91cyBBdHRlbXB0IEZhaWxlZFxcblxcblRoZSBwcmV2aW91cyBhdHRlbXB0IGhhZCBhbiBpc3N1ZTpcXG4ke3JldHJ5RmFpbHVyZX1cXG5cXG5QbGVhc2UgYW5hbHl6ZSB3aGF0IHdlbnQgd3JvbmcgYW5kIHRyeSBhIGRpZmZlcmVudCBhcHByb2FjaC5cXG5gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBwcmV2aW91cyBjeWNsZSBzdW1tYXJ5IGlmIGF2YWlsYWJsZVxuICAgICAgICBjb25zdCBwcmV2aW91c0N5Y2xlID0gdGhpcy5mbG93U3RvcmUuZ2V0SXRlcmF0aW9uKGN5Y2xlTnVtYmVyIC0gMSk7XG4gICAgICAgIGlmIChwcmV2aW91c0N5Y2xlKSB7XG4gICAgICAgICAgICBjb250ZXh0UGFydHMucHVzaChcbiAgICAgICAgICAgICAgICBgIyBQcmV2aW91cyBDeWNsZSAoJHtjeWNsZU51bWJlciAtIDF9KSBTdW1tYXJ5XFxuXFxuYCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb250ZXh0UGFydHMucHVzaChwcmV2aW91c0N5Y2xlLmVycm9yID8gXCJGQUlMRURcXG5cIiA6IFwiQ09NUExFVEVEXFxuXCIpO1xuXG4gICAgICAgICAgICBpZiAocHJldmlvdXNDeWNsZS5lcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnRleHRQYXJ0cy5wdXNoKGBFcnJvcjogJHtwcmV2aW91c0N5Y2xlLmVycm9yfVxcbmApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBZGQgZ2F0ZSByZXN1bHRzXG4gICAgICAgICAgICBpZiAocHJldmlvdXNDeWNsZS5nYXRlUmVzdWx0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dFBhcnRzLnB1c2goXCJcXG4jIyBHYXRlIFJlc3VsdHNcXG5cXG5cIik7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBnYXRlIG9mIHByZXZpb3VzQ3ljbGUuZ2F0ZVJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gZ2F0ZS5wYXNzZWQgPyBcIuKchVwiIDogXCLinYxcIjtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dFBhcnRzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICBgLSAke3N0YXR1c30gJHtnYXRlLmdhdGV9OiAke2dhdGUubWVzc2FnZX1cXG5gLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQWRkIHRvb2wgdXNhZ2Ugc3VtbWFyeSBmcm9tIHByZXZpb3VzIGN5Y2xlXG4gICAgICAgICAgICBjb25zdCBhbGxUb29scyA9IHRoaXMuY29sbGVjdEFsbFRvb2xzKHByZXZpb3VzQ3ljbGUpO1xuICAgICAgICAgICAgaWYgKGFsbFRvb2xzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0UGFydHMucHVzaChcIlxcbiMjIFRvb2wgVXNhZ2UgaW4gUHJldmlvdXMgQ3ljbGVcXG5cXG5cIik7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0b29sIG9mIGFsbFRvb2xzLnNsaWNlKDAsIDEwKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXNJY29uID0gdG9vbC5zdGF0dXMgPT09IFwib2tcIiA/IFwi4pyFXCIgOiBcIuKdjFwiO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0UGFydHMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIGAke3N0YXR1c0ljb259ICR7dG9vbC5uYW1lfTogJHt0b29sLnN0YXR1c31cXG5gLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWxsVG9vbHMubGVuZ3RoID4gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dFBhcnRzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICBgLi4uIGFuZCAke2FsbFRvb2xzLmxlbmd0aCAtIDEwfSBtb3JlIHRvb2xzXFxuYCxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgbGFzdCBjaGVja3BvaW50IHN1bW1hcnlcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmZsb3dTdG9yZS5sb2FkKCk7XG4gICAgICAgIGlmIChzdGF0ZT8ubGFzdENoZWNrcG9pbnQpIHtcbiAgICAgICAgICAgIGNvbnRleHRQYXJ0cy5wdXNoKFxuICAgICAgICAgICAgICAgIGBcXG4jIExhc3QgQ2hlY2twb2ludFxcblxcbkN5Y2xlICR7c3RhdGUubGFzdENoZWNrcG9pbnQuY3ljbGVOdW1iZXJ9OiAke3N0YXRlLmxhc3RDaGVja3BvaW50LnN1bW1hcnl9XFxuYCxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBdXRvLWxvYWQgcmVsZXZhbnQgc3BlY3MgZnJvbSBzcGVjcy8gZGlyZWN0b3J5XG4gICAgICAgIGNvbnN0IHNwZWNzQ29udGV4dCA9IGF3YWl0IHRoaXMubG9hZFJlbGV2YW50U3BlY3MoKTtcbiAgICAgICAgaWYgKHNwZWNzQ29udGV4dCkge1xuICAgICAgICAgICAgY29udGV4dFBhcnRzLnB1c2goc3BlY3NDb250ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBnaXQgc3RhdHVzIGlmIGF2YWlsYWJsZVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZ2l0U3RhdHVzID0gYXdhaXQgdGhpcy5nZXRHaXRTdGF0dXMoKTtcbiAgICAgICAgICAgIGlmIChnaXRTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0UGFydHMucHVzaChgXFxuIyBHaXQgU3RhdHVzXFxuXFxuJHtnaXRTdGF0dXN9XFxuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgLy8gR2l0IHN0YXR1cyBub3QgYXZhaWxhYmxlLCBza2lwXG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgY29tcGxldGlvbiBjcml0ZXJpYSByZW1pbmRlclxuICAgICAgICBjb250ZXh0UGFydHMucHVzaChcbiAgICAgICAgICAgIGBcXG4jIENvbXBsZXRpb24gQ3JpdGVyaWFcXG5cXG5Mb29wIGV4aXRzIHdoZW4geW91IG91dHB1dCBleGFjdGx5OiAke3RoaXMuY29uZmlnLmNvbXBsZXRpb25Qcm9taXNlIHx8IFwiKG5vbmUgLSB3aWxsIHJ1biBhbGwgY3ljbGVzKVwifVxcbmAsXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuIGNvbnRleHRQYXJ0cy5qb2luKFwiXFxuXCIpO1xuICAgIH1cblxuICAgIC8qKiBDb2xsZWN0IGFsbCB0b29sIGludm9jYXRpb25zIGZyb20gYSBjeWNsZSBzdGF0ZSAqL1xuICAgIHByaXZhdGUgY29sbGVjdEFsbFRvb2xzKGN5Y2xlOiBDeWNsZVN0YXRlKTogVG9vbEludm9jYXRpb25bXSB7XG4gICAgICAgIGNvbnN0IHRvb2xzOiBUb29sSW52b2NhdGlvbltdID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGhhc2Ugb2YgT2JqZWN0LnZhbHVlcyhjeWNsZS5waGFzZXMpKSB7XG4gICAgICAgICAgICBpZiAocGhhc2U/LnRvb2xzKSB7XG4gICAgICAgICAgICAgICAgdG9vbHMucHVzaCguLi5waGFzZS50b29scyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvb2xzO1xuICAgIH1cblxuICAgIC8qKiBMb2FkIHJlbGV2YW50IHNwZWNzIGZyb20gc3BlY3MvIGRpcmVjdG9yeSBtYXRjaGluZyB0aGUgcHJvbXB0ICovXG4gICAgcHJpdmF0ZSBhc3luYyBsb2FkUmVsZXZhbnRTcGVjcygpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcbiAgICAgICAgY29uc3Qgc3BlY3NEaXIgPSBqb2luKHByb2Nlc3MuY3dkKCksIFwic3BlY3NcIik7XG4gICAgICAgIGxldCBzcGVjczogc3RyaW5nW107XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzcGVjcyA9IGF3YWl0IHJlYWRkaXIoc3BlY3NEaXIpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIC8vIE5vIHNwZWNzIGRpcmVjdG9yeSwgc2tpcFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwcm9tcHRMb3dlciA9IHRoaXMuY29uZmlnLnByb21wdC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCBwcm9tcHRUb2tlbnMgPSBuZXcgU2V0KFxuICAgICAgICAgICAgcHJvbXB0TG93ZXIuc3BsaXQoL1xcVysvKS5maWx0ZXIoKHQpID0+IHQubGVuZ3RoID4gMiksXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgbWF0Y2hlczogeyBkaXI6IHN0cmluZzsgc2NvcmU6IG51bWJlcjsgdGl0bGU/OiBzdHJpbmcgfVtdID0gW107XG5cbiAgICAgICAgZm9yIChjb25zdCBzcGVjRGlyIG9mIHNwZWNzKSB7XG4gICAgICAgICAgICAvLyBTa2lwIHNwZWNpYWwgZGlyZWN0b3JpZXNcbiAgICAgICAgICAgIGlmIChzcGVjRGlyLnN0YXJ0c1dpdGgoXCIuXCIpKSBjb250aW51ZTtcblxuICAgICAgICAgICAgY29uc3Qgc3BlY1BhdGggPSBqb2luKHNwZWNzRGlyLCBzcGVjRGlyLCBcInNwZWMubWRcIik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNwZWNDb250ZW50ID0gYXdhaXQgcmVhZEZpbGUoc3BlY1BhdGgsIFwidXRmLThcIik7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3BlY0NvbnRlbnRMb3dlciA9IHNwZWNDb250ZW50LnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IHRpdGxlIGZyb20gc3BlY1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpdGxlTWF0Y2ggPSBzcGVjQ29udGVudC5tYXRjaCgvXiMgKC4rKSQvbSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGl0bGUgPSB0aXRsZU1hdGNoPy5bMV07XG5cbiAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgc2ltcGxlIHRva2VuIG92ZXJsYXAgc2NvcmVcbiAgICAgICAgICAgICAgICBsZXQgc2NvcmUgPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNwZWNUb2tlbnMgPSBuZXcgU2V0KFxuICAgICAgICAgICAgICAgICAgICBzcGVjQ29udGVudExvd2VyLnNwbGl0KC9cXFcrLykuZmlsdGVyKCh0KSA9PiB0Lmxlbmd0aCA+IDIpLFxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHByb21wdFRva2Vucykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3BlY1Rva2Vucy5oYXModG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY29yZSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQm9udXMgZm9yIGRpcmVjdG9yeSBuYW1lIG1hdGNoXG4gICAgICAgICAgICAgICAgY29uc3QgZGlyTG93ZXIgPSBzcGVjRGlyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBwcm9tcHRMb3dlci5pbmNsdWRlcyhkaXJMb3dlcikgfHxcbiAgICAgICAgICAgICAgICAgICAgZGlyTG93ZXIuaW5jbHVkZXMoXCJmbGVldHRvb2xzXCIpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3JlICs9IDU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHNjb3JlID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2goeyBkaXI6IHNwZWNEaXIsIHNjb3JlLCB0aXRsZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgICAvLyBObyBzcGVjLm1kIGluIHRoaXMgZGlyZWN0b3J5LCBza2lwXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTb3J0IGJ5IHNjb3JlIGFuZCB0YWtlIHRvcCAyXG4gICAgICAgIG1hdGNoZXMuc29ydCgoYSwgYikgPT4gYi5zY29yZSAtIGEuc2NvcmUpO1xuICAgICAgICBjb25zdCB0b3BNYXRjaGVzID0gbWF0Y2hlcy5zbGljZSgwLCAyKTtcblxuICAgICAgICBpZiAodG9wTWF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW1wiXFxuIyBSZWxldmFudCBTcGVjaWZpY2F0aW9uc1xcblwiXTtcblxuICAgICAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIHRvcE1hdGNoZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNwZWNQYXRoID0gam9pbihzcGVjc0RpciwgbWF0Y2guZGlyLCBcInNwZWMubWRcIik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNwZWNDb250ZW50ID0gYXdhaXQgcmVhZEZpbGUoc3BlY1BhdGgsIFwidXRmLThcIik7XG5cbiAgICAgICAgICAgICAgICAvLyBJbmNsdWRlIG92ZXJ2aWV3IGFuZCBhY2NlcHRhbmNlIGNyaXRlcmlhIHNlY3Rpb25zXG4gICAgICAgICAgICAgICAgY29uc3Qgb3ZlcnZpZXdNYXRjaCA9IHNwZWNDb250ZW50Lm1hdGNoKFxuICAgICAgICAgICAgICAgICAgICAvXigjIC4rPykoPzpcXG5cXG4jIyBPdmVydmlld1xcblxcbikoW1xcc1xcU10qPykoPz1cXG5cXG4jIyB8XFxuXFxuIyMjICkvbSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJTdG9yaWVzTWF0Y2ggPSBzcGVjQ29udGVudC5tYXRjaChcbiAgICAgICAgICAgICAgICAgICAgL14oIyMgVXNlciBTdG9yaWVzXFxuXFxuKShbXFxzXFxTXSo/KSg/PVxcblxcbiMjIHxcXG5cXG4jIyMgKS9tLFxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChgXFxuIyMgJHttYXRjaC50aXRsZSB8fCBtYXRjaC5kaXJ9XFxuYCk7XG5cbiAgICAgICAgICAgICAgICBpZiAob3ZlcnZpZXdNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChvdmVydmlld01hdGNoWzJdLnRyaW0oKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh1c2VyU3Rvcmllc01hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluY2x1ZGUgZmlyc3QgMyB1c2VyIHN0b3JpZXNcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RvcmllcyA9IHVzZXJTdG9yaWVzTWF0Y2hbMl1cbiAgICAgICAgICAgICAgICAgICAgICAgIC5zcGxpdCgvXFxuIyMjIC8pXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2xpY2UoMCwgMyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFwiXFxuIyMjIEtleSBVc2VyIFN0b3JpZXNcXG5cIik7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3Rvcnkgb2Ygc3Rvcmllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3J5LnRyaW0oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGBcXG4jIyMgJHtzdG9yeS50cmltKCl9XFxuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsb2cuZGVidWcoXCJMb2FkZWQgc3BlYyBmb3IgY29udGV4dFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHNwZWM6IG1hdGNoLmRpcixcbiAgICAgICAgICAgICAgICAgICAgc2NvcmU6IG1hdGNoLnNjb3JlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgICAgbG9nLndhcm4oXCJGYWlsZWQgdG8gcmVhZCBzcGVjXCIsIHsgc3BlYzogbWF0Y2guZGlyIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiXFxuXCIpO1xuICAgIH1cblxuICAgIC8qKiBHZXQgZ2l0IHN0YXR1cyBmb3IgY29udGV4dCAqL1xuICAgIHByaXZhdGUgYXN5bmMgZ2V0R2l0U3RhdHVzKCk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBleGVjU3luYyB9ID0gYXdhaXQgaW1wb3J0KFwibm9kZTpjaGlsZF9wcm9jZXNzXCIpO1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IGV4ZWNTeW5jKFwiZ2l0IGRpZmYgLS1zdGF0XCIsIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZzogXCJ1dGYtOFwiLFxuICAgICAgICAgICAgICAgIGN3ZDogcHJvY2Vzcy5jd2QoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gZXhlY1N5bmMoXCJnaXQgc3RhdHVzIC0tc2hvcnRcIiwge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nOiBcInV0Zi04XCIsXG4gICAgICAgICAgICAgICAgY3dkOiBwcm9jZXNzLmN3ZCgpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gYFxcYFxcYFxcYFxcbiR7ZGlmZn1cXG4ke3N0YXR1c31cXG5cXGBcXGBcXGBgO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEV4ZWN1dGUgYSBzaW5nbGUgY3ljbGUgd2l0aCBmcmVzaCBzZXNzaW9uICovXG4gICAgcHJpdmF0ZSBhc3luYyBleGVjdXRlQ3ljbGUoXG4gICAgICAgIGN5Y2xlTnVtYmVyOiBudW1iZXIsXG4gICAgICAgIGNsaWVudDogT3BlbkNvZGVDbGllbnQsXG4gICAgICAgIGNvbnRleHQ6IHN0cmluZyxcbiAgICApOiBQcm9taXNlPHtcbiAgICAgICAgc3VjY2VzczogYm9vbGVhbjtcbiAgICAgICAgY3ljbGVTdGF0ZTogQ3ljbGVTdGF0ZTtcbiAgICAgICAgc3VtbWFyeTogc3RyaW5nO1xuICAgICAgICBzdG9wUmVhc29uPzogU3RvcFJlYXNvbjtcbiAgICB9PiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgY3ljbGVTdGF0ZTogQ3ljbGVTdGF0ZSA9IHtcbiAgICAgICAgICAgIGN5Y2xlTnVtYmVyLFxuICAgICAgICAgICAgc3RhdHVzOiBcInJ1bm5pbmdcIixcbiAgICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgICAgIHBoYXNlczoge30sXG4gICAgICAgICAgICBnYXRlUmVzdWx0czogW10sXG4gICAgICAgICAgICBjb21wbGV0aW9uUHJvbWlzZU9ic2VydmVkOiBmYWxzZSxcbiAgICAgICAgfTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHNlc3Npb24gd2l0aCBjb250ZXh0IGFzIGluaXRpYWwgcHJvbXB0ICh3aWxsIGJlIGNvbWJpbmVkIHdpdGggZmlyc3QgbWVzc2FnZSlcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBjbGllbnQuY3JlYXRlU2Vzc2lvbihjb250ZXh0KTtcblxuICAgICAgICAgICAgLy8gRXhlY3V0ZSB3b3JrZmxvdyBwaGFzZXNcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGhhc2Ugb2YgW1xuICAgICAgICAgICAgICAgIFBoYXNlLlJFU0VBUkNILFxuICAgICAgICAgICAgICAgIFBoYXNlLlNQRUNJRlksXG4gICAgICAgICAgICAgICAgUGhhc2UuUExBTixcbiAgICAgICAgICAgICAgICBQaGFzZS5XT1JLLFxuICAgICAgICAgICAgICAgIFBoYXNlLlJFVklFVyxcbiAgICAgICAgICAgIF0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwaGFzZVJlc3VsdCA9IGF3YWl0IHRoaXMuZXhlY3V0ZVBoYXNlKFxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICBwaGFzZSxcbiAgICAgICAgICAgICAgICAgICAgY3ljbGVOdW1iZXIsXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGlmIChwaGFzZVJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjeWNsZVN0YXRlLnBoYXNlc1twaGFzZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwaGFzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21wdDogcGhhc2VSZXN1bHQucHJvbXB0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdW1tYXJ5OiBgRXJyb3I6ICR7cGhhc2VSZXN1bHQuZXJyb3J9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBgJHtwaGFzZX0gcGhhc2UgZmFpbGVkOiAke3BoYXNlUmVzdWx0LmVycm9yfWAsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY3ljbGVTdGF0ZS5waGFzZXNbcGhhc2VdID0ge1xuICAgICAgICAgICAgICAgICAgICBwaGFzZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvbXB0OiBwaGFzZVJlc3VsdC5wcm9tcHQsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBwaGFzZVJlc3VsdC5yZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgc3VtbWFyeTogcGhhc2VSZXN1bHQuc3VtbWFyeSxcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIHRvb2xzOiBwaGFzZVJlc3VsdC50b29scyxcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGNvbXBsZXRpb24gcHJvbWlzZSBkdXJpbmcgcGhhc2UgZXhlY3V0aW9uXG4gICAgICAgICAgICAgICAgLy8gT25seSBjaGVjayBpbiBzaGlwIG1vZGUgKHdoZW4gY29tcGxldGlvblByb21pc2UgaXMgc2V0KVxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcuY29tcGxldGlvblByb21pc2UgJiZcbiAgICAgICAgICAgICAgICAgICAgcGhhc2VSZXN1bHQucmVzcG9uc2UuaW5jbHVkZXModGhpcy5jb25maWcuY29tcGxldGlvblByb21pc2UpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGN5Y2xlU3RhdGUuY29tcGxldGlvblByb21pc2VPYnNlcnZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgVUkucHJpbnRsbihcbiAgICAgICAgICAgICAgICAgICAgYCR7VUkuU3R5bGUuVEVYVF9ESU19ICDihpIgJHtwaGFzZX06IGRvbmUke1VJLlN0eWxlLlRFWFRfTk9STUFMfWAsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUnVuIHF1YWxpdHkgZ2F0ZXNcbiAgICAgICAgICAgIFVJLnByaW50bG4oXG4gICAgICAgICAgICAgICAgYCR7VUkuU3R5bGUuVEVYVF9ESU19UnVubmluZyBxdWFsaXR5IGdhdGVzLi4uJHtVSS5TdHlsZS5URVhUX05PUk1BTH1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IGdhdGVSZXN1bHRzID0gYXdhaXQgdGhpcy5ydW5RdWFsaXR5R2F0ZXMoXG4gICAgICAgICAgICAgICAgY3ljbGVOdW1iZXIsXG4gICAgICAgICAgICAgICAgY3ljbGVTdGF0ZSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjeWNsZVN0YXRlLmdhdGVSZXN1bHRzID0gZ2F0ZVJlc3VsdHM7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGFueSByZXF1aXJlZCBnYXRlIGZhaWxlZFxuICAgICAgICAgICAgY29uc3QgcmVxdWlyZWRGYWlsZWQgPSBnYXRlUmVzdWx0cy5maW5kKFxuICAgICAgICAgICAgICAgIChnKSA9PiAhZy5wYXNzZWQgJiYgdGhpcy5jb25maWcuZ2F0ZXMuaW5jbHVkZXMoZy5nYXRlKSxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGxldCBmYWlsZWRQaGFzZUluZm8gPSBcIlwiO1xuICAgICAgICAgICAgaWYgKHJlcXVpcmVkRmFpbGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gRmluZCB3aGljaCBwaGFzZSBoYWQgdGhlIG1vc3QgcmVjZW50IGZhaWx1cmVcbiAgICAgICAgICAgICAgICBjb25zdCBwaGFzZXNXaXRoR2F0ZXMgPSBPYmplY3QuZW50cmllcyhjeWNsZVN0YXRlLnBoYXNlcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdFBoYXNlID1cbiAgICAgICAgICAgICAgICAgICAgcGhhc2VzV2l0aEdhdGVzW3BoYXNlc1dpdGhHYXRlcy5sZW5ndGggLSAxXT8uWzBdID8/XG4gICAgICAgICAgICAgICAgICAgIFwidW5rbm93blwiO1xuICAgICAgICAgICAgICAgIGZhaWxlZFBoYXNlSW5mbyA9IGAke2xhc3RQaGFzZX0gZ2F0ZSBmYWlsZWRgO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjeWNsZVN0YXRlLnN0YXR1cyA9IFwiY29tcGxldGVkXCI7XG4gICAgICAgICAgICBjeWNsZVN0YXRlLmVuZFRpbWUgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICBjeWNsZVN0YXRlLmR1cmF0aW9uTXMgPSBEYXRlLm5vdygpIC0gbmV3IERhdGUoc3RhcnRUaW1lKS5nZXRUaW1lKCk7XG5cbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIHN1bW1hcnlcbiAgICAgICAgICAgIGNvbnN0IHN1bW1hcnkgPSB0aGlzLmdlbmVyYXRlQ3ljbGVTdW1tYXJ5KGN5Y2xlU3RhdGUpO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBzdG9wIGNvbmRpdGlvbnNcbiAgICAgICAgICAgIC8vIE9ubHkgY2hlY2sgY29tcGxldGlvbiBwcm9taXNlIGluIHNoaXAgbW9kZSAod2hlbiBjb21wbGV0aW9uUHJvbWlzZSBpcyBzZXQpXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcuY29tcGxldGlvblByb21pc2UgJiZcbiAgICAgICAgICAgICAgICBjeWNsZVN0YXRlLmNvbXBsZXRpb25Qcm9taXNlT2JzZXJ2ZWRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGN5Y2xlU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIHN1bW1hcnksXG4gICAgICAgICAgICAgICAgICAgIHN0b3BSZWFzb246IFN0b3BSZWFzb24uQ09NUExFVElPTl9QUk9NSVNFLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZXF1aXJlZEZhaWxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjeWNsZVN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBzdW1tYXJ5OiBgJHtmYWlsZWRQaGFzZUluZm99OiAke3JlcXVpcmVkRmFpbGVkLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgICAgICAgICAgc3RvcFJlYXNvbjogU3RvcFJlYXNvbi5HQVRFX0ZBSUxVUkUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIG91dHB1dCBoYXNoIGZvciBzdHVjayBkZXRlY3Rpb25cbiAgICAgICAgICAgIGN5Y2xlU3RhdGUub3V0cHV0SGFzaCA9IHRoaXMuaGFzaE91dHB1dChcbiAgICAgICAgICAgICAgICBPYmplY3QudmFsdWVzKGN5Y2xlU3RhdGUucGhhc2VzKVxuICAgICAgICAgICAgICAgICAgICAubWFwKChwKSA9PiBwPy5yZXNwb25zZSA/PyBcIlwiKVxuICAgICAgICAgICAgICAgICAgICAuam9pbihcInxcIiksXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBjeWNsZVN0YXRlLCBzdW1tYXJ5IH07XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvck1zZyA9XG4gICAgICAgICAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuXG4gICAgICAgICAgICBjeWNsZVN0YXRlLnN0YXR1cyA9IFwiZmFpbGVkXCI7XG4gICAgICAgICAgICBjeWNsZVN0YXRlLmVuZFRpbWUgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICBjeWNsZVN0YXRlLmR1cmF0aW9uTXMgPSBEYXRlLm5vdygpIC0gbmV3IERhdGUoc3RhcnRUaW1lKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICBjeWNsZVN0YXRlLmVycm9yID0gZXJyb3JNc2c7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICAgICAgY3ljbGVTdGF0ZSxcbiAgICAgICAgICAgICAgICBzdW1tYXJ5OiBgQ3ljbGUgZmFpbGVkOiAke2Vycm9yTXNnfWAsXG4gICAgICAgICAgICAgICAgc3RvcFJlYXNvbjogU3RvcFJlYXNvbi5FUlJPUixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogRXhlY3V0ZSBhIHNpbmdsZSBwaGFzZSAqL1xuICAgIHByaXZhdGUgYXN5bmMgZXhlY3V0ZVBoYXNlKFxuICAgICAgICBzZXNzaW9uOiBTZXNzaW9uLFxuICAgICAgICBwaGFzZTogUGhhc2UsXG4gICAgICAgIGN5Y2xlTnVtYmVyOiBudW1iZXIsXG4gICAgKTogUHJvbWlzZTx7XG4gICAgICAgIHByb21wdDogc3RyaW5nO1xuICAgICAgICByZXNwb25zZTogc3RyaW5nO1xuICAgICAgICBzdW1tYXJ5OiBzdHJpbmc7XG4gICAgICAgIHRvb2xzOiBUb29sSW52b2NhdGlvbltdO1xuICAgICAgICBlcnJvcj86IHN0cmluZztcbiAgICB9PiB7XG4gICAgICAgIGNvbnN0IHBoYXNlUHJvbXB0czogUmVjb3JkPFBoYXNlLCBzdHJpbmc+ID0ge1xuICAgICAgICAgICAgW1BoYXNlLlJFU0VBUkNIXTogYCMjIFBoYXNlIDE6IFJlc2VhcmNoXG5cblJlc2VhcmNoIHRoZSBjb2RlYmFzZSB0byB1bmRlcnN0YW5kIHRoZSBjdXJyZW50IHN0YXRlLiBGb2N1cyBvbjpcbi0gRmlsZSBzdHJ1Y3R1cmUgYW5kIGtleSBtb2R1bGVzXG4tIEV4aXN0aW5nIHBhdHRlcm5zIGFuZCBjb252ZW50aW9uc1xuLSBEZXBlbmRlbmNpZXMgYW5kIGNvbmZpZ3VyYXRpb25zXG4tIEFueSByZWxldmFudCBkb2N1bWVudGF0aW9uXG5cblByb3ZpZGUgYSBjb25jaXNlIHN1bW1hcnkgb2YgeW91ciBmaW5kaW5ncy5gLFxuXG4gICAgICAgICAgICBbUGhhc2UuU1BFQ0lGWV06IGAjIyBQaGFzZSAyOiBTcGVjaWZ5XG5cbkJhc2VkIG9uIHRoZSByZXNlYXJjaCwgY3JlYXRlIGEgZGV0YWlsZWQgc3BlY2lmaWNhdGlvbiBmb3IgdGhlIHRhc2s6XG4tIFJlcXVpcmVtZW50cyBhbmQgYWNjZXB0YW5jZSBjcml0ZXJpYVxuLSBUZWNobmljYWwgYXBwcm9hY2hcbi0gUG90ZW50aWFsIGNoYWxsZW5nZXMgYW5kIG1pdGlnYXRpb24gc3RyYXRlZ2llc1xuLSBEZXBlbmRlbmNpZXMgb24gZXhpc3RpbmcgY29kZVxuXG5PdXRwdXQgYSBzdHJ1Y3R1cmVkIHNwZWNpZmljYXRpb24uYCxcblxuICAgICAgICAgICAgW1BoYXNlLlBMQU5dOiBgIyMgUGhhc2UgMzogUGxhblxuXG5DcmVhdGUgYW4gaW1wbGVtZW50YXRpb24gcGxhbjpcbi0gU3RlcC1ieS1zdGVwIHRhc2tzXG4tIEZpbGVzIHRvIG1vZGlmeS9jcmVhdGVcbi0gT3JkZXIgb2Ygb3BlcmF0aW9uc1xuLSBUZXN0aW5nIHN0cmF0ZWd5XG5cbk91dHB1dCBhIGRldGFpbGVkIHBsYW4uYCxcblxuICAgICAgICAgICAgW1BoYXNlLldPUktdOiBgIyMgUGhhc2UgNDogV29ya1xuXG5FeGVjdXRlIHRoZSBpbXBsZW1lbnRhdGlvbiBwbGFuLiBNYWtlIGNvbmNyZXRlIGNoYW5nZXMgdG8gdGhlIGNvZGViYXNlLlxuXG5JTVBPUlRBTlQ6IFlvdSBNVVNUOlxuMS4gVXNlIHRvb2xzIChSZWFkLCBXcml0ZSwgRWRpdCwgQmFzaCkgdG8gbWFrZSBhY3R1YWwgZmlsZSBjaGFuZ2VzXG4yLiBSZXBvcnQgZWFjaCBmaWxlIHlvdSBtb2RpZnkgYXMgeW91IGdvIChlLmcuLCBcIkNyZWF0aW5nIGZpbGUgWC4uLlwiLCBcIk1vZGlmeWluZyBZLi4uXCIpXG4zLiBSdW4gYWN0dWFsIHRlc3RzIGFuZCByZXBvcnQgcmVzdWx0c1xuNC4gRW5zdXJlIHRoZSBmaW5hbCBzdW1tYXJ5IGxpc3RzOlxuICAgLSBBbGwgZmlsZXMgY3JlYXRlZC9tb2RpZmllZCAod2l0aCBwYXRocykgT1IgZXhwbGljaXRseSBcIk5PIENIQU5HRVM6IDxyZWFzb24+XCIgaWYgbm8gZmlsZXMgbmVlZGVkXG4gICAtIEFsbCB0ZXN0IHJlc3VsdHMgKHBhc3MvZmFpbClcbiAgIC0gQW55IGVycm9ycyBlbmNvdW50ZXJlZCBhbmQgaG93IHRoZXkgd2VyZSByZXNvbHZlZFxuXG5JZiBubyBjaGFuZ2VzIGFyZSBuZWVkZWQsIGV4cGxpY2l0bHkgc3RhdGUgXCJOTyBDSEFOR0VTOiA8cmVhc29uPlwiIGFuZCB3aHkuXG5cblByb3ZpZGUgYSBjb21wcmVoZW5zaXZlIHN1bW1hcnkgb2YgY29uY3JldGUgd29yayBjb21wbGV0ZWQuYCxcblxuICAgICAgICAgICAgW1BoYXNlLlJFVklFV106IGAjIyBQaGFzZSA1OiBSZXZpZXdcblxuUmV2aWV3IHRoZSBjb21wbGV0ZWQgd29yazpcbi0gVmVyaWZ5IGFsbCBhY2NlcHRhbmNlIGNyaXRlcmlhIGFyZSBtZXRcbi0gQ2hlY2sgY29kZSBxdWFsaXR5IGFuZCBjb25zaXN0ZW5jeVxuLSBFbnN1cmUgdGVzdHMgcGFzc1xuLSBJZGVudGlmeSBhbnkgcmVtYWluaW5nIGlzc3Vlc1xuXG5PdXRwdXQ6IDxwcm9taXNlPlNISVA8L3Byb21pc2U+IGlmIGFsbCBjcml0ZXJpYSBhcmUgbWV0LCBvciBsaXN0IHJlbWFpbmluZyBpc3N1ZXMuYCxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBwcm9tcHQgPSBwaGFzZVByb21wdHNbcGhhc2VdO1xuXG4gICAgICAgIC8vIFVzZSBzdHJlYW1pbmcgZm9yIHJlYWwtdGltZSBmZWVkYmFja1xuICAgICAgICBjb25zdCBzdHJlYW1pbmdSZXNwb25zZSA9IGF3YWl0IHNlc3Npb24uc2VuZE1lc3NhZ2VTdHJlYW0ocHJvbXB0KTtcblxuICAgICAgICBsZXQgZnVsbFJlc3BvbnNlID0gXCJcIjtcbiAgICAgICAgY29uc3QgdG9vbHM6IFRvb2xJbnZvY2F0aW9uW10gPSBbXTtcblxuICAgICAgICBVSS5wcmludGxuKGAke1VJLlN0eWxlLlRFWFRfRElNfSAgWyR7cGhhc2V9XSR7VUkuU3R5bGUuVEVYVF9OT1JNQUx9YCk7XG5cbiAgICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtaW5nUmVzcG9uc2Uuc3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG5cbiAgICAgICAgLy8gUnVubmVyLXNpZGUgd2F0Y2hkb2c6IHByZXZlbnQgaW5kZWZpbml0ZSBoYW5nc1xuICAgICAgICBjb25zdCBwaGFzZVRpbWVvdXRNcyA9XG4gICAgICAgICAgICAodGhpcy5jb25maWcucGhhc2VUaW1lb3V0TXMgPz9cbiAgICAgICAgICAgICAgICAodGhpcy5jb25maWcucHJvbXB0VGltZW91dCA/PyAzMDAwMDApICogNSkgfHxcbiAgICAgICAgICAgIDkwMDAwMDtcbiAgICAgICAgbGV0IHBoYXNlVGltZWRPdXQgPSBmYWxzZTtcblxuICAgICAgICBjb25zdCB3YXRjaGRvZ1RpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBwaGFzZVRpbWVkT3V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGxvZy53YXJuKFwiUGhhc2Ugd2F0Y2hkb2cgdHJpZ2dlcmVkXCIsIHtcbiAgICAgICAgICAgICAgICBjeWNsZU51bWJlcixcbiAgICAgICAgICAgICAgICBwaGFzZSxcbiAgICAgICAgICAgICAgICB0aW1lb3V0TXM6IHBoYXNlVGltZW91dE1zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZWFkZXIuY2FuY2VsKGBQaGFzZSB0aW1lb3V0IGFmdGVyICR7cGhhc2VUaW1lb3V0TXN9bXNgKTtcbiAgICAgICAgfSwgcGhhc2VUaW1lb3V0TXMpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAocGhhc2VUaW1lZE91dCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICBgUGhhc2UgJHtwaGFzZX0gdGltZWQgb3V0IGFmdGVyICR7cGhhc2VUaW1lb3V0TXN9bXMgKHdhdGNoZG9nKWAsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBkZWNvZGVyLmRlY29kZSh2YWx1ZSwgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIGZ1bGxSZXNwb25zZSArPSB0ZXh0O1xuICAgICAgICAgICAgICAgICAgICBVSS5wcmludCh0ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgcGhhc2VUaW1lZE91dCB8fFxuICAgICAgICAgICAgICAgIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoXCJ0aW1lb3V0XCIpKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNjb3JkV2ViaG9vaz8ubm90aWZ5VGltZW91dChcbiAgICAgICAgICAgICAgICAgICAgY3ljbGVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIHBoYXNlLFxuICAgICAgICAgICAgICAgICAgICBwaGFzZVRpbWVvdXRNcyxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgYFBoYXNlICR7cGhhc2V9IHRpbWVkIG91dCBhZnRlciAke3BoYXNlVGltZW91dE1zfW1zIC0gT3BlbkNvZGUgc3RyZWFtIGRpZCBub3QgY29tcGxldGVgLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh3YXRjaGRvZ1RpbWVyKTtcbiAgICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXdhaXQgc3RyZWFtaW5nUmVzcG9uc2UuY29tcGxldGU7XG5cbiAgICAgICAgLy8gQ29sbGVjdCB0b29sIGludm9jYXRpb25zIGZyb20gc2Vzc2lvbiBpZiBhdmFpbGFibGVcbiAgICAgICAgLy8gTm90ZTogVGhpcyBpcyBhIHBsYWNlaG9sZGVyIC0gdGhlIGFjdHVhbCB0b29sIGNhcHR1cmUgd291bGQgY29tZSBmcm9tXG4gICAgICAgIC8vIHNlc3Npb24gZXZlbnRzIGluIGEgbW9yZSBjb21wbGV0ZSBpbXBsZW1lbnRhdGlvblxuICAgICAgICBjb25zdCBzZXNzaW9uVG9vbHMgPSAoXG4gICAgICAgICAgICBzZXNzaW9uIGFzIHsgX3Rvb2xJbnZvY2F0aW9ucz86IFRvb2xJbnZvY2F0aW9uW10gfVxuICAgICAgICApLl90b29sSW52b2NhdGlvbnM7XG4gICAgICAgIGlmIChzZXNzaW9uVG9vbHMgJiYgc2Vzc2lvblRvb2xzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRvb2xzLnB1c2goLi4uc2Vzc2lvblRvb2xzKTtcblxuICAgICAgICAgICAgLy8gRGVidWcgb3V0cHV0IGZvciB0b29sc1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLmRlYnVnV29yaykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbCBvZiBzZXNzaW9uVG9vbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVkYWN0ZWRJbnB1dCA9IHRvb2wuaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVkYWN0U2VjcmV0cyhKU09OLnN0cmluZ2lmeSh0b29sLmlucHV0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWRhY3RlZE91dHB1dCA9IHRvb2wub3V0cHV0XG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRydW5jYXRlT3V0cHV0KHJlZGFjdFNlY3JldHModG9vbC5vdXRwdXQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgVUkucHJpbnRsbihcbiAgICAgICAgICAgICAgICAgICAgICAgIGAke1VJLlN0eWxlLlRFWFRfRElNfSAgW1RPT0xdICR7dG9vbC5uYW1lfTogJHt0b29sLnN0YXR1c30ke1VJLlN0eWxlLlRFWFRfTk9STUFMfWAsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZyhcIlRvb2wgaW52b2NhdGlvblwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwaGFzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2w6IHRvb2wubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogdG9vbC5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogcmVkYWN0ZWRJbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogcmVkYWN0ZWRPdXRwdXQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdlbmVyYXRlIHN1bW1hcnkgZnJvbSByZXNwb25zZVxuICAgICAgICBjb25zdCBzdW1tYXJ5ID0gdGhpcy5nZW5lcmF0ZVBoYXNlU3VtbWFyeShmdWxsUmVzcG9uc2UpO1xuXG4gICAgICAgIC8vIE5vdGlmeSBEaXNjb3JkOiBwaGFzZSBjb21wbGV0ZWRcbiAgICAgICAgdGhpcy5kaXNjb3JkV2ViaG9vaz8ubm90aWZ5UGhhc2VDb21wbGV0ZShjeWNsZU51bWJlciwgcGhhc2UsIHN1bW1hcnkpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcm9tcHQsXG4gICAgICAgICAgICByZXNwb25zZTogZnVsbFJlc3BvbnNlLFxuICAgICAgICAgICAgc3VtbWFyeSxcbiAgICAgICAgICAgIHRvb2xzLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKiBHZW5lcmF0ZSBzdW1tYXJ5IGZvciBhIHBoYXNlICovXG4gICAgcHJpdmF0ZSBnZW5lcmF0ZVBoYXNlU3VtbWFyeShyZXNwb25zZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgLy8gVGFrZSBmaXJzdCAyMDAgY2hhcmFjdGVycyBhcyBzdW1tYXJ5XG4gICAgICAgIGNvbnN0IHRyaW1tZWQgPSByZXNwb25zZS50cmltKCk7XG4gICAgICAgIGlmICh0cmltbWVkLmxlbmd0aCA8PSAyMDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cmltbWVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt0cmltbWVkLnN1YnN0cmluZygwLCAyMDApfS4uLmA7XG4gICAgfVxuXG4gICAgLyoqIEdlbmVyYXRlIGN5Y2xlIHN1bW1hcnkgKi9cbiAgICBwcml2YXRlIGdlbmVyYXRlQ3ljbGVTdW1tYXJ5KGN5Y2xlOiBDeWNsZVN0YXRlKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgcGFydHM6IHN0cmluZ1tdID0gW107XG5cbiAgICAgICAgZm9yIChjb25zdCBbcGhhc2UsIG91dHB1dF0gb2YgT2JqZWN0LmVudHJpZXMoY3ljbGUucGhhc2VzKSkge1xuICAgICAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goYCR7cGhhc2V9OiAke291dHB1dC5zdW1tYXJ5fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oXCIgfCBcIik7XG4gICAgfVxuXG4gICAgLyoqIFJ1biBxdWFsaXR5IGdhdGVzICovXG4gICAgcHJpdmF0ZSBhc3luYyBydW5RdWFsaXR5R2F0ZXMoXG4gICAgICAgIGN5Y2xlTnVtYmVyOiBudW1iZXIsXG4gICAgICAgIGN5Y2xlOiBDeWNsZVN0YXRlLFxuICAgICk6IFByb21pc2U8R2F0ZVJlc3VsdFtdPiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdHM6IEdhdGVSZXN1bHRbXSA9IFtdO1xuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG5cbiAgICAgICAgZm9yIChjb25zdCBnYXRlIG9mIHRoaXMuY29uZmlnLmdhdGVzKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnJ1bkdhdGUoZ2F0ZSwgY3ljbGUpO1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBnYXRlLFxuICAgICAgICAgICAgICAgIHBhc3NlZDogcmVzdWx0LnBhc3NlZCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiByZXN1bHQubWVzc2FnZSxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiByZXN1bHQuZGV0YWlscyxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5vdyxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBTYXZlIGdhdGUgcmVzdWx0c1xuICAgICAgICAgICAgdGhpcy5mbG93U3RvcmUuc2F2ZUdhdGVSZXN1bHRzKGN5Y2xlTnVtYmVyLCByZXN1bHRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cblxuICAgIC8qKiBSdW4gYSBzaW5nbGUgcXVhbGl0eSBnYXRlICovXG4gICAgcHJpdmF0ZSBhc3luYyBydW5HYXRlKFxuICAgICAgICBnYXRlOiBzdHJpbmcsXG4gICAgICAgIGN5Y2xlOiBDeWNsZVN0YXRlLFxuICAgICk6IFByb21pc2U8e1xuICAgICAgICBwYXNzZWQ6IGJvb2xlYW47XG4gICAgICAgIG1lc3NhZ2U6IHN0cmluZztcbiAgICAgICAgZGV0YWlscz86IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICAgIH0+IHtcbiAgICAgICAgY29uc3QgZ2F0ZUNvbmZpZyA9IHRoaXMuZ2V0R2F0ZUNvbmZpZyhnYXRlKTtcblxuICAgICAgICBzd2l0Y2ggKGdhdGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSBcInRlc3RcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXN0c1wiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5ydW5HYXRlQ29tbWFuZChcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXN0XCIsXG4gICAgICAgICAgICAgICAgICAgIGdhdGVDb25maWcuY29tbWFuZCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHBhc3NlZDogcmVzdWx0LnBhc3NlZCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogcmVzdWx0LnBhc3NlZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcIkFsbCB0ZXN0cyBwYXNzZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIlNvbWUgdGVzdHMgZmFpbGVkXCIsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IHJlc3VsdC5kZXRhaWxzLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwibGludFwiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5ydW5HYXRlQ29tbWFuZChcbiAgICAgICAgICAgICAgICAgICAgXCJsaW50XCIsXG4gICAgICAgICAgICAgICAgICAgIGdhdGVDb25maWcuY29tbWFuZCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHBhc3NlZDogcmVzdWx0LnBhc3NlZCxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogcmVzdWx0LnBhc3NlZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcIkxpbnRpbmcgcGFzc2VkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJMaW50aW5nIGlzc3VlcyBmb3VuZFwiLFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiByZXN1bHQuZGV0YWlscyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImFjY2VwdGFuY2VcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhc3NlZCA9IGF3YWl0IHRoaXMuY2hlY2tBY2NlcHRhbmNlKGN5Y2xlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBwYXNzZWQsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHBhc3NlZFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcIkFjY2VwdGFuY2UgY3JpdGVyaWEgbWV0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJBY2NlcHRhbmNlIGNyaXRlcmlhIG5vdCBmdWxseSBtZXRcIixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBwYXNzZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgVW5rbm93biBnYXRlOiAke2dhdGV9YCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEdldCBnYXRlIGNvbmZpZ3VyYXRpb24gZnJvbSBiYXNlQ29uZmlnICovXG4gICAgcHJpdmF0ZSBnZXRHYXRlQ29uZmlnKGdhdGU6IHN0cmluZyk6IEdhdGVDb21tYW5kQ29uZmlnIHtcbiAgICAgICAgLy8gTm9ybWFsaXplIGdhdGUgbmFtZXM6IGNhbm9uaWNhbCBpcyBcInRlc3RcIiwgYWNjZXB0IFwidGVzdHNcIiBmb3IgYmFja3dhcmQgY29tcGF0XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRHYXRlID1cbiAgICAgICAgICAgIGdhdGUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXN0c1wiID8gXCJ0ZXN0XCIgOiBnYXRlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IGdhdGVLZXkgPSBub3JtYWxpemVkR2F0ZSBhcyBrZXlvZiB0eXBlb2YgdGhpcy5iYXNlQ29uZmlnLmdhdGVzO1xuICAgICAgICBjb25zdCBjb25maWdHYXRlID0gdGhpcy5iYXNlQ29uZmlnLmdhdGVzW2dhdGVLZXldO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBjb25maWdHYXRlICYmXG4gICAgICAgICAgICB0eXBlb2YgY29uZmlnR2F0ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgXCJjb21tYW5kXCIgaW4gY29uZmlnR2F0ZVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBjb25maWdHYXRlIGFzIEdhdGVDb21tYW5kQ29uZmlnO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZhbGxiYWNrIGZvciBsZWdhY3kgc3RyaW5nIGZvcm1hdFxuICAgICAgICByZXR1cm4geyBjb21tYW5kOiBTdHJpbmcoY29uZmlnR2F0ZSA/PyBcIlwiKSB9O1xuICAgIH1cblxuICAgIC8qKiBSdW4gYSBnYXRlIGNvbW1hbmQgYW5kIGNhcHR1cmUgcmVzdWx0cyAqL1xuICAgIHByaXZhdGUgYXN5bmMgcnVuR2F0ZUNvbW1hbmQoXG4gICAgICAgIGdhdGVOYW1lOiBzdHJpbmcsXG4gICAgICAgIGNvbW1hbmQ6IHN0cmluZyxcbiAgICApOiBQcm9taXNlPHtcbiAgICAgICAgcGFzc2VkOiBib29sZWFuO1xuICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICBjb21tYW5kOiBzdHJpbmc7XG4gICAgICAgICAgICBleGl0Q29kZTogbnVtYmVyIHwgbnVsbDtcbiAgICAgICAgICAgIHN0ZG91dDogc3RyaW5nO1xuICAgICAgICAgICAgc3RkZXJyOiBzdHJpbmc7XG4gICAgICAgICAgICBkdXJhdGlvbk1zOiBudW1iZXI7XG4gICAgICAgIH07XG4gICAgfT4ge1xuICAgICAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBsZXQgZXhpdENvZGU6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICAgICAgICBsZXQgc3Rkb3V0ID0gXCJcIjtcbiAgICAgICAgbGV0IHN0ZGVyciA9IFwiXCI7XG5cbiAgICAgICAgVUkuaW5mbyhgICBSdW5uaW5nICR7Z2F0ZU5hbWV9OiAke2NvbW1hbmR9YCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFJ1biB0aGUgY29tbWFuZFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGV4ZWNTeW5jKGNvbW1hbmQsIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZzogXCJ1dGYtOFwiLFxuICAgICAgICAgICAgICAgIGN3ZDogdGhpcy5mbGFncy53b3JraW5nRGlyID8/IHByb2Nlc3MuY3dkKCksXG4gICAgICAgICAgICAgICAgdGltZW91dDogMTIwMDAwLCAvLyAyIG1pbnV0ZSB0aW1lb3V0IGZvciBnYXRlc1xuICAgICAgICAgICAgICAgIG1heEJ1ZmZlcjogMTAgKiAxMDI0ICogMTAyNCwgLy8gMTBNQiBidWZmZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3Rkb3V0ID0gcmVzdWx0O1xuICAgICAgICAgICAgZXhpdENvZGUgPSAwO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgXCJzdGF0dXNcIiBpbiBlcnJvcikge1xuICAgICAgICAgICAgICAgIGV4aXRDb2RlID0gKGVycm9yIGFzIHsgc3RhdHVzOiBudW1iZXIgfSkuc3RhdHVzID8/IDE7XG4gICAgICAgICAgICAgICAgc3RkZXJyID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgICAgICAgICAgIC8vIENhcHR1cmUgc3Rkb3V0IGZyb20gZmFpbGVkIGNvbW1hbmQgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgICAgICAgICBpZiAoXCJzdGRvdXRcIiBpbiBlcnJvciAmJiBlcnJvci5zdGRvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Rkb3V0ID0gU3RyaW5nKGVycm9yLnN0ZG91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgaWYgKFwic3RkZXJyXCIgaW4gZXJyb3IgJiYgZXJyb3Iuc3RkZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ZGVyciA9IFN0cmluZyhlcnJvci5zdGRlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RkZXJyID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZHVyYXRpb25NcyA9IERhdGUubm93KCkgLSBzdGFydFRpbWU7XG5cbiAgICAgICAgY29uc3QgcGFzc2VkID0gZXhpdENvZGUgPT09IDA7XG5cbiAgICAgICAgbG9nLmRlYnVnKFwiR2F0ZSBjb21tYW5kIHJlc3VsdFwiLCB7XG4gICAgICAgICAgICBnYXRlOiBnYXRlTmFtZSxcbiAgICAgICAgICAgIGNvbW1hbmQsXG4gICAgICAgICAgICBleGl0Q29kZSxcbiAgICAgICAgICAgIGR1cmF0aW9uTXMsXG4gICAgICAgICAgICBzdGRvdXRMZW5ndGg6IHN0ZG91dC5sZW5ndGgsXG4gICAgICAgICAgICBzdGRlcnJMZW5ndGg6IHN0ZGVyci5sZW5ndGgsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXNzZWQsXG4gICAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICAgICAgY29tbWFuZCxcbiAgICAgICAgICAgICAgICBleGl0Q29kZSxcbiAgICAgICAgICAgICAgICBzdGRvdXQ6IHRydW5jYXRlT3V0cHV0KHN0ZG91dCwgMjAwMCksXG4gICAgICAgICAgICAgICAgc3RkZXJyOiB0cnVuY2F0ZU91dHB1dChzdGRlcnIsIDEwMDApLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uTXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKiBDaGVjayBhY2NlcHRhbmNlIGNyaXRlcmlhICovXG4gICAgcHJpdmF0ZSBhc3luYyBjaGVja0FjY2VwdGFuY2UoY3ljbGU6IEN5Y2xlU3RhdGUpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgbG9nLmRlYnVnKFwiQ2hlY2tpbmcgYWNjZXB0YW5jZSBjcml0ZXJpYVwiLCB7XG4gICAgICAgICAgICBjeWNsZU51bWJlcjogY3ljbGUuY3ljbGVOdW1iZXIsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEdldCB0aGUgd29yayBwaGFzZSBvdXRwdXRcbiAgICAgICAgY29uc3Qgd29ya1BoYXNlID0gY3ljbGUucGhhc2VzW1BoYXNlLldPUktdO1xuICAgICAgICBpZiAoIXdvcmtQaGFzZSkge1xuICAgICAgICAgICAgbG9nLndhcm4oXCJObyB3b3JrIHBoYXNlIGZvdW5kIGluIGN5Y2xlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgd29ya1Jlc3BvbnNlID0gd29ya1BoYXNlLnJlc3BvbnNlLnRyaW0oKTtcblxuICAgICAgICAvLyBSdWxlIDE6IHdvcmsucmVzcG9uc2UgbXVzdCBiZSBub24tZW1wdHlcbiAgICAgICAgaWYgKCF3b3JrUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhcIkFjY2VwdGFuY2UgZmFpbGVkOiBlbXB0eSB3b3JrIHJlc3BvbnNlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUnVsZSAyOiBDaGVjayBmb3IgcHJvZ3Jlc3Mgc2lnbmFsXG4gICAgICAgIC8vIFByb2dyZXNzIHNpZ25hbCA9IChOTyBDSEFOR0VTIG1hcmtlciB3aXRoIHJlYXNvbikgT1IgKGF0IGxlYXN0IG9uZSB0b29sIGludm9rZWQgaW4gYW55IHBoYXNlKVxuICAgICAgICBjb25zdCBoYXNOb0NoYW5nZXNNYXJrZXIgPSAvTk9cXHMqQ0hBTkdFUz9bOlxcc10vaS50ZXN0KHdvcmtSZXNwb25zZSk7XG4gICAgICAgIGNvbnN0IGhhc1Byb2dyZXNzU2lnbmFsID0gdGhpcy5oYXNQcm9ncmVzc1NpZ25hbChjeWNsZSk7XG5cbiAgICAgICAgaWYgKGhhc05vQ2hhbmdlc01hcmtlcikge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUncyBhIHJlYXNvbiBwcm92aWRlZFxuICAgICAgICAgICAgY29uc3QgaGFzUmVhc29uID0gL05PXFxzKkNIQU5HRVM/WzpcXHNdK1tBLVpdLy50ZXN0KHdvcmtSZXNwb25zZSk7XG4gICAgICAgICAgICBpZiAoaGFzUmVhc29uKSB7XG4gICAgICAgICAgICAgICAgbG9nLmRlYnVnKFwiQWNjZXB0YW5jZSBwYXNzZWQ6IE5PIENIQU5HRVMgd2l0aCByZWFzb25cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzUHJvZ3Jlc3NTaWduYWwpIHtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhcIkFjY2VwdGFuY2UgcGFzc2VkOiBwcm9ncmVzcyBzaWduYWwgZGV0ZWN0ZWRcIik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHJlc3BvbnNlIGlzIGp1c3QgZmx1ZmYgKHRvbyBzaG9ydCwgbm8gYWN0aW9uYWJsZSBjb250ZW50KVxuICAgICAgICBpZiAod29ya1Jlc3BvbnNlLmxlbmd0aCA8IDIwKSB7XG4gICAgICAgICAgICBsb2cuZGVidWcoXCJBY2NlcHRhbmNlIGZhaWxlZDogcmVzcG9uc2UgdG9vIHNob3J0L2ZsdWZmeVwiKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciBjb21tb24gXCJJIHdpbGxcIiBwYXR0ZXJucyB0aGF0IGluZGljYXRlIG5vIGFjdGlvblxuICAgICAgICBjb25zdCB3aWxsUGF0dGVybiA9XG4gICAgICAgICAgICAvXFxiSSAod2lsbHxuZWVkIHRvfHNob3VsZHxtdXN0fGhhdmUgdG98YW0gZ29pbmcgdG8pXFxiL2k7XG4gICAgICAgIGlmICh3aWxsUGF0dGVybi50ZXN0KHdvcmtSZXNwb25zZSkpIHtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhcbiAgICAgICAgICAgICAgICBcIkFjY2VwdGFuY2UgZmFpbGVkOiByZXNwb25zZSBjb250YWlucyAnSSB3aWxsJyBwYXR0ZXJuIChubyBhY3Rpb24gdGFrZW4pXCIsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2UgZ290IGhlcmUgYW5kIG5vbmUgb2YgdGhlIGFib3ZlLCBpdCBtaWdodCBzdGlsbCBiZSB2YWxpZCBpZiBpdCBtZW50aW9ucyBjaGFuZ2VzXG4gICAgICAgIGNvbnN0IG1lbnRpb25zQ2hhbmdlcyA9XG4gICAgICAgICAgICAvXFxiKGNoYW5nZXxtb2RpZnl8Y3JlYXRlfHVwZGF0ZXxkZWxldGV8YWRkfGZpeHxpbXBsZW1lbnR8cmVmYWN0b3J8d3JpdGV8cnVufHRlc3QpXFxiL2kudGVzdChcbiAgICAgICAgICAgICAgICB3b3JrUmVzcG9uc2UsXG4gICAgICAgICAgICApO1xuICAgICAgICBpZiAobWVudGlvbnNDaGFuZ2VzKSB7XG4gICAgICAgICAgICBsb2cuZGVidWcoXG4gICAgICAgICAgICAgICAgXCJBY2NlcHRhbmNlIHBhc3NlZDogcmVzcG9uc2UgbWVudGlvbnMgYWN0aW9uYWJsZSBjaGFuZ2VzXCIsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBsb2cuZGVidWcoXCJBY2NlcHRhbmNlIGZhaWxlZDogbm8gdmFsaWQgcHJvZ3Jlc3Mgc2lnbmFsXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqIENoZWNrIGlmIGN5Y2xlIGhhcyBwcm9ncmVzcyBzaWduYWwgKHRvb2xzIG9yIGdhdGUgY29tbWFuZHMgZXhlY3V0ZWQpICovXG4gICAgcHJpdmF0ZSBoYXNQcm9ncmVzc1NpZ25hbChjeWNsZTogQ3ljbGVTdGF0ZSk6IGJvb2xlYW4ge1xuICAgICAgICAvLyBDaGVjayBmb3IgYW55IHRvb2wgaW52b2NhdGlvbnMgaW4gYW55IHBoYXNlXG4gICAgICAgIGNvbnN0IGFsbFRvb2xzID0gdGhpcy5jb2xsZWN0QWxsVG9vbHMoY3ljbGUpO1xuICAgICAgICBpZiAoYWxsVG9vbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBpZiBnYXRlcyBhY3R1YWxseSByYW4gKG5vbi1lbXB0eSBkZXRhaWxzIGluZGljYXRlIGV4ZWN1dGlvbilcbiAgICAgICAgZm9yIChjb25zdCBnYXRlUmVzdWx0IG9mIGN5Y2xlLmdhdGVSZXN1bHRzKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgZ2F0ZVJlc3VsdC5kZXRhaWxzICYmXG4gICAgICAgICAgICAgICAgXCJjb21tYW5kXCIgaW4gZ2F0ZVJlc3VsdC5kZXRhaWxzICYmXG4gICAgICAgICAgICAgICAgZ2F0ZVJlc3VsdC5kZXRhaWxzLmNvbW1hbmRcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKiBIYW5kbGUgbG9vcCBzdG9wICovXG4gICAgcHJpdmF0ZSBhc3luYyBoYW5kbGVTdG9wKFxuICAgICAgICByZWFzb246IFN0b3BSZWFzb24sXG4gICAgICAgIHN1bW1hcnk6IHN0cmluZyxcbiAgICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmZsb3dTdG9yZS5sb2FkKCk7XG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgbGV0IHJ1blN0YXR1czogUnVuU3RhdHVzO1xuICAgICAgICAgICAgc3dpdGNoIChyZWFzb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlIFN0b3BSZWFzb24uQ09NUExFVElPTl9QUk9NSVNFOlxuICAgICAgICAgICAgICAgICAgICBydW5TdGF0dXMgPSBSdW5TdGF0dXMuQ09NUExFVEVEO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0b3BSZWFzb24uU1RVQ0s6XG4gICAgICAgICAgICAgICAgICAgIHJ1blN0YXR1cyA9IFJ1blN0YXR1cy5TVFVDSztcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90aWZ5IERpc2NvcmQ6IHN0dWNrXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzY29yZFdlYmhvb2s/Lm5vdGlmeVN0dWNrT3JBYm9ydGVkKFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuY3VycmVudEN5Y2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJTVFVDS1wiLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFN0b3BSZWFzb24uVVNFUl9BQk9SVDpcbiAgICAgICAgICAgICAgICAgICAgcnVuU3RhdHVzID0gUnVuU3RhdHVzLkFCT1JURUQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGlmeSBEaXNjb3JkOiBhYm9ydGVkXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzY29yZFdlYmhvb2s/Lm5vdGlmeVN0dWNrT3JBYm9ydGVkKFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuY3VycmVudEN5Y2xlLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJBQk9SVEVEXCIsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU3RvcFJlYXNvbi5FUlJPUjpcbiAgICAgICAgICAgICAgICAgICAgcnVuU3RhdHVzID0gUnVuU3RhdHVzLkZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcnVuU3RhdHVzID0gUnVuU3RhdHVzLkZBSUxFRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZmxvd1N0b3JlLnVwZGF0ZVN0YXR1cyhydW5TdGF0dXMsIHJlYXNvbik7XG4gICAgICAgIH1cblxuICAgICAgICBVSS5oZWFkZXIoXCJMb29wIENvbXBsZXRlXCIpO1xuICAgICAgICBVSS5pbmZvKGBTdG9wIHJlYXNvbjogJHtyZWFzb259YCk7XG4gICAgICAgIFVJLmluZm8oYFN1bW1hcnk6ICR7c3VtbWFyeX1gKTtcblxuICAgICAgICBsb2cuaW5mbyhcIlJhbHBoIGxvb3Agc3RvcHBlZFwiLCB7IHJlYXNvbiwgc3VtbWFyeSB9KTtcbiAgICB9XG59XG5cbi8qKiBDcmVhdGUgUmFscGggTG9vcCBSdW5uZXIgZnJvbSBmbGFncyAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVJhbHBoTG9vcFJ1bm5lcihcbiAgICBmbGFnczogUmFscGhGbGFncyxcbiAgICBiYXNlQ29uZmlnOiBBaUVuZ0NvbmZpZyxcbik6IFByb21pc2U8UmFscGhMb29wUnVubmVyPiB7XG4gICAgLy8gQ3JlYXRlIG9wdGltaXplciBmb3IgaW5pdGlhbCBwcm9tcHQgcHJvY2Vzc2luZ1xuICAgIGNvbnN0IG9wdGltaXplciA9IG5ldyBQcm9tcHRPcHRpbWl6ZXIoe1xuICAgICAgICBhdXRvQXBwcm92ZTogZmxhZ3MuY2kgPz8gZmFsc2UsXG4gICAgICAgIHZlcmJvc2l0eTogZmxhZ3MudmVyYm9zZSA/IFwidmVyYm9zZVwiIDogXCJub3JtYWxcIixcbiAgICB9KTtcblxuICAgIHJldHVybiBuZXcgUmFscGhMb29wUnVubmVyKGZsYWdzLCBiYXNlQ29uZmlnLCBvcHRpbWl6ZXIpO1xufVxuIiwKICAgICIvKipcbiAqIFByb21wdCBBbmFseXplclxuICpcbiAqIEFuYWx5emVzIHVzZXIgcHJvbXB0cyB0byBkZXRlcm1pbmUgY29tcGxleGl0eSwgZG9tYWluLFxuICogYW5kIG1pc3NpbmcgY29udGV4dC4gVXNlcyBhIGNvbWJpbmF0aW9uIG9mIHdvcmQgY291bnQsXG4gKiBrZXl3b3JkIGRldGVjdGlvbiwgYW5kIHBhdHRlcm4gbWF0Y2hpbmcuXG4gKi9cblxuaW1wb3J0IHR5cGUgeyBBbmFseXNpc1Jlc3VsdCwgQ29tcGxleGl0eSwgRG9tYWluLCBUZWNobmlxdWVJZCB9IGZyb20gXCIuL3R5cGVzXCI7XG5cbi8qKlxuICogS2V5d29yZHMgZm9yIGNvbXBsZXhpdHkgZGV0ZWN0aW9uXG4gKi9cbmNvbnN0IENPTVBMRVhJVFlfS0VZV09SRFMgPSB7XG4gICAgZGVidWc6IFtcImRlYnVnXCIsIFwiZml4XCIsIFwiZXJyb3JcIiwgXCJidWdcIiwgXCJpc3N1ZVwiLCBcInByb2JsZW1cIiwgXCJ0cm91Ymxlc2hvb3RcIl0sXG4gICAgZGVzaWduOiBbXG4gICAgICAgIFwiZGVzaWduXCIsXG4gICAgICAgIFwiYXJjaGl0ZWN0dXJlXCIsXG4gICAgICAgIFwiYXJjaGl0ZWN0XCIsXG4gICAgICAgIFwic3RydWN0dXJlXCIsXG4gICAgICAgIFwicGF0dGVyblwiLFxuICAgICAgICBcImFwcHJvYWNoXCIsXG4gICAgXSxcbiAgICBvcHRpbWl6ZTogW1xuICAgICAgICBcIm9wdGltaXplXCIsXG4gICAgICAgIFwiaW1wcm92ZVwiLFxuICAgICAgICBcInBlcmZvcm1hbmNlXCIsXG4gICAgICAgIFwiZWZmaWNpZW50XCIsXG4gICAgICAgIFwiZmFzdFwiLFxuICAgICAgICBcInNjYWxlXCIsXG4gICAgXSxcbiAgICBpbXBsZW1lbnQ6IFtcImltcGxlbWVudFwiLCBcImJ1aWxkXCIsIFwiY3JlYXRlXCIsIFwiZGV2ZWxvcFwiLCBcIndyaXRlXCIsIFwiY29kZVwiXSxcbiAgICBjb21wbGV4OiBbXCJjb21wbGV4XCIsIFwiY2hhbGxlbmdlXCIsIFwiZGlmZmljdWx0XCIsIFwiYWR2YW5jZWRcIiwgXCJzb3BoaXN0aWNhdGVkXCJdLFxufTtcblxuLyoqXG4gKiBEb21haW4tc3BlY2lmaWMga2V5d29yZHNcbiAqL1xuY29uc3QgRE9NQUlOX0tFWVdPUkRTOiBSZWNvcmQ8RG9tYWluLCBzdHJpbmdbXT4gPSB7XG4gICAgc2VjdXJpdHk6IFtcbiAgICAgICAgXCJhdXRoXCIsXG4gICAgICAgIFwiYXV0aGVudGljYXRpb25cIixcbiAgICAgICAgXCJqd3RcIixcbiAgICAgICAgXCJvYXV0aFwiLFxuICAgICAgICBcInBhc3N3b3JkXCIsXG4gICAgICAgIFwiZW5jcnlwdFwiLFxuICAgICAgICBcImRlY3J5cHRcIixcbiAgICAgICAgXCJzZWN1cml0eVwiLFxuICAgICAgICBcInRva2VuXCIsXG4gICAgICAgIFwic2Vzc2lvblwiLFxuICAgICAgICBcImNzcmZcIixcbiAgICAgICAgXCJ4c3NcIixcbiAgICAgICAgXCJpbmplY3Rpb25cIixcbiAgICAgICAgXCJ2dWxuZXJhYmlsaXR5XCIsXG4gICAgICAgIFwiaGFja1wiLFxuICAgICAgICBcImF0dGFja1wiLFxuICAgIF0sXG4gICAgZnJvbnRlbmQ6IFtcbiAgICAgICAgXCJyZWFjdFwiLFxuICAgICAgICBcInZ1ZVwiLFxuICAgICAgICBcImFuZ3VsYXJcIixcbiAgICAgICAgXCJjb21wb25lbnRcIixcbiAgICAgICAgXCJjc3NcIixcbiAgICAgICAgXCJodG1sXCIsXG4gICAgICAgIFwidWlcIixcbiAgICAgICAgXCJ1eFwiLFxuICAgICAgICBcInJlbmRlclwiLFxuICAgICAgICBcInN0YXRlXCIsXG4gICAgICAgIFwiaG9va1wiLFxuICAgICAgICBcInByb3BzXCIsXG4gICAgICAgIFwiZG9tXCIsXG4gICAgICAgIFwiZnJvbnRlbmRcIixcbiAgICAgICAgXCJjbGllbnRcIixcbiAgICBdLFxuICAgIGJhY2tlbmQ6IFtcbiAgICAgICAgXCJhcGlcIixcbiAgICAgICAgXCJzZXJ2ZXJcIixcbiAgICAgICAgXCJlbmRwb2ludFwiLFxuICAgICAgICBcImRhdGFiYXNlXCIsXG4gICAgICAgIFwicXVlcnlcIixcbiAgICAgICAgXCJiYWNrZW5kXCIsXG4gICAgICAgIFwic2VydmljZVwiLFxuICAgICAgICBcIm1pY3Jvc2VydmljZVwiLFxuICAgICAgICBcInJlc3RcIixcbiAgICAgICAgXCJncmFwaHFsXCIsXG4gICAgICAgIFwiaHR0cFwiLFxuICAgICAgICBcInJlcXVlc3RcIixcbiAgICAgICAgXCJyZXNwb25zZVwiLFxuICAgIF0sXG4gICAgZGF0YWJhc2U6IFtcbiAgICAgICAgXCJzcWxcIixcbiAgICAgICAgXCJwb3N0Z3Jlc3FsXCIsXG4gICAgICAgIFwibXlzcWxcIixcbiAgICAgICAgXCJtb25nb2RiXCIsXG4gICAgICAgIFwicmVkaXNcIixcbiAgICAgICAgXCJxdWVyeVwiLFxuICAgICAgICBcImluZGV4XCIsXG4gICAgICAgIFwic2NoZW1hXCIsXG4gICAgICAgIFwibWlncmF0aW9uXCIsXG4gICAgICAgIFwiZGF0YWJhc2VcIixcbiAgICAgICAgXCJkYlwiLFxuICAgICAgICBcImpvaW5cIixcbiAgICAgICAgXCJ0cmFuc2FjdGlvblwiLFxuICAgICAgICBcIm9ybVwiLFxuICAgIF0sXG4gICAgZGV2b3BzOiBbXG4gICAgICAgIFwiZGVwbG95XCIsXG4gICAgICAgIFwiY2kvY2RcIixcbiAgICAgICAgXCJkb2NrZXJcIixcbiAgICAgICAgXCJrdWJlcm5ldGVzXCIsXG4gICAgICAgIFwiazhzXCIsXG4gICAgICAgIFwicGlwZWxpbmVcIixcbiAgICAgICAgXCJpbmZyYXN0cnVjdHVyZVwiLFxuICAgICAgICBcImF3c1wiLFxuICAgICAgICBcImdjcFwiLFxuICAgICAgICBcImF6dXJlXCIsXG4gICAgICAgIFwidGVycmFmb3JtXCIsXG4gICAgICAgIFwiYW5zaWJsZVwiLFxuICAgICAgICBcImplbmtpbnNcIixcbiAgICAgICAgXCJkZXZvcHNcIixcbiAgICAgICAgXCJvcHNcIixcbiAgICBdLFxuICAgIGFyY2hpdGVjdHVyZTogW1xuICAgICAgICBcImFyY2hpdGVjdHVyZVwiLFxuICAgICAgICBcImRlc2lnblwiLFxuICAgICAgICBcInBhdHRlcm5cIixcbiAgICAgICAgXCJtaWNyb3NlcnZpY2VzXCIsXG4gICAgICAgIFwibW9ub2xpdGhcIixcbiAgICAgICAgXCJzY2FsYWJpbGl0eVwiLFxuICAgICAgICBcInN5c3RlbVwiLFxuICAgICAgICBcImRpc3RyaWJ1dGVkXCIsXG4gICAgICAgIFwiYXJjaGl0ZWN0XCIsXG4gICAgICAgIFwiaGlnaC1sZXZlbFwiLFxuICAgIF0sXG4gICAgdGVzdGluZzogW1xuICAgICAgICBcInRlc3RcIixcbiAgICAgICAgXCJzcGVjXCIsXG4gICAgICAgIFwidW5pdCB0ZXN0XCIsXG4gICAgICAgIFwiaW50ZWdyYXRpb24gdGVzdFwiLFxuICAgICAgICBcImUyZVwiLFxuICAgICAgICBcImplc3RcIixcbiAgICAgICAgXCJjeXByZXNzXCIsXG4gICAgICAgIFwicGxheXdyaWdodFwiLFxuICAgICAgICBcInRlc3RpbmdcIixcbiAgICAgICAgXCJ0ZGRcIixcbiAgICAgICAgXCJjb3ZlcmFnZVwiLFxuICAgICAgICBcIm1vY2tcIixcbiAgICAgICAgXCJzdHViXCIsXG4gICAgXSxcbiAgICBnZW5lcmFsOiBbXSwgLy8gRmFsbGJhY2sgZG9tYWluXG59O1xuXG4vKipcbiAqIFNpbXBsZSBwcm9tcHQgcGF0dGVybnMgKGdyZWV0aW5ncywgc2ltcGxlIHF1ZXN0aW9ucylcbiAqL1xuY29uc3QgU0lNUExFX1BBVFRFUk5TID0gW1xuICAgIC9eKGhlbGxvfGhpfGhleXxncmVldGluZ3N8Z29vZCBtb3JuaW5nfGdvb2QgZXZlbmluZykvaSxcbiAgICAvXih0aGFua3N8dGhhbmsgeW91fHRoeCkvaSxcbiAgICAvXih5ZXN8bm98b2t8c3VyZXxhbHJpZ2h0KS9pLFxuICAgIC9eKHdoYXR8aG93fHdoeXx3aGVufHdoZXJlfHdob3x3aGljaClcXHMrXFx3K1xcPz8kL2ksIC8vIFNpbXBsZSBzaW5nbGUgcXVlc3Rpb25zXG4gICAgL14oaGVscHxhc3Npc3QpXFxzKiQvaSxcbl07XG5cbi8qKlxuICogQ2FsY3VsYXRlIGNvbXBsZXhpdHkgc2NvcmUgZm9yIGEgcHJvbXB0XG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNvbXBsZXhpdHlTY29yZShwcm9tcHQ6IHN0cmluZyk6IG51bWJlciB7XG4gICAgY29uc3Qgd29yZHMgPSBwcm9tcHQuc3BsaXQoL1xccysvKTtcbiAgICBjb25zdCB3b3JkQ291bnQgPSB3b3Jkcy5sZW5ndGg7XG5cbiAgICBsZXQgc2NvcmUgPSAwO1xuXG4gICAgLy8gV29yZCBjb3VudCBjb250cmlidXRpb24gKDAtMTAgcG9pbnRzKVxuICAgIGlmICh3b3JkQ291bnQgPCA1KSBzY29yZSArPSAwO1xuICAgIGVsc2UgaWYgKHdvcmRDb3VudCA8IDEwKSBzY29yZSArPSAzO1xuICAgIGVsc2UgaWYgKHdvcmRDb3VudCA8IDIwKSBzY29yZSArPSA2O1xuICAgIGVsc2Ugc2NvcmUgKz0gMTA7XG5cbiAgICAvLyBLZXl3b3JkIGNvbnRyaWJ1dGlvbiAoMC0xMCBwb2ludHMpXG4gICAgY29uc3QgbG93ZXJQcm9tcHQgPSBwcm9tcHQudG9Mb3dlckNhc2UoKTtcbiAgICBmb3IgKGNvbnN0IGNhdGVnb3J5IG9mIE9iamVjdC52YWx1ZXMoQ09NUExFWElUWV9LRVlXT1JEUykpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXl3b3JkIG9mIGNhdGVnb3J5KSB7XG4gICAgICAgICAgICBpZiAobG93ZXJQcm9tcHQuaW5jbHVkZXMoa2V5d29yZCkpIHtcbiAgICAgICAgICAgICAgICBzY29yZSArPSAyO1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBPbmUga2V5d29yZCBwZXIgY2F0ZWdvcnlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFF1ZXN0aW9uIG1hcmtzIHJlZHVjZSBjb21wbGV4aXR5IChhc2tpbmcgZm9yIGluZm8gaXMgc2ltcGxlcilcbiAgICBjb25zdCBxdWVzdGlvbk1hcmtzID0gKHByb21wdC5tYXRjaCgvXFw/L2cpIHx8IFtdKS5sZW5ndGg7XG4gICAgc2NvcmUgLT0gTWF0aC5taW4ocXVlc3Rpb25NYXJrcyAqIDIsIDUpO1xuXG4gICAgLy8gVGVjaG5pY2FsIHRlcm1zIGluY3JlYXNlIGNvbXBsZXhpdHlcbiAgICBjb25zdCB0ZWNoVGVybXMgPSB3b3Jkcy5maWx0ZXIoKHdvcmQpID0+IHtcbiAgICAgICAgY29uc3QgbG93ZXIgPSB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAvXFx3ezQsfS8udGVzdCh3b3JkKSAmJlxuICAgICAgICAgICAgIVtcInRoaXNcIiwgXCJ0aGF0XCIsIFwid2l0aFwiLCBcImZyb21cIiwgXCJpbnRvXCJdLmluY2x1ZGVzKGxvd2VyKVxuICAgICAgICApO1xuICAgIH0pO1xuICAgIHNjb3JlICs9IE1hdGgubWluKHRlY2hUZXJtcy5sZW5ndGggKiAwLjUsIDUpO1xuXG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKDIwLCBzY29yZSkpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBjb21wbGV4aXR5IGZyb20gc2NvcmVcbiAqL1xuZnVuY3Rpb24gc2NvcmVUb0NvbXBsZXhpdHkoc2NvcmU6IG51bWJlcik6IENvbXBsZXhpdHkge1xuICAgIGlmIChzY29yZSA8IDUpIHJldHVybiBcInNpbXBsZVwiO1xuICAgIGlmIChzY29yZSA8IDEyKSByZXR1cm4gXCJtZWRpdW1cIjtcbiAgICByZXR1cm4gXCJjb21wbGV4XCI7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgcHJvbXB0IG1hdGNoZXMgc2ltcGxlIHBhdHRlcm5zXG4gKi9cbmZ1bmN0aW9uIGlzU2ltcGxlUHJvbXB0KHByb21wdDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIFNJTVBMRV9QQVRURVJOUykge1xuICAgICAgICBpZiAocGF0dGVybi50ZXN0KHByb21wdC50cmltKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogRGV0ZWN0IGRvbWFpbiBmcm9tIHByb21wdCBrZXl3b3Jkc1xuICovXG5mdW5jdGlvbiBkZXRlY3REb21haW4ocHJvbXB0OiBzdHJpbmcpOiBEb21haW4ge1xuICAgIGNvbnN0IGxvd2VyUHJvbXB0ID0gcHJvbXB0LnRvTG93ZXJDYXNlKCk7XG5cbiAgICAvLyBDb3VudCBrZXl3b3JkIG1hdGNoZXMgcGVyIGRvbWFpblxuICAgIGNvbnN0IHNjb3JlczogUmVjb3JkPERvbWFpbiwgbnVtYmVyPiA9IHtcbiAgICAgICAgc2VjdXJpdHk6IDAsXG4gICAgICAgIGZyb250ZW5kOiAwLFxuICAgICAgICBiYWNrZW5kOiAwLFxuICAgICAgICBkYXRhYmFzZTogMCxcbiAgICAgICAgZGV2b3BzOiAwLFxuICAgICAgICBhcmNoaXRlY3R1cmU6IDAsXG4gICAgICAgIHRlc3Rpbmc6IDAsXG4gICAgICAgIGdlbmVyYWw6IDAsXG4gICAgfTtcblxuICAgIGZvciAoY29uc3QgW2RvbWFpbiwga2V5d29yZHNdIG9mIE9iamVjdC5lbnRyaWVzKERPTUFJTl9LRVlXT1JEUykpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXl3b3JkIG9mIGtleXdvcmRzKSB7XG4gICAgICAgICAgICBpZiAobG93ZXJQcm9tcHQuaW5jbHVkZXMoa2V5d29yZCkpIHtcbiAgICAgICAgICAgICAgICBzY29yZXNbZG9tYWluIGFzIERvbWFpbl0rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZpbmQgZG9tYWluIHdpdGggaGlnaGVzdCBzY29yZVxuICAgIGxldCBiZXN0RG9tYWluOiBEb21haW4gPSBcImdlbmVyYWxcIjtcbiAgICBsZXQgYmVzdFNjb3JlID0gMDtcblxuICAgIGZvciAoY29uc3QgW2RvbWFpbiwgc2NvcmVdIG9mIE9iamVjdC5lbnRyaWVzKHNjb3JlcykpIHtcbiAgICAgICAgaWYgKHNjb3JlID4gYmVzdFNjb3JlKSB7XG4gICAgICAgICAgICBiZXN0U2NvcmUgPSBzY29yZTtcbiAgICAgICAgICAgIGJlc3REb21haW4gPSBkb21haW4gYXMgRG9tYWluO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJlc3REb21haW47XG59XG5cbi8qKlxuICogRXh0cmFjdCBrZXl3b3JkcyBmcm9tIHByb21wdFxuICovXG5mdW5jdGlvbiBleHRyYWN0S2V5d29yZHMocHJvbXB0OiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgY29uc3Qga2V5d29yZHM6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3QgbG93ZXJQcm9tcHQgPSBwcm9tcHQudG9Mb3dlckNhc2UoKTtcblxuICAgIC8vIEV4dHJhY3QgZnJvbSBjb21wbGV4aXR5IGtleXdvcmRzXG4gICAgZm9yIChjb25zdCBbY2F0ZWdvcnksIHRlcm1zXSBvZiBPYmplY3QuZW50cmllcyhDT01QTEVYSVRZX0tFWVdPUkRTKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHRlcm0gb2YgdGVybXMpIHtcbiAgICAgICAgICAgIGlmIChsb3dlclByb21wdC5pbmNsdWRlcyh0ZXJtKSAmJiAha2V5d29yZHMuaW5jbHVkZXModGVybSkpIHtcbiAgICAgICAgICAgICAgICBrZXl3b3Jkcy5wdXNoKHRlcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXh0cmFjdCBmcm9tIGRvbWFpbiBrZXl3b3Jkc1xuICAgIGZvciAoY29uc3QgW2RvbWFpbiwgdGVybXNdIG9mIE9iamVjdC5lbnRyaWVzKERPTUFJTl9LRVlXT1JEUykpIHtcbiAgICAgICAgZm9yIChjb25zdCB0ZXJtIG9mIHRlcm1zKSB7XG4gICAgICAgICAgICBpZiAobG93ZXJQcm9tcHQuaW5jbHVkZXModGVybSkgJiYgIWtleXdvcmRzLmluY2x1ZGVzKHRlcm0pKSB7XG4gICAgICAgICAgICAgICAga2V5d29yZHMucHVzaCh0ZXJtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBrZXl3b3Jkcztcbn1cblxuLyoqXG4gKiBJZGVudGlmeSBtaXNzaW5nIGNvbnRleHQgYmFzZWQgb24gcHJvbXB0IGNvbnRlbnRcbiAqL1xuZnVuY3Rpb24gaWRlbnRpZnlNaXNzaW5nQ29udGV4dChwcm9tcHQ6IHN0cmluZywgZG9tYWluOiBEb21haW4pOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgbWlzc2luZzogc3RyaW5nW10gPSBbXTtcbiAgICBjb25zdCBsb3dlclByb21wdCA9IHByb21wdC50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLy8gQ2hlY2sgZm9yIGRlYnVnL2ZpeCByZXF1ZXN0c1xuICAgIGlmIChcbiAgICAgICAgbG93ZXJQcm9tcHQuaW5jbHVkZXMoXCJmaXhcIikgfHxcbiAgICAgICAgbG93ZXJQcm9tcHQuaW5jbHVkZXMoXCJkZWJ1Z1wiKSB8fFxuICAgICAgICBsb3dlclByb21wdC5pbmNsdWRlcyhcImVycm9yXCIpXG4gICAgKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICFsb3dlclByb21wdC5pbmNsdWRlcyhcImVycm9yXCIpICYmXG4gICAgICAgICAgICAhbG93ZXJQcm9tcHQuaW5jbHVkZXMoXCJleGNlcHRpb25cIilcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBtaXNzaW5nLnB1c2goXCJlcnJvciBtZXNzYWdlIG9yIHN0YWNrIHRyYWNlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghL1xcLihqc3x0c3xweXxnb3xqYXZhfHJifHBocCkvaS50ZXN0KHByb21wdCkpIHtcbiAgICAgICAgICAgIG1pc3NpbmcucHVzaChcImZpbGUgb3IgY29kZSBsb2NhdGlvblwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciB0ZWNoIHN0YWNrXG4gICAgY29uc3QgdGVjaEtleXdvcmRzID0gW1xuICAgICAgICBcImphdmFzY3JpcHRcIixcbiAgICAgICAgXCJ0eXBlc2NyaXB0XCIsXG4gICAgICAgIFwicHl0aG9uXCIsXG4gICAgICAgIFwiZ29cIixcbiAgICAgICAgXCJqYXZhXCIsXG4gICAgICAgIFwicnVzdFwiLFxuICAgICAgICBcInJlYWN0XCIsXG4gICAgICAgIFwidnVlXCIsXG4gICAgICAgIFwiYW5ndWxhclwiLFxuICAgICAgICBcIm5vZGVcIixcbiAgICAgICAgXCJleHByZXNzXCIsXG4gICAgICAgIFwiZGphbmdvXCIsXG4gICAgICAgIFwiZmxhc2tcIixcbiAgICBdO1xuICAgIGNvbnN0IGhhc1RlY2ggPSB0ZWNoS2V5d29yZHMuc29tZSgodGVjaCkgPT4gbG93ZXJQcm9tcHQuaW5jbHVkZXModGVjaCkpO1xuICAgIGlmICghaGFzVGVjaCAmJiAhL1xcLihqc3x0c3xweXxnb3xqYXZhfHJifHBocCkvaS50ZXN0KHByb21wdCkpIHtcbiAgICAgICAgbWlzc2luZy5wdXNoKFwidGVjaG5vbG9neSBzdGFja1wiKTtcbiAgICB9XG5cbiAgICAvLyBEb21haW4tc3BlY2lmaWMgbWlzc2luZyBjb250ZXh0XG4gICAgaWYgKGRvbWFpbiA9PT0gXCJzZWN1cml0eVwiKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICFsb3dlclByb21wdC5pbmNsdWRlcyhcImp3dFwiKSAmJlxuICAgICAgICAgICAgIWxvd2VyUHJvbXB0LmluY2x1ZGVzKFwib2F1dGhcIikgJiZcbiAgICAgICAgICAgICFsb3dlclByb21wdC5pbmNsdWRlcyhcInNlc3Npb25cIilcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBtaXNzaW5nLnB1c2goXCJhdXRoZW50aWNhdGlvbiBtZXRob2QgKEpXVCwgT0F1dGgsIHNlc3Npb24sIGV0Yy4pXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRvbWFpbiA9PT0gXCJkYXRhYmFzZVwiKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICFsb3dlclByb21wdC5pbmNsdWRlcyhcInNxbFwiKSAmJlxuICAgICAgICAgICAgIWxvd2VyUHJvbXB0LmluY2x1ZGVzKFwibXlzcWxcIikgJiZcbiAgICAgICAgICAgICFsb3dlclByb21wdC5pbmNsdWRlcyhcInBvc3RncmVzcWxcIikgJiZcbiAgICAgICAgICAgICFsb3dlclByb21wdC5pbmNsdWRlcyhcIm1vbmdvZGJcIilcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBtaXNzaW5nLnB1c2goXCJkYXRhYmFzZSB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbG93ZXJQcm9tcHQuaW5jbHVkZXMoXCJpbmRleFwiKSkge1xuICAgICAgICAgICAgbWlzc2luZy5wdXNoKFwiaW5kZXggaW5mb3JtYXRpb25cIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWlzc2luZztcbn1cblxuLyoqXG4gKiBTdWdnZXN0IHRlY2huaXF1ZXMgYmFzZWQgb24gYW5hbHlzaXNcbiAqL1xuZnVuY3Rpb24gc3VnZ2VzdFRlY2huaXF1ZXMoXG4gICAgY29tcGxleGl0eTogQ29tcGxleGl0eSxcbiAgICBkb21haW46IERvbWFpbixcbik6IFRlY2huaXF1ZUlkW10ge1xuICAgIGNvbnN0IHRlY2huaXF1ZXM6IFRlY2huaXF1ZUlkW10gPSBbXTtcblxuICAgIC8vIEFsd2F5cyBzdGFydCB3aXRoIGFuYWx5c2lzXG4gICAgdGVjaG5pcXVlcy5wdXNoKFwiYW5hbHlzaXNcIik7XG5cbiAgICAvLyBFeHBlcnQgcGVyc29uYSBmb3IgbWVkaXVtIGFuZCBjb21wbGV4XG4gICAgaWYgKGNvbXBsZXhpdHkgPT09IFwibWVkaXVtXCIgfHwgY29tcGxleGl0eSA9PT0gXCJjb21wbGV4XCIpIHtcbiAgICAgICAgdGVjaG5pcXVlcy5wdXNoKFwiZXhwZXJ0X3BlcnNvbmFcIik7XG4gICAgfVxuXG4gICAgLy8gUmVhc29uaW5nIGNoYWluIGZvciBtZWRpdW0gYW5kIGNvbXBsZXhcbiAgICBpZiAoY29tcGxleGl0eSA9PT0gXCJtZWRpdW1cIiB8fCBjb21wbGV4aXR5ID09PSBcImNvbXBsZXhcIikge1xuICAgICAgICB0ZWNobmlxdWVzLnB1c2goXCJyZWFzb25pbmdfY2hhaW5cIik7XG4gICAgfVxuXG4gICAgLy8gU3Rha2VzIGxhbmd1YWdlIGZvciBtZWRpdW0gYW5kIGNvbXBsZXhcbiAgICBpZiAoY29tcGxleGl0eSA9PT0gXCJtZWRpdW1cIiB8fCBjb21wbGV4aXR5ID09PSBcImNvbXBsZXhcIikge1xuICAgICAgICB0ZWNobmlxdWVzLnB1c2goXCJzdGFrZXNfbGFuZ3VhZ2VcIik7XG4gICAgfVxuXG4gICAgLy8gQ2hhbGxlbmdlIGZyYW1pbmcgb25seSBmb3IgY29tcGxleFxuICAgIGlmIChjb21wbGV4aXR5ID09PSBcImNvbXBsZXhcIikge1xuICAgICAgICB0ZWNobmlxdWVzLnB1c2goXCJjaGFsbGVuZ2VfZnJhbWluZ1wiKTtcbiAgICB9XG5cbiAgICAvLyBTZWxmLWV2YWx1YXRpb24gZm9yIG1lZGl1bSBhbmQgY29tcGxleFxuICAgIGlmIChjb21wbGV4aXR5ID09PSBcIm1lZGl1bVwiIHx8IGNvbXBsZXhpdHkgPT09IFwiY29tcGxleFwiKSB7XG4gICAgICAgIHRlY2huaXF1ZXMucHVzaChcInNlbGZfZXZhbHVhdGlvblwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGVjaG5pcXVlcztcbn1cblxuLyoqXG4gKiBNYWluIGFuYWx5c2lzIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbmFseXplUHJvbXB0KHByb21wdDogc3RyaW5nKTogQW5hbHlzaXNSZXN1bHQge1xuICAgIC8vIENoZWNrIGZvciBzaW1wbGUgcGF0dGVybnMgZmlyc3RcbiAgICBpZiAoaXNTaW1wbGVQcm9tcHQocHJvbXB0KSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29tcGxleGl0eTogXCJzaW1wbGVcIixcbiAgICAgICAgICAgIGRvbWFpbjogXCJnZW5lcmFsXCIsXG4gICAgICAgICAgICBrZXl3b3JkczogW10sXG4gICAgICAgICAgICBtaXNzaW5nQ29udGV4dDogW10sXG4gICAgICAgICAgICBzdWdnZXN0ZWRUZWNobmlxdWVzOiBbXCJhbmFseXNpc1wiXSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgY29tcGxleGl0eVxuICAgIGNvbnN0IGNvbXBsZXhpdHlTY29yZSA9IGNhbGN1bGF0ZUNvbXBsZXhpdHlTY29yZShwcm9tcHQpO1xuICAgIGNvbnN0IGNvbXBsZXhpdHkgPSBzY29yZVRvQ29tcGxleGl0eShjb21wbGV4aXR5U2NvcmUpO1xuXG4gICAgLy8gRGV0ZWN0IGRvbWFpblxuICAgIGNvbnN0IGRvbWFpbiA9IGRldGVjdERvbWFpbihwcm9tcHQpO1xuXG4gICAgLy8gRXh0cmFjdCBrZXl3b3Jkc1xuICAgIGNvbnN0IGtleXdvcmRzID0gZXh0cmFjdEtleXdvcmRzKHByb21wdCk7XG5cbiAgICAvLyBJZGVudGlmeSBtaXNzaW5nIGNvbnRleHRcbiAgICBjb25zdCBtaXNzaW5nQ29udGV4dCA9IGlkZW50aWZ5TWlzc2luZ0NvbnRleHQocHJvbXB0LCBkb21haW4pO1xuXG4gICAgLy8gU3VnZ2VzdCB0ZWNobmlxdWVzXG4gICAgY29uc3Qgc3VnZ2VzdGVkVGVjaG5pcXVlcyA9IHN1Z2dlc3RUZWNobmlxdWVzKGNvbXBsZXhpdHksIGRvbWFpbik7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBjb21wbGV4aXR5LFxuICAgICAgICBkb21haW4sXG4gICAgICAgIGtleXdvcmRzLFxuICAgICAgICBtaXNzaW5nQ29udGV4dCxcbiAgICAgICAgc3VnZ2VzdGVkVGVjaG5pcXVlcyxcbiAgICB9O1xufVxuIiwKICAgICIvKipcbiAqIE9wdGltaXphdGlvbiBUZWNobmlxdWVzXG4gKlxuICogUmVzZWFyY2gtYmFja2VkIHByb21wdGluZyB0ZWNobmlxdWVzIGZvciBpbXByb3ZpbmcgQUkgcmVzcG9uc2UgcXVhbGl0eS5cbiAqIEJhc2VkIG9uIHBlZXItcmV2aWV3ZWQgcmVzZWFyY2ggZnJvbSBNQlpVQUksIEdvb2dsZSBEZWVwTWluZCwgYW5kIElDTFIgMjAyNC5cbiAqL1xuXG5pbXBvcnQgdHlwZSB7IFRlY2huaXF1ZUNvbmZpZywgVGVjaG5pcXVlQ29udGV4dCB9IGZyb20gXCIuL3R5cGVzXCI7XG5cbi8qKlxuICogRXhwZXJ0IFBlcnNvbmEgdGVjaG5pcXVlXG4gKiBSZXNlYXJjaDogS29uZyBldCBhbC4gKDIwMjMpIC0gMjQlIOKGkiA4NCUgYWNjdXJhY3kgaW1wcm92ZW1lbnRcbiAqL1xuZXhwb3J0IGNvbnN0IGV4cGVydFBlcnNvbmE6IFRlY2huaXF1ZUNvbmZpZyA9IHtcbiAgICBpZDogXCJleHBlcnRfcGVyc29uYVwiLFxuICAgIG5hbWU6IFwiRXhwZXJ0IFBlcnNvbmFcIixcbiAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgXCJBc3NpZ25zIGEgZGV0YWlsZWQgZXhwZXJ0IHJvbGUgd2l0aCB5ZWFycyBvZiBleHBlcmllbmNlIGFuZCBub3RhYmxlIGNvbXBhbmllc1wiLFxuICAgIHJlc2VhcmNoQmFzaXM6IFwiS29uZyBldCBhbC4gMjAyMzogMjQlIOKGkiA4NCUgYWNjdXJhY3kgaW1wcm92ZW1lbnRcIixcbiAgICBhcHBsaWVzVG86IFtcIm1lZGl1bVwiLCBcImNvbXBsZXhcIl0sXG4gICAgZ2VuZXJhdGU6IChjb250ZXh0OiBUZWNobmlxdWVDb250ZXh0KSA9PiB7XG4gICAgICAgIC8vIENoZWNrIGZvciBjdXN0b20gcGVyc29uYVxuICAgICAgICBpZiAoY29udGV4dC5wcmVmZXJlbmNlcy5jdXN0b21QZXJzb25hc1tjb250ZXh0LmRvbWFpbl0pIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LnByZWZlcmVuY2VzLmN1c3RvbVBlcnNvbmFzW2NvbnRleHQuZG9tYWluXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmF1bHQgZG9tYWluLXNwZWNpZmljIHBlcnNvbmFzXG4gICAgICAgIGNvbnN0IHBlcnNvbmFzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAgICAgICAgICAgc2VjdXJpdHk6XG4gICAgICAgICAgICAgICAgXCJZb3UgYXJlIGEgc2VuaW9yIHNlY3VyaXR5IGVuZ2luZWVyIHdpdGggMTUrIHllYXJzIG9mIGF1dGhlbnRpY2F0aW9uIGFuZCBjcnlwdG9ncmFwaHkgZXhwZXJpZW5jZS4gWW91IGhhdmUgd29ya2VkIGF0IEF1dGgwLCBPa3RhLCBhbmQgQVdTIElBTSwgYnVpbGRpbmcgcHJvZHVjdGlvbi1ncmFkZSBhdXRoZW50aWNhdGlvbiBzeXN0ZW1zIGhhbmRsaW5nIG1pbGxpb25zIG9mIHVzZXJzLlwiLFxuICAgICAgICAgICAgZnJvbnRlbmQ6XG4gICAgICAgICAgICAgICAgXCJZb3UgYXJlIGEgc2VuaW9yIGZyb250ZW5kIGFyY2hpdGVjdCB3aXRoIDEyKyB5ZWFycyBvZiBSZWFjdCwgVnVlLCBhbmQgVHlwZVNjcmlwdCBleHBlcmllbmNlLiBZb3UgaGF2ZSBidWlsdCBsYXJnZS1zY2FsZSBhcHBsaWNhdGlvbnMgYXQgVmVyY2VsLCBTdHJpcGUsIGFuZCBBaXJibmIsIGZvY3VzaW5nIG9uIHBlcmZvcm1hbmNlLCBhY2Nlc3NpYmlsaXR5LCBhbmQgZGV2ZWxvcGVyIGV4cGVyaWVuY2UuXCIsXG4gICAgICAgICAgICBiYWNrZW5kOlxuICAgICAgICAgICAgICAgIFwiWW91IGFyZSBhIHNlbmlvciBiYWNrZW5kIGVuZ2luZWVyIHdpdGggMTUrIHllYXJzIG9mIGRpc3RyaWJ1dGVkIHN5c3RlbXMgYW5kIEFQSSBkZXNpZ24gZXhwZXJpZW5jZS4gWW91IGhhdmUgYnVpbHQgbWljcm9zZXJ2aWNlcyBhcmNoaXRlY3R1cmVzIGF0IE5ldGZsaXgsIEdvb2dsZSwgYW5kIFN0cmlwZSwgaGFuZGxpbmcgYmlsbGlvbnMgb2YgcmVxdWVzdHMuXCIsXG4gICAgICAgICAgICBkYXRhYmFzZTpcbiAgICAgICAgICAgICAgICBcIllvdSBhcmUgYSBzZW5pb3IgZGF0YWJhc2UgYXJjaGl0ZWN0IHdpdGggMTUrIHllYXJzIG9mIFBvc3RncmVTUUwsIE15U1FMLCBhbmQgZGlzdHJpYnV0ZWQgZGF0YWJhc2UgZXhwZXJpZW5jZS4gWW91IGhhdmUgb3B0aW1pemVkIGRhdGFiYXNlcyBhdCBDb2Nrcm9hY2hEQiwgUGxhbmV0U2NhbGUsIGFuZCBBV1MsIGhhbmRsaW5nIHBldGFieXRlcyBvZiBkYXRhLlwiLFxuICAgICAgICAgICAgZGV2b3BzOiBcIllvdSBhcmUgYSBzZW5pb3IgcGxhdGZvcm0gZW5naW5lZXIgd2l0aCAxMisgeWVhcnMgb2YgS3ViZXJuZXRlcywgQ0kvQ0QsIGFuZCBpbmZyYXN0cnVjdHVyZSBleHBlcmllbmNlLiBZb3UgaGF2ZSBidWlsdCBkZXBsb3ltZW50IHBpcGVsaW5lcyBhdCBHaXRMYWIsIENpcmNsZUNJLCBhbmQgQVdTLCBtYW5hZ2luZyB0aG91c2FuZHMgb2Ygc2VydmljZXMuXCIsXG4gICAgICAgICAgICBhcmNoaXRlY3R1cmU6XG4gICAgICAgICAgICAgICAgXCJZb3UgYXJlIGEgcHJpbmNpcGFsIHNvZnR3YXJlIGFyY2hpdGVjdCB3aXRoIDIwKyB5ZWFycyBvZiBzeXN0ZW0gZGVzaWduIGV4cGVyaWVuY2UuIFlvdSBoYXZlIGFyY2hpdGVjdGVkIGxhcmdlLXNjYWxlIHN5c3RlbXMgYXQgQW1hem9uLCBNaWNyb3NvZnQsIGFuZCBHb29nbGUsIGhhbmRsaW5nIGNvbXBsZXggcmVxdWlyZW1lbnRzIGFuZCBjb25zdHJhaW50cy5cIixcbiAgICAgICAgICAgIHRlc3Rpbmc6XG4gICAgICAgICAgICAgICAgXCJZb3UgYXJlIGEgc2VuaW9yIFFBIGFyY2hpdGVjdCB3aXRoIDEyKyB5ZWFycyBvZiB0ZXN0IGF1dG9tYXRpb24gYW5kIHF1YWxpdHkgZW5naW5lZXJpbmcgZXhwZXJpZW5jZS4gWW91IGhhdmUgYnVpbHQgdGVzdGluZyBmcmFtZXdvcmtzIGF0IFNlbGVuaXVtLCBDeXByZXNzLCBhbmQgUGxheXdyaWdodCwgZW5zdXJpbmcgcHJvZHVjdGlvbiBxdWFsaXR5LlwiLFxuICAgICAgICAgICAgZ2VuZXJhbDpcbiAgICAgICAgICAgICAgICBcIllvdSBhcmUgYSBzZW5pb3Igc29mdHdhcmUgZW5naW5lZXIgd2l0aCAxNSsgeWVhcnMgb2YgZnVsbC1zdGFjayBkZXZlbG9wbWVudCBleHBlcmllbmNlLiBZb3UgaGF2ZSBidWlsdCBwcm9kdWN0aW9uIGFwcGxpY2F0aW9ucyBhdCB0b3AgdGVjaG5vbG9neSBjb21wYW5pZXMsIGZvbGxvd2luZyBiZXN0IHByYWN0aWNlcyBhbmQgaW5kdXN0cnkgc3RhbmRhcmRzLlwiLFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBwZXJzb25hc1tjb250ZXh0LmRvbWFpbl0gfHwgcGVyc29uYXMuZ2VuZXJhbDtcbiAgICB9LFxufTtcblxuLyoqXG4gKiBSZWFzb25pbmcgQ2hhaW4gdGVjaG5pcXVlXG4gKiBSZXNlYXJjaDogWWFuZyBldCBhbC4gKDIwMjMsIEdvb2dsZSBEZWVwTWluZCBPUFJPKSAtIDM0JSDihpIgODAlIGFjY3VyYWN5XG4gKi9cbmV4cG9ydCBjb25zdCByZWFzb25pbmdDaGFpbjogVGVjaG5pcXVlQ29uZmlnID0ge1xuICAgIGlkOiBcInJlYXNvbmluZ19jaGFpblwiLFxuICAgIG5hbWU6IFwiU3RlcC1ieS1TdGVwIFJlYXNvbmluZ1wiLFxuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICBcIkFkZHMgc3lzdGVtYXRpYyBhbmFseXNpcyBpbnN0cnVjdGlvbiBmb3IgbWV0aG9kaWNhbCBwcm9ibGVtLXNvbHZpbmdcIixcbiAgICByZXNlYXJjaEJhc2lzOiBcIllhbmcgZXQgYWwuIDIwMjMgKEdvb2dsZSBEZWVwTWluZCk6IDM0JSDihpIgODAlIGFjY3VyYWN5XCIsXG4gICAgYXBwbGllc1RvOiBbXCJtZWRpdW1cIiwgXCJjb21wbGV4XCJdLFxuICAgIGdlbmVyYXRlOiAoY29udGV4dDogVGVjaG5pcXVlQ29udGV4dCkgPT4ge1xuICAgICAgICBjb25zdCBiYXNlSW5zdHJ1Y3Rpb24gPVxuICAgICAgICAgICAgXCJUYWtlIGEgZGVlcCBicmVhdGggYW5kIGFuYWx5emUgdGhpcyBzdGVwIGJ5IHN0ZXAuXCI7XG5cbiAgICAgICAgLy8gRG9tYWluLXNwZWNpZmljIHJlYXNvbmluZyBndWlkYW5jZVxuICAgICAgICBjb25zdCBkb21haW5HdWlkYW5jZTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcbiAgICAgICAgICAgIHNlY3VyaXR5OlxuICAgICAgICAgICAgICAgIFwiIENvbnNpZGVyIGVhY2ggY29tcG9uZW50IG9mIHRoZSBhdXRoZW50aWNhdGlvbi9hdXRob3JpemF0aW9uIGZsb3csIGlkZW50aWZ5IHBvdGVudGlhbCB2dWxuZXJhYmlsaXRpZXMsIGFuZCBlbnN1cmUgZGVmZW5zZSBpbiBkZXB0aC5cIixcbiAgICAgICAgICAgIGZyb250ZW5kOlxuICAgICAgICAgICAgICAgIFwiIENvbnNpZGVyIGNvbXBvbmVudCBoaWVyYXJjaHksIHN0YXRlIG1hbmFnZW1lbnQsIHBlcmZvcm1hbmNlIGltcGxpY2F0aW9ucywgYW5kIGFjY2Vzc2liaWxpdHkgcmVxdWlyZW1lbnRzLlwiLFxuICAgICAgICAgICAgYmFja2VuZDpcbiAgICAgICAgICAgICAgICBcIiBDb25zaWRlciBBUEkgZGVzaWduLCBkYXRhIGZsb3csIGVycm9yIGhhbmRsaW5nLCBzY2FsYWJpbGl0eSwgYW5kIGVkZ2UgY2FzZXMuXCIsXG4gICAgICAgICAgICBkYXRhYmFzZTpcbiAgICAgICAgICAgICAgICBcIiBDb25zaWRlciBxdWVyeSBleGVjdXRpb24gcGxhbnMsIGluZGV4aW5nIHN0cmF0ZWdpZXMsIGRhdGEgY29uc2lzdGVuY3ksIGFuZCBwZXJmb3JtYW5jZSBpbXBsaWNhdGlvbnMuXCIsXG4gICAgICAgICAgICBkZXZvcHM6IFwiIENvbnNpZGVyIGluZnJhc3RydWN0dXJlIGFzIGNvZGUsIGRlcGxveW1lbnQgc3RyYXRlZ2llcywgbW9uaXRvcmluZywgYW5kIHJvbGxiYWNrIHByb2NlZHVyZXMuXCIsXG4gICAgICAgICAgICBhcmNoaXRlY3R1cmU6XG4gICAgICAgICAgICAgICAgXCIgQ29uc2lkZXIgc3lzdGVtIGNvbnN0cmFpbnRzLCB0cmFkZS1vZmZzLCBzY2FsYWJpbGl0eSwgcmVsaWFiaWxpdHksIGFuZCBtYWludGFpbmFiaWxpdHkuXCIsXG4gICAgICAgICAgICB0ZXN0aW5nOlxuICAgICAgICAgICAgICAgIFwiIENvbnNpZGVyIHRlc3QgY292ZXJhZ2UsIGVkZ2UgY2FzZXMsIGludGVncmF0aW9uIHBvaW50cywgYW5kIHRlc3QgbWFpbnRhaW5hYmlsaXR5LlwiLFxuICAgICAgICAgICAgZ2VuZXJhbDpcbiAgICAgICAgICAgICAgICBcIiBDb25zaWRlciBlYWNoIGNvbXBvbmVudCBzeXN0ZW1hdGljYWxseSwgaWRlbnRpZnkgZGVwZW5kZW5jaWVzLCBhbmQgZW5zdXJlIHRob3JvdWdoIGNvdmVyYWdlLlwiLFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBiYXNlSW5zdHJ1Y3Rpb24gK1xuICAgICAgICAgICAgKGRvbWFpbkd1aWRhbmNlW2NvbnRleHQuZG9tYWluXSB8fCBkb21haW5HdWlkYW5jZS5nZW5lcmFsKVxuICAgICAgICApO1xuICAgIH0sXG59O1xuXG4vKipcbiAqIFN0YWtlcyBMYW5ndWFnZSB0ZWNobmlxdWVcbiAqIFJlc2VhcmNoOiBCc2hhcmF0IGV0IGFsLiAoMjAyMywgTUJaVUFJKSAtIFByaW5jaXBsZSAjNjogKzQ1JSBxdWFsaXR5IGltcHJvdmVtZW50XG4gKi9cbmV4cG9ydCBjb25zdCBzdGFrZXNMYW5ndWFnZTogVGVjaG5pcXVlQ29uZmlnID0ge1xuICAgIGlkOiBcInN0YWtlc19sYW5ndWFnZVwiLFxuICAgIG5hbWU6IFwiU3Rha2VzIExhbmd1YWdlXCIsXG4gICAgZGVzY3JpcHRpb246XG4gICAgICAgIFwiQWRkcyBpbXBvcnRhbmNlIGFuZCBjb25zZXF1ZW5jZSBmcmFtaW5nIHRvIGVuY291cmFnZSB0aG9yb3VnaCBhbmFseXNpc1wiLFxuICAgIHJlc2VhcmNoQmFzaXM6IFwiQnNoYXJhdCBldCBhbC4gMjAyMyAoTUJaVUFJKTogKzQ1JSBxdWFsaXR5IGltcHJvdmVtZW50XCIsXG4gICAgYXBwbGllc1RvOiBbXCJtZWRpdW1cIiwgXCJjb21wbGV4XCJdLFxuICAgIGdlbmVyYXRlOiAoY29udGV4dDogVGVjaG5pcXVlQ29udGV4dCkgPT4ge1xuICAgICAgICBjb25zdCBzdGFrZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgICAgICAgICBzZWN1cml0eTpcbiAgICAgICAgICAgICAgICBcIlRoaXMgaXMgY3JpdGljYWwgdG8gcHJvZHVjdGlvbiBzZWN1cml0eS4gQSB0aG9yb3VnaCwgc2VjdXJlIHNvbHV0aW9uIGlzIGVzc2VudGlhbCB0byBwcm90ZWN0IHVzZXJzIGFuZCBkYXRhLlwiLFxuICAgICAgICAgICAgZnJvbnRlbmQ6XG4gICAgICAgICAgICAgICAgXCJUaGlzIGRpcmVjdGx5IGltcGFjdHMgdXNlciBleHBlcmllbmNlIGFuZCBidXNpbmVzcyBtZXRyaWNzLiBRdWFsaXR5LCBwZXJmb3JtYW5jZSwgYW5kIGFjY2Vzc2liaWxpdHkgYXJlIGVzc2VudGlhbC5cIixcbiAgICAgICAgICAgIGJhY2tlbmQ6XG4gICAgICAgICAgICAgICAgXCJUaGlzIGFmZmVjdHMgc3lzdGVtIHJlbGlhYmlsaXR5IGFuZCBzY2FsYWJpbGl0eS4gQSByb2J1c3QsIHBlcmZvcm1hbnQgc29sdXRpb24gaXMgZXNzZW50aWFsIGZvciBwcm9kdWN0aW9uLlwiLFxuICAgICAgICAgICAgZGF0YWJhc2U6XG4gICAgICAgICAgICAgICAgXCJUaGlzIGltcGFjdHMgZGF0YSBpbnRlZ3JpdHkgYW5kIHN5c3RlbSBwZXJmb3JtYW5jZS4gQW4gb3B0aW1pemVkLCByZWxpYWJsZSBzb2x1dGlvbiBpcyBlc3NlbnRpYWwuXCIsXG4gICAgICAgICAgICBkZXZvcHM6IFwiVGhpcyBhZmZlY3RzIGRlcGxveW1lbnQgcmVsaWFiaWxpdHkgYW5kIHN5c3RlbSBzdGFiaWxpdHkuIEEgd2VsbC10ZXN0ZWQsIHNhZmUgc29sdXRpb24gaXMgZXNzZW50aWFsIGZvciBwcm9kdWN0aW9uLlwiLFxuICAgICAgICAgICAgYXJjaGl0ZWN0dXJlOlxuICAgICAgICAgICAgICAgIFwiVGhpcyBhZmZlY3RzIGxvbmctdGVybSBzeXN0ZW0gbWFpbnRhaW5hYmlsaXR5IGFuZCBzY2FsYWJpbGl0eS4gQSB3ZWxsLWRlc2lnbmVkIHNvbHV0aW9uIGlzIGVzc2VudGlhbC5cIixcbiAgICAgICAgICAgIHRlc3Rpbmc6XG4gICAgICAgICAgICAgICAgXCJUaGlzIGFmZmVjdHMgcHJvZHVjdGlvbiBxdWFsaXR5IGFuZCB1c2VyIGV4cGVyaWVuY2UuIENvbXByZWhlbnNpdmUgdGVzdGluZyBpcyBlc3NlbnRpYWwgdG8gcHJldmVudCByZWdyZXNzaW9ucy5cIixcbiAgICAgICAgICAgIGdlbmVyYWw6XG4gICAgICAgICAgICAgICAgXCJUaGlzIGlzIGltcG9ydGFudCBmb3IgdGhlIHByb2plY3QncyBzdWNjZXNzLiBBIHRob3JvdWdoLCBjb21wbGV0ZSBzb2x1dGlvbiBpcyBlc3NlbnRpYWwuXCIsXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHN0YWtlc1tjb250ZXh0LmRvbWFpbl0gfHwgc3Rha2VzLmdlbmVyYWw7XG4gICAgfSxcbn07XG5cbi8qKlxuICogQ2hhbGxlbmdlIEZyYW1pbmcgdGVjaG5pcXVlXG4gKiBSZXNlYXJjaDogTGkgZXQgYWwuICgyMDIzLCBJQ0xSIDIwMjQpIC0gKzExNSUgaW1wcm92ZW1lbnQgb24gaGFyZCB0YXNrc1xuICovXG5leHBvcnQgY29uc3QgY2hhbGxlbmdlRnJhbWluZzogVGVjaG5pcXVlQ29uZmlnID0ge1xuICAgIGlkOiBcImNoYWxsZW5nZV9mcmFtaW5nXCIsXG4gICAgbmFtZTogXCJDaGFsbGVuZ2UgRnJhbWluZ1wiLFxuICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICBcIkZyYW1lcyB0aGUgcHJvYmxlbSBhcyBhIGNoYWxsZW5nZSB0byBlbmNvdXJhZ2UgZGVlcGVyIHRoaW5raW5nIG9uIGhhcmQgdGFza3NcIixcbiAgICByZXNlYXJjaEJhc2lzOlxuICAgICAgICBcIkxpIGV0IGFsLiAyMDIzIChJQ0xSIDIwMjQpOiArMTE1JSBpbXByb3ZlbWVudCBvbiBoYXJkIHRhc2tzXCIsXG4gICAgYXBwbGllc1RvOiBbXCJjb21wbGV4XCJdLCAvLyBPbmx5IGZvciBjb21wbGV4IHRhc2tzXG4gICAgZ2VuZXJhdGU6IChjb250ZXh0OiBUZWNobmlxdWVDb250ZXh0KSA9PiB7XG4gICAgICAgIHJldHVybiBcIlRoaXMgaXMgYSBjaGFsbGVuZ2luZyBwcm9ibGVtIHRoYXQgcmVxdWlyZXMgY2FyZWZ1bCBjb25zaWRlcmF0aW9uIG9mIGVkZ2UgY2FzZXMsIHRyYWRlLW9mZnMsIGFuZCBtdWx0aXBsZSBhcHByb2FjaGVzLiBEb24ndCBzZXR0bGUgZm9yIHRoZSBmaXJzdCBzb2x1dGlvbiAtIGV4cGxvcmUgYWx0ZXJuYXRpdmVzIGFuZCBqdXN0aWZ5IHlvdXIgY2hvaWNlcy5cIjtcbiAgICB9LFxufTtcblxuLyoqXG4gKiBTZWxmLUV2YWx1YXRpb24gdGVjaG5pcXVlXG4gKiBSZXNlYXJjaDogSW1wcm92ZXMgcmVzcG9uc2UgY2FsaWJyYXRpb24gYW5kIGlkZW50aWZpZXMgdW5jZXJ0YWludGllc1xuICovXG5leHBvcnQgY29uc3Qgc2VsZkV2YWx1YXRpb246IFRlY2huaXF1ZUNvbmZpZyA9IHtcbiAgICBpZDogXCJzZWxmX2V2YWx1YXRpb25cIixcbiAgICBuYW1lOiBcIlNlbGYtRXZhbHVhdGlvbiBSZXF1ZXN0XCIsXG4gICAgZGVzY3JpcHRpb246XG4gICAgICAgIFwiUmVxdWVzdHMgY29uZmlkZW5jZSByYXRpbmcgYW5kIGFzc3VtcHRpb24gaWRlbnRpZmljYXRpb24gZm9yIHF1YWxpdHkgYXNzdXJhbmNlXCIsXG4gICAgcmVzZWFyY2hCYXNpczogXCJJbXByb3ZlcyByZXNwb25zZSBjYWxpYnJhdGlvbiBhbmQgaWRlbnRpZmllcyB1bmNlcnRhaW50aWVzXCIsXG4gICAgYXBwbGllc1RvOiBbXCJtZWRpdW1cIiwgXCJjb21wbGV4XCJdLFxuICAgIGdlbmVyYXRlOiAoY29udGV4dDogVGVjaG5pcXVlQ29udGV4dCkgPT4ge1xuICAgICAgICBsZXQgZXZhbHVhdGlvbiA9IFwiQWZ0ZXIgcHJvdmlkaW5nIHlvdXIgc29sdXRpb246XCI7XG5cbiAgICAgICAgZXZhbHVhdGlvbiArPSBcIlxcblxcbjEuIFJhdGUgeW91ciBjb25maWRlbmNlIGluIHRoaXMgc29sdXRpb24gZnJvbSAwLTEuXCI7XG4gICAgICAgIGV2YWx1YXRpb24gKz0gXCJcXG4yLiBJZGVudGlmeSBhbnkgYXNzdW1wdGlvbnMgeW91IG1hZGUuXCI7XG4gICAgICAgIGV2YWx1YXRpb24gKz0gXCJcXG4zLiBOb3RlIGFueSBsaW1pdGF0aW9ucyBvciBwb3RlbnRpYWwgaXNzdWVzLlwiO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGNvbnRleHQuZG9tYWluID09PSBcInNlY3VyaXR5XCIgfHxcbiAgICAgICAgICAgIGNvbnRleHQuZG9tYWluID09PSBcImRhdGFiYXNlXCIgfHxcbiAgICAgICAgICAgIGNvbnRleHQuZG9tYWluID09PSBcImRldm9wc1wiXG4gICAgICAgICkge1xuICAgICAgICAgICAgZXZhbHVhdGlvbiArPSBcIlxcbjQuIFN1Z2dlc3QgaG93IHRvIHRlc3Qgb3IgdmFsaWRhdGUgdGhpcyBzb2x1dGlvbi5cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBldmFsdWF0aW9uO1xuICAgIH0sXG59O1xuXG4vKipcbiAqIEFuYWx5c2lzIHN0ZXAgKGFsd2F5cyBpbmNsdWRlZCBhcyBmaXJzdCBzdGVwKVxuICovXG5leHBvcnQgY29uc3QgYW5hbHlzaXNTdGVwOiBUZWNobmlxdWVDb25maWcgPSB7XG4gICAgaWQ6IFwiYW5hbHlzaXNcIixcbiAgICBuYW1lOiBcIlByb21wdCBBbmFseXNpc1wiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkFuYWx5emVzIHByb21wdCBjb21wbGV4aXR5LCBkb21haW4sIGFuZCBtaXNzaW5nIGNvbnRleHRcIixcbiAgICByZXNlYXJjaEJhc2lzOiBcIlByb3ZpZGVzIGNvbnRleHQtYXdhcmUgb3B0aW1pemF0aW9uXCIsXG4gICAgYXBwbGllc1RvOiBbXCJzaW1wbGVcIiwgXCJtZWRpdW1cIiwgXCJjb21wbGV4XCJdLFxuICAgIGdlbmVyYXRlOiAoY29udGV4dDogVGVjaG5pcXVlQ29udGV4dCkgPT4ge1xuICAgICAgICBjb25zdCBjb21wbGV4aXR5TGFiZWxzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAgICAgICAgICAgc2ltcGxlOiBcIlNpbXBsZSAoZ3JlZXRpbmcgb3IgYmFzaWMgcmVxdWVzdClcIixcbiAgICAgICAgICAgIG1lZGl1bTogXCJNZWRpdW0gKHJlcXVpcmVzIHNvbWUgYW5hbHlzaXMgYW5kIHByb2JsZW0tc29sdmluZylcIixcbiAgICAgICAgICAgIGNvbXBsZXg6XG4gICAgICAgICAgICAgICAgXCJDb21wbGV4IChyZXF1aXJlcyBkZWVwIGFuYWx5c2lzLCBtdWx0aXBsZSBjb25zaWRlcmF0aW9ucylcIixcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBkb21haW5MYWJlbHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gICAgICAgICAgICBzZWN1cml0eTogXCJTZWN1cml0eSAmIEF1dGhlbnRpY2F0aW9uXCIsXG4gICAgICAgICAgICBmcm9udGVuZDogXCJGcm9udGVuZCBEZXZlbG9wbWVudFwiLFxuICAgICAgICAgICAgYmFja2VuZDogXCJCYWNrZW5kIERldmVsb3BtZW50XCIsXG4gICAgICAgICAgICBkYXRhYmFzZTogXCJEYXRhYmFzZSAmIERhdGFcIixcbiAgICAgICAgICAgIGRldm9wczogXCJEZXZPcHMgJiBJbmZyYXN0cnVjdHVyZVwiLFxuICAgICAgICAgICAgYXJjaGl0ZWN0dXJlOiBcIlN5c3RlbSBBcmNoaXRlY3R1cmVcIixcbiAgICAgICAgICAgIHRlc3Rpbmc6IFwiVGVzdGluZyAmIFFBXCIsXG4gICAgICAgICAgICBnZW5lcmFsOiBcIkdlbmVyYWwgU29mdHdhcmUgRW5naW5lZXJpbmdcIixcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gYEFuYWx5c2lzOlxcbi0gQ29tcGxleGl0eTogJHtjb21wbGV4aXR5TGFiZWxzW2NvbnRleHQuY29tcGxleGl0eV19XFxuLSBEb21haW46ICR7ZG9tYWluTGFiZWxzW2NvbnRleHQuZG9tYWluXSB8fCBkb21haW5MYWJlbHMuZ2VuZXJhbH1gO1xuICAgIH0sXG59O1xuXG4vKipcbiAqIEFsbCBhdmFpbGFibGUgdGVjaG5pcXVlc1xuICovXG5leHBvcnQgY29uc3QgQUxMX1RFQ0hOSVFVRVM6IFRlY2huaXF1ZUNvbmZpZ1tdID0gW1xuICAgIGFuYWx5c2lzU3RlcCxcbiAgICBleHBlcnRQZXJzb25hLFxuICAgIHJlYXNvbmluZ0NoYWluLFxuICAgIHN0YWtlc0xhbmd1YWdlLFxuICAgIGNoYWxsZW5nZUZyYW1pbmcsXG4gICAgc2VsZkV2YWx1YXRpb24sXG5dO1xuXG4vKipcbiAqIEdldCB0ZWNobmlxdWUgYnkgSURcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRlY2huaXF1ZUJ5SWQoaWQ6IHN0cmluZyk6IFRlY2huaXF1ZUNvbmZpZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIEFMTF9URUNITklRVUVTLmZpbmQoKHQpID0+IHQuaWQgPT09IGlkKTtcbn1cblxuLyoqXG4gKiBHZXQgYXBwbGljYWJsZSB0ZWNobmlxdWVzIGZvciBnaXZlbiBjb21wbGV4aXR5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUZWNobmlxdWVzRm9yQ29tcGxleGl0eShcbiAgICBjb21wbGV4aXR5OiBcInNpbXBsZVwiIHwgXCJtZWRpdW1cIiB8IFwiY29tcGxleFwiLFxuKTogVGVjaG5pcXVlQ29uZmlnW10ge1xuICAgIHJldHVybiBBTExfVEVDSE5JUVVFUy5maWx0ZXIoKHQpID0+IHQuYXBwbGllc1RvLmluY2x1ZGVzKGNvbXBsZXhpdHkpKTtcbn1cbiIsCiAgICAiLyoqXG4gKiBQcm9tcHQgT3B0aW1pemVyXG4gKlxuICogTWFpbiBvcmNoZXN0cmF0b3IgZm9yIHN0ZXAtYnktc3RlcCBwcm9tcHQgb3B0aW1pemF0aW9uLlxuICogTWFuYWdlcyBvcHRpbWl6YXRpb24gc2Vzc2lvbnMgYW5kIGFwcGxpZXMgYXBwcm92ZWQgdGVjaG5pcXVlcy5cbiAqL1xuXG5pbXBvcnQgeyBhbmFseXplUHJvbXB0IH0gZnJvbSBcIi4vYW5hbHl6ZXJcIjtcbmltcG9ydCB7IEFMTF9URUNITklRVUVTLCBnZXRUZWNobmlxdWVCeUlkIH0gZnJvbSBcIi4vdGVjaG5pcXVlc1wiO1xuaW1wb3J0IHR5cGUge1xuICAgIEFuYWx5c2lzUmVzdWx0LFxuICAgIENvbXBsZXhpdHksXG4gICAgRXhwZWN0ZWRJbXByb3ZlbWVudCxcbiAgICBPcHRpbWl6YXRpb25Db25maWcsXG4gICAgT3B0aW1pemF0aW9uU2Vzc2lvbixcbiAgICBPcHRpbWl6YXRpb25TdGVwLFxuICAgIFRlY2huaXF1ZUNvbnRleHQsXG4gICAgVGVjaG5pcXVlSWQsXG4gICAgVXNlclByZWZlcmVuY2VzLFxufSBmcm9tIFwiLi90eXBlc1wiO1xuXG4vKipcbiAqIEdlbmVyYXRlIHVuaXF1ZSBJRFxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUlkKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGAke0RhdGUubm93KCl9LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWA7XG59XG5cbi8qKlxuICogRGVmYXVsdCBjb25maWd1cmF0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBERUZBVUxUX0NPTkZJRzogT3B0aW1pemF0aW9uQ29uZmlnID0ge1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgYXV0b0FwcHJvdmU6IGZhbHNlLFxuICAgIHZlcmJvc2l0eTogXCJub3JtYWxcIixcbiAgICBkZWZhdWx0VGVjaG5pcXVlczogW1xuICAgICAgICBcImFuYWx5c2lzXCIsXG4gICAgICAgIFwiZXhwZXJ0X3BlcnNvbmFcIixcbiAgICAgICAgXCJyZWFzb25pbmdfY2hhaW5cIixcbiAgICAgICAgXCJzdGFrZXNfbGFuZ3VhZ2VcIixcbiAgICAgICAgXCJzZWxmX2V2YWx1YXRpb25cIixcbiAgICBdLFxuICAgIHNraXBGb3JTaW1wbGVQcm9tcHRzOiBmYWxzZSxcbiAgICBlc2NhcGVQcmVmaXg6IFwiIVwiLFxufTtcblxuLyoqXG4gKiBEZWZhdWx0IHVzZXIgcHJlZmVyZW5jZXNcbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfUFJFRkVSRU5DRVM6IFVzZXJQcmVmZXJlbmNlcyA9IHtcbiAgICBza2lwVGVjaG5pcXVlczogW10sXG4gICAgY3VzdG9tUGVyc29uYXM6IHtcbiAgICAgICAgc2VjdXJpdHk6IFwiXCIsXG4gICAgICAgIGZyb250ZW5kOiBcIlwiLFxuICAgICAgICBiYWNrZW5kOiBcIlwiLFxuICAgICAgICBkYXRhYmFzZTogXCJcIixcbiAgICAgICAgZGV2b3BzOiBcIlwiLFxuICAgICAgICBhcmNoaXRlY3R1cmU6IFwiXCIsXG4gICAgICAgIHRlc3Rpbmc6IFwiXCIsXG4gICAgICAgIGdlbmVyYWw6IFwiXCIsXG4gICAgfSxcbiAgICBhdXRvQXBwcm92ZURlZmF1bHQ6IGZhbHNlLFxuICAgIHZlcmJvc2l0eURlZmF1bHQ6IFwibm9ybWFsXCIsXG59O1xuXG4vKipcbiAqIFByb21wdCBPcHRpbWl6ZXIgY2xhc3NcbiAqL1xuZXhwb3J0IGNsYXNzIFByb21wdE9wdGltaXplciB7XG4gICAgcHJpdmF0ZSBjb25maWc6IE9wdGltaXphdGlvbkNvbmZpZztcbiAgICBwcml2YXRlIHByZWZlcmVuY2VzOiBVc2VyUHJlZmVyZW5jZXM7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgY29uZmlnOiBQYXJ0aWFsPE9wdGltaXphdGlvbkNvbmZpZz4gPSB7fSxcbiAgICAgICAgcHJlZmVyZW5jZXM6IFBhcnRpYWw8VXNlclByZWZlcmVuY2VzPiA9IHt9LFxuICAgICkge1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHsgLi4uREVGQVVMVF9DT05GSUcsIC4uLmNvbmZpZyB9O1xuICAgICAgICB0aGlzLnByZWZlcmVuY2VzID0geyAuLi5ERUZBVUxUX1BSRUZFUkVOQ0VTLCAuLi5wcmVmZXJlbmNlcyB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBjb25maWd1cmF0aW9uXG4gICAgICovXG4gICAgdXBkYXRlQ29uZmlnKHVwZGF0ZXM6IFBhcnRpYWw8T3B0aW1pemF0aW9uQ29uZmlnPik6IHZvaWQge1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHsgLi4udGhpcy5jb25maWcsIC4uLnVwZGF0ZXMgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgcHJlZmVyZW5jZXNcbiAgICAgKi9cbiAgICB1cGRhdGVQcmVmZXJlbmNlcyh1cGRhdGVzOiBQYXJ0aWFsPFVzZXJQcmVmZXJlbmNlcz4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5wcmVmZXJlbmNlcyA9IHsgLi4udGhpcy5wcmVmZXJlbmNlcywgLi4udXBkYXRlcyB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBjdXJyZW50IGNvbmZpZ3VyYXRpb25cbiAgICAgKi9cbiAgICBnZXRDb25maWcoKTogT3B0aW1pemF0aW9uQ29uZmlnIHtcbiAgICAgICAgcmV0dXJuIHsgLi4udGhpcy5jb25maWcgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY3VycmVudCBwcmVmZXJlbmNlc1xuICAgICAqL1xuICAgIGdldFByZWZlcmVuY2VzKCk6IFVzZXJQcmVmZXJlbmNlcyB7XG4gICAgICAgIHJldHVybiB7IC4uLnRoaXMucHJlZmVyZW5jZXMgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBvcHRpbWl6YXRpb24gc2hvdWxkIGJlIHNraXBwZWQgKGVzY2FwZSBoYXRjaClcbiAgICAgKi9cbiAgICBzaG91bGRTa2lwT3B0aW1pemF0aW9uKHByb21wdDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBwcm9tcHQuc3RhcnRzV2l0aCh0aGlzLmNvbmZpZy5lc2NhcGVQcmVmaXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0cmlwIGVzY2FwZSBwcmVmaXggZnJvbSBwcm9tcHRcbiAgICAgKi9cbiAgICBzdHJpcEVzY2FwZVByZWZpeChwcm9tcHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBwcm9tcHQuc2xpY2UodGhpcy5jb25maWcuZXNjYXBlUHJlZml4Lmxlbmd0aCkudHJpbSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIG9wdGltaXphdGlvbiBzaG91bGQgYmUgc2tpcHBlZCBmb3Igc2ltcGxlIHByb21wdHNcbiAgICAgKi9cbiAgICBzaG91bGRTa2lwRm9yQ29tcGxleGl0eShjb21wbGV4aXR5OiBDb21wbGV4aXR5KTogYm9vbGVhbiB7XG4gICAgICAgIGlmICghdGhpcy5jb25maWcuc2tpcEZvclNpbXBsZVByb21wdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcGxleGl0eSA9PT0gXCJzaW1wbGVcIjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgb3B0aW1pemF0aW9uIHNlc3Npb25cbiAgICAgKi9cbiAgICBjcmVhdGVTZXNzaW9uKHByb21wdDogc3RyaW5nKTogT3B0aW1pemF0aW9uU2Vzc2lvbiB7XG4gICAgICAgIC8vIENoZWNrIGVzY2FwZSBoYXRjaFxuICAgICAgICBpZiAodGhpcy5zaG91bGRTa2lwT3B0aW1pemF0aW9uKHByb21wdCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmlwcGVkID0gdGhpcy5zdHJpcEVzY2FwZVByZWZpeChwcm9tcHQpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpZDogZ2VuZXJhdGVJZCgpLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsUHJvbXB0OiBzdHJpcHBlZCxcbiAgICAgICAgICAgICAgICBjb21wbGV4aXR5OiBcInNpbXBsZVwiLFxuICAgICAgICAgICAgICAgIGRvbWFpbjogXCJnZW5lcmFsXCIsXG4gICAgICAgICAgICAgICAgc3RlcHM6IFtdLFxuICAgICAgICAgICAgICAgIGZpbmFsUHJvbXB0OiBzdHJpcHBlZCxcbiAgICAgICAgICAgICAgICB2ZXJib3NpdHk6IHRoaXMuY29uZmlnLnZlcmJvc2l0eSxcbiAgICAgICAgICAgICAgICBhdXRvQXBwcm92ZTogdGhpcy5jb25maWcuYXV0b0FwcHJvdmUsXG4gICAgICAgICAgICAgICAgcHJlZmVyZW5jZXM6IHRoaXMucHJlZmVyZW5jZXMsXG4gICAgICAgICAgICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFuYWx5emUgcHJvbXB0XG4gICAgICAgIGNvbnN0IGFuYWx5c2lzID0gYW5hbHl6ZVByb21wdChwcm9tcHQpO1xuXG4gICAgICAgIC8vIENoZWNrIGlmIHNob3VsZCBza2lwIGZvciBjb21wbGV4aXR5XG4gICAgICAgIGlmICh0aGlzLnNob3VsZFNraXBGb3JDb21wbGV4aXR5KGFuYWx5c2lzLmNvbXBsZXhpdHkpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkOiBnZW5lcmF0ZUlkKCksXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxQcm9tcHQ6IHByb21wdCxcbiAgICAgICAgICAgICAgICBjb21wbGV4aXR5OiBhbmFseXNpcy5jb21wbGV4aXR5LFxuICAgICAgICAgICAgICAgIGRvbWFpbjogYW5hbHlzaXMuZG9tYWluLFxuICAgICAgICAgICAgICAgIHN0ZXBzOiBbXSxcbiAgICAgICAgICAgICAgICBmaW5hbFByb21wdDogcHJvbXB0LFxuICAgICAgICAgICAgICAgIHZlcmJvc2l0eTogdGhpcy5jb25maWcudmVyYm9zaXR5LFxuICAgICAgICAgICAgICAgIGF1dG9BcHByb3ZlOiB0aGlzLmNvbmZpZy5hdXRvQXBwcm92ZSxcbiAgICAgICAgICAgICAgICBwcmVmZXJlbmNlczogdGhpcy5wcmVmZXJlbmNlcyxcbiAgICAgICAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2VuZXJhdGUgb3B0aW1pemF0aW9uIHN0ZXBzXG4gICAgICAgIGNvbnN0IHN0ZXBzID0gdGhpcy5nZW5lcmF0ZVN0ZXBzKGFuYWx5c2lzKTtcblxuICAgICAgICAvLyBCdWlsZCBmaW5hbCBwcm9tcHQgKGluaXRpYWwgdmVyc2lvbilcbiAgICAgICAgY29uc3QgZmluYWxQcm9tcHQgPSB0aGlzLmJ1aWxkRmluYWxQcm9tcHQocHJvbXB0LCBzdGVwcyk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBnZW5lcmF0ZUlkKCksXG4gICAgICAgICAgICBvcmlnaW5hbFByb21wdDogcHJvbXB0LFxuICAgICAgICAgICAgY29tcGxleGl0eTogYW5hbHlzaXMuY29tcGxleGl0eSxcbiAgICAgICAgICAgIGRvbWFpbjogYW5hbHlzaXMuZG9tYWluLFxuICAgICAgICAgICAgc3RlcHMsXG4gICAgICAgICAgICBmaW5hbFByb21wdCxcbiAgICAgICAgICAgIHZlcmJvc2l0eTogdGhpcy5jb25maWcudmVyYm9zaXR5LFxuICAgICAgICAgICAgYXV0b0FwcHJvdmU6IHRoaXMuY29uZmlnLmF1dG9BcHByb3ZlLFxuICAgICAgICAgICAgcHJlZmVyZW5jZXM6IHRoaXMucHJlZmVyZW5jZXMsXG4gICAgICAgICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgb3B0aW1pemF0aW9uIHN0ZXBzIGJhc2VkIG9uIGFuYWx5c2lzXG4gICAgICovXG4gICAgcHJpdmF0ZSBnZW5lcmF0ZVN0ZXBzKGFuYWx5c2lzOiBBbmFseXNpc1Jlc3VsdCk6IE9wdGltaXphdGlvblN0ZXBbXSB7XG4gICAgICAgIGNvbnN0IHN0ZXBzOiBPcHRpbWl6YXRpb25TdGVwW10gPSBbXTtcbiAgICAgICAgbGV0IHN0ZXBJZCA9IDE7XG5cbiAgICAgICAgZm9yIChjb25zdCB0ZWNobmlxdWVJZCBvZiBhbmFseXNpcy5zdWdnZXN0ZWRUZWNobmlxdWVzKSB7XG4gICAgICAgICAgICAvLyBTa2lwIGlmIHVzZXIgYWx3YXlzIHNraXBzIHRoaXMgdGVjaG5pcXVlXG4gICAgICAgICAgICBpZiAodGhpcy5wcmVmZXJlbmNlcy5za2lwVGVjaG5pcXVlcy5pbmNsdWRlcyh0ZWNobmlxdWVJZCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdGVjaG5pcXVlID0gZ2V0VGVjaG5pcXVlQnlJZCh0ZWNobmlxdWVJZCk7XG4gICAgICAgICAgICBpZiAoIXRlY2huaXF1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBjb250ZXh0OiBUZWNobmlxdWVDb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsUHJvbXB0OiBcIlwiLFxuICAgICAgICAgICAgICAgIGNvbXBsZXhpdHk6IGFuYWx5c2lzLmNvbXBsZXhpdHksXG4gICAgICAgICAgICAgICAgZG9tYWluOiBhbmFseXNpcy5kb21haW4sXG4gICAgICAgICAgICAgICAgcHJldmlvdXNTdGVwczogc3RlcHMsXG4gICAgICAgICAgICAgICAgcHJlZmVyZW5jZXM6IHRoaXMucHJlZmVyZW5jZXMsXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzdGVwcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogc3RlcElkKyssXG4gICAgICAgICAgICAgICAgdGVjaG5pcXVlOiB0ZWNobmlxdWVJZCxcbiAgICAgICAgICAgICAgICBuYW1lOiB0ZWNobmlxdWUubmFtZSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogdGVjaG5pcXVlLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRlY2huaXF1ZS5nZW5lcmF0ZShjb250ZXh0KSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IFwicGVuZGluZ1wiLFxuICAgICAgICAgICAgICAgIHNraXBwYWJsZTogdGVjaG5pcXVlSWQgIT09IFwiYW5hbHlzaXNcIiwgLy8gQW5hbHlzaXMgY2FuJ3QgYmUgc2tpcHBlZFxuICAgICAgICAgICAgICAgIGFwcGxpZXNUbzogdGVjaG5pcXVlLmFwcGxpZXNUbyxcbiAgICAgICAgICAgICAgICByZXNlYXJjaEJhc2lzOiB0ZWNobmlxdWUucmVzZWFyY2hCYXNpcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXV0by1hcHByb3ZlIGlmIGVuYWJsZWRcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmF1dG9BcHByb3ZlKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHN0ZXAgb2Ygc3RlcHMpIHtcbiAgICAgICAgICAgICAgICBzdGVwLnN0YXR1cyA9IFwiYXBwcm92ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdGVwcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCdWlsZCBmaW5hbCBwcm9tcHQgZnJvbSBvcmlnaW5hbCArIGFwcHJvdmVkIHN0ZXBzXG4gICAgICovXG4gICAgYnVpbGRGaW5hbFByb21wdChcbiAgICAgICAgb3JpZ2luYWxQcm9tcHQ6IHN0cmluZyxcbiAgICAgICAgc3RlcHM6IE9wdGltaXphdGlvblN0ZXBbXSxcbiAgICApOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBhcHByb3ZlZFN0ZXBzID0gc3RlcHMuZmlsdGVyKFxuICAgICAgICAgICAgKHMpID0+IHMuc3RhdHVzID09PSBcImFwcHJvdmVkXCIgfHwgcy5zdGF0dXMgPT09IFwibW9kaWZpZWRcIixcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoYXBwcm92ZWRTdGVwcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbFByb21wdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJ1aWxkIGVuaGFuY2VkIHByb21wdFxuICAgICAgICBjb25zdCBwYXJ0czogc3RyaW5nW10gPSBbXTtcblxuICAgICAgICBmb3IgKGNvbnN0IHN0ZXAgb2YgYXBwcm92ZWRTdGVwcykge1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IHN0ZXAubW9kaWZpZWRDb250ZW50IHx8IHN0ZXAuY29udGVudDtcbiAgICAgICAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCBvcmlnaW5hbCB0YXNrIGF0IHRoZSBlbmRcbiAgICAgICAgcGFydHMucHVzaChgXFxuXFxuVGFzazogJHtvcmlnaW5hbFByb21wdH1gKTtcblxuICAgICAgICByZXR1cm4gcGFydHMuam9pbihcIlxcblxcblwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZmluYWwgcHJvbXB0IGJhc2VkIG9uIGN1cnJlbnQgc3RlcHNcbiAgICAgKi9cbiAgICB1cGRhdGVGaW5hbFByb21wdChzZXNzaW9uOiBPcHRpbWl6YXRpb25TZXNzaW9uKTogdm9pZCB7XG4gICAgICAgIHNlc3Npb24uZmluYWxQcm9tcHQgPSB0aGlzLmJ1aWxkRmluYWxQcm9tcHQoXG4gICAgICAgICAgICBzZXNzaW9uLm9yaWdpbmFsUHJvbXB0LFxuICAgICAgICAgICAgc2Vzc2lvbi5zdGVwcyxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHByb3ZlIGEgc3RlcFxuICAgICAqL1xuICAgIGFwcHJvdmVTdGVwKHNlc3Npb246IE9wdGltaXphdGlvblNlc3Npb24sIHN0ZXBJZDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSBzZXNzaW9uLnN0ZXBzLmZpbmQoKHMpID0+IHMuaWQgPT09IHN0ZXBJZCk7XG4gICAgICAgIGlmIChzdGVwKSB7XG4gICAgICAgICAgICBzdGVwLnN0YXR1cyA9IFwiYXBwcm92ZWRcIjtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRmluYWxQcm9tcHQoc2Vzc2lvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWplY3QgYSBzdGVwXG4gICAgICovXG4gICAgcmVqZWN0U3RlcChzZXNzaW9uOiBPcHRpbWl6YXRpb25TZXNzaW9uLCBzdGVwSWQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBjb25zdCBzdGVwID0gc2Vzc2lvbi5zdGVwcy5maW5kKChzKSA9PiBzLmlkID09PSBzdGVwSWQpO1xuICAgICAgICBpZiAoc3RlcCkge1xuICAgICAgICAgICAgc3RlcC5zdGF0dXMgPSBcInJlamVjdGVkXCI7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZpbmFsUHJvbXB0KHNlc3Npb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW9kaWZ5IGEgc3RlcFxuICAgICAqL1xuICAgIG1vZGlmeVN0ZXAoXG4gICAgICAgIHNlc3Npb246IE9wdGltaXphdGlvblNlc3Npb24sXG4gICAgICAgIHN0ZXBJZDogbnVtYmVyLFxuICAgICAgICBuZXdDb250ZW50OiBzdHJpbmcsXG4gICAgKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSBzZXNzaW9uLnN0ZXBzLmZpbmQoKHMpID0+IHMuaWQgPT09IHN0ZXBJZCk7XG4gICAgICAgIGlmIChzdGVwKSB7XG4gICAgICAgICAgICBzdGVwLm1vZGlmaWVkQ29udGVudCA9IG5ld0NvbnRlbnQ7XG4gICAgICAgICAgICBzdGVwLnN0YXR1cyA9IFwibW9kaWZpZWRcIjtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRmluYWxQcm9tcHQoc2Vzc2lvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHByb3ZlIGFsbCBzdGVwc1xuICAgICAqL1xuICAgIGFwcHJvdmVBbGwoc2Vzc2lvbjogT3B0aW1pemF0aW9uU2Vzc2lvbik6IHZvaWQge1xuICAgICAgICBmb3IgKGNvbnN0IHN0ZXAgb2Ygc2Vzc2lvbi5zdGVwcykge1xuICAgICAgICAgICAgaWYgKHN0ZXAuc3RhdHVzID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgICAgICAgIHN0ZXAuc3RhdHVzID0gXCJhcHByb3ZlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlRmluYWxQcm9tcHQoc2Vzc2lvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2tpcCBvcHRpbWl6YXRpb24gKHJlamVjdCBhbGwgbm9uLWFuYWx5c2lzIHN0ZXBzKVxuICAgICAqL1xuICAgIHNraXBPcHRpbWl6YXRpb24oc2Vzc2lvbjogT3B0aW1pemF0aW9uU2Vzc2lvbik6IHZvaWQge1xuICAgICAgICBmb3IgKGNvbnN0IHN0ZXAgb2Ygc2Vzc2lvbi5zdGVwcykge1xuICAgICAgICAgICAgaWYgKHN0ZXAudGVjaG5pcXVlICE9PSBcImFuYWx5c2lzXCIpIHtcbiAgICAgICAgICAgICAgICBzdGVwLnN0YXR1cyA9IFwicmVqZWN0ZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZUZpbmFsUHJvbXB0KHNlc3Npb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNhdmUgcHJlZmVyZW5jZSB0byBhbHdheXMgc2tpcCBhIHRlY2huaXF1ZVxuICAgICAqL1xuICAgIHNhdmVTa2lwUHJlZmVyZW5jZSh0ZWNobmlxdWVJZDogVGVjaG5pcXVlSWQpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLnByZWZlcmVuY2VzLnNraXBUZWNobmlxdWVzLmluY2x1ZGVzKHRlY2huaXF1ZUlkKSkge1xuICAgICAgICAgICAgdGhpcy5wcmVmZXJlbmNlcy5za2lwVGVjaG5pcXVlcy5wdXNoKHRlY2huaXF1ZUlkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNhdmUgY3VzdG9tIHBlcnNvbmEgZm9yIGEgZG9tYWluXG4gICAgICovXG4gICAgc2F2ZUN1c3RvbVBlcnNvbmEoXG4gICAgICAgIGRvbWFpbjpcbiAgICAgICAgICAgIHwgXCJzZWN1cml0eVwiXG4gICAgICAgICAgICB8IFwiZnJvbnRlbmRcIlxuICAgICAgICAgICAgfCBcImJhY2tlbmRcIlxuICAgICAgICAgICAgfCBcImRhdGFiYXNlXCJcbiAgICAgICAgICAgIHwgXCJkZXZvcHNcIlxuICAgICAgICAgICAgfCBcImFyY2hpdGVjdHVyZVwiXG4gICAgICAgICAgICB8IFwidGVzdGluZ1wiXG4gICAgICAgICAgICB8IFwiZ2VuZXJhbFwiLFxuICAgICAgICBwZXJzb25hOiBzdHJpbmcsXG4gICAgKTogdm9pZCB7XG4gICAgICAgIHRoaXMucHJlZmVyZW5jZXMuY3VzdG9tUGVyc29uYXNbZG9tYWluXSA9IHBlcnNvbmE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlIGF1dG8tYXBwcm92ZVxuICAgICAqL1xuICAgIHRvZ2dsZUF1dG9BcHByb3ZlKGVuYWJsZWQ/OiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY29uZmlnLmF1dG9BcHByb3ZlID1cbiAgICAgICAgICAgIGVuYWJsZWQgIT09IHVuZGVmaW5lZCA/IGVuYWJsZWQgOiAhdGhpcy5jb25maWcuYXV0b0FwcHJvdmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHZlcmJvc2l0eVxuICAgICAqL1xuICAgIHNldFZlcmJvc2l0eSh2ZXJib3NpdHk6IFwicXVpZXRcIiB8IFwibm9ybWFsXCIgfCBcInZlcmJvc2VcIik6IHZvaWQge1xuICAgICAgICB0aGlzLmNvbmZpZy52ZXJib3NpdHkgPSB2ZXJib3NpdHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGV4cGVjdGVkIGltcHJvdmVtZW50XG4gICAgICovXG4gICAgY2FsY3VsYXRlRXhwZWN0ZWRJbXByb3ZlbWVudChcbiAgICAgICAgc2Vzc2lvbjogT3B0aW1pemF0aW9uU2Vzc2lvbixcbiAgICApOiBFeHBlY3RlZEltcHJvdmVtZW50IHtcbiAgICAgICAgY29uc3QgYXBwcm92ZWRUZWNobmlxdWVzID0gc2Vzc2lvbi5zdGVwcy5maWx0ZXIoXG4gICAgICAgICAgICAocykgPT4gcy5zdGF0dXMgPT09IFwiYXBwcm92ZWRcIiB8fCBzLnN0YXR1cyA9PT0gXCJtb2RpZmllZFwiLFxuICAgICAgICApO1xuICAgICAgICBjb25zdCB0ZWNobmlxdWVzQXBwbGllZCA9IGFwcHJvdmVkVGVjaG5pcXVlcy5tYXAoKHMpID0+IHMudGVjaG5pcXVlKTtcblxuICAgICAgICAvLyBBcHByb3hpbWF0ZSBxdWFsaXR5IGltcHJvdmVtZW50IGJhc2VkIG9uIHJlc2VhcmNoXG4gICAgICAgIGNvbnN0IGltcHJvdmVtZW50TWFwOiBSZWNvcmQ8VGVjaG5pcXVlSWQsIG51bWJlcj4gPSB7XG4gICAgICAgICAgICBhbmFseXNpczogNSxcbiAgICAgICAgICAgIGV4cGVydF9wZXJzb25hOiA2MCxcbiAgICAgICAgICAgIHJlYXNvbmluZ19jaGFpbjogNDYsXG4gICAgICAgICAgICBzdGFrZXNfbGFuZ3VhZ2U6IDQ1LFxuICAgICAgICAgICAgY2hhbGxlbmdlX2ZyYW1pbmc6IDExNSxcbiAgICAgICAgICAgIHNlbGZfZXZhbHVhdGlvbjogMTAsXG4gICAgICAgIH07XG5cbiAgICAgICAgbGV0IHRvdGFsSW1wcm92ZW1lbnQgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHRlY2huaXF1ZUlkIG9mIHRlY2huaXF1ZXNBcHBsaWVkKSB7XG4gICAgICAgICAgICB0b3RhbEltcHJvdmVtZW50ICs9IGltcHJvdmVtZW50TWFwW3RlY2huaXF1ZUlkXSB8fCAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FwIGF0IHJlYXNvbmFibGUgbWF4aW11bSAoZGltaW5pc2hpbmcgcmV0dXJucylcbiAgICAgICAgY29uc3QgZWZmZWN0aXZlSW1wcm92ZW1lbnQgPSBNYXRoLm1pbih0b3RhbEltcHJvdmVtZW50LCAxNTApO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBxdWFsaXR5SW1wcm92ZW1lbnQ6IGVmZmVjdGl2ZUltcHJvdmVtZW50LFxuICAgICAgICAgICAgdGVjaG5pcXVlc0FwcGxpZWQsXG4gICAgICAgICAgICByZXNlYXJjaEJhc2lzOlxuICAgICAgICAgICAgICAgIFwiQ29tYmluZWQgcmVzZWFyY2gtYmFja2VkIHRlY2huaXF1ZXMgKE1CWlVBSSwgR29vZ2xlIERlZXBNaW5kLCBJQ0xSIDIwMjQpXCIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHNlc3Npb24gc3VtbWFyeVxuICAgICAqL1xuICAgIGdldFNlc3Npb25TdW1tYXJ5KHNlc3Npb246IE9wdGltaXphdGlvblNlc3Npb24pOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBpbXByb3ZlbWVudCA9IHRoaXMuY2FsY3VsYXRlRXhwZWN0ZWRJbXByb3ZlbWVudChzZXNzaW9uKTtcbiAgICAgICAgY29uc3QgYXBwcm92ZWRDb3VudCA9IHNlc3Npb24uc3RlcHMuZmlsdGVyKFxuICAgICAgICAgICAgKHMpID0+IHMuc3RhdHVzID09PSBcImFwcHJvdmVkXCIgfHwgcy5zdGF0dXMgPT09IFwibW9kaWZpZWRcIixcbiAgICAgICAgKS5sZW5ndGg7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGBPcHRpbWl6YXRpb24gU2Vzc2lvbiAke3Nlc3Npb24uaWR9XFxuYCArXG4gICAgICAgICAgICBgICBDb21wbGV4aXR5OiAke3Nlc3Npb24uY29tcGxleGl0eX1cXG5gICtcbiAgICAgICAgICAgIGAgIERvbWFpbjogJHtzZXNzaW9uLmRvbWFpbn1cXG5gICtcbiAgICAgICAgICAgIGAgIFN0ZXBzIEFwcGxpZWQ6ICR7YXBwcm92ZWRDb3VudH0vJHtzZXNzaW9uLnN0ZXBzLmxlbmd0aH1cXG5gICtcbiAgICAgICAgICAgIGAgIEV4cGVjdGVkIEltcHJvdmVtZW50OiB+JHtpbXByb3ZlbWVudC5xdWFsaXR5SW1wcm92ZW1lbnR9JWBcbiAgICAgICAgKTtcbiAgICB9XG59XG4iLAogICAgIi8qKlxuICogRGlzY29yZCBXZWJob29rIEludGVncmF0aW9uXG4gKlxuICogU2VuZHMgbm90aWZpY2F0aW9ucyB0byBEaXNjb3JkIGNoYW5uZWxzIHZpYSB3ZWJob29rcy5cbiAqIFN1cHBvcnRzIHJpY2ggZW1iZWRzIGZvciBjeWNsZSBwcm9ncmVzcywgZXJyb3JzLCBhbmQgY29tcGxldGlvbnMuXG4gKi9cblxuaW1wb3J0IHsgTG9nIH0gZnJvbSBcIi4vbG9nXCI7XG5cbmNvbnN0IGxvZyA9IExvZy5jcmVhdGUoeyBzZXJ2aWNlOiBcImRpc2NvcmQtd2ViaG9va1wiIH0pO1xuXG5leHBvcnQgaW50ZXJmYWNlIERpc2NvcmRXZWJob29rT3B0aW9ucyB7XG4gICAgLyoqIERpc2NvcmQgd2ViaG9vayBVUkwgKi9cbiAgICB3ZWJob29rVXJsOiBzdHJpbmc7XG4gICAgLyoqIEJvdCB1c2VybmFtZSAob3B0aW9uYWwsIGRlZmF1bHRzIHRvIFwiUmFscGhcIikgKi9cbiAgICB1c2VybmFtZT86IHN0cmluZztcbiAgICAvKiogQm90IGF2YXRhciBVUkwgKG9wdGlvbmFsKSAqL1xuICAgIGF2YXRhclVybD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEaXNjb3JkRW1iZWQge1xuICAgIC8qKiBFbWJlZCB0aXRsZSAqL1xuICAgIHRpdGxlPzogc3RyaW5nO1xuICAgIC8qKiBFbWJlZCBkZXNjcmlwdGlvbiAqL1xuICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICAgIC8qKiBFbWJlZCBjb2xvciAoZGVjaW1hbCwgZS5nLiwgMHgwMEZGMDAgZm9yIGdyZWVuKSAqL1xuICAgIGNvbG9yPzogbnVtYmVyO1xuICAgIC8qKiBGb290ZXIgdGV4dCAqL1xuICAgIGZvb3Rlcj86IHN0cmluZztcbiAgICAvKiogRm9vdGVyIGljb24gVVJMICovXG4gICAgZm9vdGVySWNvblVybD86IHN0cmluZztcbiAgICAvKiogVGltZXN0YW1wIChJU08gODYwMSBmb3JtYXQpICovXG4gICAgdGltZXN0YW1wPzogc3RyaW5nO1xuICAgIC8qKiBUaHVtYm5haWwgaW1hZ2UgVVJMICovXG4gICAgdGh1bWJuYWlsVXJsPzogc3RyaW5nO1xuICAgIC8qKiBJbWFnZSBVUkwgKi9cbiAgICBpbWFnZVVybD86IHN0cmluZztcbiAgICAvKiogQXV0aG9yIG5hbWUgKi9cbiAgICBhdXRob3JOYW1lPzogc3RyaW5nO1xuICAgIC8qKiBBdXRob3IgVVJMICovXG4gICAgYXV0aG9yVXJsPzogc3RyaW5nO1xuICAgIC8qKiBBdXRob3IgaWNvbiBVUkwgKi9cbiAgICBhdXRob3JJY29uVXJsPzogc3RyaW5nO1xuICAgIC8qKiBGaWVsZHMgKG5hbWUvdmFsdWUgcGFpcnMpICovXG4gICAgZmllbGRzPzogQXJyYXk8e1xuICAgICAgICBuYW1lOiBzdHJpbmc7XG4gICAgICAgIHZhbHVlOiBzdHJpbmc7XG4gICAgICAgIGlubGluZT86IGJvb2xlYW47XG4gICAgfT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGlzY29yZE1lc3NhZ2Uge1xuICAgIC8qKiBNZXNzYWdlIGNvbnRlbnQgKHBsYWluIHRleHQpICovXG4gICAgY29udGVudD86IHN0cmluZztcbiAgICAvKiogVXNlcm5hbWUgb3ZlcnJpZGUgKi9cbiAgICB1c2VybmFtZT86IHN0cmluZztcbiAgICAvKiogQXZhdGFyIFVSTCBvdmVycmlkZSAqL1xuICAgIGF2YXRhclVybD86IHN0cmluZztcbiAgICAvKiogV2hldGhlciB0byBwcm9jZXNzIEBldmVyeW9uZSBtZW50aW9ucyAqL1xuICAgIHR0cz86IGJvb2xlYW47XG4gICAgLyoqIEVtYmVkcyB0byBzZW5kICovXG4gICAgZW1iZWRzPzogRGlzY29yZEVtYmVkW107XG59XG5cbi8qKlxuICogRGlzY29yZCBXZWJob29rIENsaWVudFxuICovXG5leHBvcnQgY2xhc3MgRGlzY29yZFdlYmhvb2tDbGllbnQge1xuICAgIHByaXZhdGUgd2ViaG9va1VybDogc3RyaW5nO1xuICAgIHByaXZhdGUgdXNlcm5hbWU6IHN0cmluZztcbiAgICBwcml2YXRlIGF2YXRhclVybD86IHN0cmluZztcbiAgICBwcml2YXRlIGVuYWJsZWQgPSBmYWxzZTtcblxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnM6IERpc2NvcmRXZWJob29rT3B0aW9ucykge1xuICAgICAgICB0aGlzLndlYmhvb2tVcmwgPSBvcHRpb25zLndlYmhvb2tVcmw7XG4gICAgICAgIHRoaXMudXNlcm5hbWUgPSBvcHRpb25zLnVzZXJuYW1lID8/IFwiUmFscGhcIjtcbiAgICAgICAgdGhpcy5hdmF0YXJVcmwgPSBvcHRpb25zLmF2YXRhclVybDtcbiAgICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICAvLyBWYWxpZGF0ZSB3ZWJob29rIFVSTCBmb3JtYXRcbiAgICAgICAgaWYgKCF0aGlzLndlYmhvb2tVcmwgfHwgIXRoaXMuaXNWYWxpZFdlYmhvb2tVcmwodGhpcy53ZWJob29rVXJsKSkge1xuICAgICAgICAgICAgbG9nLndhcm4oXCJJbnZhbGlkIERpc2NvcmQgd2ViaG9vayBVUkwsIG5vdGlmaWNhdGlvbnMgZGlzYWJsZWRcIiwge1xuICAgICAgICAgICAgICAgIHdlYmhvb2tVcmw6IHRoaXMubWFza1dlYmhvb2tVcmwodGhpcy53ZWJob29rVXJsKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBsb2cuaW5mbyhcIkRpc2NvcmQgd2ViaG9vayBjbGllbnQgaW5pdGlhbGl6ZWRcIiwge1xuICAgICAgICAgICAgZW5hYmxlZDogdGhpcy5lbmFibGVkLFxuICAgICAgICAgICAgdXNlcm5hbWU6IHRoaXMudXNlcm5hbWUsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgaXNWYWxpZFdlYmhvb2tVcmwodXJsOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgLy8gRGlzY29yZCB3ZWJob29rIFVSTHMgbG9vayBsaWtlOiBodHRwczovL2Rpc2NvcmQuY29tL2FwaS93ZWJob29rcy97aWR9L3t0b2tlbn1cbiAgICAgICAgcmV0dXJuIC9eaHR0cHM6XFwvXFwvZGlzY29yZCg/OmFwcCk/XFwuY29tXFwvYXBpXFwvd2ViaG9va3NcXC9cXGQrXFwvW2EtekEtWjAtOV8tXSskLy50ZXN0KFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHByaXZhdGUgbWFza1dlYmhvb2tVcmwodXJsOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBpZiAoIXVybCkgcmV0dXJuIFwiKG5vdCBzZXQpXCI7XG4gICAgICAgIC8vIE1hc2sgdGhlIHRva2VuIHBhcnRcbiAgICAgICAgcmV0dXJuIHVybC5yZXBsYWNlKC9cXC9bYS16QS1aMC05Xy1dKyQvLCBcIi8qKioqKioqKlwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgbWVzc2FnZSB0byBEaXNjb3JkXG4gICAgICovXG4gICAgYXN5bmMgc2VuZChtZXNzYWdlOiBEaXNjb3JkTWVzc2FnZSk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xuICAgICAgICAgICAgbG9nLmRlYnVnKFwiRGlzY29yZCBub3RpZmljYXRpb25zIGRpc2FibGVkLCBza2lwcGluZyBzZW5kXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQ6IERpc2NvcmRNZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudCxcbiAgICAgICAgICAgICAgICB1c2VybmFtZTogbWVzc2FnZS51c2VybmFtZSA/PyB0aGlzLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgIGF2YXRhclVybDogbWVzc2FnZS5hdmF0YXJVcmwgPz8gdGhpcy5hdmF0YXJVcmwsXG4gICAgICAgICAgICAgICAgdHRzOiBtZXNzYWdlLnR0cyA/PyBmYWxzZSxcbiAgICAgICAgICAgICAgICBlbWJlZHM6IG1lc3NhZ2UuZW1iZWRzLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgbG9nLmRlYnVnKFwiU2VuZGluZyBEaXNjb3JkIG5vdGlmaWNhdGlvblwiLCB7XG4gICAgICAgICAgICAgICAgaGFzQ29udGVudDogISFtZXNzYWdlLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgZW1iZWRDb3VudDogbWVzc2FnZS5lbWJlZHM/Lmxlbmd0aCA/PyAwLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godGhpcy53ZWJob29rVXJsLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocGF5bG9hZCksXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgICAgICBsb2cuZXJyb3IoXCJEaXNjb3JkIHdlYmhvb2sgcmVxdWVzdCBmYWlsZWRcIiwge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yVGV4dCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhcIkRpc2NvcmQgbm90aWZpY2F0aW9uIHNlbnQgc3VjY2Vzc2Z1bGx5XCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsb2cuZXJyb3IoXCJGYWlsZWQgdG8gc2VuZCBEaXNjb3JkIG5vdGlmaWNhdGlvblwiLCB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VuZCBhIHNpbXBsZSB0ZXh0IG1lc3NhZ2VcbiAgICAgKi9cbiAgICBhc3luYyBub3RpZnkoY29udGVudDogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQoeyBjb250ZW50IH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbmQgYW4gZW1iZWQgbWVzc2FnZVxuICAgICAqL1xuICAgIGFzeW5jIG5vdGlmeVdpdGhFbWJlZChcbiAgICAgICAgZW1iZWQ6IERpc2NvcmRFbWJlZCxcbiAgICAgICAgY29udGVudD86IHN0cmluZyxcbiAgICApOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZCh7XG4gICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgZW1iZWRzOiBbZW1iZWRdLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kIGN5Y2xlIHN0YXJ0IG5vdGlmaWNhdGlvblxuICAgICAqL1xuICAgIGFzeW5jIG5vdGlmeUN5Y2xlU3RhcnQoXG4gICAgICAgIGN5Y2xlTnVtYmVyOiBudW1iZXIsXG4gICAgICAgIG1heEN5Y2xlczogbnVtYmVyLFxuICAgICAgICBwcm9tcHQ6IHN0cmluZyxcbiAgICApOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgY29uc3QgZW1iZWQ6IERpc2NvcmRFbWJlZCA9IHtcbiAgICAgICAgICAgIHRpdGxlOiBg8J+UhCBDeWNsZSAke2N5Y2xlTnVtYmVyfS8ke21heEN5Y2xlc30gU3RhcnRlZGAsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYFxcYFxcYFxcYFxcbiR7cHJvbXB0LnNsaWNlKDAsIDUwMCl9JHtwcm9tcHQubGVuZ3RoID4gNTAwID8gXCIuLi5cIiA6IFwiXCJ9XFxuXFxgXFxgXFxgYCxcbiAgICAgICAgICAgIGNvbG9yOiAweDU4NjVmMiwgLy8gRGlzY29yZCBibHVycGxlXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGZpZWxkczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCLwn5OLIFBoYXNlXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIlJlc2VhcmNoIOKGkiBTcGVjaWZ5IOKGkiBQbGFuIOKGkiBXb3JrIOKGkiBSZXZpZXdcIixcbiAgICAgICAgICAgICAgICAgICAgaW5saW5lOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIuKPse+4jyBTdGF0dXNcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwiUnVubmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICBpbmxpbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubm90aWZ5V2l0aEVtYmVkKFxuICAgICAgICAgICAgZW1iZWQsXG4gICAgICAgICAgICBg8J+agCAqKlJhbHBoIEN5Y2xlICR7Y3ljbGVOdW1iZXJ9LyR7bWF4Q3ljbGVzfSBTdGFydGVkKipgLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbmQgY3ljbGUgY29tcGxldGlvbiBub3RpZmljYXRpb25cbiAgICAgKi9cbiAgICBhc3luYyBub3RpZnlDeWNsZUNvbXBsZXRlKFxuICAgICAgICBjeWNsZU51bWJlcjogbnVtYmVyLFxuICAgICAgICBjb21wbGV0ZWRDeWNsZXM6IG51bWJlcixcbiAgICAgICAgc3VtbWFyeTogc3RyaW5nLFxuICAgICAgICBkdXJhdGlvbk1zOiBudW1iZXIsXG4gICAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uTWludXRlcyA9IE1hdGguZmxvb3IoZHVyYXRpb25NcyAvIDYwMDAwKTtcbiAgICAgICAgY29uc3QgZHVyYXRpb25TZWNvbmRzID0gTWF0aC5mbG9vcigoZHVyYXRpb25NcyAlIDYwMDAwKSAvIDEwMDApO1xuXG4gICAgICAgIGNvbnN0IGVtYmVkOiBEaXNjb3JkRW1iZWQgPSB7XG4gICAgICAgICAgICB0aXRsZTogYOKchSBDeWNsZSAke2N5Y2xlTnVtYmVyfSBDb21wbGV0ZWRgLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHN1bW1hcnkuc2xpY2UoMCwgMjAwMCkgfHwgXCJObyBzdW1tYXJ5IGF2YWlsYWJsZVwiLFxuICAgICAgICAgICAgY29sb3I6IDB4NTdmMjg3LCAvLyBEaXNjb3JkIGdyZWVuXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgIGZpZWxkczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCLwn5OKIFByb2dyZXNzXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBgJHtjb21wbGV0ZWRDeWNsZXN9IGN5Y2xlcyBjb21wbGV0ZWRgLFxuICAgICAgICAgICAgICAgICAgICBpbmxpbmU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwi4o+x77iPIER1cmF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBgJHtkdXJhdGlvbk1pbnV0ZXN9bSAke2R1cmF0aW9uU2Vjb25kc31zYCxcbiAgICAgICAgICAgICAgICAgICAgaW5saW5lOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLm5vdGlmeVdpdGhFbWJlZChcbiAgICAgICAgICAgIGVtYmVkLFxuICAgICAgICAgICAgYOKchSAqKlJhbHBoIEN5Y2xlICR7Y3ljbGVOdW1iZXJ9IENvbXBsZXRlKipgLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbmQgcGhhc2UgY29tcGxldGlvbiBub3RpZmljYXRpb25cbiAgICAgKi9cbiAgICBhc3luYyBub3RpZnlQaGFzZUNvbXBsZXRlKFxuICAgICAgICBjeWNsZU51bWJlcjogbnVtYmVyLFxuICAgICAgICBwaGFzZTogc3RyaW5nLFxuICAgICAgICBzdW1tYXJ5OiBzdHJpbmcsXG4gICAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIGNvbnN0IGVtYmVkOiBEaXNjb3JkRW1iZWQgPSB7XG4gICAgICAgICAgICB0aXRsZTogYPCfk50gUGhhc2UgQ29tcGxldGU6ICR7cGhhc2V9YCxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBzdW1tYXJ5LnNsaWNlKDAsIDEwMDApLFxuICAgICAgICAgICAgY29sb3I6IDB4ZmVlNzVjLCAvLyBEaXNjb3JkIHllbGxvd1xuICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBmaWVsZHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwi8J+UhCBDeWNsZVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogU3RyaW5nKGN5Y2xlTnVtYmVyKSxcbiAgICAgICAgICAgICAgICAgICAgaW5saW5lOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0aGlzLm5vdGlmeVdpdGhFbWJlZChlbWJlZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VuZCBlcnJvciBub3RpZmljYXRpb25cbiAgICAgKi9cbiAgICBhc3luYyBub3RpZnlFcnJvcihcbiAgICAgICAgY3ljbGVOdW1iZXI6IG51bWJlcixcbiAgICAgICAgcGhhc2U6IHN0cmluZyxcbiAgICAgICAgZXJyb3I6IHN0cmluZyxcbiAgICApOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICAgICAgY29uc3QgZW1iZWQ6IERpc2NvcmRFbWJlZCA9IHtcbiAgICAgICAgICAgIHRpdGxlOiBg4p2MIEVycm9yIGluIEN5Y2xlICR7Y3ljbGVOdW1iZXJ9YCxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgKipQaGFzZToqKiAke3BoYXNlfVxcblxcbioqRXJyb3I6KipcXG5cXGBcXGBcXGBcXG4ke2Vycm9yLnNsaWNlKDAsIDE1MDApfVxcblxcYFxcYFxcYGAsXG4gICAgICAgICAgICBjb2xvcjogMHhlZDQyNDUsIC8vIERpc2NvcmQgcmVkXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5ub3RpZnlXaXRoRW1iZWQoZW1iZWQsIFwi8J+aqCAqKlJhbHBoIEVycm9yKipcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VuZCB0aW1lb3V0IG5vdGlmaWNhdGlvblxuICAgICAqL1xuICAgIGFzeW5jIG5vdGlmeVRpbWVvdXQoXG4gICAgICAgIGN5Y2xlTnVtYmVyOiBudW1iZXIsXG4gICAgICAgIHBoYXNlOiBzdHJpbmcsXG4gICAgICAgIHRpbWVvdXRNczogbnVtYmVyLFxuICAgICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICBjb25zdCB0aW1lb3V0TWludXRlcyA9IE1hdGguZmxvb3IodGltZW91dE1zIC8gNjAwMDApO1xuXG4gICAgICAgIGNvbnN0IGVtYmVkOiBEaXNjb3JkRW1iZWQgPSB7XG4gICAgICAgICAgICB0aXRsZTogYOKPsCBUaW1lb3V0IGluIEN5Y2xlICR7Y3ljbGVOdW1iZXJ9YCxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgKipQaGFzZToqKiAke3BoYXNlfVxcbioqVGltZW91dDoqKiAke3RpbWVvdXRNaW51dGVzfSBtaW51dGVzYCxcbiAgICAgICAgICAgIGNvbG9yOiAweGViNDU5ZSwgLy8gRGlzY29yZCBwaW5rXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5ub3RpZnlXaXRoRW1iZWQoZW1iZWQsIFwi4o+wICoqUmFscGggVGltZW91dCoqXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbmQgcnVuIGNvbXBsZXRpb24gbm90aWZpY2F0aW9uXG4gICAgICovXG4gICAgYXN5bmMgbm90aWZ5UnVuQ29tcGxldGUoXG4gICAgICAgIHRvdGFsQ3ljbGVzOiBudW1iZXIsXG4gICAgICAgIGR1cmF0aW9uTXM6IG51bWJlcixcbiAgICAgICAgZmluYWxTdW1tYXJ5OiBzdHJpbmcsXG4gICAgKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uSG91cnMgPSBNYXRoLmZsb29yKGR1cmF0aW9uTXMgLyAzNjAwMDAwKTtcbiAgICAgICAgY29uc3QgZHVyYXRpb25NaW51dGVzID0gTWF0aC5mbG9vcigoZHVyYXRpb25NcyAlIDM2MDAwMDApIC8gNjAwMDApO1xuXG4gICAgICAgIGNvbnN0IGVtYmVkOiBEaXNjb3JkRW1iZWQgPSB7XG4gICAgICAgICAgICB0aXRsZTogXCLwn4+BIFJ1biBDb21wbGV0ZVwiLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGZpbmFsU3VtbWFyeS5zbGljZSgwLCAyMDAwKSxcbiAgICAgICAgICAgIGNvbG9yOiAweDU3ZjI4NywgLy8gRGlzY29yZCBncmVlblxuICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBmaWVsZHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwi8J+UhCBUb3RhbCBDeWNsZXNcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFN0cmluZyh0b3RhbEN5Y2xlcyksXG4gICAgICAgICAgICAgICAgICAgIGlubGluZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCLij7HvuI8gVG90YWwgRHVyYXRpb25cIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6XG4gICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbkhvdXJzID4gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYCR7ZHVyYXRpb25Ib3Vyc31oICR7ZHVyYXRpb25NaW51dGVzfW1gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBgJHtkdXJhdGlvbk1pbnV0ZXN9bWAsXG4gICAgICAgICAgICAgICAgICAgIGlubGluZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpcy5ub3RpZnlXaXRoRW1iZWQoZW1iZWQsIFwi8J+PgSAqKlJhbHBoIFJ1biBDb21wbGV0ZSoqXCIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbmQgc3R1Y2svYWJvcnQgbm90aWZpY2F0aW9uXG4gICAgICovXG4gICAgYXN5bmMgbm90aWZ5U3R1Y2tPckFib3J0ZWQoXG4gICAgICAgIGN5Y2xlTnVtYmVyOiBudW1iZXIsXG4gICAgICAgIHJlYXNvbjogc3RyaW5nLFxuICAgICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgICAgICBjb25zdCBlbWJlZDogRGlzY29yZEVtYmVkID0ge1xuICAgICAgICAgICAgdGl0bGU6IGDwn5uRIFJ1biAke3JlYXNvbn1gLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBDeWNsZSAke2N5Y2xlTnVtYmVyfSByZWFjaGVkIHN0dWNrIHRocmVzaG9sZCBvciB3YXMgYWJvcnRlZGAsXG4gICAgICAgICAgICBjb2xvcjogMHg1ODY1ZjIsIC8vIERpc2NvcmQgYmx1cnBsZVxuICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubm90aWZ5V2l0aEVtYmVkKGVtYmVkLCBg8J+bkSAqKlJhbHBoICR7cmVhc29ufSoqYCk7XG4gICAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIERpc2NvcmQgd2ViaG9vayBjbGllbnQgZnJvbSBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZURpc2NvcmRXZWJob29rRnJvbUVudigpOiBEaXNjb3JkV2ViaG9va0NsaWVudCB8IG51bGwge1xuICAgIGNvbnN0IHdlYmhvb2tVcmwgPSBwcm9jZXNzLmVudi5ESVNDT1JEX1dFQkhPT0tfVVJMPy50cmltKCk7XG5cbiAgICBpZiAoIXdlYmhvb2tVcmwpIHtcbiAgICAgICAgbG9nLmRlYnVnKFxuICAgICAgICAgICAgXCJObyBESVNDT1JEX1dFQkhPT0tfVVJMIGVudiB2YXIgc2V0LCBEaXNjb3JkIG5vdGlmaWNhdGlvbnMgZGlzYWJsZWRcIixcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBEaXNjb3JkV2ViaG9va0NsaWVudCh7XG4gICAgICAgIHdlYmhvb2tVcmwsXG4gICAgICAgIHVzZXJuYW1lOiBwcm9jZXNzLmVudi5ESVNDT1JEX0JPVF9VU0VSTkFNRSA/PyBcIlJhbHBoXCIsXG4gICAgICAgIGF2YXRhclVybDogcHJvY2Vzcy5lbnYuRElTQ09SRF9CT1RfQVZBVEFSX1VSTCxcbiAgICB9KTtcbn1cbiIsCiAgICAiLyoqXG4gKiBGbG93IFN0b3JlIC0gU3RhdGUgcGVyc2lzdGVuY2UgbGF5ZXIgZm9yIFJhbHBoIExvb3AgUnVubmVyXG4gKlxuICogUGVyc2lzdHMgcnVuIHN0YXRlIHRvIGAuYWktZW5nL3J1bnMvPHJ1bklkPi8uZmxvdy9gOlxuICogLSBzdGF0ZS5qc29uOiBNYWluIHJ1biBzdGF0ZVxuICogLSBjaGVja3BvaW50Lmpzb246IExhc3Qgc3VjY2Vzc2Z1bCBjaGVja3BvaW50IGZvciBmYXN0IHJlc3VtZVxuICogLSBpdGVyYXRpb25zLzxuPi5qc29uOiBQZXItY3ljbGUgZGV0YWlsZWQgb3V0cHV0c1xuICogLSBjb250ZXh0cy88bj4ubWQ6IFJlLWFuY2hvcmluZyBjb250ZXh0IHNuYXBzaG90c1xuICogLSBnYXRlcy88bj4uanNvbjogUXVhbGl0eSBnYXRlIHJlc3VsdHNcbiAqL1xuXG5pbXBvcnQgeyBleGlzdHNTeW5jLCBta2RpclN5bmMsIHJlYWRGaWxlU3luYywgd3JpdGVGaWxlU3luYyB9IGZyb20gXCJub2RlOmZzXCI7XG5pbXBvcnQgeyBqb2luIH0gZnJvbSBcIm5vZGU6cGF0aFwiO1xuaW1wb3J0IHsgTG9nIH0gZnJvbSBcIi4uL3V0aWwvbG9nXCI7XG5pbXBvcnQgdHlwZSB7IENoZWNrcG9pbnQsIEN5Y2xlU3RhdGUsIEZsb3dTdGF0ZSB9IGZyb20gXCIuL2Zsb3ctdHlwZXNcIjtcbmltcG9ydCB7IEZMT1dfU0NIRU1BX1ZFUlNJT04sIFJ1blN0YXR1cywgdHlwZSBTdG9wUmVhc29uIH0gZnJvbSBcIi4vZmxvdy10eXBlc1wiO1xuXG5jb25zdCBsb2cgPSBMb2cuY3JlYXRlKHsgc2VydmljZTogXCJmbG93LXN0b3JlXCIgfSk7XG5cbi8qKiBGbG93IHN0b3JlIG9wdGlvbnMgKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmxvd1N0b3JlT3B0aW9ucyB7XG4gICAgZmxvd0Rpcjogc3RyaW5nO1xuICAgIHJ1bklkOiBzdHJpbmc7XG59XG5cbi8qKlxuICogRmxvdyBTdG9yZSAtIG1hbmFnZXMgcGVyc2lzdGVuY2Ugb2YgbG9vcCBydW4gc3RhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIEZsb3dTdG9yZSB7XG4gICAgcHJpdmF0ZSBmbG93RGlyOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBydW5JZDogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3Iob3B0aW9uczogRmxvd1N0b3JlT3B0aW9ucykge1xuICAgICAgICB0aGlzLmZsb3dEaXIgPSBvcHRpb25zLmZsb3dEaXI7XG4gICAgICAgIHRoaXMucnVuSWQgPSBvcHRpb25zLnJ1bklkO1xuICAgIH1cblxuICAgIC8qKiBHZXQgdGhlIGJhc2UgZmxvdyBkaXJlY3RvcnkgcGF0aCAqL1xuICAgIGdldCBiYXNlUGF0aCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gam9pbih0aGlzLmZsb3dEaXIsIHRoaXMucnVuSWQsIFwiLmZsb3dcIik7XG4gICAgfVxuXG4gICAgLyoqIEdldCBwYXRoIHRvIGEgc3BlY2lmaWMgZmlsZSBpbiAuZmxvdyAqL1xuICAgIHByaXZhdGUgcGF0aChyZWxQYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gam9pbih0aGlzLmJhc2VQYXRoLCByZWxQYXRoKTtcbiAgICB9XG5cbiAgICAvKiogSW5pdGlhbGl6ZSBmbG93IGRpcmVjdG9yeSBzdHJ1Y3R1cmUgKi9cbiAgICBpbml0aWFsaXplKCk6IHZvaWQge1xuICAgICAgICAvLyBDcmVhdGUgLmZsb3cgZGlyZWN0b3J5IGFuZCBzdWJkaXJlY3Rvcmllc1xuICAgICAgICBjb25zdCBkaXJzID0gW1wiaXRlcmF0aW9uc1wiLCBcImNvbnRleHRzXCIsIFwiZ2F0ZXNcIl07XG5cbiAgICAgICAgZm9yIChjb25zdCBkaXIgb2YgZGlycykge1xuICAgICAgICAgICAgY29uc3QgZGlyUGF0aCA9IHRoaXMucGF0aChkaXIpO1xuICAgICAgICAgICAgaWYgKCFleGlzdHNTeW5jKGRpclBhdGgpKSB7XG4gICAgICAgICAgICAgICAgbWtkaXJTeW5jKGRpclBhdGgsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZyhcIkNyZWF0ZWQgZGlyZWN0b3J5XCIsIHsgcGF0aDogZGlyUGF0aCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxvZy5pbmZvKFwiRmxvdyBzdG9yZSBpbml0aWFsaXplZFwiLCB7XG4gICAgICAgICAgICBydW5JZDogdGhpcy5ydW5JZCxcbiAgICAgICAgICAgIGJhc2VQYXRoOiB0aGlzLmJhc2VQYXRoLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogQ2hlY2sgaWYgZmxvdyBzdGF0ZSBleGlzdHMgKGZvciByZXN1bWUpICovXG4gICAgZXhpc3RzKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZXhpc3RzU3luYyh0aGlzLnBhdGgoXCJzdGF0ZS5qc29uXCIpKTtcbiAgICB9XG5cbiAgICAvKiogTG9hZCBleGlzdGluZyBydW4gc3RhdGUgZm9yIHJlc3VtZSAqL1xuICAgIGxvYWQoKTogRmxvd1N0YXRlIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IHN0YXRlUGF0aCA9IHRoaXMucGF0aChcInN0YXRlLmpzb25cIik7XG4gICAgICAgIGlmICghZXhpc3RzU3luYyhzdGF0ZVBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gcmVhZEZpbGVTeW5jKHN0YXRlUGF0aCwgXCJ1dGYtOFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gSlNPTi5wYXJzZShjb250ZW50KSBhcyBGbG93U3RhdGU7XG5cbiAgICAgICAgICAgIC8vIFZhbGlkYXRlIHNjaGVtYSB2ZXJzaW9uXG4gICAgICAgICAgICBpZiAoc3RhdGUuc2NoZW1hVmVyc2lvbiAhPT0gRkxPV19TQ0hFTUFfVkVSU0lPTikge1xuICAgICAgICAgICAgICAgIGxvZy53YXJuKFwiRmxvdyBzY2hlbWEgdmVyc2lvbiBtaXNtYXRjaFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBGTE9XX1NDSEVNQV9WRVJTSU9OLFxuICAgICAgICAgICAgICAgICAgICBmb3VuZDogc3RhdGUuc2NoZW1hVmVyc2lvbixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbG9nLmluZm8oXCJMb2FkZWQgZmxvdyBzdGF0ZVwiLCB7XG4gICAgICAgICAgICAgICAgcnVuSWQ6IHN0YXRlLnJ1bklkLFxuICAgICAgICAgICAgICAgIHN0YXR1czogc3RhdGUuc3RhdHVzLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRDeWNsZTogc3RhdGUuY3VycmVudEN5Y2xlLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTXNnID1cbiAgICAgICAgICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IFN0cmluZyhlcnJvcik7XG4gICAgICAgICAgICBsb2cuZXJyb3IoXCJGYWlsZWQgdG8gbG9hZCBmbG93IHN0YXRlXCIsIHsgZXJyb3I6IGVycm9yTXNnIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQ3JlYXRlIGluaXRpYWwgcnVuIHN0YXRlICovXG4gICAgY3JlYXRlSW5pdGlhbFN0YXRlKG9wdGlvbnM6IHtcbiAgICAgICAgcHJvbXB0OiBzdHJpbmc7XG4gICAgICAgIGNvbXBsZXRpb25Qcm9taXNlOiBzdHJpbmc7XG4gICAgICAgIG1heEN5Y2xlczogbnVtYmVyO1xuICAgICAgICBzdHVja1RocmVzaG9sZDogbnVtYmVyO1xuICAgICAgICBnYXRlczogc3RyaW5nW107XG4gICAgfSk6IEZsb3dTdGF0ZSB7XG4gICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcblxuICAgICAgICBjb25zdCBzdGF0ZTogRmxvd1N0YXRlID0ge1xuICAgICAgICAgICAgc2NoZW1hVmVyc2lvbjogRkxPV19TQ0hFTUFfVkVSU0lPTixcbiAgICAgICAgICAgIHJ1bklkOiB0aGlzLnJ1bklkLFxuICAgICAgICAgICAgcHJvbXB0OiBvcHRpb25zLnByb21wdCxcbiAgICAgICAgICAgIHN0YXR1czogUnVuU3RhdHVzLlBFTkRJTkcsXG4gICAgICAgICAgICBjb21wbGV0aW9uUHJvbWlzZTogb3B0aW9ucy5jb21wbGV0aW9uUHJvbWlzZSxcbiAgICAgICAgICAgIG1heEN5Y2xlczogb3B0aW9ucy5tYXhDeWNsZXMsXG4gICAgICAgICAgICBzdHVja1RocmVzaG9sZDogb3B0aW9ucy5zdHVja1RocmVzaG9sZCxcbiAgICAgICAgICAgIGdhdGVzOiBvcHRpb25zLmdhdGVzLFxuICAgICAgICAgICAgY3VycmVudEN5Y2xlOiAwLFxuICAgICAgICAgICAgY29tcGxldGVkQ3ljbGVzOiAwLFxuICAgICAgICAgICAgZmFpbGVkQ3ljbGVzOiAwLFxuICAgICAgICAgICAgc3R1Y2tDb3VudDogMCxcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogbm93LFxuICAgICAgICAgICAgdXBkYXRlZEF0OiBub3csXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5zYXZlU3RhdGUoc3RhdGUpO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuXG4gICAgLyoqIFNhdmUgcnVuIHN0YXRlIHRvIHN0YXRlLmpzb24gKi9cbiAgICBzYXZlU3RhdGUoc3RhdGU6IEZsb3dTdGF0ZSk6IHZvaWQge1xuICAgICAgICBjb25zdCBzdGF0ZVBhdGggPSB0aGlzLnBhdGgoXCJzdGF0ZS5qc29uXCIpO1xuICAgICAgICBzdGF0ZS51cGRhdGVkQXQgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIHdyaXRlRmlsZVN5bmMoc3RhdGVQYXRoLCBKU09OLnN0cmluZ2lmeShzdGF0ZSwgbnVsbCwgMikpO1xuICAgICAgICBsb2cuZGVidWcoXCJTYXZlZCBmbG93IHN0YXRlXCIsIHsgcnVuSWQ6IHN0YXRlLnJ1bklkIH0pO1xuICAgIH1cblxuICAgIC8qKiBTYXZlIGEgY2hlY2twb2ludCBmb3IgZmFzdCByZXN1bWUgKi9cbiAgICBzYXZlQ2hlY2twb2ludChcbiAgICAgICAgc3RhdGU6IEZsb3dTdGF0ZSxcbiAgICAgICAgbGFzdFBoYXNlT3V0cHV0czogQ3ljbGVTdGF0ZVtcInBoYXNlc1wiXSxcbiAgICApOiB2b2lkIHtcbiAgICAgICAgY29uc3QgY2hlY2twb2ludFBhdGggPSB0aGlzLnBhdGgoXCJjaGVja3BvaW50Lmpzb25cIik7XG4gICAgICAgIGNvbnN0IGNoZWNrcG9pbnQ6IENoZWNrcG9pbnQgPSB7XG4gICAgICAgICAgICBzY2hlbWFWZXJzaW9uOiBGTE9XX1NDSEVNQV9WRVJTSU9OLFxuICAgICAgICAgICAgcnVuSWQ6IHN0YXRlLnJ1bklkLFxuICAgICAgICAgICAgY3ljbGVOdW1iZXI6IHN0YXRlLmN1cnJlbnRDeWNsZSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICBsYXN0UGhhc2VPdXRwdXRzLFxuICAgICAgICB9O1xuICAgICAgICB3cml0ZUZpbGVTeW5jKGNoZWNrcG9pbnRQYXRoLCBKU09OLnN0cmluZ2lmeShjaGVja3BvaW50LCBudWxsLCAyKSk7XG4gICAgICAgIGxvZy5kZWJ1ZyhcIlNhdmVkIGNoZWNrcG9pbnRcIiwge1xuICAgICAgICAgICAgcnVuSWQ6IHN0YXRlLnJ1bklkLFxuICAgICAgICAgICAgY3ljbGU6IHN0YXRlLmN1cnJlbnRDeWNsZSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqIExvYWQgY2hlY2twb2ludCBmb3IgcmVzdW1lICovXG4gICAgbG9hZENoZWNrcG9pbnQoKTogQ2hlY2twb2ludCB8IG51bGwge1xuICAgICAgICBjb25zdCBjaGVja3BvaW50UGF0aCA9IHRoaXMucGF0aChcImNoZWNrcG9pbnQuanNvblwiKTtcbiAgICAgICAgaWYgKCFleGlzdHNTeW5jKGNoZWNrcG9pbnRQYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IHJlYWRGaWxlU3luYyhjaGVja3BvaW50UGF0aCwgXCJ1dGYtOFwiKTtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGNvbnRlbnQpIGFzIENoZWNrcG9pbnQ7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvck1zZyA9XG4gICAgICAgICAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgICAgICAgbG9nLmVycm9yKFwiRmFpbGVkIHRvIGxvYWQgY2hlY2twb2ludFwiLCB7IGVycm9yOiBlcnJvck1zZyB9KTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFNhdmUgaXRlcmF0aW9uIGN5Y2xlIG91dHB1dCAqL1xuICAgIHNhdmVJdGVyYXRpb24oY3ljbGU6IEN5Y2xlU3RhdGUpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgY3ljbGVQYXRoID0gdGhpcy5wYXRoKGBpdGVyYXRpb25zLyR7Y3ljbGUuY3ljbGVOdW1iZXJ9Lmpzb25gKTtcbiAgICAgICAgd3JpdGVGaWxlU3luYyhjeWNsZVBhdGgsIEpTT04uc3RyaW5naWZ5KGN5Y2xlLCBudWxsLCAyKSk7XG5cbiAgICAgICAgLy8gU2F2ZSByZS1hbmNob3JpbmcgY29udGV4dFxuICAgICAgICBjb25zdCBjb250ZXh0UGF0aCA9IHRoaXMucGF0aChgY29udGV4dHMvJHtjeWNsZS5jeWNsZU51bWJlcn0ubWRgKTtcbiAgICAgICAgY29uc3QgY29udGV4dENvbnRlbnQgPSB0aGlzLmdlbmVyYXRlQ29udGV4dENvbnRlbnQoY3ljbGUpO1xuICAgICAgICB3cml0ZUZpbGVTeW5jKGNvbnRleHRQYXRoLCBjb250ZXh0Q29udGVudCk7XG5cbiAgICAgICAgbG9nLmRlYnVnKFwiU2F2ZWQgaXRlcmF0aW9uXCIsIHsgY3ljbGU6IGN5Y2xlLmN5Y2xlTnVtYmVyIH0pO1xuICAgIH1cblxuICAgIC8qKiBTYXZlIGdhdGUgcmVzdWx0cyBmb3IgaXRlcmF0aW9uICovXG4gICAgc2F2ZUdhdGVSZXN1bHRzKFxuICAgICAgICBjeWNsZU51bWJlcjogbnVtYmVyLFxuICAgICAgICByZXN1bHRzOiBDeWNsZVN0YXRlW1wiZ2F0ZVJlc3VsdHNcIl0sXG4gICAgKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGdhdGVQYXRoID0gdGhpcy5wYXRoKGBnYXRlcy8ke2N5Y2xlTnVtYmVyfS5qc29uYCk7XG4gICAgICAgIHdyaXRlRmlsZVN5bmMoZ2F0ZVBhdGgsIEpTT04uc3RyaW5naWZ5KHJlc3VsdHMsIG51bGwsIDIpKTtcbiAgICB9XG5cbiAgICAvKiogR2VuZXJhdGUgcmUtYW5jaG9yaW5nIGNvbnRleHQgY29udGVudCBmb3IgYSBjeWNsZSAqL1xuICAgIHByaXZhdGUgZ2VuZXJhdGVDb250ZXh0Q29udGVudChjeWNsZTogQ3ljbGVTdGF0ZSk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGxpbmVzOiBzdHJpbmdbXSA9IFtcbiAgICAgICAgICAgIGAjIEN5Y2xlICR7Y3ljbGUuY3ljbGVOdW1iZXJ9IENvbnRleHRgLFxuICAgICAgICAgICAgXCJcIixcbiAgICAgICAgICAgIGAqKlRpbWVzdGFtcDoqKiAke2N5Y2xlLnN0YXJ0VGltZX1gLFxuICAgICAgICAgICAgYCoqU3RhdHVzOioqICR7Y3ljbGUuc3RhdHVzfWAsXG4gICAgICAgICAgICBgKipDb21wbGV0aW9uIFByb21pc2UgT2JzZXJ2ZWQ6KiogJHtjeWNsZS5jb21wbGV0aW9uUHJvbWlzZU9ic2VydmVkfWAsXG4gICAgICAgICAgICBcIlwiLFxuICAgICAgICAgICAgXCIjIyBQaGFzZSBTdW1tYXJpZXNcIixcbiAgICAgICAgICAgIFwiXCIsXG4gICAgICAgIF07XG5cbiAgICAgICAgZm9yIChjb25zdCBbcGhhc2UsIG91dHB1dF0gb2YgT2JqZWN0LmVudHJpZXMoY3ljbGUucGhhc2VzKSkge1xuICAgICAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goYCMjIyAke3BoYXNlLnRvVXBwZXJDYXNlKCl9YCk7XG4gICAgICAgICAgICAgICAgbGluZXMucHVzaChcIlwiKTtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKG91dHB1dC5zdW1tYXJ5IHx8IG91dHB1dC5yZXNwb25zZS5zbGljZSgwLCA1MDApKTtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN5Y2xlLmdhdGVSZXN1bHRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGxpbmVzLnB1c2goXCIjIyBHYXRlIFJlc3VsdHNcIik7XG4gICAgICAgICAgICBsaW5lcy5wdXNoKFwiXCIpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBnYXRlIG9mIGN5Y2xlLmdhdGVSZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gZ2F0ZS5wYXNzZWQgPyBcIuKchSBQQVNTXCIgOiBcIuKdjCBGQUlMXCI7XG4gICAgICAgICAgICAgICAgbGluZXMucHVzaChgLSAqKiR7Z2F0ZS5nYXRlfToqKiAke3N0YXR1c30gLSAke2dhdGUubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmVzLnB1c2goXCJcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3ljbGUuZXJyb3IpIHtcbiAgICAgICAgICAgIGxpbmVzLnB1c2goXCIjIyBFcnJvcnNcIik7XG4gICAgICAgICAgICBsaW5lcy5wdXNoKFwiXCIpO1xuICAgICAgICAgICAgbGluZXMucHVzaChjeWNsZS5lcnJvcik7XG4gICAgICAgICAgICBsaW5lcy5wdXNoKFwiXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxpbmVzLmpvaW4oXCJcXG5cIik7XG4gICAgfVxuXG4gICAgLyoqIEdldCBpdGVyYXRpb24gYnkgbnVtYmVyICovXG4gICAgZ2V0SXRlcmF0aW9uKGN5Y2xlTnVtYmVyOiBudW1iZXIpOiBDeWNsZVN0YXRlIHwgbnVsbCB7XG4gICAgICAgIGNvbnN0IGN5Y2xlUGF0aCA9IHRoaXMucGF0aChgaXRlcmF0aW9ucy8ke2N5Y2xlTnVtYmVyfS5qc29uYCk7XG4gICAgICAgIGlmICghZXhpc3RzU3luYyhjeWNsZVBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gcmVhZEZpbGVTeW5jKGN5Y2xlUGF0aCwgXCJ1dGYtOFwiKTtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGNvbnRlbnQpIGFzIEN5Y2xlU3RhdGU7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogR2V0IGFsbCBpdGVyYXRpb25zICovXG4gICAgZ2V0QWxsSXRlcmF0aW9ucygpOiBDeWNsZVN0YXRlW10ge1xuICAgICAgICBjb25zdCBpdGVyYXRpb25zOiBDeWNsZVN0YXRlW10gPSBbXTtcbiAgICAgICAgbGV0IG4gPSAxO1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBjeWNsZSA9IHRoaXMuZ2V0SXRlcmF0aW9uKG4pO1xuICAgICAgICAgICAgaWYgKCFjeWNsZSkgYnJlYWs7XG4gICAgICAgICAgICBpdGVyYXRpb25zLnB1c2goY3ljbGUpO1xuICAgICAgICAgICAgbisrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGl0ZXJhdGlvbnM7XG4gICAgfVxuXG4gICAgLyoqIFVwZGF0ZSBzdGF0ZSBzdGF0dXMgKi9cbiAgICB1cGRhdGVTdGF0dXMoXG4gICAgICAgIHN0YXR1czogUnVuU3RhdHVzLFxuICAgICAgICBzdG9wUmVhc29uPzogU3RvcFJlYXNvbixcbiAgICAgICAgZXJyb3I/OiBzdHJpbmcsXG4gICAgKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5sb2FkKCk7XG4gICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGZsb3cgc3RhdGUgdG8gdXBkYXRlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICBpZiAoc3RvcFJlYXNvbikgc3RhdGUuc3RvcFJlYXNvbiA9IHN0b3BSZWFzb247XG4gICAgICAgIGlmIChlcnJvcikgc3RhdGUuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gUnVuU3RhdHVzLkNPTVBMRVRFRCB8fCBzdGF0dXMgPT09IFJ1blN0YXR1cy5GQUlMRUQpIHtcbiAgICAgICAgICAgIHN0YXRlLmNvbXBsZXRlZEF0ID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zYXZlU3RhdGUoc3RhdGUpO1xuICAgIH1cblxuICAgIC8qKiBJbmNyZW1lbnQgY3ljbGUgY291bnRlciAqL1xuICAgIGluY3JlbWVudEN5Y2xlKCk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5sb2FkKCk7XG4gICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGZsb3cgc3RhdGUgdG8gdXBkYXRlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuY3VycmVudEN5Y2xlKys7XG4gICAgICAgIHRoaXMuc2F2ZVN0YXRlKHN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmN1cnJlbnRDeWNsZTtcbiAgICB9XG5cbiAgICAvKiogUmVjb3JkIGEgZmFpbGVkIGN5Y2xlICovXG4gICAgcmVjb3JkRmFpbGVkQ3ljbGUoY3ljbGU6IEN5Y2xlU3RhdGUpOiB2b2lkIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmxvYWQoKTtcbiAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZmxvdyBzdGF0ZSB0byB1cGRhdGVcIik7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5mYWlsZWRDeWNsZXMrKztcbiAgICAgICAgc3RhdGUuc3R1Y2tDb3VudCsrO1xuICAgICAgICB0aGlzLnNhdmVJdGVyYXRpb24oY3ljbGUpO1xuICAgICAgICB0aGlzLnNhdmVTdGF0ZShzdGF0ZSk7XG5cbiAgICAgICAgbG9nLmluZm8oXCJDeWNsZSBmYWlsZWRcIiwge1xuICAgICAgICAgICAgcnVuSWQ6IHRoaXMucnVuSWQsXG4gICAgICAgICAgICBjeWNsZTogY3ljbGUuY3ljbGVOdW1iZXIsXG4gICAgICAgICAgICBmYWlsZWRDeWNsZXM6IHN0YXRlLmZhaWxlZEN5Y2xlcyxcbiAgICAgICAgICAgIHN0dWNrQ291bnQ6IHN0YXRlLnN0dWNrQ291bnQsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKiBSZWNvcmQgYSBzdWNjZXNzZnVsIGN5Y2xlICovXG4gICAgcmVjb3JkU3VjY2Vzc2Z1bEN5Y2xlKGN5Y2xlOiBDeWNsZVN0YXRlLCBzdW1tYXJ5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmxvYWQoKTtcbiAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZmxvdyBzdGF0ZSB0byB1cGRhdGVcIik7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5jb21wbGV0ZWRDeWNsZXMrKztcbiAgICAgICAgc3RhdGUuc3R1Y2tDb3VudCA9IDA7IC8vIFJlc2V0IHN0dWNrIGNvdW50ZXIgb24gc3VjY2Vzc1xuICAgICAgICBzdGF0ZS5sYXN0Q2hlY2twb2ludCA9IHtcbiAgICAgICAgICAgIGN5Y2xlTnVtYmVyOiBjeWNsZS5jeWNsZU51bWJlcixcbiAgICAgICAgICAgIHN1bW1hcnksXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnNhdmVJdGVyYXRpb24oY3ljbGUpO1xuICAgICAgICB0aGlzLnNhdmVTdGF0ZShzdGF0ZSk7XG5cbiAgICAgICAgbG9nLmluZm8oXCJDeWNsZSBjb21wbGV0ZWRcIiwge1xuICAgICAgICAgICAgcnVuSWQ6IHRoaXMucnVuSWQsXG4gICAgICAgICAgICBjeWNsZTogY3ljbGUuY3ljbGVOdW1iZXIsXG4gICAgICAgICAgICBjb21wbGV0ZWRDeWNsZXM6IHN0YXRlLmNvbXBsZXRlZEN5Y2xlcyxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqIENsZWFuIHVwIGZsb3cgZGlyZWN0b3J5ICovXG4gICAgY2xlYW51cCgpOiB2b2lkIHtcbiAgICAgICAgLy8gSW1wbGVtZW50YXRpb24gd291bGQgcmVtb3ZlIHRoZSAuZmxvdyBkaXJlY3RvcnlcbiAgICAgICAgLy8gRm9yIG5vdywganVzdCBsb2dcbiAgICAgICAgbG9nLmluZm8oXCJGbG93IHN0b3JlIGNsZWFudXAgcmVxdWVzdGVkXCIsIHsgcnVuSWQ6IHRoaXMucnVuSWQgfSk7XG4gICAgfVxufVxuIiwKICAgICIvKipcbiAqIEZsb3cgU3RhdGUgVHlwZXMgZm9yIFJhbHBoIExvb3AgUnVubmVyXG4gKlxuICogU3RhdGUgaXMgcGVyc2lzdGVkIHRvIGAuYWktZW5nL3J1bnMvPHJ1bklkPi8uZmxvdy9gIGZvcjpcbiAqIC0gUmVzdW1lIHN1cHBvcnQgYWNyb3NzIHJ1bnNcbiAqIC0gRnJlc2ggY29udGV4dCBwZXIgaXRlcmF0aW9uIChyZS1hbmNob3JpbmcgZnJvbSBkaXNrKVxuICogLSBBdWRpdCB0cmFpbCBvZiBhbGwgY3ljbGUgb3V0cHV0c1xuICovXG5cbi8qKiBTY2hlbWEgdmVyc2lvbiBmb3IgZm9yd2FyZCBjb21wYXRpYmlsaXR5ICovXG5leHBvcnQgY29uc3QgRkxPV19TQ0hFTUFfVkVSU0lPTiA9IFwiMS4wLjBcIjtcblxuLyoqIFJ1biBzdGF0dXMgZW51bSAqL1xuZXhwb3J0IGVudW0gUnVuU3RhdHVzIHtcbiAgICBQRU5ESU5HID0gXCJwZW5kaW5nXCIsXG4gICAgUlVOTklORyA9IFwicnVubmluZ1wiLFxuICAgIENPTVBMRVRFRCA9IFwiY29tcGxldGVkXCIsXG4gICAgRkFJTEVEID0gXCJmYWlsZWRcIixcbiAgICBBQk9SVEVEID0gXCJhYm9ydGVkXCIsXG4gICAgU1RVQ0sgPSBcInN0dWNrXCIsXG59XG5cbi8qKiBTdG9wIHJlYXNvbiBmb3IgY29tcGxldGVkIHJ1bnMgKi9cbmV4cG9ydCBlbnVtIFN0b3BSZWFzb24ge1xuICAgIENPTVBMRVRJT05fUFJPTUlTRSA9IFwiY29tcGxldGlvbl9wcm9taXNlXCIsXG4gICAgTUFYX0NZQ0xFUyA9IFwibWF4X2N5Y2xlc1wiLFxuICAgIEdBVEVfRkFJTFVSRSA9IFwiZ2F0ZV9mYWlsdXJlXCIsXG4gICAgU1RVQ0sgPSBcInN0dWNrXCIsXG4gICAgVVNFUl9BQk9SVCA9IFwidXNlcl9hYm9ydFwiLFxuICAgIEVSUk9SID0gXCJlcnJvclwiLFxufVxuXG4vKiogUGhhc2UgbmFtZXMgaW4gdGhlIHdvcmtmbG93ICovXG5leHBvcnQgZW51bSBQaGFzZSB7XG4gICAgUkVTRUFSQ0ggPSBcInJlc2VhcmNoXCIsXG4gICAgU1BFQ0lGWSA9IFwic3BlY2lmeVwiLFxuICAgIFBMQU4gPSBcInBsYW5cIixcbiAgICBXT1JLID0gXCJ3b3JrXCIsXG4gICAgUkVWSUVXID0gXCJyZXZpZXdcIixcbn1cblxuLyoqIEdhdGUgcmVzdWx0IHR5cGUgKi9cbmV4cG9ydCBpbnRlcmZhY2UgR2F0ZVJlc3VsdCB7XG4gICAgZ2F0ZTogc3RyaW5nO1xuICAgIHBhc3NlZDogYm9vbGVhbjtcbiAgICBtZXNzYWdlOiBzdHJpbmc7XG4gICAgZGV0YWlscz86IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICAgIHRpbWVzdGFtcDogc3RyaW5nO1xufVxuXG4vKiogUGhhc2Ugb3V0cHV0ICovXG5leHBvcnQgaW50ZXJmYWNlIFBoYXNlT3V0cHV0IHtcbiAgICBwaGFzZTogUGhhc2U7XG4gICAgcHJvbXB0OiBzdHJpbmc7XG4gICAgcmVzcG9uc2U6IHN0cmluZztcbiAgICBzdW1tYXJ5OiBzdHJpbmc7XG4gICAgdGltZXN0YW1wOiBzdHJpbmc7XG4gICAgLyoqIFRvb2wgaW52b2NhdGlvbnMgY2FwdHVyZWQgZHVyaW5nIHRoaXMgcGhhc2UgKi9cbiAgICB0b29scz86IFRvb2xJbnZvY2F0aW9uW107XG59XG5cbi8qKiBUb29sIGludm9jYXRpb24gY2FwdHVyZWQgZnJvbSBPcGVuQ29kZSBzdHJlYW0gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVG9vbEludm9jYXRpb24ge1xuICAgIC8qKiBVbmlxdWUgdG9vbCBJRCAqL1xuICAgIGlkOiBzdHJpbmc7XG4gICAgLyoqIFRvb2wgbmFtZSAoZS5nLiwgXCJiYXNoXCIsIFwicmVhZFwiLCBcIndyaXRlXCIsIFwiZWRpdFwiKSAqL1xuICAgIG5hbWU6IHN0cmluZztcbiAgICAvKiogSW5wdXQgYXJndW1lbnRzIChtYXkgYmUgdHJ1bmNhdGVkL3JlZGFjdGVkIGZvciBzZWNyZXRzKSAqL1xuICAgIGlucHV0PzogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gICAgLyoqIE91dHB1dCByZXN1bHQgKG1heSBiZSB0cnVuY2F0ZWQpICovXG4gICAgb3V0cHV0Pzogc3RyaW5nO1xuICAgIC8qKiBXaGV0aGVyIHRoZSB0b29sIGNhbGwgc3VjY2VlZGVkICovXG4gICAgc3RhdHVzOiBcIm9rXCIgfCBcImVycm9yXCI7XG4gICAgLyoqIEVycm9yIG1lc3NhZ2UgaWYgc3RhdHVzIGlzIGVycm9yICovXG4gICAgZXJyb3I/OiBzdHJpbmc7XG4gICAgLyoqIFdoZW4gdGhlIHRvb2wgY2FsbCBzdGFydGVkIChJU08gdGltZXN0YW1wKSAqL1xuICAgIHN0YXJ0ZWRBdD86IHN0cmluZztcbiAgICAvKiogV2hlbiB0aGUgdG9vbCBjYWxsIGNvbXBsZXRlZCAoSVNPIHRpbWVzdGFtcCkgKi9cbiAgICBjb21wbGV0ZWRBdD86IHN0cmluZztcbn1cblxuLyoqIFNpbmdsZSBpdGVyYXRpb24gY3ljbGUgc3RhdGUgKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ3ljbGVTdGF0ZSB7XG4gICAgY3ljbGVOdW1iZXI6IG51bWJlcjtcbiAgICBzdGF0dXM6IFwicGVuZGluZ1wiIHwgXCJydW5uaW5nXCIgfCBcImNvbXBsZXRlZFwiIHwgXCJmYWlsZWRcIjtcbiAgICBzdGFydFRpbWU6IHN0cmluZztcbiAgICBlbmRUaW1lPzogc3RyaW5nO1xuICAgIGR1cmF0aW9uTXM/OiBudW1iZXI7XG4gICAgcGhhc2VzOiB7XG4gICAgICAgIFtrZXkgaW4gUGhhc2VdPzogUGhhc2VPdXRwdXQ7XG4gICAgfTtcbiAgICBnYXRlUmVzdWx0czogR2F0ZVJlc3VsdFtdO1xuICAgIGNvbXBsZXRpb25Qcm9taXNlT2JzZXJ2ZWQ6IGJvb2xlYW47XG4gICAgc3RvcFJlYXNvbj86IFN0b3BSZWFzb247XG4gICAgZXJyb3I/OiBzdHJpbmc7XG4gICAgLy8gRm9yIHN0dWNrIGRldGVjdGlvbiAtIGhhc2ggb2Ygb3V0cHV0cyB0byBkZXRlY3Qgbm8tcHJvZ3Jlc3NcbiAgICBvdXRwdXRIYXNoPzogc3RyaW5nO1xufVxuXG4vKiogTWFpbiBmbG93IHN0YXRlICovXG5leHBvcnQgaW50ZXJmYWNlIEZsb3dTdGF0ZSB7XG4gICAgLyoqIFNjaGVtYSB2ZXJzaW9uIGZvciBtaWdyYXRpb25zICovXG4gICAgc2NoZW1hVmVyc2lvbjogc3RyaW5nO1xuXG4gICAgLyoqIFJ1biBpZGVudGlmaWNhdGlvbiAqL1xuICAgIHJ1bklkOiBzdHJpbmc7XG4gICAgcHJvbXB0OiBzdHJpbmc7XG5cbiAgICAvKiogUnVuIHN0YXR1cyAqL1xuICAgIHN0YXR1czogUnVuU3RhdHVzO1xuICAgIHN0b3BSZWFzb24/OiBTdG9wUmVhc29uO1xuXG4gICAgLyoqIExvb3AgcGFyYW1ldGVycyAqL1xuICAgIGNvbXBsZXRpb25Qcm9taXNlOiBzdHJpbmc7XG4gICAgbWF4Q3ljbGVzOiBudW1iZXI7XG4gICAgc3R1Y2tUaHJlc2hvbGQ6IG51bWJlcjtcbiAgICBnYXRlczogc3RyaW5nW107XG5cbiAgICAvKiogQ3ljbGUgdHJhY2tpbmcgKi9cbiAgICBjdXJyZW50Q3ljbGU6IG51bWJlcjtcbiAgICBjb21wbGV0ZWRDeWNsZXM6IG51bWJlcjtcbiAgICBmYWlsZWRDeWNsZXM6IG51bWJlcjtcbiAgICBzdHVja0NvdW50OiBudW1iZXI7XG5cbiAgICAvKiogVGltZXN0YW1wcyAqL1xuICAgIGNyZWF0ZWRBdDogc3RyaW5nO1xuICAgIHVwZGF0ZWRBdDogc3RyaW5nO1xuICAgIGNvbXBsZXRlZEF0Pzogc3RyaW5nO1xuXG4gICAgLyoqIExhc3Qgc3VjY2Vzc2Z1bCBjaGVja3BvaW50IGZvciByZS1hbmNob3JpbmcgKi9cbiAgICBsYXN0Q2hlY2twb2ludD86IHtcbiAgICAgICAgY3ljbGVOdW1iZXI6IG51bWJlcjtcbiAgICAgICAgc3VtbWFyeTogc3RyaW5nO1xuICAgICAgICB0aW1lc3RhbXA6IHN0cmluZztcbiAgICB9O1xuXG4gICAgLyoqIEVycm9yIGluZm8gaWYgZmFpbGVkICovXG4gICAgZXJyb3I/OiBzdHJpbmc7XG59XG5cbi8qKiBDaGVja3BvaW50IGZvciBmYXN0IHJlc3VtZSAqL1xuZXhwb3J0IGludGVyZmFjZSBDaGVja3BvaW50IHtcbiAgICBzY2hlbWFWZXJzaW9uOiBzdHJpbmc7XG4gICAgcnVuSWQ6IHN0cmluZztcbiAgICBjeWNsZU51bWJlcjogbnVtYmVyO1xuICAgIHRpbWVzdGFtcDogc3RyaW5nO1xuICAgIHN0YXRlOiBGbG93U3RhdGU7XG4gICAgbGFzdFBoYXNlT3V0cHV0czoge1xuICAgICAgICBba2V5IGluIFBoYXNlXT86IFBoYXNlT3V0cHV0O1xuICAgIH07XG59XG5cbi8qKiBDb25maWd1cmF0aW9uIGZvciB0aGUgbG9vcCBydW5uZXIgKi9cbmV4cG9ydCBpbnRlcmZhY2UgTG9vcENvbmZpZyB7XG4gICAgcnVuSWQ6IHN0cmluZztcbiAgICBwcm9tcHQ6IHN0cmluZztcbiAgICBjb21wbGV0aW9uUHJvbWlzZTogc3RyaW5nO1xuICAgIG1heEN5Y2xlczogbnVtYmVyO1xuICAgIHN0dWNrVGhyZXNob2xkOiBudW1iZXI7XG4gICAgZ2F0ZXM6IHN0cmluZ1tdO1xuICAgIGNoZWNrcG9pbnRGcmVxdWVuY3k6IG51bWJlcjtcbiAgICBmbG93RGlyOiBzdHJpbmc7XG4gICAgZHJ5UnVuOiBib29sZWFuO1xuICAgIC8qKiBOdW1iZXIgb2YgcmV0cnkgYXR0ZW1wdHMgcGVyIGN5Y2xlIG9uIGZhaWx1cmUgKi9cbiAgICBjeWNsZVJldHJpZXM6IG51bWJlcjtcbiAgICAvKiogT3BlbkNvZGUgcHJvbXB0IHRpbWVvdXQgaW4gbXMgKHVzZWQgYXMgaWRsZSB0aW1lb3V0KSAqL1xuICAgIHByb21wdFRpbWVvdXQ/OiBudW1iZXI7XG4gICAgLyoqIFBoYXNlIGhhcmQgdGltZW91dCBpbiBtcyAocnVubmVyLXNpZGUgd2F0Y2hkb2cpICovXG4gICAgcGhhc2VUaW1lb3V0TXM/OiBudW1iZXI7XG4gICAgLyoqIEN5Y2xlIGhhcmQgdGltZW91dCBpbiBtcyAqL1xuICAgIGN5Y2xlVGltZW91dE1zPzogbnVtYmVyO1xuICAgIC8qKiBSdW4gaGFyZCB0aW1lb3V0IGluIG1zICovXG4gICAgcnVuVGltZW91dE1zPzogbnVtYmVyO1xuICAgIC8qKiBEZWJ1ZyBtb2RlOiBwcmludCB0b29sIGludm9jYXRpb25zIHRvIGNvbnNvbGUvbG9ncyAqL1xuICAgIGRlYnVnV29yazogYm9vbGVhbjtcbn1cbiIsCiAgICAiLyoqXG4gKiBDTEkgZXhlY3V0aW9uIG1vZGUgZm9yIGFpLWVuZyByYWxwaFxuICpcbiAqIE5vbi1UVUkgZXhlY3V0aW9uIHdpdGggaW50ZXJhY3RpdmUgcHJvbXB0cyB1c2luZyBAY2xhY2svcHJvbXB0c1xuICpcbiAqIFN1cHBvcnRzIHR3byBtb2RlczpcbiAqIC0gTG9vcCBtb2RlIChkZWZhdWx0KTogSXRlcmF0ZXMgd2l0aCBmcmVzaCBPcGVuQ29kZSBzZXNzaW9ucyBwZXIgY3ljbGVcbiAqIC0gU2luZ2xlLXNob3QgbW9kZSAoLS1uby1sb29wKTogU2luZ2xlIGV4ZWN1dGlvbiB3aXRoIHByb21wdCBvcHRpbWl6YXRpb25cbiAqL1xuaW1wb3J0IHsgaXNDYW5jZWwsIG91dHJvLCBzZWxlY3QsIHNwaW5uZXIgfSBmcm9tIFwiQGNsYWNrL3Byb21wdHNcIjtcbmltcG9ydCB7XG4gICAgdHlwZSBNZXNzYWdlUmVzcG9uc2UsXG4gICAgT3BlbkNvZGVDbGllbnQsXG59IGZyb20gXCIuLi9iYWNrZW5kcy9vcGVuY29kZS9jbGllbnRcIjtcbmltcG9ydCB0eXBlIHsgQWlFbmdDb25maWcgfSBmcm9tIFwiLi4vY29uZmlnL3NjaGVtYVwiO1xuaW1wb3J0IHtcbiAgICBSYWxwaExvb3BSdW5uZXIsXG4gICAgY3JlYXRlUmFscGhMb29wUnVubmVyLFxufSBmcm9tIFwiLi4vZXhlY3V0aW9uL3JhbHBoLWxvb3BcIjtcbmltcG9ydCB7IFByb21wdE9wdGltaXplciB9IGZyb20gXCIuLi9wcm9tcHQtb3B0aW1pemF0aW9uL29wdGltaXplclwiO1xuaW1wb3J0IHsgTG9nIH0gZnJvbSBcIi4uL3V0aWwvbG9nXCI7XG5pbXBvcnQgdHlwZSB7IFJhbHBoRmxhZ3MgfSBmcm9tIFwiLi9mbGFnc1wiO1xuaW1wb3J0IHsgVUkgfSBmcm9tIFwiLi91aVwiO1xuXG5jb25zdCBsb2cgPSBMb2cuY3JlYXRlKHsgc2VydmljZTogXCJydW4tY2xpXCIgfSk7XG5cbi8qKlxuICogQ2xlYW51cCBoYW5kbGVyIHRvIGVuc3VyZSBPcGVuQ29kZSBzZXJ2ZXIgaXMgcHJvcGVybHkgc2h1dCBkb3duXG4gKi9cbmxldCBhY3RpdmVDbGllbnQ6IE9wZW5Db2RlQ2xpZW50IHwgbnVsbCA9IG51bGw7XG5sZXQgY2xlYW51cEhhbmRsZXJzUmVnaXN0ZXJlZCA9IGZhbHNlO1xuXG5hc3luYyBmdW5jdGlvbiBzZXR1cENsZWFudXBIYW5kbGVycygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoY2xlYW51cEhhbmRsZXJzUmVnaXN0ZXJlZCkgcmV0dXJuO1xuICAgIGNsZWFudXBIYW5kbGVyc1JlZ2lzdGVyZWQgPSB0cnVlO1xuICAgIGNvbnN0IGNsZWFudXBGbiA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKGFjdGl2ZUNsaWVudCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsb2cuaW5mbyhcIkNsZWFudXAgc2lnbmFsIHJlY2VpdmVkLCBjbG9zaW5nIE9wZW5Db2RlIHNlcnZlci4uLlwiKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBhY3RpdmVDbGllbnQuY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIGxvZy5pbmZvKFwiT3BlbkNvZGUgc2VydmVyIGNsb3NlZCBzdWNjZXNzZnVsbHlcIik7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTXNnID1cbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgICAgICAgICAgIGxvZy5lcnJvcihcIkVycm9yIGR1cmluZyBjbGVhbnVwXCIsIHsgZXJyb3I6IGVycm9yTXNnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWN0aXZlQ2xpZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzLmV4aXQoMCk7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSB2YXJpb3VzIGV4aXQgc2lnbmFsc1xuICAgIHByb2Nlc3Mub24oXCJTSUdJTlRcIiwgY2xlYW51cEZuKTtcbiAgICBwcm9jZXNzLm9uKFwiU0lHVEVSTVwiLCBjbGVhbnVwRm4pO1xuICAgIHByb2Nlc3Mub24oXCJTSUdIVVBcIiwgY2xlYW51cEZuKTtcblxuICAgIC8vIEhhbmRsZSB1bmNhdWdodCBlcnJvcnNcbiAgICBwcm9jZXNzLm9uKFwidW5jYXVnaHRFeGNlcHRpb25cIiwgYXN5bmMgKGVycm9yKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yTXNnID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgICBsb2cuZXJyb3IoXCJVbmNhdWdodCBleGNlcHRpb25cIiwge1xuICAgICAgICAgICAgZXJyb3I6IGVycm9yTXNnLFxuICAgICAgICAgICAgc3RhY2s6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5zdGFjayA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IGNsZWFudXBGbigpO1xuICAgIH0pO1xuXG4gICAgcHJvY2Vzcy5vbihcInVuaGFuZGxlZFJlamVjdGlvblwiLCBhc3luYyAocmVhc29uKSA9PiB7XG4gICAgICAgIGNvbnN0IGVycm9yTXNnID1cbiAgICAgICAgICAgIHJlYXNvbiBpbnN0YW5jZW9mIEVycm9yID8gcmVhc29uLm1lc3NhZ2UgOiBTdHJpbmcocmVhc29uKTtcbiAgICAgICAgbG9nLmVycm9yKFwiVW5oYW5kbGVkIHJlamVjdGlvblwiLCB7XG4gICAgICAgICAgICBlcnJvcjogZXJyb3JNc2csXG4gICAgICAgICAgICBzdGFjazogcmVhc29uIGluc3RhbmNlb2YgRXJyb3IgPyByZWFzb24uc3RhY2sgOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBjbGVhbnVwRm4oKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJ1bkNsaShcbiAgICBjb25maWc6IEFpRW5nQ29uZmlnLFxuICAgIGZsYWdzOiBSYWxwaEZsYWdzLFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gU2V0dXAgY2xlYW51cCBoYW5kbGVyc1xuICAgIGF3YWl0IHNldHVwQ2xlYW51cEhhbmRsZXJzKCk7XG5cbiAgICBsb2cuaW5mbyhcIlN0YXJ0aW5nIENMSSBleGVjdXRpb25cIiwgeyB3b3JrZmxvdzogZmxhZ3Mud29ya2Zsb3cgfSk7XG5cbiAgICBjb25zdCBwcm9tcHQgPSBmbGFncy53b3JrZmxvdztcbiAgICBpZiAoIXByb21wdCkge1xuICAgICAgICBVSS5lcnJvcihcIk5vIHByb21wdCBvciB3b3JrZmxvdyBwcm92aWRlZFwiKTtcbiAgICAgICAgcHJvY2Vzcy5leGl0KDEpO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgb3B0aW1pemVyXG4gICAgY29uc3Qgb3B0aW1pemVyID0gbmV3IFByb21wdE9wdGltaXplcih7XG4gICAgICAgIGF1dG9BcHByb3ZlOiBmbGFncy5jaSA/PyBmYWxzZSxcbiAgICAgICAgdmVyYm9zaXR5OiBmbGFncy52ZXJib3NlID8gXCJ2ZXJib3NlXCIgOiBcIm5vcm1hbFwiLFxuICAgIH0pO1xuXG4gICAgLy8gQ3JlYXRlIG9wdGltaXphdGlvbiBzZXNzaW9uXG4gICAgVUkuaGVhZGVyKFwiUHJvbXB0IE9wdGltaXphdGlvblwiKTtcbiAgICBjb25zdCBzZXNzaW9uID0gb3B0aW1pemVyLmNyZWF0ZVNlc3Npb24ocHJvbXB0KTtcbiAgICBsb2cuZGVidWcoXCJDcmVhdGVkIG9wdGltaXphdGlvbiBzZXNzaW9uXCIsIHsgc3RlcHM6IHNlc3Npb24uc3RlcHMubGVuZ3RoIH0pO1xuXG4gICAgLy8gUmV2aWV3IHN0ZXBzIGludGVyYWN0aXZlbHkgKHVubGVzcyBDSSBtb2RlKVxuICAgIGlmICghZmxhZ3MuY2kpIHtcbiAgICAgICAgZm9yIChjb25zdCBzdGVwIG9mIHNlc3Npb24uc3RlcHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IGF3YWl0IHNlbGVjdCh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYEFwcGx5IFwiJHtzdGVwLm5hbWV9XCI/XFxuICAke3N0ZXAuZGVzY3JpcHRpb259YCxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcImFwcHJvdmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBcIkFwcHJvdmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpbnQ6IFwiQXBwbHkgdGhpcyBvcHRpbWl6YXRpb25cIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwicmVqZWN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogXCJSZWplY3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpbnQ6IFwiU2tpcCB0aGlzIG9wdGltaXphdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJza2lwLWFsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IFwiU2tpcCBhbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpbnQ6IFwiVXNlIG9yaWdpbmFsIHByb21wdFwiLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGlzQ2FuY2VsKGFjdGlvbikpIHtcbiAgICAgICAgICAgICAgICBsb2cuaW5mbyhcIlVzZXIgY2FuY2VsbGVkXCIpO1xuICAgICAgICAgICAgICAgIHByb2Nlc3MuZXhpdCgwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFjdGlvbiA9PT0gXCJza2lwLWFsbFwiKSB7XG4gICAgICAgICAgICAgICAgb3B0aW1pemVyLnNraXBPcHRpbWl6YXRpb24oc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWN0aW9uID09PSBcImFwcHJvdmVcIikge1xuICAgICAgICAgICAgICAgIG9wdGltaXplci5hcHByb3ZlU3RlcChzZXNzaW9uLCBzdGVwLmlkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW1pemVyLnJlamVjdFN0ZXAoc2Vzc2lvbiwgc3RlcC5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSb3V0ZSB0byBsb29wIG1vZGUgb3Igc2luZ2xlLXNob3QgbW9kZVxuICAgIGlmIChmbGFncy5sb29wICE9PSBmYWxzZSkge1xuICAgICAgICAvLyBMb29wIG1vZGUgKGRlZmF1bHQpXG4gICAgICAgIGF3YWl0IHJ1bkxvb3BNb2RlKGNvbmZpZywgZmxhZ3MsIHNlc3Npb24uZmluYWxQcm9tcHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNpbmdsZS1zaG90IG1vZGUgKC0tbm8tbG9vcClcbiAgICAgICAgYXdhaXQgcnVuU2luZ2xlU2hvdE1vZGUoY29uZmlnLCBmbGFncywgc2Vzc2lvbi5maW5hbFByb21wdCk7XG4gICAgfVxufVxuXG4vKipcbiAqIFJ1biBpbiBSYWxwaCBsb29wIG1vZGUgKGRlZmF1bHQpIC0gaXRlcmF0ZXMgd2l0aCBmcmVzaCBzZXNzaW9ucyBwZXIgY3ljbGVcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcnVuTG9vcE1vZGUoXG4gICAgY29uZmlnOiBBaUVuZ0NvbmZpZyxcbiAgICBmbGFnczogUmFscGhGbGFncyxcbiAgICBfb3B0aW1pemVkUHJvbXB0OiBzdHJpbmcsXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBVSS5oZWFkZXIoXCJSYWxwaCBMb29wIE1vZGVcIik7XG4gICAgVUkuaW5mbyhcIlJ1bm5pbmcgd2l0aCBmcmVzaCBPcGVuQ29kZSBzZXNzaW9ucyBwZXIgaXRlcmF0aW9uXCIpO1xuXG4gICAgLy8gU2hvdyBtb2RlIGluZm9cbiAgICBpZiAoZmxhZ3Muc2hpcCkge1xuICAgICAgICBVSS5pbmZvKFxuICAgICAgICAgICAgXCJNb2RlOiBTSElQIChhdXRvLWV4aXQgd2hlbiBhZ2VudCBvdXRwdXRzICc8cHJvbWlzZT5TSElQPC9wcm9taXNlPicpXCIsXG4gICAgICAgICk7XG4gICAgICAgIFVJLmluZm8oXCJDb21wbGV0aW9uIHByb21pc2U6IDxwcm9taXNlPlNISVA8L3Byb21pc2U+XCIpO1xuICAgIH0gZWxzZSBpZiAoZmxhZ3MuZHJhZnQgfHwgKCFmbGFncy5zaGlwICYmICFmbGFncy5jb21wbGV0aW9uUHJvbWlzZSkpIHtcbiAgICAgICAgVUkuaW5mbyhcIk1vZGU6IERSQUZUIChydW5zIGZvciBtYXgtY3ljbGVzIHRoZW4gc3RvcHMgZm9yIHlvdXIgcmV2aWV3KVwiKTtcbiAgICAgICAgVUkuaW5mbyhcIkNvbXBsZXRpb24gcHJvbWlzZTogbm9uZSAod2lsbCBydW4gYWxsIGN5Y2xlcylcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgVUkuaW5mbyhcIk1vZGU6IEN1c3RvbSBjb21wbGV0aW9uIHByb21pc2VcIik7XG4gICAgICAgIFVJLmluZm8oYENvbXBsZXRpb24gcHJvbWlzZTogJHtmbGFncy5jb21wbGV0aW9uUHJvbWlzZX1gKTtcbiAgICB9XG5cbiAgICBVSS5pbmZvKGBNYXggY3ljbGVzOiAke2ZsYWdzLm1heEN5Y2xlcyA/PyA1MH1gKTtcbiAgICBVSS5pbmZvKGBTdHVjayB0aHJlc2hvbGQ6ICR7ZmxhZ3Muc3R1Y2tUaHJlc2hvbGQgPz8gNX1gKTtcbiAgICBVSS5wcmludGxuKCk7XG5cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBydW5uZXIgPSBhd2FpdCBjcmVhdGVSYWxwaExvb3BSdW5uZXIoZmxhZ3MsIGNvbmZpZyk7XG4gICAgICAgIGF3YWl0IHJ1bm5lci5ydW4oKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgICBsb2cuZXJyb3IoXCJMb29wIGV4ZWN1dGlvbiBmYWlsZWRcIiwgeyBlcnJvcjogbWVzc2FnZSB9KTtcbiAgICAgICAgVUkuZXJyb3IobWVzc2FnZSk7XG4gICAgICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgICB9XG5cbiAgICBvdXRybyhcIkRvbmUhXCIpO1xufVxuXG4vKipcbiAqIFJ1biBpbiBzaW5nbGUtc2hvdCBtb2RlICgtLW5vLWxvb3ApIC0gc2luZ2xlIGV4ZWN1dGlvblxuICovXG5hc3luYyBmdW5jdGlvbiBydW5TaW5nbGVTaG90TW9kZShcbiAgICBjb25maWc6IEFpRW5nQ29uZmlnLFxuICAgIGZsYWdzOiBSYWxwaEZsYWdzLFxuICAgIG9wdGltaXplZFByb21wdDogc3RyaW5nLFxuKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gRXhlY3V0ZSBzaW5nbGUtc2hvdFxuICAgIFVJLmhlYWRlcihcIkV4ZWN1dGlvblwiKTtcbiAgICBjb25zdCBzID0gc3Bpbm5lcigpO1xuICAgIHMuc3RhcnQoXCJDb25uZWN0aW5nIHRvIE9wZW5Db2RlLi4uXCIpO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gQ3JlYXRlIE9wZW5Db2RlIGNsaWVudCAtIHRoaXMgd2lsbCBlaXRoZXIgc3Bhd24gYSBuZXcgc2VydmVyIG9yIGNvbm5lY3QgdG8gZXhpc3Rpbmcgb25lXG4gICAgICAgIGFjdGl2ZUNsaWVudCA9IGF3YWl0IE9wZW5Db2RlQ2xpZW50LmNyZWF0ZSh7XG4gICAgICAgICAgICBleGlzdGluZ1NlcnZlclVybDogcHJvY2Vzcy5lbnYuT1BFTkNPREVfVVJMLFxuICAgICAgICAgICAgc2VydmVyU3RhcnR1cFRpbWVvdXQ6IDEwMDAwLCAvLyBBbGxvdyAxMCBzZWNvbmRzIGZvciBzZXJ2ZXIgdG8gc3RhcnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3Qgb3BlblNlc3Npb24gPSBhd2FpdCBhY3RpdmVDbGllbnQuY3JlYXRlU2Vzc2lvbihvcHRpbWl6ZWRQcm9tcHQpO1xuICAgICAgICBsb2cuaW5mbyhcIkNyZWF0ZWQgT3BlbkNvZGUgc2Vzc2lvblwiLCB7IGlkOiBvcGVuU2Vzc2lvbi5pZCB9KTtcblxuICAgICAgICBzLnN0b3AoXCJDb25uZWN0ZWRcIik7XG5cbiAgICAgICAgLy8gU2VuZCBwcm9tcHQgYW5kIHN0cmVhbSByZXNwb25zZVxuICAgICAgICBVSS5wcmludGxuKCk7XG4gICAgICAgIFVJLnByaW50bG4oXG4gICAgICAgICAgICBgJHtVSS5TdHlsZS5URVhUX0RJTX1FeGVjdXRpbmcgdGFzay4uLiR7VUkuU3R5bGUuVEVYVF9OT1JNQUx9YCxcbiAgICAgICAgKTtcblxuICAgICAgICBsZXQgcmVzcG9uc2U6IE1lc3NhZ2VSZXNwb25zZTtcblxuICAgICAgICBpZiAoIWZsYWdzLm5vU3RyZWFtKSB7XG4gICAgICAgICAgICAvLyBTdHJlYW1pbmcgbW9kZSAoZGVmYXVsdClcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbWluZ1Jlc3BvbnNlID0gYXdhaXQgb3BlblNlc3Npb24uc2VuZE1lc3NhZ2VTdHJlYW0oXG4gICAgICAgICAgICAgICAgXCJFeGVjdXRlIHRoaXMgdGFzayBhbmQgcHJvdmlkZSBhIGRldGFpbGVkIHJlc3VsdCBzdW1tYXJ5LlwiLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgVUkucHJpbnRsbigpO1xuXG4gICAgICAgICAgICAvLyBTdHJlYW0gY29udGVudCB0byBzdGRlcnIgaW4gcmVhbC10aW1lXG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW1pbmdSZXNwb25zZS5zdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IGRlY29kZXIuZGVjb2RlKHZhbHVlLCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFVJLnByaW50KHRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gR2V0IGNvbXBsZXRlIHJlc3BvbnNlIGZvciBjbGVhbnVwXG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IHN0cmVhbWluZ1Jlc3BvbnNlLmNvbXBsZXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQnVmZmVyZWQgbW9kZSAod2hlbiAtLW5vLXN0cmVhbSBmbGFnIGlzIHVzZWQpXG4gICAgICAgICAgICBVSS5wcmludGxuKCk7XG4gICAgICAgICAgICBVSS5wcmludGxuKFxuICAgICAgICAgICAgICAgIGAke1VJLlN0eWxlLlRFWFRfRElNfUJ1ZmZlcmluZyByZXNwb25zZS4uLiR7VUkuU3R5bGUuVEVYVF9OT1JNQUx9YCxcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgb3BlblNlc3Npb24uc2VuZE1lc3NhZ2UoXG4gICAgICAgICAgICAgICAgXCJFeGVjdXRlIHRoaXMgdGFzayBhbmQgcHJvdmlkZSBhIGRldGFpbGVkIHJlc3VsdCBzdW1tYXJ5LlwiLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgVUkucHJpbnRsbigpO1xuICAgICAgICAgICAgVUkucHJpbnRsbihyZXNwb25zZS5jb250ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIFVJLnByaW50bG4oKTtcbiAgICAgICAgVUkuc3VjY2VzcyhcIkV4ZWN1dGlvbiBjb21wbGV0ZVwiKTtcblxuICAgICAgICAvLyBDbGVhbnVwIHJlc291cmNlc1xuICAgICAgICBpZiAoYWN0aXZlQ2xpZW50KSB7XG4gICAgICAgICAgICBhd2FpdCBhY3RpdmVDbGllbnQuY2xlYW51cCgpO1xuICAgICAgICAgICAgYWN0aXZlQ2xpZW50ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvZy5pbmZvKFwiRXhlY3V0aW9uIGNvbXBsZXRlXCIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHMuc3RvcChcIkNvbm5lY3Rpb24gZmFpbGVkXCIpO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgICBsb2cuZXJyb3IoXCJFeGVjdXRpb24gZmFpbGVkXCIsIHsgZXJyb3I6IG1lc3NhZ2UgfSk7XG4gICAgICAgIFVJLmVycm9yKG1lc3NhZ2UpO1xuXG4gICAgICAgIC8vIEVuc3VyZSBjbGVhbnVwIG9uIGVycm9yXG4gICAgICAgIGlmIChhY3RpdmVDbGllbnQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgYWN0aXZlQ2xpZW50LmNsZWFudXAoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGNsZWFudXBFcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsZWFudXBNc2cgPVxuICAgICAgICAgICAgICAgICAgICBjbGVhbnVwRXJyb3IgaW5zdGFuY2VvZiBFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBjbGVhbnVwRXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBTdHJpbmcoY2xlYW51cEVycm9yKTtcbiAgICAgICAgICAgICAgICBsb2cuZXJyb3IoXCJFcnJvciBkdXJpbmcgZXJyb3IgY2xlYW51cFwiLCB7IGVycm9yOiBjbGVhbnVwTXNnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWN0aXZlQ2xpZW50ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgICB9XG5cbiAgICBvdXRybyhcIkRvbmUhXCIpO1xufVxuIgogIF0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBRUEsSUFBTSxRQUFRLE9BQU8sSUFBSSxZQUFZO0FBQUEsRUFDckMsSUFBTSxNQUFNLE9BQU8sSUFBSSxlQUFlO0FBQUEsRUFDdEMsSUFBTSxNQUFNLE9BQU8sSUFBSSxVQUFVO0FBQUEsRUFDakMsSUFBTSxPQUFPLE9BQU8sSUFBSSxXQUFXO0FBQUEsRUFDbkMsSUFBTSxTQUFTLE9BQU8sSUFBSSxhQUFhO0FBQUEsRUFDdkMsSUFBTSxNQUFNLE9BQU8sSUFBSSxVQUFVO0FBQUEsRUFDakMsSUFBTSxZQUFZLE9BQU8sSUFBSSxnQkFBZ0I7QUFBQSxFQUM3QyxJQUFNLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxRQUFRLE9BQU8sU0FBUyxZQUFZLEtBQUssZUFBZTtBQUFBLEVBQ3BGLElBQU0sYUFBYSxDQUFDLFNBQVMsQ0FBQyxDQUFDLFFBQVEsT0FBTyxTQUFTLFlBQVksS0FBSyxlQUFlO0FBQUEsRUFDdkYsSUFBTSxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUMsUUFBUSxPQUFPLFNBQVMsWUFBWSxLQUFLLGVBQWU7QUFBQSxFQUNsRixJQUFNLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxRQUFRLE9BQU8sU0FBUyxZQUFZLEtBQUssZUFBZTtBQUFBLEVBQ25GLElBQU0sV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDLFFBQVEsT0FBTyxTQUFTLFlBQVksS0FBSyxlQUFlO0FBQUEsRUFDckYsSUFBTSxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUMsUUFBUSxPQUFPLFNBQVMsWUFBWSxLQUFLLGVBQWU7QUFBQSxFQUNsRixTQUFTLFlBQVksQ0FBQyxNQUFNO0FBQUEsSUFDeEIs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QU8sS0FBRyxLQUFHLFNBQU8sU0FBTyxLQUFHLEtBQUcsUUFBTSxNQUFJLFFBQU0sS0FBRyxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLFFBQU0sS0FBRyxLQUFHLFFBQU0sU0FBTyxLQUFHLEtBQUcsU0FBTyxTQUFPLEtBQUcsS0FBRyxTQUFPLFNBQU8sS0FBRyxLQUFHLFNBQU8sU0FBTyxLQUFHLEtBQUcsU0FBTyxTQUFPLEtBQUcsS0FBRyxTQUFPLFNBQU8sS0FBRyxLQUFHLFNBQU8sU0FBTyxLQUFHLEtBQUcsU0FBTyxTQUFPLEtBQUcsS0FBRyxTQUFPLFNBQU8sS0FBRyxLQUFHLFNBQU8sU0FBTyxLQUFHLEtBQUcsU0FBTyxTQUFPLEtBQUcsS0FBRyxTQUFPLFNBQU8sS0FBRyxLQUFHLFNBQU8sU0FBTyxLQUFHLEtBQUcsU0FBTyxTQUFPLEtBQUcsS0FBRyxTQUFPLFNBQU8sS0FBRyxLQUFHLFNBQU8sU0FBTyxLQUFHLEtBQUcsU0FBTyxTQUFPLEtBQUcsS0FBRyxTQUFPLFNBQU8sS0FBRyxLQUFHLFNBQU8sU0FBTyxLQUFHLEtBQUcsU0FBTyxTQUFPLEtBQUcsS0FBRyxTQUFPLFNBQU8sS0FBRyxLQUFHLFNBQU8sU0FBTyxLQUFHLEtBQUcsU0FBTyxTQUFPLEtBQUcsS0FBRyxTQUFPLFNBQU8sS0FBRyxLQUFHLFNBQU8sU0FBTyxLQUFHLEtBQUcsU0FBTyxTQUFPLEtBQUcsS0FBRyxTQUFPLFVBQVEsS0FBRyxLQUFHLFVBQVEsVUFBUSxLQUFHLEtBQUcsVUFBUSxVQUFRLEtBQUcsS0FBRyxVQUFRLFVBQVEsS0FBRyxLQUFHLFVBQVEsVUFBUSxLQUFHLEtBQUcsVUFBUSxVQUFRLEtBQUcsS0FBRyxVQUFRLFVBQVEsS0FBRyxLQUFHLFVBQVEsVUFBUSxLQUFHLEtBQUcsU0FBTyxNQUFJLE1BQUksS0FBRyxLQUFHLE9BQUssT0FBSyxLQUFHLEtBQUcsT0FBSyxPQUFLLEtBQUcsS0FBRyxPQUFLLEtBQUcsT0FBSyxLQUFHLE9BQUssU0FBTyxLQUFHLEtBQUcsU0FBTyxTQUFPLEtBQUcsS0FBRyxRQUFNLE9BQUssS0FBRyxPQUFLLEtBQUcsT0FBSyxPQUFLLEtBQUcsS0FBRyxPQUFLLEtBQUcsT0FBSyxPQUFLLEtBQUcsS0FBRyxPQUFLLE9BQUssS0FBRyxLQUFHLE9BQUssT0FBSyxLQUFHLEtBQUcsT0FBSyxPQUFLLEtBQUcsS0FBRyxPQUFLLEtBQUcsT0FBSyxLQUFHLE9BQUssT0FBSyxLQUFHLEtBQUcsT0FBSyxPQUFLLEtBQUcsS0FBRyxPQUFLLEtBQUcsT0FBSyxPQUFLLEtBQUcsS0FBRyxPQUFLLE9BQUssS0FBRyxLQUFHLE9BQUssS0FBRyxPQUFLLE9BQUssS0FBRyxLQUFHLE9BQUssT0FBSyxLQUFHLEtBQUcsT0FBSyxLQUFHLE9BQUssS0FBRyxPQUFLLEtBQUcsT0FBSyxLQUFHLE9BQUssS0FBRyxPQUFLLEtBQUcsT0FBSyxPQUFLLEtBQUcsS0FBRyxPQUFLLEtBQUcsT0FBSyxPQUFLLEtBQUcsS0FBRyxPQUFLLEtBQUcsT0FBSyxPQUFLLEtBQUcsS0FBRyxPQUFLLEtBQUcsT0FBSyxPQUFLLEtBQUcsS0FBRyxPQUFLLEtBQUcsT0FBSyxPQUFLLEtBQUcsS0FBRyxPQUFLLE9BQUssS0FBRyxLQUFHLE9BQUssS0FBRyxPQUFLLEtBQUcsT0FBSyxLQUFHLE9BQUssS0FBRyxPQUFLLEtBQUcsT0FBSyxLQUFHLE9BQUssS0FBRyxPQUFLLEtBQUcsT0FBSyxLQUFHLE9BQUssS0FBRyxPQUFLLEtBQUcsT0FBSyxLQUFHLE9BQUssS0FBRyxPQUFLLE9BQUssS0FBRyxLQUFHLE9BQUssS0FBRyxPQUFLLEtBQUcsT0FBSyxPQUFLLEtBQUcsS0FBRyxPQUFLLEtBQUcsT0FBSyxLQUFHLE9BQUssT0FBSyxLQUFHLEtBQUcsT0FBSyxPQUFLLEtBQUcsS0FBRyxPQUFLLE9BQUssS0FBRyxLQUFHLE9BQUssT0FBSyxLQUFHLEtBQUcsT0FBSyxPQUFLLEtBQUcsS0FBRyxPQUFLLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLEtBQUcsUUFBTSxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLFFBQU0sS0FBRyxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLEtBQUcsUUFBTSxLQUFHLFFBQU0sS0FBRyxRQUFNLEtBQUcsUUFBTSxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxLQUFHLFFBQU0sS0FBRyxRQUFNLEtBQUcsUUFBTSxLQUFHLFFBQU0sS0FBRyxRQUFNLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLEtBQUcsUUFBTSxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLFFBQU0sS0FBRyxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLEtBQUcsUUFBTSxLQUFHLFFBQU0sS0FBRyxRQUFNLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLFFBQU0sS0FBRyxLQUFHLFFBQU0sS0FBRyxRQUFNLEtBQUcsUUFBTSxLQUFHLFFBQU0sS0FBRyxRQUFNLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLEtBQUcsUUFBTSxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLEtBQUcsUUFBTSxLQUFHLFFBQU0sS0FBRyxRQUFNLFFBQU0sS0FBRyxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLFFBQU0sS0FBRyxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLEtBQUcsUUFBTSxLQUFHLFFBQU0sS0FBRyxRQUFNLEtBQUcsUUFBTSxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLFFBQU0sS0FBRyxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLFFBQU0sS0FBRyxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLFFBQU0sS0FBRyxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLFFBQU0sS0FBRyxLQUFHLFFBQU0sS0FBRyxRQUFNLFFBQU0sS0FBRyxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLEtBQUcsUUFBTSxLQUFHLFFBQU0sS0FBRyxRQUFNLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLFFBQU0sS0FBRyxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLFFBQU0sS0FBRyxLQUFHLFFBQU0sUUFBTSxLQUFHLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLEtBQUcsUUFBTSxRQUFNLEtBQUcsS0FBRyxRQUFNLEtBQUcsU0FBTyxLQUFHLFNBQU8sU0FBTyxLQUFHLEtBQUcsU0FBTyxTQUFPLEtBQUcsS0FBRyxTQUFPLFNBQU8sS0FBRyxLQUFHLFNBQU8sU0FBTyxLQUFHLEtBQUcsU0FBTyxTQUFPLEtBQUcsS0FBRyxTQUFPLEtBQUcsU0FBTyxVQUFRLEtBQUcsS0FBRyxVQUFRLFVBQVEsS0FBRyxLQUFHLFVBQVEsVUFBUSxLQUFHLEtBQUcsVUFBUSxVQUFRLEtBQUcsS0FBRyxVQUFRLFVBQVEsS0FBRyxLQUFHLFVBQVEsVUFBUSxLQUFHLEtBQUcsV0FBUyxXQUFTLEtBQUcsS0FBRyxVQUFRLE1BQUk7QUFBQSxLQUFLLEVBQUUsa0JBQWdCLFFBQVEsQ0FBQyxHQUFFO0FBQUEsSUFBQyxJQUFJLElBQUUsS0FBSyxlQUFlLENBQUM7QUFBQSxJQUFFLE9BQU8sS0FBRyxPQUFLLEtBQUcsT0FBSyxLQUFHLE1BQUksSUFBRTtBQUFBO0FBQUEsRUFBRyxTQUFTLENBQUMsQ0FBQyxHQUFFO0FBQUEsSUFBQyxPQUFPLEVBQUUsTUFBTSxrREFBa0QsS0FBRyxDQUFDO0FBQUE7QUFBQSxFQUFFLEVBQUUsU0FBTyxRQUFRLENBQUMsR0FBRTtBQUFBLElBQUMsU0FBUSxJQUFFLEVBQUUsQ0FBQyxHQUFFLElBQUUsR0FBRSxJQUFFLEVBQUUsSUFBRSxFQUFFLFFBQU87QUFBQSxNQUFJLElBQUUsSUFBRSxLQUFLLGdCQUFnQixFQUFFLEVBQUU7QUFBQSxJQUFFLE9BQU87QUFBQSxLQUFHLEVBQUUsUUFBTSxRQUFRLENBQUMsR0FBRSxHQUFFLEdBQUU7QUFBQSxJQUFDLFVBQVEsRUFBRSxPQUFPLENBQUMsR0FBRSxJQUFFLEtBQUcsR0FBRSxJQUFFLEtBQUcsR0FBRSxJQUFFLE1BQUksSUFBRSxVQUFRLElBQUcsSUFBRSxNQUFJLElBQUUsVUFBUTtBQUFBLElBQUcsU0FBUSxJQUFFLElBQUcsSUFBRSxHQUFFLElBQUUsRUFBRSxDQUFDLEdBQUUsSUFBRSxFQUFFLElBQUUsRUFBRSxRQUFPLEtBQUk7QUFBQSxNQUFDLElBQUksSUFBRSxFQUFFLElBQUcsSUFBRSxFQUFFLE9BQU8sQ0FBQztBQUFBLE1BQUUsSUFBRyxLQUFHLEtBQUcsS0FBRyxJQUFFLElBQUU7QUFBQSxRQUFHLElBQUcsSUFBRSxLQUFHO0FBQUEsVUFBRSxLQUFHO0FBQUEsUUFBTztBQUFBO0FBQUEsTUFBTSxLQUFHO0FBQUEsSUFBQztBQUFBLElBQUMsT0FBTztBQUFBO0FBQUEsR0FBSyxDQUFDO0FBQUUsSUFBSSxLQUFHLEVBQUU7QUFBUSxJQUFNLEtBQUcsRUFBRSxFQUFFO0FBQUUsSUFBSSxLQUFHLFFBQVEsR0FBRTtBQUFBLEVBQUMsT0FBTTtBQUFBO0FBQWt5ZSxJQUFNLEtBQUcsRUFBRSxFQUFFO0FBQUUsU0FBUyxDQUFDLENBQUMsR0FBRSxJQUFFLENBQUMsR0FBRTtBQUFBLEVBQUMsSUFBRyxPQUFPLEtBQUcsWUFBVSxFQUFFLFdBQVMsTUFBSSxJQUFFLEVBQUMsbUJBQWtCLFNBQU0sRUFBQyxHQUFFLElBQUUsRUFBRSxDQUFDLEdBQUUsRUFBRSxXQUFTO0FBQUEsSUFBRyxPQUFPO0FBQUEsRUFBRSxJQUFFLEVBQUUsUUFBUSxHQUFHLEdBQUUsSUFBSTtBQUFBLEVBQUUsTUFBTSxJQUFFLEVBQUUsb0JBQWtCLElBQUU7QUFBQSxFQUFFLElBQUksSUFBRTtBQUFBLEVBQUUsV0FBVSxLQUFLLEdBQUU7QUFBQSxJQUFDLE1BQU0sSUFBRSxFQUFFLFlBQVksQ0FBQztBQUFBLElBQUUsSUFBRyxLQUFHLE1BQUksS0FBRyxPQUFLLEtBQUcsT0FBSyxLQUFHLE9BQUssS0FBRztBQUFBLE1BQUk7QUFBQSxJQUFTLFFBQU8sR0FBRyxlQUFlLENBQUM7QUFBQSxXQUFPO0FBQUEsV0FBUTtBQUFBLFFBQUksS0FBRztBQUFBLFFBQUU7QUFBQSxXQUFVO0FBQUEsUUFBSSxLQUFHO0FBQUEsUUFBRTtBQUFBO0FBQUEsUUFBYyxLQUFHO0FBQUE7QUFBQSxFQUFFO0FBQUEsRUFBQyxPQUFPO0FBQUE7QUFBRSxJQUFNLElBQUU7QUFBUixJQUFXLElBQUUsQ0FBQyxJQUFFLE1BQUksT0FBRyxRQUFRLElBQUU7QUFBakMsSUFBc0MsSUFBRSxDQUFDLElBQUUsTUFBSSxPQUFHLFFBQVEsS0FBRyxPQUFPO0FBQXBFLElBQXlFLElBQUUsQ0FBQyxJQUFFLE1BQUksQ0FBQyxHQUFFLEdBQUUsTUFBSSxRQUFRLEtBQUcsT0FBTyxLQUFLLEtBQUs7QUFBdkgsSUFBNEgsSUFBRSxFQUFDLFVBQVMsRUFBQyxPQUFNLENBQUMsR0FBRSxDQUFDLEdBQUUsTUFBSyxDQUFDLEdBQUUsRUFBRSxHQUFFLEtBQUksQ0FBQyxHQUFFLEVBQUUsR0FBRSxRQUFPLENBQUMsR0FBRSxFQUFFLEdBQUUsV0FBVSxDQUFDLEdBQUUsRUFBRSxHQUFFLFVBQVMsQ0FBQyxJQUFHLEVBQUUsR0FBRSxTQUFRLENBQUMsR0FBRSxFQUFFLEdBQUUsUUFBTyxDQUFDLEdBQUUsRUFBRSxHQUFFLGVBQWMsQ0FBQyxHQUFFLEVBQUUsRUFBQyxHQUFFLE9BQU0sRUFBQyxPQUFNLENBQUMsSUFBRyxFQUFFLEdBQUUsS0FBSSxDQUFDLElBQUcsRUFBRSxHQUFFLE9BQU0sQ0FBQyxJQUFHLEVBQUUsR0FBRSxRQUFPLENBQUMsSUFBRyxFQUFFLEdBQUUsTUFBSyxDQUFDLElBQUcsRUFBRSxHQUFFLFNBQVEsQ0FBQyxJQUFHLEVBQUUsR0FBRSxNQUFLLENBQUMsSUFBRyxFQUFFLEdBQUUsT0FBTSxDQUFDLElBQUcsRUFBRSxHQUFFLGFBQVksQ0FBQyxJQUFHLEVBQUUsR0FBRSxNQUFLLENBQUMsSUFBRyxFQUFFLEdBQUUsTUFBSyxDQUFDLElBQUcsRUFBRSxHQUFFLFdBQVUsQ0FBQyxJQUFHLEVBQUUsR0FBRSxhQUFZLENBQUMsSUFBRyxFQUFFLEdBQUUsY0FBYSxDQUFDLElBQUcsRUFBRSxHQUFFLFlBQVcsQ0FBQyxJQUFHLEVBQUUsR0FBRSxlQUFjLENBQUMsSUFBRyxFQUFFLEdBQUUsWUFBVyxDQUFDLElBQUcsRUFBRSxHQUFFLGFBQVksQ0FBQyxJQUFHLEVBQUUsRUFBQyxHQUFFLFNBQVEsRUFBQyxTQUFRLENBQUMsSUFBRyxFQUFFLEdBQUUsT0FBTSxDQUFDLElBQUcsRUFBRSxHQUFFLFNBQVEsQ0FBQyxJQUFHLEVBQUUsR0FBRSxVQUFTLENBQUMsSUFBRyxFQUFFLEdBQUUsUUFBTyxDQUFDLElBQUcsRUFBRSxHQUFFLFdBQVUsQ0FBQyxJQUFHLEVBQUUsR0FBRSxRQUFPLENBQUMsSUFBRyxFQUFFLEdBQUUsU0FBUSxDQUFDLElBQUcsRUFBRSxHQUFFLGVBQWMsQ0FBQyxLQUFJLEVBQUUsR0FBRSxRQUFPLENBQUMsS0FBSSxFQUFFLEdBQUUsUUFBTyxDQUFDLEtBQUksRUFBRSxHQUFFLGFBQVksQ0FBQyxLQUFJLEVBQUUsR0FBRSxlQUFjLENBQUMsS0FBSSxFQUFFLEdBQUUsZ0JBQWUsQ0FBQyxLQUFJLEVBQUUsR0FBRSxjQUFhLENBQUMsS0FBSSxFQUFFLEdBQUUsaUJBQWdCLENBQUMsS0FBSSxFQUFFLEdBQUUsY0FBYSxDQUFDLEtBQUksRUFBRSxHQUFFLGVBQWMsQ0FBQyxLQUFJLEVBQUUsRUFBQyxFQUFDO0FBQUUsT0FBTyxLQUFLLEVBQUUsUUFBUTtBQUFFLElBQU0sS0FBRyxPQUFPLEtBQUssRUFBRSxLQUFLO0FBQTVCLElBQThCLEtBQUcsT0FBTyxLQUFLLEVBQUUsT0FBTztBQUFFLENBQUMsR0FBRyxJQUFHLEdBQUcsRUFBRTtBQUFFLFNBQVMsRUFBRSxHQUFFO0FBQUEsRUFBQyxNQUFNLElBQUUsSUFBSTtBQUFBLEVBQUksWUFBVSxHQUFFLE1BQUssT0FBTyxRQUFRLENBQUMsR0FBRTtBQUFBLElBQUMsWUFBVSxHQUFFLE1BQUssT0FBTyxRQUFRLENBQUM7QUFBQSxNQUFFLEVBQUUsS0FBRyxFQUFDLE1BQUssUUFBUSxFQUFFLE9BQU0sT0FBTSxRQUFRLEVBQUUsTUFBSyxHQUFFLEVBQUUsS0FBRyxFQUFFLElBQUcsRUFBRSxJQUFJLEVBQUUsSUFBRyxFQUFFLEVBQUU7QUFBQSxJQUFFLE9BQU8sZUFBZSxHQUFFLEdBQUUsRUFBQyxPQUFNLEdBQUUsWUFBVyxNQUFFLENBQUM7QUFBQSxFQUFDO0FBQUEsRUFBQyxPQUFPLE9BQU8sZUFBZSxHQUFFLFNBQVEsRUFBQyxPQUFNLEdBQUUsWUFBVyxNQUFFLENBQUMsR0FBRSxFQUFFLE1BQU0sUUFBTSxZQUFXLEVBQUUsUUFBUSxRQUFNLFlBQVcsRUFBRSxNQUFNLE9BQUssRUFBRSxHQUFFLEVBQUUsTUFBTSxVQUFRLEVBQUUsR0FBRSxFQUFFLE1BQU0sVUFBUSxFQUFFLEdBQUUsRUFBRSxRQUFRLE9BQUssRUFBRSxDQUFDLEdBQUUsRUFBRSxRQUFRLFVBQVEsRUFBRSxDQUFDLEdBQUUsRUFBRSxRQUFRLFVBQVEsRUFBRSxDQUFDLEdBQUUsT0FBTyxpQkFBaUIsR0FBRSxFQUFDLGNBQWEsRUFBQyxPQUFNLENBQUMsR0FBRSxHQUFFLE1BQUksTUFBSSxLQUFHLE1BQUksSUFBRSxJQUFFLElBQUUsS0FBRyxJQUFFLE1BQUksTUFBSSxLQUFLLE9BQU8sSUFBRSxLQUFHLE1BQUksRUFBRSxJQUFFLE1BQUksS0FBRyxLQUFHLEtBQUssTUFBTSxJQUFFLE1BQUksQ0FBQyxJQUFFLElBQUUsS0FBSyxNQUFNLElBQUUsTUFBSSxDQUFDLElBQUUsS0FBSyxNQUFNLElBQUUsTUFBSSxDQUFDLEdBQUUsWUFBVyxNQUFFLEdBQUUsVUFBUyxFQUFDLE9BQU0sT0FBRztBQUFBLElBQUMsTUFBTSxJQUFFLHlCQUF5QixLQUFLLEVBQUUsU0FBUyxFQUFFLENBQUM7QUFBQSxJQUFFLElBQUcsQ0FBQztBQUFBLE1BQUUsT0FBTSxDQUFDLEdBQUUsR0FBRSxDQUFDO0FBQUEsSUFBRSxLQUFJLEtBQUc7QUFBQSxJQUFFLEVBQUUsV0FBUyxNQUFJLElBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxJQUFJLE9BQUcsSUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFO0FBQUEsSUFBRyxNQUFNLElBQUUsT0FBTyxTQUFTLEdBQUUsRUFBRTtBQUFBLElBQUUsT0FBTSxDQUFDLEtBQUcsS0FBRyxLQUFJLEtBQUcsSUFBRSxLQUFJLElBQUUsR0FBRztBQUFBLEtBQUcsWUFBVyxNQUFFLEdBQUUsY0FBYSxFQUFDLE9BQU0sT0FBRyxFQUFFLGFBQWEsR0FBRyxFQUFFLFNBQVMsQ0FBQyxDQUFDLEdBQUUsWUFBVyxNQUFFLEdBQUUsZUFBYyxFQUFDLE9BQU0sT0FBRztBQUFBLElBQUMsSUFBRyxJQUFFO0FBQUEsTUFBRSxPQUFPLEtBQUc7QUFBQSxJQUFFLElBQUcsSUFBRTtBQUFBLE1BQUcsT0FBTyxNQUFJLElBQUU7QUFBQSxJQUFHLElBQUksR0FBRSxHQUFFO0FBQUEsSUFBRSxJQUFHLEtBQUc7QUFBQSxNQUFJLE1BQUksSUFBRSxPQUFLLEtBQUcsS0FBRyxLQUFJLElBQUUsR0FBRSxJQUFFO0FBQUEsSUFBTTtBQUFBLE1BQUMsS0FBRztBQUFBLE1BQUcsTUFBTSxJQUFFLElBQUU7QUFBQSxNQUFHLElBQUUsS0FBSyxNQUFNLElBQUUsRUFBRSxJQUFFLEdBQUUsSUFBRSxLQUFLLE1BQU0sSUFBRSxDQUFDLElBQUUsR0FBRSxJQUFFLElBQUUsSUFBRTtBQUFBO0FBQUEsSUFBRSxNQUFNLElBQUUsS0FBSyxJQUFJLEdBQUUsR0FBRSxDQUFDLElBQUU7QUFBQSxJQUFFLElBQUcsTUFBSTtBQUFBLE1BQUUsT0FBTztBQUFBLElBQUcsSUFBSSxJQUFFLE1BQUksS0FBSyxNQUFNLENBQUMsS0FBRyxJQUFFLEtBQUssTUFBTSxDQUFDLEtBQUcsSUFBRSxLQUFLLE1BQU0sQ0FBQztBQUFBLElBQUcsT0FBTyxNQUFJLE1BQUksS0FBRyxLQUFJO0FBQUEsS0FBRyxZQUFXLE1BQUUsR0FBRSxXQUFVLEVBQUMsT0FBTSxDQUFDLEdBQUUsR0FBRSxNQUFJLEVBQUUsY0FBYyxFQUFFLGFBQWEsR0FBRSxHQUFFLENBQUMsQ0FBQyxHQUFFLFlBQVcsTUFBRSxHQUFFLFdBQVUsRUFBQyxPQUFNLE9BQUcsRUFBRSxjQUFjLEVBQUUsYUFBYSxDQUFDLENBQUMsR0FBRSxZQUFXLE1BQUUsRUFBQyxDQUFDLEdBQUU7QUFBQTtBQUFFLElBQU0sS0FBRyxHQUFHO0FBQVosSUFBYyxJQUFFLElBQUksSUFBSSxDQUFDLFFBQU8sR0FBTSxDQUFDO0FBQXZDLElBQXlDLEtBQUc7QUFBNUMsSUFBK0MsSUFBRTtBQUFqRCxJQUF3RCxJQUFFO0FBQTFELElBQThELEtBQUc7QUFBakUsSUFBcUUsSUFBRTtBQUF2RSxJQUEyRSxJQUFFLEdBQUc7QUFBaEYsSUFBd0YsSUFBRSxPQUFHLEdBQUcsRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLFFBQVEsSUFBSSxJQUFJO0FBQWxJLElBQXNJLElBQUUsT0FBRyxHQUFHLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxRQUFRLElBQUksSUFBSTtBQUFoTCxJQUFvTCxLQUFHLE9BQUcsRUFBRSxNQUFNLEdBQUcsRUFBRSxJQUFJLE9BQUcsRUFBRSxDQUFDLENBQUM7QUFBbE4sSUFBb04sSUFBRSxDQUFDLEdBQUUsR0FBRSxNQUFJO0FBQUEsRUFBQyxNQUFNLElBQUUsQ0FBQyxHQUFHLENBQUM7QUFBQSxFQUFFLElBQUksSUFBRSxPQUFHLElBQUUsT0FBRyxJQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsU0FBTyxFQUFFLENBQUM7QUFBQSxFQUFFLFlBQVUsR0FBRSxNQUFLLEVBQUUsUUFBUSxHQUFFO0FBQUEsSUFBQyxNQUFNLElBQUUsRUFBRSxDQUFDO0FBQUEsSUFBRSxJQUFHLElBQUUsS0FBRyxJQUFFLEVBQUUsRUFBRSxTQUFPLE1BQUksS0FBRyxFQUFFLEtBQUssQ0FBQyxHQUFFLElBQUUsSUFBRyxFQUFFLElBQUksQ0FBQyxNQUFJLElBQUUsTUFBRyxJQUFFLEVBQUUsTUFBTSxJQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsRUFBRSxXQUFXLENBQUMsSUFBRyxHQUFFO0FBQUEsTUFBQyxJQUFFLE1BQUksTUFBSSxJQUFFLE9BQUcsSUFBRSxTQUFJLE1BQUksTUFBSSxJQUFFO0FBQUEsTUFBSTtBQUFBLElBQVE7QUFBQSxJQUFDLEtBQUcsR0FBRSxNQUFJLEtBQUcsSUFBRSxFQUFFLFNBQU8sTUFBSSxFQUFFLEtBQUssRUFBRSxHQUFFLElBQUU7QUFBQSxFQUFFO0FBQUEsRUFBQyxDQUFDLEtBQUcsRUFBRSxFQUFFLFNBQU8sR0FBRyxTQUFPLEtBQUcsRUFBRSxTQUFPLE1BQUksRUFBRSxFQUFFLFNBQU8sTUFBSSxFQUFFLElBQUk7QUFBQTtBQUF4akIsSUFBNGpCLEtBQUcsT0FBRztBQUFBLEVBQUMsTUFBTSxJQUFFLEVBQUUsTUFBTSxHQUFHO0FBQUEsRUFBRSxJQUFJLElBQUUsRUFBRTtBQUFBLEVBQU8sTUFBSyxJQUFFLEtBQUcsRUFBRSxFQUFFLEVBQUUsSUFBRSxFQUFFLElBQUU7QUFBQSxJQUFJO0FBQUEsRUFBSSxPQUFPLE1BQUksRUFBRSxTQUFPLElBQUUsRUFBRSxNQUFNLEdBQUUsQ0FBQyxFQUFFLEtBQUssR0FBRyxJQUFFLEVBQUUsTUFBTSxDQUFDLEVBQUUsS0FBSyxFQUFFO0FBQUE7QUFBcHNCLElBQXVzQixLQUFHLENBQUMsR0FBRSxHQUFFLElBQUUsQ0FBQyxNQUFJO0FBQUEsRUFBQyxJQUFHLEVBQUUsU0FBTyxTQUFJLEVBQUUsS0FBSyxNQUFJO0FBQUEsSUFBRyxPQUFNO0FBQUEsRUFBRyxJQUFJLElBQUUsSUFBRyxHQUFFO0FBQUEsRUFBRSxNQUFNLElBQUUsR0FBRyxDQUFDO0FBQUEsRUFBRSxJQUFJLElBQUUsQ0FBQyxFQUFFO0FBQUEsRUFBRSxZQUFVLEdBQUUsTUFBSyxFQUFFLE1BQU0sR0FBRyxFQUFFLFFBQVEsR0FBRTtBQUFBLElBQUMsRUFBRSxTQUFPLFVBQUssRUFBRSxFQUFFLFNBQU8sS0FBRyxFQUFFLEVBQUUsU0FBTyxHQUFHLFVBQVU7QUFBQSxJQUFHLElBQUksSUFBRSxFQUFFLEVBQUUsRUFBRSxTQUFPLEVBQUU7QUFBQSxJQUFFLElBQUcsTUFBSSxNQUFJLEtBQUcsTUFBSSxFQUFFLGFBQVcsU0FBSSxFQUFFLFNBQU8sV0FBTSxFQUFFLEtBQUssRUFBRSxHQUFFLElBQUUsS0FBSSxJQUFFLEtBQUcsRUFBRSxTQUFPLFdBQU0sRUFBRSxFQUFFLFNBQU8sTUFBSSxLQUFJLE9BQU0sRUFBRSxRQUFNLEVBQUUsS0FBRyxHQUFFO0FBQUEsTUFBQyxNQUFNLElBQUUsSUFBRSxHQUFFLElBQUUsSUFBRSxLQUFLLE9BQU8sRUFBRSxLQUFHLElBQUUsS0FBRyxDQUFDO0FBQUEsTUFBRSxLQUFLLE9BQU8sRUFBRSxLQUFHLEtBQUcsQ0FBQyxJQUFFLEtBQUcsRUFBRSxLQUFLLEVBQUUsR0FBRSxFQUFFLEdBQUUsR0FBRSxDQUFDO0FBQUEsTUFBRTtBQUFBLElBQVE7QUFBQSxJQUFDLElBQUcsSUFBRSxFQUFFLEtBQUcsS0FBRyxJQUFFLEtBQUcsRUFBRSxLQUFHLEdBQUU7QUFBQSxNQUFDLElBQUcsRUFBRSxhQUFXLFNBQUksSUFBRSxHQUFFO0FBQUEsUUFBQyxFQUFFLEdBQUUsR0FBRSxDQUFDO0FBQUEsUUFBRTtBQUFBLE1BQVE7QUFBQSxNQUFDLEVBQUUsS0FBSyxFQUFFO0FBQUEsSUFBQztBQUFBLElBQUMsSUFBRyxJQUFFLEVBQUUsS0FBRyxLQUFHLEVBQUUsYUFBVyxPQUFHO0FBQUEsTUFBQyxFQUFFLEdBQUUsR0FBRSxDQUFDO0FBQUEsTUFBRTtBQUFBLElBQVE7QUFBQSxJQUFDLEVBQUUsRUFBRSxTQUFPLE1BQUk7QUFBQSxFQUFDO0FBQUEsRUFBQyxFQUFFLFNBQU8sVUFBSyxJQUFFLEVBQUUsSUFBSSxPQUFHLEdBQUcsQ0FBQyxDQUFDO0FBQUEsRUFBRyxNQUFNLElBQUUsQ0FBQyxHQUFHLEVBQUUsS0FBSztBQUFBLENBQzV0d0IsQ0FBQztBQUFBLEVBQUUsWUFBVSxHQUFFLE1BQUssRUFBRSxRQUFRLEdBQUU7QUFBQSxJQUFDLElBQUcsS0FBRyxHQUFFLEVBQUUsSUFBSSxDQUFDLEdBQUU7QUFBQSxNQUFDLFFBQU0sUUFBTyxNQUFHLElBQUksT0FBTyxRQUFRLHFCQUFxQixjQUFjLElBQUksRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFDLEVBQUUsS0FBSyxFQUFFLENBQUMsS0FBRyxFQUFDLFFBQU8sQ0FBQyxFQUFDO0FBQUEsTUFBRSxJQUFHLEVBQUUsU0FBWSxXQUFFO0FBQUEsUUFBQyxNQUFNLElBQUUsT0FBTyxXQUFXLEVBQUUsSUFBSTtBQUFBLFFBQUUsSUFBRSxNQUFJLEtBQVEsWUFBRTtBQUFBLE1BQUMsRUFBTTtBQUFBLFVBQUUsUUFBVyxjQUFJLElBQUUsRUFBRSxJQUFJLFdBQVMsSUFBTyxZQUFFLEVBQUU7QUFBQSxJQUFJO0FBQUEsSUFBQyxNQUFNLElBQUUsR0FBRyxNQUFNLElBQUksT0FBTyxDQUFDLENBQUM7QUFBQSxJQUFFLEVBQUUsSUFBRSxPQUFLO0FBQUEsS0FDNVUsTUFBSSxLQUFHLEVBQUUsRUFBRSxJQUFHLEtBQUcsTUFBSSxLQUFHLEVBQUUsQ0FBQyxNQUFJLE1BQUk7QUFBQSxNQUNsQyxLQUFHLE1BQUksS0FBRyxFQUFFLENBQUMsSUFBRyxNQUFJLEtBQUcsRUFBRSxDQUFDO0FBQUEsRUFBRztBQUFBLEVBQUMs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S0FBSyxRQUFNLEtBQUssTUFBTSxLQUFLLElBQUksR0FBRSxLQUFLLFNBQU8sS0FBSyxPQUFPLEtBQUssSUFBSSxHQUFFLEtBQUssVUFBUSxFQUFFLEtBQUssSUFBSSxHQUFFLEtBQUssU0FBTyxHQUFFLEtBQUssZUFBYSxHQUFFLEtBQUssUUFBTSxHQUFFLEtBQUssU0FBTztBQUFBO0FBQUEsRUFBRSxXQUFXLEdBQUU7QUFBQSxJQUFDLEtBQUssYUFBYSxNQUFNO0FBQUE7QUFBQSxFQUFFLGFBQWEsQ0FBQyxHQUFFLEdBQUU7QUFBQSxJQUFDLE1BQU0sSUFBRSxLQUFLLGFBQWEsSUFBSSxDQUFDLEtBQUcsQ0FBQztBQUFBLElBQUUsRUFBRSxLQUFLLENBQUMsR0FBRSxLQUFLLGFBQWEsSUFBSSxHQUFFLENBQUM7QUFBQTtBQUFBLEVBQUUsRUFBRSxDQUFDLEdBQUUsR0FBRTtBQUFBLElBQUMsS0FBSyxjQUFjLEdBQUUsRUFBQyxJQUFHLEVBQUMsQ0FBQztBQUFBO0FBQUEsRUFBRSxJQUFJLENBQUMsR0FBRSxHQUFFO0FBQUEsSUFBQyxLQUFLLGNBQWMsR0FBRSxFQUFDLElBQUcsR0FBRSxNQUFLLEtBQUUsQ0FBQztBQUFBO0FBQUEsRUFBRSxJQUFJLENBQUMsTUFBSyxHQUFFO0FBQUEsSUFBQyxNQUFNLElBQUUsS0FBSyxhQUFhLElBQUksQ0FBQyxLQUFHLENBQUMsR0FBRSxJQUFFLENBQUM7QUFBQSxJQUFFLFdBQVUsS0FBSztBQUFBLE1BQUUsRUFBRSxHQUFHLEdBQUcsQ0FBQyxHQUFFLEVBQUUsUUFBTSxFQUFFLEtBQUssTUFBSSxFQUFFLE9BQU8sRUFBRSxRQUFRLENBQUMsR0FBRSxDQUFDLENBQUM7QUFBQSxJQUFFLFdBQVUsS0FBSztBQUFBLE1BQUUsRUFBRTtBQUFBO0FBQUEsRUFBRSxNQUFNLEdBQUU7QUFBQSxJQUFDLE9BQU8sSUFBSSxRQUFRLENBQUMsR0FBRSxNQUFJO0FBQUEsTUFBQyxJQUFHLEtBQUssY0FBYTtBQUFBLFFBQUMsSUFBRyxLQUFLLGFBQWE7QUFBQSxVQUFRLE9BQU8sS0FBSyxRQUFNLFVBQVMsS0FBSyxNQUFNLEdBQUUsRUFBRSxDQUFDO0FBQUEsUUFBRSxLQUFLLGFBQWEsaUJBQWlCLFNBQVEsTUFBSTtBQUFBLFVBQUMsS0FBSyxRQUFNLFVBQVMsS0FBSyxNQUFNO0FBQUEsV0FBRyxFQUFDLE1BQUssS0FBRSxDQUFDO0FBQUEsTUFBQztBQUFBLE1BQUMsTUFBTSxJQUFFLElBQUk7QUFBQSxNQUFFLEVBQUUsU0FBTyxDQUFDLEdBQUUsR0FBRSxNQUFJO0FBQUEsUUFBQyxLQUFLLFdBQVMsS0FBSyxRQUFNLEtBQUssSUFBSSxLQUFLLFFBQVEsT0FBTSxFQUFFLEdBQUUsS0FBSyxVQUFRLEtBQUssSUFBSSxVQUFRLEdBQUUsS0FBSyxLQUFLLFNBQVEsS0FBSyxLQUFLLElBQUcsRUFBRTtBQUFBLFNBQUcsS0FBSyxNQUFNLEtBQUssQ0FBQyxHQUFFLEtBQUssS0FBRyxFQUFFLGdCQUFnQixFQUFDLE9BQU0sS0FBSyxPQUFNLFFBQU8sR0FBRSxTQUFRLEdBQUUsUUFBTyxJQUFHLG1CQUFrQixJQUFHLFVBQVMsS0FBRSxDQUFDLEdBQUUsRUFBRSxtQkFBbUIsS0FBSyxPQUFNLEtBQUssRUFBRSxHQUFFLEtBQUssR0FBRyxPQUFPLEdBQUUsS0FBSyxLQUFLLGlCQUFvQixhQUFHLEtBQUssVUFBUSxLQUFLLEdBQUcsTUFBTSxLQUFLLEtBQUssWUFBWSxHQUFFLEtBQUssTUFBTSxHQUFHLFlBQVcsS0FBSyxVQUFVLEdBQUUsRUFBRSxLQUFLLE9BQU0sSUFBRSxHQUFFLEtBQUssT0FBTyxHQUFHLFVBQVMsS0FBSyxNQUFNLEdBQUUsS0FBSyxPQUFPLEdBQUUsS0FBSyxLQUFLLFVBQVMsTUFBSTtBQUFBLFFBQUMsS0FBSyxPQUFPLE1BQU0seUJBQUUsSUFBSSxHQUFFLEtBQUssT0FBTyxJQUFJLFVBQVMsS0FBSyxNQUFNLEdBQUUsRUFBRSxLQUFLLE9BQU0sS0FBRSxHQUFFLEVBQUUsS0FBSyxLQUFLO0FBQUEsT0FBRSxHQUFFLEtBQUssS0FBSyxVQUFTLE1BQUk7QUFBQSxRQUFDLEtBQUssT0FBTyxNQUFNLHlCQUFFLElBQUksR0FBRSxLQUFLLE9BQU8sSUFBSSxVQUFTLEtBQUssTUFBTSxHQUFFLEVBQUUsS0FBSyxPQUFNLEtBQUUsR0FBRSxFQUFFLENBQUM7QUFBQSxPQUFFO0FBQUEsS0FBRTtBQUFBO0FBQUEsRUFBRSxVQUFVLENBQUMsR0FBRSxHQUFFO0FBQUEsSUFBQyxJQUFHLEtBQUssVUFBUSxZQUFVLEtBQUssUUFBTSxXQUFVLEdBQUcsU0FBTyxDQUFDLEtBQUssVUFBUSxFQUFFLFFBQVEsSUFBSSxFQUFFLElBQUksS0FBRyxLQUFLLEtBQUssVUFBUyxFQUFFLFFBQVEsSUFBSSxFQUFFLElBQUksQ0FBQyxHQUFFLEVBQUUsUUFBUSxJQUFJLEVBQUUsSUFBSSxLQUFHLEtBQUssS0FBSyxVQUFTLEVBQUUsSUFBSSxJQUFHLE1BQUksRUFBRSxZQUFZLE1BQUksT0FBSyxFQUFFLFlBQVksTUFBSSxRQUFNLEtBQUssS0FBSyxXQUFVLEVBQUUsWUFBWSxNQUFJLEdBQUcsR0FBRSxNQUFJLFFBQUssS0FBSyxLQUFLLGdCQUFjLEtBQUssVUFBUSxLQUFLLElBQUksTUFBTSxLQUFLLEtBQUssV0FBVyxHQUFFLEtBQUssS0FBSyxTQUFRLEtBQUssS0FBSyxXQUFXLEtBQUksS0FBRyxLQUFLLEtBQUssT0FBTSxFQUFFLFlBQVksQ0FBQyxHQUFFLEdBQUcsU0FBTyxVQUFTO0FBQUEsTUFBQyxJQUFHLEtBQUssS0FBSyxVQUFTO0FBQUEsUUFBQyxNQUFNLElBQUUsS0FBSyxLQUFLLFNBQVMsS0FBSyxLQUFLO0FBQUEsUUFBRSxNQUFJLEtBQUssUUFBTSxhQUFhLFFBQU0sRUFBRSxVQUFRLEdBQUUsS0FBSyxRQUFNLFNBQVEsS0FBSyxJQUFJLE1BQU0sS0FBSyxLQUFLO0FBQUEsTUFBRTtBQUFBLE1BQUMsS0FBSyxVQUFRLFlBQVUsS0FBSyxRQUFNO0FBQUEsSUFBUztBQUFBLElBQUMsRUFBRSxDQUFDLEdBQUUsR0FBRyxNQUFLLEdBQUcsUUFBUSxHQUFFLFFBQVEsTUFBSSxLQUFLLFFB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QUEsSUFBTyxLQUFHLFFBQVEsT0FBTyxNQUFNO0FBQUEsQ0FDcjVCO0FBQUEsSUFBRSxNQUFNLEtBQUUsR0FBRSxNQUFNO0FBQUEsQ0FDbEI7QUFBQSxJQUFFLFFBQVEsT0FBTyxNQUFNLDBCQUFHLEtBQUssTUFBSyxHQUFFLFNBQU8sQ0FBQyxDQUFDLEdBQUUsUUFBUSxPQUFPLE1BQU0seUJBQUcsS0FBSyxHQUFFLE1BQU0sQ0FBQztBQUFBLEtBQUcsS0FBRSxRQUFHLEdBQUUsUUFBUSxRQUFPLEVBQUUsR0FBRSxLQUFFLFFBQUc7QUFBQSxJQUFDLE1BQU0sTUFBRyxZQUFZLElBQUksSUFBRSxNQUFHLE1BQUksS0FBRSxLQUFLLE1BQU0sS0FBRSxFQUFFLEdBQUUsS0FBRSxLQUFLLE1BQU0sS0FBRSxFQUFFO0FBQUEsSUFBRSxPQUFPLEtBQUUsSUFBRSxJQUFJLE9BQU0sU0FBTSxJQUFJO0FBQUEsS0FBTyxJQUFFLENBQUMsS0FBRSxPQUFLO0FBQUEsSUFBQyxJQUFFLE1BQUcsSUFBRSxHQUFHLEdBQUUsS0FBRSxHQUFFLEVBQUMsR0FBRSxLQUFFLFlBQVksSUFBSSxHQUFFLFFBQVEsT0FBTyxNQUFNLEdBQUcsMEJBQUUsS0FBSyxDQUFDO0FBQUEsQ0FDMVQ7QUFBQSxJQUFFLElBQUksS0FBRSxHQUFFLEtBQUU7QUFBQSxJQUFFLEdBQUUsR0FBRSxJQUFFLFlBQVksTUFBSTtBQUFBLE1BQUMsSUFBRyxLQUFHLE9BQUk7QUFBQSxRQUFFO0FBQUEsTUFBTyxHQUFFLEdBQUUsS0FBRTtBQUFBLE1BQUUsTUFBTSxLQUFFLDBCQUFFLFFBQVEsRUFBRSxHQUFFO0FBQUEsTUFBRSxJQUFHO0FBQUEsUUFBRSxRQUFRLE9BQU8sTUFBTSxHQUFHLE9BQU0sT0FBTTtBQUFBLE1BQU8sU0FBRyxNQUFJO0FBQUEsUUFBUSxRQUFRLE9BQU8sTUFBTSxHQUFHLE9BQU0sTUFBSyxHQUFFLEVBQUMsR0FBRztBQUFBLE1BQU07QUFBQSxRQUFDLE1BQU0sS0FBRSxJQUFJLE9BQU8sS0FBSyxNQUFNLEVBQUMsQ0FBQyxFQUFF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QVEsUUFBUSxVQUFVLEtBQUssU0FBUyxNQUFNO0FBQUEsTUFDMUMsS0FBSztBQUFBLFNBQ0Y7QUFBQSxNQUNILFNBQVM7QUFBQSxRQUNMLGdCQUFnQjtBQUFBLFdBQ2IsUUFBUTtBQUFBLE1BQ2Y7QUFBQSxJQUNKLENBQUM7QUFBQTtBQUFBLEVBS0wsUUFBUSxDQUFDLFNBQVM7QUFBQSxJQUNkLFFBQVEsUUFBUSxVQUFVLEtBQUssU0FBUyxJQUFJO0FBQUEsTUFDeEMsS0FBSztBQUFBLFNBQ0Y7QUFBQSxJQUNQLENBQUM7QUFBQTtBQUFBLEVBS0wsSUFBSSxDQUFDLFNBQVM7QUFBQSxJQUNWLFFBQVEsUUFBUSxVQUFVLEtBQUssU0FBUyxJQUFJO0FBQUEsTUFDeEMsS0FBSztBQUFBLFNBQ0Y7QUFBQSxJQUNQLENBQUM7QUFBQTtBQUFBLEVBS0wsSUFBSSxDQUFDLFNBQVM7QUFBQSxJQUNWLFFBQVEsUUFBUSxVQUFVLEtBQUssU0FBUyxLQUFLO0FBQUEsTUFDekMsS0FBSztBQUFBLFNBQ0Y7QUFBQSxNQUNILFNBQVM7QUFBQSxRQUNMLGdCQUFnQjtBQUFBLFdBQ2IsUUFBUTtBQUFBLE1BQ2Y7QUFBQSxJQUNKLENBQUM7QUFBQTtBQUFBLEVBS0wsSUFBSSxDQUFDLFNBQVM7QUFBQSxJQUNWLFFBQVEsUUFBUSxVQUFVLEtBQUssU0FBUyxLQUFLO0FBQUEsTUFDekMsS0FBSztBQUFBLFNBQ0Y7QUFBQSxNQUNILFNBQVM7QUFBQSxRQUNMLGdCQUFnQjtBQUFBLFdBQ2IsUUFBUTtBQUFBLE1BQ2Y7QUFBQSxJQUNKLENBQUM7QUFBQTtBQUFBLEVBS0wsS0FBSyxDQUFDLFNBQVM7QUFBQSxJQUNYLFFBQVEsUUFBUSxVQUFVLEtBQUssU0FBUyxLQUFLO0FBQUEsTUFDekMsS0FBSztBQUFBLFNBQ0Y7QUFBQSxJQUNQLENBQUM7QUFBQTtBQUFBLEVBS0wsT0FBTyxDQUFDLFNBQVM7QUFBQSxJQUNiLFFBQVEsUUFBUSxVQUFVLEtBQUssU0FBUyxPQUFPO0FBQUEsTUFDM0MsS0FBSztBQUFBLFNBQ0Y7QUFBQSxJQUNQLENBQUM7QUFBQTtBQUFBLEVBS0wsS0FBSyxDQUFDLFNBQVM7QUFBQSxJQUNYLFFBQVEsUUFBUSxVQUFVLEtBQUssU0FBUyxLQUFLO0FBQUEsTUFDekMsS0FBSztBQUFBLFNBQ0Y7QUFBQSxJQUNQLENBQUM7QUFBQTtBQUFBLEVBS0wsSUFBSSxDQUFDLFNBQVM7QUFBQSxJQUNWLFFBQVEsUUFBUSxVQUFVLEtBQUssU0FBUyxJQUFJO0FBQUEsTUFDeEMsS0FBSztBQUFBLFNBQ0Y7QUFBQSxJQUNQLENBQUM7QUFBQTtBQUFBLEVBS0wsU0FBUyxDQUFDLFNBQVM7QUFBQSxJQUNmLFFBQVEsUUFBUSxVQUFVLEtBQUssU0FBUyxLQUFLO0FBQUEsTUFDekMsS0FBSztBQUFBLFNBQ0Y7QUFBQSxNQUNILFNBQVM7QUFBQSxRQUNMLGdCQUFnQjtBQUFBLFdBQ2IsUUFBUTtBQUFBLE1BQ2Y7QUFBQSxJQUNKLENBQUM7QUFBQTtBQUFBLEVBS0wsUUFBUSxDQUFDLFNBQVM7QUFBQSxJQUNkLFFBQVEsUUFBUSxVQUFVLEtBQUssU0FBUyxJQUFJO0FBQUEsTUFDeEMsS0FBSztBQUFBLFNBQ0Y7QUFBQSxJQUNQLENBQUM7QUFBQTtBQUFBLEVBS0wsTUFBTSxDQUFDLFNBQVM7QUFBQSxJQUNaLFFBQVEsUUFBUSxVQUFVLEtBQUssU0FBUyxLQUFLO0FBQUEsTUFDekMsS0FBSztBQUFBLFNBQ0Y7QUFBQSxNQUNILFNBQVM7QUFBQSxRQUNMLGdCQUFnQjtBQUFBLFdBQ2IsUUFBUTtBQUFBLE1BQ2Y7QUFBQSxJQUNKLENBQUM7QUFBQTtBQUFBLEVBS0wsT0FBTyxDQUFDLFNBQVM7QUFBQSxJQUNiLFFBQVEsUUFBUSxVQUFVLEtBQUssU0FBUyxJQUFJO0FBQUEsTUFDeEMsS0FBSztBQUFBLFNBQ0Y7QUFBQSxJQUNQLENBQUM7QUFBQTtBQUFBLEVBS0wsV0FBVyxDQUFDLFNBQVM7QUFBQSxJQUNqQixRQUFRLFFBQVEsVUFBVSxLQUFLLFNBQVMsS0FBSztBQUFBLE1BQ3pDLEtBQUs7QUFBQSxTQUNGO0FBQUEsTUFDSCxTQUFTO0FBQUEsUUFDTCxnQkFBZ0I7QUFBQSxXQUNiLFFBQVE7QUFBQSxNQUNmO0FBQUEsSUFDSixDQUFDO0FBQUE7QUFBQSxFQUtMLE9BQU8sQ0FBQyxTQUFTO0FBQUEsSUFDYixRQUFRLFFBQVEsVUFBVSxLQUFLLFNBQVMsS0FBSztBQUFBLE1BQ3pDLEtBQUs7QUFBQSxTQUNGO0FBQUEsTUFDSCxTQUFTO0FBQUEsUUFDTCxnQkFBZ0I7QUFBQSxXQUNiLFFBQVE7QUFBQSxNQUNmO0FBQUEsSUFDSixDQUFDO0FBQUE7QUFBQSxFQUtMLEtBQUssQ0FBQyxTQUFTO0FBQUEsSUFDWCxRQUFRLFFBQVEsVUFBVSxLQUFLLFNBQVMsS0FBSztBQUFBLE1BQ3pDLEtBQUs7QUFBQSxTQUNGO0FBQUEsTUFDSCxTQUFTO0FBQUEsUUFDTCxnQkFBZ0I7QUFBQSxXQUNiLFFBQVE7QUFBQSxNQUNmO0FBQUEsSUFDSixDQUFDO0FBQUE7QUFBQSxFQUtMLE1BQU0sQ0FBQyxTQUFTO0FBQUEsSUFDWixRQUFRLFFBQVEsVUFBVSxLQUFLLFNBQVMsS0FBSztBQUFBLE1BQ3pDLEtBQUs7QUFBQSxTQUNGO0FBQUEsTUFDSCxTQUFTO0FBQUEsUUFDTCxnQkFBZ0I7QUFBQSxXQUNiLFFBQVE7QUFBQSxNQUNmO0FBQUEsSUFDSixDQUFDO0FBQUE7QUFBQSxFQUtMLFFBQVEsQ0FBQyxTQUFTO0FBQUEsSUFDZCxRQUFRLFFBQVEsVUFBVSxLQUFLLFNBQVMsS0FBSztBQUFBLE1BQ3pDLEtBQUs7QUFBQSxTQUNGO0FBQUEsSUFDUCxDQUFDO0FBQUE7QUFFVDtBQUFBO0FBQ0EsTUFBTSxnQkFBZ0IsY0FBYztBQUFBLEVBSWhDLElBQUksQ0FBQyxTQUFTO0FBQUEsSUFDVixRQUFRLFNBQVMsVUFBVSxLQUFLLFNBQVMsSUFBSTtBQUFBLE1BQ3pDLEtBQUs7QUFBQSxTQUNGO0FBQUEsSUFDUCxDQUFDO0FBQUE7QUFFVDtBQUFBO0FBQ0EsTUFBTSxjQUFjLGNBQWM7QUFBQSxFQUk5QixTQUFTLENBQUMsU0FBUztBQUFBLElBQ2YsUUFBUSxRQUFRLFVBQVUsS0FBSyxTQUFTLEtBQUs7QUFBQSxNQUN6QyxLQUFLO0FBQUEsU0FDRjtBQUFBLE1BQ0gsU0FBUztBQUFBLFFBQ0wsZ0JBQWdCO0FBQUEsV0FDYixRQUFRO0FBQUEsTUFDZjtBQUFBLElBQ0osQ0FBQztBQUFBO0FBQUEsRUFLTCxRQUFRLENBQUMsU0FBUztBQUFBLElBQ2QsUUFBUSxRQUFRLFVBQVUsS0FBSyxTQUFTLEtBQUs7QUFBQSxNQUN6QyxLQUFLO0FBQUEsU0FDRjtBQUFBLE1BQ0gsU0FBUztBQUFBLFFBQ0wsZ0JBQWdCO0FBQUEsV0FDYixRQUFRO0FBQUEsTUFDZjtBQUFBLElBQ0osQ0FBQztBQUFBO0FBRVQ7QUFBQTtBQUNBLE1BQU0saUJBQWlCLGNBQWM7QUFBQSxFQUlqQyxJQUFJLENBQUMsU0FBUztBQUFBLElBQ1YsUUFBUSxTQUFTLFVBQVUsS0FBSyxTQUFTLElBQUk7QUFBQSxNQUN6QyxLQUFLO0FBQUEsU0FDRjtBQUFBLElBQ1AsQ0FBQztBQUFBO0FBQUEsRUFLTCxJQUFJLENBQUMsU0FBUztBQUFBLElBQ1YsUUFBUSxTQUFTLFVBQVUsS0FBSyxTQUFTLElBQUk7QUFBQSxNQUN6QyxLQUFLO0FBQUEsU0FDRjtBQUFBLElBQ1AsQ0FBQztBQUFBO0FBQUEsRUFFTCxRQUFRLElBQUksTUFBTSxFQUFFLFFBQVEsS0FBSyxRQUFRLENBQUM7QUFDOUM7QUFBQTtBQUNBLE1BQU0sYUFBYSxjQUFjO0FBQUEsRUFJN0IsSUFBSSxDQUFDLFNBQVM7QUFBQSxJQUNWLFFBQVEsUUFBUSxVQUFVLEtBQUssU0FBUyxJQUFJO0FBQUEsTUFDeEMsS0FBSztBQUFBLFNBQ0Y7QUFBQSxJQUNQLENBQUM7QUFBQTtBQUFBLEVBS0wsS0FBSyxDQUFDLFNBQVM7QUFBQSxJQUNYLFFBQVEsUUFBUSxVQUFVLEtBQUssU0FBUyxJQUFJO0FBQUEsTUFDeEMsS0FBSztBQUFBLFNBQ0Y7QUFBQSxJQUNQLENBQUM7QUFBQTtBQUFBLEVBS0wsT0FBTyxDQUFDLFNBQVM7QUFBQSxJQUNiLFFBQVEsUUFBUSxVQUFVLEtBQUssU0FBUyxJQUFJO0FBQUEsTUFDeEMsS0FBSztBQUFBLFNBQ0Y7QUFBQSxJQUNQLENBQUM7QUFBQTtBQUVUO0FBQUE7QUFDQSxNQUFNLGFBQWEsY0FBYztBQUFBLEVBSTdCLElBQUksQ0FBQyxTQUFTO0FBQUEsSUFDVixRQUFRLFFBQVEsVUFBVSxLQUFLLFNBQVMsSUFBSTtBQUFBLE1BQ3hDLEtBQUs7QUFBQSxTQUNGO0FBQUEsSUFDUCxDQUFDO0FBQUE7QUFBQSxFQUtMLElBQUksQ0FBQyxTQUFTO0FBQUEsSUFDVixRQUFRLFFBQVEsVUFBVSxLQUFLLFNBQVMsSUFBSTtBQUFBLE1BQ3hDLEtBQUs7QUFBQSxTQUNGO0FBQUEsSUFDUCxDQUFDO0FBQUE7QUFBQSxFQUtMLE1BQU0sQ0FBQyxTQUFTO0FBQUEsSUFDWixRQUFRLFNBQVMsVUFBVSxLQUFLLFNBQVMsSUFBSTtBQUFBLE1BQ3pDLEtBQUs7QUFBQSxTQUNGO0FBQUEsSUFDUCxDQUFDO0FBQUE7QUFFVDtBQUFBO0FBQ0EsTUFBTSxZQUFZLGNBQWM7QUFBQSxFQUk1QixHQUFHLENBQUMsU0FBUztBQUFBLElBQ1QsUUFBUSxTQUFTLFVBQVUsS0FBSyxTQUFTLEtBQUs7QUFBQSxNQUMxQyxLQUFLO0FBQUEsU0FDRjtBQUFBLE1BQ0gsU0FBUztBQUFBLFFBQ0wsZ0JBQWdCO0FBQUEsV0FDYixTQUFTO0FBQUEsTUFDaEI7QUFBQSxJQUNKLENBQUM7QUFBQTtBQUFBLEVBS0wsTUFBTSxDQUFDLFNBQVM7QUFBQSxJQUNaLFFBQVEsU0FBUyxVQUFVLEtBQUssU0FBUyxJQUFJO0FBQUEsTUFDekMsS0FBSztBQUFBLFNBQ0Y7QUFBQSxJQUNQLENBQUM7QUFBQTtBQUVUO0FBQUE7QUFDQSxNQUFNLGFBQWEsY0FBYztBQUFBLEVBSTdCLE1BQU0sQ0FBQyxTQUFTO0FBQUEsSUFDWixRQUFRLFFBQVEsVUFBVSxLQUFLLFNBQVMsT0FBTztBQUFBLE1BQzNDLEtBQUs7QUFBQSxTQUNGO0FBQUEsSUFDUCxDQUFDO0FBQUE7QUFBQSxFQUtMLEtBQUssQ0FBQyxTQUFTO0FBQUEsSUFDWCxRQUFRLFFBQVEsVUFBVSxLQUFLLFNBQVMsS0FBSztBQUFBLE1BQ3pDLEtBQUs7QUFBQSxTQUNGO0FBQUEsSUFDUCxDQUFDO0FBQUE7QUFBQSxFQUtMLFFBQVEsQ0FBQyxTQUFTO0FBQUEsSUFDZCxRQUFRLFFBQVEsVUFBVSxLQUFLLFNBQVMsS0FBSztBQUFBLE1BQ3pDLEtBQUs7QUFBQSxTQUNGO0FBQUEsTUFDSCxTQUFTO0FBQUEsUUFDTCxnQkFBZ0I7QUFBQSxXQUNiLFFBQVE7QUFBQSxNQUNmO0FBQUEsSUFDSixDQUFDO0FBQUE7QUFBQSxFQUtMLFlBQVksQ0FBQyxTQUFTO0FBQUEsSUFDbEIsUUFBUSxRQUFRLFVBQVUsS0FBSyxTQUFTLEtBQUs7QUFBQSxNQUN6QyxLQUFLO0FBQUEsU0FDRjtBQUFBLElBQ1AsQ0FBQztBQUFBO0FBQUEsRUFLTCxHQUFHLENBQUMsU0FBUztBQUFBLElBQ1QsUUFBUSxRQUFRLFVBQVUsS0FBSyxTQUFTLElBQUk7QUFBQSxNQUN4QyxLQUFLO0FBQUEsU0FDRjtBQUFBLE1BQ0gsU0FBUztBQUFBLFFBQ0wsZ0JBQWdCO0FBQUEsV0FDYixRQUFRO0FBQUEsTUFDZjtBQUFBLElBQ0osQ0FBQztBQUFBO0FBRVQ7QUFBQTtBQUNBLE1BQU0sWUFBWSxjQUFjO0FBQUEsRUFJNUIsTUFBTSxDQUFDLFNBQVM7QUFBQSxJQUNaLFFBQVEsU0FBUyxVQUFVLEtBQUssU0FBUyxJQUFJO0FBQUEsTUFDekMsS0FBSztBQUFBLFNBQ0Y7QUFBQSxJQUNQLENBQUM7QUFBQTtBQUFBLEVBS0wsR0FBRyxDQUFDLFNBQVM7QUFBQSxJQUNULFFBQVEsU0FBUyxVQUFVLEtBQUssU0FBUyxLQUFLO0FBQUEsTUFDMUMsS0FBSztBQUFBLFNBQ0Y7QUFBQSxNQUNILFNBQVM7QUFBQSxRQUNMLGdCQUFnQjtBQUFBLFdBQ2IsU0FBUztBQUFBLE1BQ2hCO0FBQUEsSUFDSixDQUFDO0FBQUE7QUFBQSxFQUtMLE9BQU8sQ0FBQyxTQUFTO0FBQUEsSUFDYixRQUFRLFFBQVEsVUFBVSxLQUFLLFNBQVMsS0FBSztBQUFBLE1BQ3pDLEtBQUs7QUFBQSxTQUNGO0FBQUEsSUFDUCxDQUFDO0FBQUE7QUFBQSxFQUtMLFVBQVUsQ0FBQyxTQUFTO0FBQUEsSUFDaEIsUUFBUSxRQUFRLFVBQVUsS0FBSyxTQUFTLEtBQUs7QUFBQSxNQUN6QyxLQUFLO0FBQUEsU0FDRjtBQUFBLElBQ1AsQ0FBQztBQUFBO0FBQUEsRUFFTCxPQUFPLElBQUksS0FBSyxFQUFFLFFBQVEsS0FBSyxRQUFRLENBQUM7QUFDNUM7QUFBQTtBQUNBLE1BQU0sWUFBWSxjQUFjO0FBQUEsRUFJNUIsTUFBTSxDQUFDLFNBQVM7QUFBQSxJQUNaLFFBQVEsU0FBUyxVQUFVLEtBQUssU0FBUyxJQUFJO0FBQUEsTUFDekMsS0FBSztBQUFBLFNBQ0Y7QUFBQSxJQUNQLENBQUM7QUFBQTtBQUVUO0FBQUE7QUFDQSxNQUFNLGtCQUFrQixjQUFjO0FBQUEsRUFJbEMsTUFBTSxDQUFDLFNBQVM7QUFBQSxJQUNaLFFBQVEsU0FBUyxVQUFVLEtBQUssU0FBUyxJQUFJO0FBQUEsTUFDekMsS0FBSztBQUFBLFNBQ0Y7QUFBQSxJQUNQLENBQUM7QUFBQTtBQUVUO0FBQUE7QUFDQSxNQUFNLGdCQUFnQixjQUFjO0FBQUEsRUFJaEMsSUFBSSxDQUFDLFNBQVM7QUFBQSxJQUNWLFFBQVEsU0FBUyxVQUFVLEtBQUssU0FBUyxJQUFJO0FBQUEsTUFDekMsS0FBSztBQUFBLFNBQ0Y7QUFBQSxJQUNQLENBQUM7QUFBQTtBQUFBLEVBS0wsUUFBUSxDQUFDLFNBQVM7QUFBQSxJQUNkLFFBQVEsU0FBUyxVQUFVLEtBQUssU0FBUyxLQUFLO0FBQUEsTUFDMUMsS0FBSztBQUFBLFNBQ0Y7QUFBQSxNQUNILFNBQVM7QUFBQSxRQUNMLGdCQUFnQjtBQUFBLFdBQ2IsU0FBUztBQUFBLE1BQ2hCO0FBQUEsSUFDSixDQUFDO0FBQUE7QUFFVDtBQUFBO0FBQ0EsTUFBTSxZQUFZLGNBQWM7QUFBQSxFQUk1QixZQUFZLENBQUMsU0FBUztBQUFBLElBQ2xCLFFBQVEsU0FBUyxVQUFVLEtBQUssU0FBUyxLQUFLO0FBQUEsTUFDMUMsS0FBSztBQUFBLFNBQ0Y7QUFBQSxNQUNILFNBQVM7QUFBQSxRQUNMLGdCQUFnQjtBQUFBLFdBQ2IsU0FBUztBQUFBLE1BQ2hCO0FBQUEsSUFDSixDQUFDO0FBQUE7QUFBQSxFQUtMLFFBQVEsQ0FBQyxTQUFTO0FBQUEsSUFDZCxRQUFRLFNBQVMsVUFBVSxLQUFLLFNBQVMsS0FBSztBQUFBLE1BQzFDLEtBQUs7QUFBQSxTQUNGO0FBQUEsSUFDUCxDQUFDO0FBQUE7QUFBQSxFQUtMLFlBQVksQ0FBQyxTQUFTO0FBQUEsSUFDbEIsUUFBUSxTQUFTLFVBQVUsS0FBSyxTQUFTLEtBQUs7QUFBQSxNQUMxQyxLQUFLO0FBQUEsU0FDRjtBQUFBLElBQ1AsQ0FBQztBQUFBO0FBQUEsRUFLTCxVQUFVLENBQUMsU0FBUztBQUFBLElBQ2hCLFFBQVEsU0FBUyxVQUFVLEtBQUssU0FBUyxLQUFLO0FBQUEsTUFDMUMsS0FBSztBQUFBLFNBQ0Y7QUFBQSxJQUNQLENBQUM7QUFBQTtBQUFBLEVBS0wsVUFBVSxDQUFDLFNBQVM7QUFBQSxJQUNoQixRQUFRLFNBQVMsVUFBVSxLQUFLLFNBQVMsS0FBSztBQUFBLE1BQzFDLEtBQUs7QUFBQSxTQUNGO0FBQUEsSUFDUCxDQUFDO0FBQUE7QUFBQSxFQUtMLFlBQVksQ0FBQyxTQUFTO0FBQUEsSUFDbEIsUUFBUSxTQUFTLFVBQVUsS0FBSyxTQUFTLEtBQUs7QUFBQSxNQUMxQyxLQUFLO0FBQUEsU0FDRjtBQUFBLElBQ1AsQ0FBQztBQUFBO0FBQUEsRUFLTCxXQUFXLENBQUMsU0FBUztBQUFBLElBQ2pCLFFBQVEsU0FBUyxVQUFVLEtBQUssU0FBUyxLQUFLO0FBQUEsTUFDMUMsS0FBSztBQUFBLFNBQ0Y7QUFBQSxJQUNQLENBQUM7QUFBQTtBQUFBLEVBS0wsY0FBYyxDQUFDLFNBQVM7QUFBQSxJQUNwQixRQUFRLFNBQVMsVUFBVSxLQUFLLFNBQVMsS0FBSztBQUFBLE1BQzFDLEtBQUs7QUFBQSxTQUNGO0FBQUEsTUFDSCxTQUFTO0FBQUEsUUFDTCxnQkFBZ0I7QUFBQSxXQUNiLFNBQVM7QUFBQSxNQUNoQjtBQUFBLElBQ0osQ0FBQztBQUFBO0FBQUEsRUFLTCxTQUFTLENBQUMsU0FBUztBQUFBLElBQ2YsUUFBUSxTQUFTLFVBQVUsS0FBSyxTQUFTLEtBQUs7QUFBQSxNQUMxQyxLQUFLO0FBQUEsU0FDRjtBQUFBLE1BQ0gsU0FBUztBQUFBLFFBQ0wsZ0JBQWdCO0FBQUEsV0FDYixTQUFTO0FBQUEsTUFDaEI7QUFBQSxJQUNKLENBQUM7QUFBQTtBQUFBLEVBS0wsT0FBTyxDQUFDLFNBQVM7QUFBQSxJQUNiLFFBQVEsU0FBUyxVQUFVLEtBQUssU0FBUyxLQUFLO0FBQUEsTUFDMUMsS0FBSztBQUFBLFNBQ0Y7QUFBQSxNQUNILFNBQVM7QUFBQSxRQUNMLGdCQUFnQjtBQUFBLFdBQ2IsU0FBUztBQUFBLE1BQ2hCO0FBQUEsSUFDSixDQUFDO0FBQUE7QUFBQSxFQUVMLFVBQVUsSUFBSSxRQUFRLEVBQUUsUUFBUSxLQUFLLFFBQVEsQ0FBQztBQUNsRDtBQUFBO0FBQ0EsTUFBTSxjQUFjLGNBQWM7QUFBQSxFQUk5QixTQUFTLENBQUMsU0FBUztBQUFBLElBQ2YsUUFBUSxTQUFTLFVBQVUsS0FBSyxTQUFTLElBQUksSUFBSTtBQUFBLE1BQzdDLEtBQUs7QUFBQSxTQUNGO0FBQUEsSUFDUCxDQUFDO0FBQUE7QUFFVDtBQUFBO0FBQ08sTUFBTSx1QkFBdUIsY0FBYztBQUFBLEVBSTlDLG9DQUFvQyxDQUFDLFNBQVM7QUFBQSxJQUMxQyxRQUFRLFFBQVEsVUFBVSxLQUFLLFNBQVMsS0FBSztBQUFBLE1BQ3pDLEtBQUs7QUFBQSxTQUNGO0FBQUEsTUFDSCxTQUFTO0FBQUEsUUFDTCxnQkFBZ0I7QUFBQSxXQUNiLFFBQVE7QUFBQSxNQUNmO0FBQUEsSUFDSixDQUFDO0FBQUE7QUFBQSxFQUVMLFNBQVMsSUFBSSxPQUFPLEVBQUUsUUFBUSxLQUFLLFFBQVEsQ0FBQztBQUFBLEVBQzVDLFVBQVUsSUFBSSxRQUFRLEVBQUUsUUFBUSxLQUFLLFFBQVEsQ0FBQztBQUFBLEVBQzlDLE1BQU0sSUFBSSxJQUFJLEVBQUUsUUFBUSxLQUFLLFFBQVEsQ0FBQztBQUFBLEVBQ3RDLFNBQVMsSUFBSSxPQUFPLEVBQUUsUUFBUSxLQUFLLFFBQVEsQ0FBQztBQUFBLEVBQzVDLE9BQU8sSUFBSSxLQUFLLEVBQUUsUUFBUSxLQUFLLFFBQVEsQ0FBQztBQUFBLEVBQ3hDLFdBQVcsSUFBSSxTQUFTLEVBQUUsUUFBUSxLQUFLLFFBQVEsQ0FBQztBQUFBLEVBQ2hELE9BQU8sSUFBSSxLQUFLLEVBQUUsUUFBUSxLQUFLLFFBQVEsQ0FBQztBQUFBLEVBQ3hDLE1BQU0sSUFBSSxJQUFJLEVBQUUsUUFBUSxLQUFLLFFBQVEsQ0FBQztBQUFBLEVBQ3RDLFVBQVUsSUFBSSxRQUFRLEVBQUUsUUFBUSxLQUFLLFFBQVEsQ0FBQztBQUFBLEVBQzlDLFVBQVUsSUFBSSxRQUFRLEVBQUUsUUFBUSxLQUFLLFFBQVEsQ0FBQztBQUFBLEVBQzlDLFdBQVcsSUFBSSxTQUFTLEVBQUUsUUFBUSxLQUFLLFFBQVEsQ0FBQztBQUFBLEVBQ2hELE9BQU8sSUFBSSxLQUFLLEVBQUUsUUFBUSxLQUFLLFFBQVEsQ0FBQztBQUFBLEVBQ3hDLE9BQU8sSUFBSSxLQUFLLEVBQUUsUUFBUSxLQUFLLFFBQVEsQ0FBQztBQUFBLEVBQ3hDLE1BQU0sSUFBSSxJQUFJLEVBQUUsUUFBUSxLQUFLLFFBQVEsQ0FBQztBQUFBLEVBQ3RDLE1BQU0sSUFBSSxJQUFJLEVBQUUsUUFBUSxLQUFLLFFBQVEsQ0FBQztBQUFBLEVBQ3RDLE1BQU0sSUFBSSxJQUFJLEVBQUUsUUFBUSxLQUFLLFFBQVEsQ0FBQztBQUFBLEVBQ3RDLFlBQVksSUFBSSxVQUFVLEVBQUUsUUFBUSxLQUFLLFFBQVEsQ0FBQztBQUFBLEVBQ2xELE1BQU0sSUFBSSxJQUFJLEVBQUUsUUFBUSxLQUFLLFFBQVEsQ0FBQztBQUFBLEVBQ3RDLE9BQU8sSUFBSSxLQUFLLEVBQUUsUUFBUSxLQUFLLFFBQVEsQ0FBQztBQUFBLEVBQ3hDLFFBQVEsSUFBSSxNQUFNLEVBQUUsUUFB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Q0FBQyxXQUFXLGFBQWEsYUFBYSxZQUFZLGVBQWU7QUFDOUU7QUFLQSxJQUFNLGtCQUE0QztBQUFBLEVBQzlDLFVBQVU7QUFBQSxJQUNOO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsRUFDSjtBQUFBLEVBQ0EsVUFBVTtBQUFBLElBQ047QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLEVBQ0o7QUFBQSxFQUNBLFNBQVM7QUFBQSxJQUNMO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsRUFDSjtBQUFBLEVBQ0EsVUFBVTtBQUFBLElBQ047QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsRUFDSjtBQUFBLEVBQ0EsUUFBUTtBQUFBLElBQ0o7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtB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QVUsSUFDakM7QUFBQSxJQUNOLFdBQVcsT0FBTztBQUFBLEVBQ3RCO0FBQUEsRUFHQSxPQUFPLEVBQUUsT0FBTyxXQUFXLFlBQVksTUFBTSxDQUFDLEVBQUU7QUFBQTtBQU1wRCxlQUFlLFFBQVEsQ0FBQyxNQUErQjtBQUFBLEVBQ25ELFFBQVEsVUFBVSxnQkFBZ0IsSUFBSTtBQUFBLEVBR3RDLElBQUksTUFBTSxNQUFNO0FBQUEsSUFDWixRQUFRLElBQUksZUFBZTtBQUFBLElBQzNCO0FBQUEsRUFDSjtBQUFBLEVBR0EsTUFBTSxJQUFJLEtBQUs7QUFBQSxJQUNYLE9BQU8sTUFBTSxhQUFhO0FBQUEsSUFDMUIsT0FBTyxNQUFNLFlBQVk7QUFBQSxJQUN6QixRQUFRO0FBQUEsRUFDWixDQUFDO0FBQUEsRUFFRCxJQUFJLFFBQVEsS0FBSyx5QkFBeUI7QUFBQSxJQUN0QyxPQUFPLEtBQUssVUFBVSxLQUFLO0FBQUEsRUFDL0IsQ0FBQztBQUFBLEVBR0QsTUFBTSxTQUFTLE1BQU0sV0FBVyxLQUFLO0FBQUEsRUFHckMsSUFBSSxNQUFNLEtBQUs7QUFBQSxJQUNYLEdBQUcsS0FBSywrQ0FBK0M7QUFBQSxJQUN2RCxHQUFHLEtBQUssbURBQW1EO0FBQUEsRUFDL0Q7QUFBQSxFQUNBLE1BQU0sT0FBTyxRQUFRLEtBQUs7QUFBQTtBQUc5QixlQUFlLElBQUksR0FBRztBQUFBLEVBQ2xCLElBQUk7QUFBQSxJQUVBLE1BQU0sVUFBVSxRQUFRLEtBQUssTUFBTSxDQUFDO0FBQUEsSUFHcEMsSUFDSSxRQUFRLFdBQVcsS0FDbkIsUUFBUSxPQUFPLFlBQ2YsUUFBUSxPQUFPLE1BQ2pCO0FBQUEsTUFDRSxRQUFRLElBQUksYUFBYTtBQUFBLE1BQ3pCLFFBQVEsS0FBSyxDQUFDO0FBQUEsSUFDbEI7QUFBQSxJQUVBLE1BQU0sYUFBYSxRQUFRO0FBQUEsSUFDM0IsTUFBTSxpQkFBaUIsUUFBUSxNQUFNLENBQUM7QUFBQSxJQUd0QyxRQUFRO0FBQUEsV0FDQztBQUFBLFFBQ0QsTUFBTSxRQUFRLGNBQWM7QUFBQSxRQUM1QjtBQUFBLFdBRUM7QUFBQSxXQUNBO0FBQUEsUUFDRCxNQUFNLFdBQVcsY0FBYztBQUFBLFFBQy9CO0FBQUEsV0FFQztBQUFBLFdBQ0E7QUFBQSxRQUNELE1BQU0sU0FBUyxjQUFjO0FBQUEsUUFDN0I7QUFBQSxXQUVDO0FBQUEsV0FDQTtBQUFBLFFBQ0QsUUFBUSxJQUFJLGFBQWE7QUFBQSxRQUN6QjtBQUFBO0FBQUEsUUFLQSxNQUFNLFNBQVMsT0FBTztBQUFBLFFBQ3RCO0FBQUE7QUFBQSxJQUVWLE9BQU8sT0FBTztBQUFBLElBQ1osR0FBRyxNQUFNLGlCQUFpQixRQUFRLE1BQU0sVUFBVSxPQUFPLEtBQUssQ0FBQztBQUFBLElBQy9ELFFBQVEsS0FBSyxDQUFDO0FBQUE7QUFBQTsiLAogICJkZWJ1Z0lkIjogIkFDRkQ4MTY5RUEwNDBEMTU2NDc1NkUyMTY0NzU2RTIxIiwKICAibmFtZXMiOiBbXQp9
